<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java高级 - 余丰旭的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="余丰旭的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="余丰旭的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="记录Java高级方面知识，包括多线程、IO、泛型、集合、网络编程、反射等。"><meta property="og:type" content="blog"><meta property="og:title" content="Java高级"><meta property="og:url" content="https://fxgood.gitee.io/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"><meta property="og:site_name" content="余丰旭的博客"><meta property="og:description" content="记录Java高级方面知识，包括多线程、IO、泛型、集合、网络编程、反射等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/a7437d2699d34cc582cbbd041ec7fefa.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100238580.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100254726.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/217a185420c343c588eace6cab65a7ee.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/0ff201a797884d01ab10b9011b7dcada.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/368db7198d97447795b9c31952568c7f.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1446daae771048868a2cce95c2072908.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/fbce2f0eaa654fb983fce7738ee031ab.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/b37e9f32887744b0bc1349993c1f2767.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/7e50b194a59c4f3ab77971be9f5487e4.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1f12c768903643f2ab209cb65deaf7a7.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015165822331.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170036496.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170515904.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170758744.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170832228.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170923073.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018115847328.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018200409123.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205807182.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205833959.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205905165.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210011651.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210314315.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020185549611.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020193009794.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213052703.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213128277.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211021093805529.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211026101834161.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211224214935079.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150203537.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150801352.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226093527904.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226143304180.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226145634905.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150152685.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150512810.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231155043835.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231163746622.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103822036.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103915239.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101134612613.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103453508.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103515417.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103526943.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103543846.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103603452.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103611895.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105095131010.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105100554138.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164815175.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164848679.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165142642.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165528449.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604170541798.png"><meta property="og:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604171910160.png"><meta property="article:published_time" content="2020-07-29T16:00:00.000Z"><meta property="article:modified_time" content="2022-06-30T04:32:08.354Z"><meta property="article:author" content="余丰旭"><meta property="article:tag" content="编程语言"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/a7437d2699d34cc582cbbd041ec7fefa.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://fxgood.gitee.io/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"},"headline":"Java高级","image":["https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/a7437d2699d34cc582cbbd041ec7fefa.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100238580.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100254726.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/217a185420c343c588eace6cab65a7ee.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/0ff201a797884d01ab10b9011b7dcada.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/368db7198d97447795b9c31952568c7f.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1446daae771048868a2cce95c2072908.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/fbce2f0eaa654fb983fce7738ee031ab.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/b37e9f32887744b0bc1349993c1f2767.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/7e50b194a59c4f3ab77971be9f5487e4.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1f12c768903643f2ab209cb65deaf7a7.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015165822331.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170036496.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170515904.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170758744.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170832228.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170923073.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018115847328.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018200409123.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205807182.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205833959.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205905165.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210011651.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210314315.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020185549611.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020193009794.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213052703.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213128277.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211021093805529.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211026101834161.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211224214935079.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150203537.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150801352.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226093527904.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226143304180.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226145634905.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150152685.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150512810.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231155043835.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231163746622.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103822036.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103915239.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101134612613.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103453508.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103515417.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103526943.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103543846.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103603452.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103611895.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105095131010.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105100554138.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164815175.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164848679.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165142642.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165528449.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604170541798.png","https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604171910160.png"],"datePublished":"2020-07-29T16:00:00.000Z","dateModified":"2022-06-30T04:32:08.354Z","author":{"@type":"Person","name":"余丰旭"},"publisher":{"@type":"Organization","name":"余丰旭的博客","logo":{"@type":"ImageObject","url":"https://fxgood.gitee.io/img/logo.svg"}},"description":"记录Java高级方面知识，包括多线程、IO、泛型、集合、网络编程、反射等。"}</script><link rel="canonical" href="https://fxgood.gitee.io/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="余丰旭的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-29T16:00:00.000Z" title="2020/7/30 上午12:00:00">2020-07-30</time>发表</span><span class="level-item"><time dateTime="2022-06-30T04:32:08.354Z" title="2022/6/30 下午12:32:08">2022-06-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">3 小时读完 (大约23549个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java高级</h1><div class="content"><h1 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h1><h2 id="1-1-基本概念：程序、进程、线程"><a href="#1-1-基本概念：程序、进程、线程" class="headerlink" title="1.1 基本概念：程序、进程、线程"></a>1.1 基本概念：程序、进程、线程</h2><p>程序：一段静态的代码<br>进程：正在运行的程序，是<strong>资源分配的基本单位</strong>。<br>线程：<strong>是CPU执行和调度的最小单位</strong>，每个线程拥有<strong>独立的运行栈和程序计数器pc</strong>，线程切换的开销比较小。多个线程共享一个进程的资源（共享进程的方法区和堆，但存在安全隐患）。</p>
<p> <img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/a7437d2699d34cc582cbbd041ec7fefa.png" alt="在这里插入图片描述"><br> 在Java的内存区域中，<strong>栈区（虚拟机栈）和程序计数器是每个线程一份</strong>，<strong>方法区和堆区，是每个进程一份，各个线程共享</strong>。</p>
<p><strong>使用多线程的优点</strong><br>1.资源利用率提升，程序处理效率提高<br>2.改善程序结构，代码会相对简单<br>3.软件运行速度提升，提升应用程序的响应速度</p>
<p><strong>何时需要多线程</strong><br>1.程序需要同时执行两个或多个任务<br>2.程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等<br>3.需要一些后台运行的程序时</p>
<p><strong>Java程序至少有3个线程</strong><br>1.主线程<br>2.垃圾回收线程<br>3.异常处理线程（会影响主线程）</p>
<h2 id="1-2-线程的创建和使用"><a href="#1-2-线程的创建和使用" class="headerlink" title="1.2 线程的创建和使用"></a>1.2 线程的创建和使用</h2><p>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 </p>
<p><strong>Thread类的特性</strong><br>1.每个线程都是通过特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为<strong>线程体</strong><br>2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run()<br>3.<strong>Thread类实现了Runnable接口</strong></p>
<p><strong>start方法作用</strong><br>1.启动当前线程<br>2.调用当前线程的run方法</p>
<p><strong>注意</strong><br>1.不能通过调用run方法来启动线程（仍然在主线程中执行）<br>2.额外再启动一个线程，需要重新创建一个线程的对象</p>
<p><strong>两种创建线程的方法</strong><br>1.继承Thread类，重写run方法<br>2.实现Runnable接口，实现run方法，在Thread构造器中传入一个Runnable接口实现对象</p>
<p><strong>两种创建线程方法的比较</strong><br>开发中，优先选择Runnable接口的方法<br>1.实现的方式没有类单继承性的限制<br>2.实现的方式更适合来处理多个线程共享数据的情况</p>
<p><strong>注意，这里ticket没有加static，就实现了三个线程共享ticket</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sell</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖&quot;</span> + ticket + <span class="string">&quot;号票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 死锁的四个必要条件</span></span><br><span class="line"><span class="comment"> * 1.互斥访问：共享资源互斥访问</span></span><br><span class="line"><span class="comment"> * 2.请求并保持：已经持有资源的情况下，申请别的资源未果，也不释放自己持有的资源（站在自己角度）</span></span><br><span class="line"><span class="comment"> * 3.不可剥夺：进程申请的资源除了完成任务释放，别人无法将其释放（站在别人角度）</span></span><br><span class="line"><span class="comment"> * 4.循环等待：系统中存在资源循环等待的链条*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sell sell = <span class="keyword">new</span> Sell();</span><br><span class="line">        <span class="keyword">new</span> Thread(sell).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sell).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sell).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100238580.png" alt="image-20220424100238580"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220424100254726.png" alt="image-20220424100254726"></p>
<p><strong>Thread类常用方法</strong><br>1.<code>void start()</code>：启动当前线程；调用当前线程的run()<br>2.<code>run()</code>：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中<br>3.<code>String getName()</code><br>4.<code>void setName()</code><br>5.<code>static Thread currentThread()</code>:返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。<br>6.<code>yield()</code>：释放cpu的执行权（有可能紧接着又获取了cpu的执行权）<br>7.<code>h.join()</code>：在线程a中执行<code>h.join()</code>，会阻塞当前线程a，直到h线程执行完，线程a才结束阻塞状态<br>8.<code>stop()</code>：强制线程生命周期结束，<strong>deprecated 不推荐使用，因为不安全，过时的api</strong><br>9.<code>static void sleep(long millis)</code>：睡眠(阻塞)若干毫秒；静态方法，可以直接调用。<br>注意：如果是在run方法中使用sleep，则处理sleep的异常只能try-catch，无法throws；因为是重写Thread的run方法，其并无异常抛出，故子类重写也无法抛出异常。<br>10.<code>bool isAlive()</code>：判断当前线程是否存活（是否执行完了），阻塞状态下返回值也是true。</p>
<p><strong>获取线程名称</strong><br><code>Thread.currentThread().getName();</code></p>
<p><strong>更改线程名称</strong><br>1.通过<code>Thread.currentThread().setName();</code><br>2.通过构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> MyThread(<span class="string">&quot;一号线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用匿名对象执行开启线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">             System.out.println(count++);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br></pre></td></tr></table></figure>
<h2 id="1-3-线程的调度"><a href="#1-3-线程的调度" class="headerlink" title="1.3 线程的调度"></a>1.3 线程的调度</h2><ul>
<li>Java的调度方法</li>
</ul>
<p>1.同优先级线程组成先进先出队列（先到先服务），使用时间片策略<br>2.对于高优先级，使用优先调度的抢占式策略</p>
<ul>
<li>线程的优先级</li>
</ul>
<p>1.线程的优先级等级：<code>MAX_PRIORITY:10</code>,<code>MIN_PRIORITY:1</code>,<code>NORM_PRIORITY:5</code><br>2.获取和设置当前线程的优先级：<code>getPriority()</code>,<code>setPriority(int p)</code></p>
<blockquote>
<p>注意：并不是优先级高的执行完再执行优先级低的，而是优先级高的获取CPU的概率更高</p>
</blockquote>
<h2 id="1-4-线程的分类"><a href="#1-4-线程的分类" class="headerlink" title="1.4 线程的分类"></a>1.4 线程的分类</h2><p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) </p>
<p>用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：</p>
<p>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br>Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</p>
<p>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p>值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。下面的方法就是用来设置守护线程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonTread = <span class="keyword">new</span> Thread();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设定 daemonThread 为 守护线程，default false(非守护线程)</span></span><br><span class="line"> daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 验证当前线程是否为守护线程，返回 true 则为守护线程</span></span><br><span class="line"> daemonThread.isDaemon();</span><br></pre></td></tr></table></figure>
<h2 id="1-5-线程的生命周期"><a href="#1-5-线程的生命周期" class="headerlink" title="1.5 线程的生命周期"></a>1.5 线程的生命周期</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/217a185420c343c588eace6cab65a7ee.png" alt="在这里插入图片描述"></p>
<h2 id="1-6-线程的同步"><a href="#1-6-线程的同步" class="headerlink" title="1.6 线程的同步"></a>1.6 线程的同步</h2><p>线程同步，主要用来解决线程的安全问题。</p>
<p><strong>例：创建三个线程卖票，总共100张</strong><br>1.问题：卖票过程中，出现了重票、错票（0，-1号票）–&gt;出现了线程的安全问题<br>2.问题出现的原因：某线程操作车票时，别的线程也参与进来<br>3.如何解决：某线程操作车票时，即使出现阻塞（例如sleep(100);)，别人也不能参与进来。<br>4.在Java中，我们通过同步机制，来解决线程的安全问题</p>
<p><strong>解决方式</strong></p>
<ol>
<li>同步代码块<br>a.同步监视器（又叫锁）：任何一个对象都可以作为锁；<strong>要求多个线程必须要共用同一把锁。</strong><br>b.同步原理：当一个线程执行代码碰到一个锁时，如果已经有别的线程使用了锁并且没有归还，那么本线程就阻塞在这里。</li>
</ol>
<p><strong>继承Thread方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sell s1 = <span class="keyword">new</span> Sell();</span><br><span class="line">        Sell s2 = <span class="keyword">new</span> Sell();</span><br><span class="line">        Sell s3 = <span class="keyword">new</span> Sell();</span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sell</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">10000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Sell.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;出售第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Sell.class</code>充分说明了，在Java中<strong>类也是对象</strong></p>
<p><strong>实现Runnable接口方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sell2 sell=<span class="keyword">new</span> Sell2();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(sell);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(sell);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(sell);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sell2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;出售&quot;</span>+ticket--+<span class="string">&quot;号票&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>同步方法<br>如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。</li>
</ol>
<p><strong>实现Runnable接口方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售&quot;</span> + ticket-- + <span class="string">&quot;号票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>继承Thread方式</strong>，注意这里的sell方法必须要加static，否则会出现安全问题（不加static，同步方法所用的锁，不是同一个）</p>
<p><font color='red'>同步方法不加static，使用的是<code>this</code>作为锁。加了static，使用的是<code>类名.class</code>作为锁</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window4 w1=<span class="keyword">new</span> Window4();</span><br><span class="line">        Window4 w2=<span class="keyword">new</span> Window4();</span><br><span class="line">        Window4 w3=<span class="keyword">new</span> Window4();</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">10000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>)	<span class="comment">//这里可能会出现卖第0张票的情况</span></span><br><span class="line">            sell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;出售&quot;</span>+ticket--+<span class="string">&quot;号票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用同步锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Window();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10000</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售&quot;</span> + ticket-- + <span class="string">&quot;号票&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">/*保证无论发生什么特殊情况，一定能够释放锁*/</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>可重入锁 ReentrantLock</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；如果有两个不同的方法用到同一个锁，其中方法A里面又调用了方法B，那就不会死锁了</span><br></pre></td></tr></table></figure>

<p>面试题：synchronized和Lock的区别？<br>synchronized在执行完同步代码以后，自动释放同步监视器<br>Lock方式手动加锁和释放锁，更加灵活。</p>
<h2 id="1-7-改造懒汉单例模式使之线程安全"><a href="#1-7-改造懒汉单例模式使之线程安全" class="headerlink" title="1.7 改造懒汉单例模式使之线程安全"></a>1.7 改造懒汉单例模式使之线程安全</h2><p>**注意，写了两次判断<code>instance==null</code>**，这样效率最高。只在首次访问的时候进行同步，后续已经有instance的情况下无需同步，直接返回instance，最大化效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式之懒汉式</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Tool instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Tool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Tool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Tool();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-线程的死锁问题"><a href="#1-8-线程的死锁问题" class="headerlink" title="1.8 线程的死锁问题"></a>1.8 线程的死锁问题</h2><p><strong>死锁</strong>：<br>1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续<br>（操作系统中学到的定义：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，这些永远都在互相等待的进程，称为死锁进程）</p>
<p><strong>解决方法</strong><br>1.专门的算法、原则<br>2.尽量减少同步资源的定义<br>3.尽量避免嵌套同步</p>
<p><strong>死锁发生的四个必要条件</strong><br>1.互斥：共享资源互斥访问<br>2.请求并保持：进程请求资源未果，不会释放自身已经占有的资源<br>3.不可剥夺：只有进程自身使用完资源后才会释放，别人无法将其释放<br>4.循环等待：多个进程之间存在资源请求的环路</p>
<p><strong>预防死锁</strong><br>1.破坏请求并保持条件：一次性请求所有需要的资源，否则就不申请<br>2.破坏不可剥夺条件：请求资源未果，释放自身占有的资源<br>3.破坏循环等待条件：可用资源线性排序，只能从低到高申请资源</p>
<p><strong>避免死锁</strong><br>银行家算法：已分配资源表、可用资源表、所需资源表；每次分配给一个能够满足其需求的进程，该进程执行完后返还所有的资源，不断循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。</span><br></pre></td></tr></table></figure>
<p><strong>预防死锁和避免死锁的区别</strong><br>预防死锁是通过破坏死锁发生的必要条件中的一个，限制条件比较严格，可能造成系统资源利用率和系统吞吐率的下降。<br>避免死锁施加的条件比较宽松，<strong>在资源的动态分配中，避免系统出现不安全状态</strong>。</p>
<h2 id="1-9-线程的通信"><a href="#1-9-线程的通信" class="headerlink" title="1.9 线程的通信"></a>1.9 线程的通信</h2><p>例题：使用两个线程打印1~100。线程1，线程2交替打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Count();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();	<span class="comment">//或者this.notify,  如果用的是某个obj，则obj.notify</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;数&quot;</span> + num--);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait(); <span class="comment">/*自我阻塞，wait会自动释放锁（与sleep的区别）*/</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>涉及到的三个方法</strong><br>1.<code>wait()</code>：一旦执行此方法，当前线程就进入<strong>阻塞状态</strong>， <strong>并释放同步监视器</strong><br>2.<code>notify()</code>：一旦执行此方法。就会唤醒被wait的一个线程。如果有多个，则唤醒优先级最高的<br>3.<code>notifyAll()</code>：唤醒所有wait的线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补充：</span><br><span class="line">this.notify();//唤醒同步监视器等待池中的一个线程（放入锁池中，开始竞争锁）</span><br><span class="line">this.wait(); //当前线程停止执行，并释放锁，进入同步监视器的等待池中（不竞争锁）</span><br></pre></td></tr></table></figure>





<p><strong>说明</strong><br>1.wait(), notify(), notifyAll() 三个方法必须使用在同步代码块或者同步方法中<br>2.<font color='red'>三者的调用者<strong>必须</strong>是同步代码块或同步方法中的<strong>同步监视器</strong>，否则会报异常</font>，不加调用者默认是<code>this.</code><br>3.三者是定义在java.lang.Object类中的</p>
<p>上述例题也可以使用公平锁来实现（存在一个等待队列，先进先出）,<strong>注意要使用finally来保证unlock的执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Count();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">/*fair lock*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+num--);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>生产者消费者问题</strong><br><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/0ff201a797884d01ab10b9011b7dcada.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(clerk)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(clerk)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> products = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//notity(); 也可以写这里</span></span><br><span class="line">        <span class="keyword">if</span> (products &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产第&quot;</span> + (++products) + <span class="string">&quot;个商品&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (products &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费第&quot;</span> + products-- + <span class="string">&quot;个商品&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (products &lt; <span class="number">20</span>)</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.produce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有个疑问：如果把sleep写在两个同步方法中，while中只有调用，则会出现每次生产者生产满20个消费者才去消费，每次消费者消费完了生产者才开始生产。即每轮while循环结束同步方法都不释放锁。（在while中随意加入一个语句如print，则此现象消失，正常交替执行）</p>
</blockquote>
<h2 id="1-10-JDK5-0新增线程创建方式"><a href="#1-10-JDK5-0新增线程创建方式" class="headerlink" title="1.10 JDK5.0新增线程创建方式"></a>1.10 JDK5.0新增线程创建方式</h2><p><strong>新增方式一：实现Callable接口</strong><br>与Runnable相比，Callable功能更强大<br>1.相比<code>run()</code>方法，可以有返回值<br>2.方法可以抛出异常（重写Runnable中的run不能抛出异常，因为Runnable接口中的run没有抛  ）<br>3.支持泛型的返回值<br>4.需要借助<code>FutureTask</code>类，比如获取返回值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(count);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        Object ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ans = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100000000</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>使用泛型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(count);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ans = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100000000</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增方式二：使用线程池</strong><br>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。<br>好处：<br>1.提高响应速度（减少了创建新线程的时间）<br>2.降低资源消耗（重复利用线程池中的线程，不需要每次都创建）<br>3.便于线程管理：<br><code>corePoolSize</code>核心池的大小<br><code>maximumPoolSize</code>最大线程数<br><code>keepAliveTime</code> 线程没有任务时最多保持多长时间后会终止</p>
<p><strong>线程池相关API</strong><br>1.JDK5.0起提供了线程池相关API：<code>ExecutorService</code>和<code>Executors</code><br>2.<code>ExecutorService</code> 真正的线程池接口.常见子类<code>ThreadPoolExecutor</code></p>
<ul>
<li><code>void execute(Runnable command)</code>:执行任务/命令,没有返回值,一般用来执行Runnable</li>
<li><code>&lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):</code>执行任务,有返回值,一般用来执行Callable</li>
<li><code>void shutdown()</code>:关闭连接池</li>
</ul>
<p>3.Executors:工具类、线程池的工厂类,用于创建并返回不同类型的线程池</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>:创建一个可根据需要创建新线程的线程池</li>
<li><code>Executors.newFixedThreadPool(n)</code>:创建一个可重用固定线程数的线程池</li>
<li><code>Executors.newSingleThreadExecutor()</code>:创建一个只有一个线程的线程池</li>
<li><code>Executors.newScheduledThreadPool(n)</code>:创建一个线程池,它可以安排在给定延迟后运行命令或者定期地执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Executors是线程池的工厂类*/</span></span><br><span class="line">        ExecutorService server= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        server.execute(<span class="keyword">new</span> Count());</span><br><span class="line">        server.submit(<span class="keyword">new</span> Calculate());</span><br><span class="line">        <span class="comment">/*或者使用FutureTask包装Calculate()以获取线程返回值*/</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Calculate());</span><br><span class="line">        server.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;<span class="number">100</span>)</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum+=i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol>
<li>谈谈你对程序、进程、线程的理解</li>
</ol>
<p><strong>程序</strong>：一段静态代码<br><strong>进程</strong>：关于进程我想谈两点，一个是为什么需要进程这个概念，另一个是进程的作用。首先，现代操作系统的一大特点就是多道程序设计，那么在此之前是单道程序设计，一个程序运行时占有所有的资源，那么就无需资源的分配和调度，也就无需进程这个概念。到了多道程序设计中，多个程序并发执行，这就涉及到了系统资源的分配和调度，诸如CPU资源、存储资源、IO资源、文件资源，那么进程这个概念就应运而生。因此进程的作用有两大点，第一，它是资源分配和调度的基本单位。第二，它是程序独立运行的载体，保障程序正常执行。<br><strong>线程</strong>：线程是CPU调度的基本单位，多个线程之间共享进程的资源；线程包含在进程之中，是进程中实际运行工作的单位。</p>
<blockquote>
<p>操作系统四大特性：虚拟、异步、共享、并发。<br>2. 对比两种线程的创建方式<br>3. sleep和wait方法的异同？<br>相同点：都能使当前线程阻塞<br>不同点：1.sleep声明在Thread类中，wait声明在Object类中 2.<code>sleep()</code>可以在任何地方使用，<code>wait()</code>需要在同步方法或者同步代码块中调用 3.如果都使用在同步代码块或者同步方法中，sleep方法不会释放锁，wait会释放锁</p>
</blockquote>
<h1 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2.常用类"></a>2.常用类</h1><h2 id="2-1-字符串相关的类"><a href="#2-1-字符串相关的类" class="headerlink" title="2.1 字符串相关的类"></a>2.1 字符串相关的类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p><strong>String特性</strong><br>1.String类:代表字符串.Java程序中,所有字符串的字面值(如”abc”)都是String类的实例<br>2.String是一个<strong>final类</strong>,不可以继承<br>3.字符串是<strong>常量</strong>,值在创建之后不可改变,字符内容是存储在一个字符数组value[]中的<br>4.通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中<br>5.字符串常量池(<strong>位于方法区中,后来改叫meta space</strong>)中是不会存储相同内容的字符串的<br><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/368db7198d97447795b9c31952568c7f.png" alt="在这里插入图片描述"><br><strong>String对象的创建</strong><br>1.字面量的方式,<code>String str=&quot;abc&quot;;</code><br>2.<code>String s=new String()</code><br>3.<code>String s=new String(String s2)</code><br>4.<code>String s=new String(char[] arr)</code><br>5.<code>String s=new String(char[] arr,int startIndex, int count)</code></p>
<blockquote>
<p>字符串常量池存储在字符串常量池,目的是共享; 字符串非常量的对象存储在堆中</p>
</blockquote>
<p>面试题1:下面的<code>p1.name==p2.name?</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;yfx&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;yfx&quot;</span>);</span><br><span class="line">        System.out.println(p1.name == p2.name); <span class="comment">//true 地址相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试题2:<code>String s=new String(&quot;abc&quot;);</code> 在内存中创建了几个对象? 答:<strong>如果常量池中没有abc,则创建了两个,有的话则创建一个</strong>(现在常量池创建”abc”,然后在堆中创建一个String对象,内容<strong>fianl char[]value</strong>指向常量池的”abc”)</p>
<p>面试题3:下面几种字符串连接后,在内存中实际是怎么样的?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;java&quot;</span>, s2 = <span class="string">&quot;docker&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3=<span class="string">&quot;javadocker&quot;</span>;</span><br><span class="line">    String s4=<span class="string">&quot;java&quot;</span>+<span class="string">&quot;docker&quot;</span>;	<span class="comment">//编译阶段会直接合成&quot;javadocker&quot;</span></span><br><span class="line">    String s5=s1+<span class="string">&quot;docker&quot;</span>;</span><br><span class="line">    String s6=<span class="string">&quot;java&quot;</span>+s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3==s4); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s3==s5); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s3==s6); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s5==s6); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	String s7=s5.intern();	</span><br><span class="line"><span class="comment">//intern():如果常量池中没有s5的字符串值,那么就在常量池中创建该字符串常量,并返回其引用;如果常量池中已经有,则直接返回引用</span></span><br><span class="line">    System.out.println(s3==s7); <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String s8=<span class="string">&quot;java&quot;</span>;	<span class="comment">//final修饰的变成常量</span></span><br><span class="line">    String s9=s8+<span class="string">&quot;docker&quot;</span>;</span><br><span class="line">    System.out.println(s3==s9); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>涉及到对象的连接,则都在堆中产生新的String对象; </p>
</blockquote>
<p>面试题4:java的值传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;	<span class="comment">//将常量池中&quot;test ok&quot;的地址赋值给str</span></span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Main obj = <span class="keyword">new</span> Main();</span><br><span class="line">        obj.change(obj.str, obj.ch);</span><br><span class="line">        System.out.println(obj.str);    <span class="comment">//good</span></span><br><span class="line">        System.out.println(obj.ch);     <span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p>1.<code>int length()</code><br>2.<code>char charAt(int index)</code><br>3.<code>boolean isEmpty()</code><br>4.<code>String toLowerCase()</code><br>5.<code>String toUpperCase()</code><br>6.<code>String trim()</code>:返回字符串的副本,忽略前导空白和尾部空白<br>7.<code>boolean equalsIgnoreCase(String s)</code><br>8.<code>String concat(String str)</code>:将指定字符串连接到此字符串的结尾,等价于<code>+</code><br>9.<code>int compareTo(String s)</code>:比较两个字符串字典序<br>10.<code>String substring(int beginIndex)</code>:<br>11.<code>String substring(int beginIndex, int endIndex)</code>:按照下标截取字符串,左闭右开<br>12.<code>boolean endsWith(String suffix)</code>:是否以指定的后缀结束<br>13.<code>boolean startsWith(String prefix)</code>:是否以指定的前缀开始<br>14.<code>boolean startsWith(String prefix,int offset)</code>:测试此字符串从指定索引开始的子串是否以指定前缀开始</p>
<p>15.<code>boolean contains(CharSequence s)</code>:当且仅当此字符串包含指定的char值序列时,返回true<br>16.<code>int indexOf(String str)</code>:返回子串第一次出现的索引,未找到返回-1<br>17.<code>int indexOf(String s,int fromIndex)</code>:返回子串从偏移下标开始首次出现的索引<br>18.<code>int lastIndexOf(String s)</code>:反向搜索<br>19.<code>int lastIndexOf(String s,int fromIndex)</code>,从指定偏移量开始反向搜索</p>
<p>20.<code>String replace(char oldChar,char newChar)</code>:替换所有指定字符<br>21.<code>String replace(CharSequence target, CharSequence replacement)</code>:替换所有指定子串<br>22.<code>String replaceAll(String regex, String replacement)</code>:使用给定的子串替换所有匹配正则表达式的子串<br>23.<code>String replaceFirst(String regex, String replacement):</code> </p>
<p>24.<code>boolean matches(String regex)</code>:告知此字符串是否匹配给定的正则表达式</p>
<p>25.<code>String[] split(String regex)</code>:根据给定正则表达式的匹配拆分此字符串<br>26.<code>String[] split(String regex, int limit)</code>:根据给定正则表达式来拆分此字符串,最多不超过limit个,如果超过了,剩下的全部放到最后一个元素中</p>
<h3 id="String与基本数据类型转换"><a href="#String与基本数据类型转换" class="headerlink" title="String与基本数据类型转换"></a>String与基本数据类型转换</h3><p>1.String转基本数据类型、包装类: 调用包装类的静态方法:<code>parseXXX(str)</code><br>2.基本数据类型、包装类转Stirng:<code>String.valueOf(xxx)</code><br>3.String转char[]:<code>str.toCharArray()</code><br>4.char[]转String:<code>new String(char[] arr)</code><br>5.String转byte[]:<code>str.getBytes()</code><br>6.byte[]转String:<code>new String(bytes[] arr)</code> 重载函数<code>new String(bytes[]arr,字符集)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String s=<span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();<span class="comment">//使用默认的字符集</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        <span class="comment">//[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67]  utf-8编码一个汉字3个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] gbks = s.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(gbks));</span><br><span class="line">        <span class="comment">//[97, 98, 99, 49, 50, 51, -42, -48, -71, -6]       gbk编码一个汉字2个字节</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        <span class="comment">//abc123中国</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(gbks));</span><br><span class="line">        <span class="comment">//abc123�й�  字符集指定错误,出现乱码</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(gbks,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="comment">//abc123中国</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer,StringBuilder"></a>StringBuffer,StringBuilder</h3><p><strong>String</strong>:<br>1.不可变字符序列</p>
<p><strong>StringBuffer</strong>:<br>1.可变字符序列<br>2.线程安全,效率低 (除了构造方法,所有方法都加了<strong>synchronized</strong>)</p>
<p><strong>StringBuilder</strong>:<br>1.可变字符序列<br>2.线程不安全,效率高</p>
<blockquote>
<p>三者底层都是用char[]存储</p>
</blockquote>
<p><strong>StringBuffer和StringBuilder的扩容</strong><br>默认情况下,扩容为原来的2倍+2,同时将原有数组中的元素复制到新的数组中<br><strong>指导意义</strong>: 如果需要对字符串进行频繁的添加, 建议使用此构造器<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code>,提前指定容量,以免频繁扩容,降低效率</p>
<p><strong>三者效率对比</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        buffer.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer use &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        builder.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder use &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        s += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;String use &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1446daae771048868a2cce95c2072908.png" alt="在这里插入图片描述"></p>
<h2 id="2-2-JDK8之前的时间API"><a href="#2-2-JDK8之前的时间API" class="headerlink" title="2.2 JDK8之前的时间API"></a>2.2 JDK8之前的时间API</h2><h3 id="System静态方法"><a href="#System静态方法" class="headerlink" title="System静态方法"></a>System静态方法</h3><p><code>System.currentTimeMillis()</code>: 返回1970年1月1日0点到现在经历了多少毫秒,返回值是long类型</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>有两个Date类<br>java.util.Date和java.sql.Date(继承前边的类)</p>
<p><strong>java.util.Date</strong><br>1.构造器一:<code>Date()</code> 创建了一个对应当前时间的Date对象</p>
<p>2.构造器二<code>Date(long time)</code> 创建指定毫秒数的Date类</p>
<p><strong>java.sql.Date</strong><br>对应着数据库中的日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">//Wed Aug 25 10:49:42 CST 2021</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">        <span class="comment">//1629859782884</span></span><br><span class="line">        Date date2=<span class="keyword">new</span> Date(<span class="number">1629859782884L</span>);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">        <span class="comment">//Wed Aug 25 10:49:42 CST 2021</span></span><br><span class="line">        Date date3=<span class="keyword">new</span> java.sql.Date(<span class="number">2131243242334L</span>);</span><br><span class="line">        System.out.println(date3);</span><br><span class="line">        <span class="comment">//2037-07-15</span></span><br><span class="line">        <span class="comment">/*java.util.Date转换为java.sql.Date*/</span></span><br><span class="line">        <span class="comment">//情形一 多态,对象本身就是sql下的Date</span></span><br><span class="line">        Date date4=<span class="keyword">new</span> java.sql.Date(<span class="number">2315432424345L</span>);</span><br><span class="line">        java.sql.Date date5= (java.sql.Date) date4;</span><br><span class="line">        <span class="comment">//情形二 对象本身就是util下的Date,无法直接强制转换.但是他们拥有一个共同的东西,就是毫秒数</span></span><br><span class="line">        Date date6=<span class="keyword">new</span> Date();</span><br><span class="line">        java.sql.Date date7=<span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p><code>Calendar</code>是一个<strong>抽象基类</strong>,主要用于完成日期字段之间相互操作的功能</p>
<p>获取Calendar实例的方法<br>1.使用<code>Calendar.getInstance()</code>方法 (抽象类无法实例化,这里返回的是子类GregorianCalendar的对象,多态,用Calendar接收)<br>2.调用它的子类<code>GregorianCalendar</code>的构造器</p>
<p>一个Canlendar的实例是系统时间的抽象表示,通过<code>get(int field)</code>方法来取得想要的时间信息.比如YEAR, MONTH, DAY_OF_WEEK, HOUR_OF_DAY,MINUTE, SECOND<br>1.<code>public void set(int field, int value)</code><br>2.<code>public void add(int field, int amount)</code><br>3.<code>public final Date getTime()</code><br>4.<code>public final void setTime(Date date)</code></p>
<p><strong>注意</strong><br>1.获取月份时:一月是0, 二月是1, 以此类推, 12月是11<br>2.获取星期时,周日是1,周二是2,…,周六是7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance(); <span class="comment">//多态</span></span><br><span class="line">        System.out.println(calendar.getClass());    <span class="comment">//java.util.GregorianCalendar</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">10</span>);   <span class="comment">//往前倒10个月</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getTime()</span></span><br><span class="line">        Date date=calendar.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setTime()</span></span><br><span class="line">        calendar.setTime(date); <span class="comment">//用date来设置calendar</span></span><br><span class="line">        calendar.setTimeInMillis(<span class="number">23214325798L</span>); <span class="comment">//用毫秒数设置calendar</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p>用于对Date类的格式化和解析</p>
<p>Date类的API不易于国际化,大部分都被废弃了,<code>java.text.SimpleDateFormat</code>类是一个<strong>不与语言环境有关</strong>的方式来格式化和解析日期的具体类</p>
<p>它允许进行<strong>格式化: 日期-&gt;文本</strong>, <strong>解析: 文本-&gt;日期</strong></p>
<p>1.格式化<br><code>SimpleDateFormat()</code>: 默认的模式和语言环境创建对象<br><code>public SimpleDateFormat(String pattern)</code> 该构造方法可以用参数pattern指定的格式创建一个对象,该对象调用<br><code>public String format(Date date):</code> 方法格式化时间对象date</p>
<p>2.解析<br><code>public Date parse(String source): </code> 从给定字符串的开始解析文本,以生成一个日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">/*格式化:date转String*/</span></span><br><span class="line">        String format = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(format); <span class="comment">//2021-08-25 04:00:54</span></span><br><span class="line">        <span class="comment">/*解析*:String转Date*/</span></span><br><span class="line">        Date date = sdf.parse(<span class="string">&quot;2021-08-25 16:30:20&quot;</span>);</span><br><span class="line">        System.out.println(date);   <span class="comment">//Wed Aug 25 16:30:20 CST 2021</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果用SimpleDateFormat类解析字符串成java.sql.Date</strong>,就先解析为java.util.Date,在用毫秒数转换为java.util.Date</p>
<p><strong>例题</strong><br>1990-01-01开始,三天打鱼两天晒网,请问给定日期在做什么事情?<br>答:用SimpleDateFomart类解析两个日期,算出毫秒值之差,然后向上整除<code>1000*3600*24</code>(这里用向上除法$(m+n-1)/n$), 然后结果+1(代表一共有多少天), 然后对5取模. <code>0~2</code>在打渔,<code>3~4</code>在晒网</p>
<h2 id="2-3-JDK8中新日期的API"><a href="#2-3-JDK8中新日期的API" class="headerlink" title="2.3 JDK8中新日期的API"></a>2.3 JDK8中新日期的API</h2><p>JDK1.0包含了一个<code>java.util.Date</code>类,但是它的大多数方法已经在JDK1.1引入Calendar类后被弃用了.而Calendar类并不比Date好多少.它们面临的问题是:<br>1.<strong>可变性</strong>:像日期和事件这样的类,应该是不可变得<br>2.<strong>偏移性</strong>:Date中的年份是从1900开始的,而月份是从0开始的<br>3.<strong>格式化</strong>:格式化只对Date有用,Calendar则不行<br>此外,它们也不是线程安全的; 不能处理润秒等</p>
<p>总结:对日期和时间的操作一直是Java程序员最痛苦的地方之一</p>
<p>第三次引入的API是成功的,并且Java8中引入的<code>java.time</code>API已经纠正了过去的缺陷,将在很长一段时间内它都会为我们服务</p>
<h3 id="LocalDate-LocalTime-LocalDateTime"><a href="#LocalDate-LocalTime-LocalDateTime" class="headerlink" title="LocalDate,LocalTime,LocalDateTime"></a>LocalDate,LocalTime,LocalDateTime</h3><p>其中<strong>LocalDateTime</strong>最常用</p>
<p>1.now(): 当前的日期、时间<br>2.of(): 设置指定的年、月、日、时、分、秒   无偏移量，方便<br>3.getXxx(): 获取某项时间信息<br>4.with(): 修改日期,返回修改后的时间对象,<strong>不修改原来的时间对象</strong><br>5.plus()/minus(): 增减日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*now(): 当前的日期、时间*/</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();  <span class="comment">//LocalDateTime用的最频繁</span></span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    System.out.println(localTime);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*of(): 设置指定的年、月、日、时、分、秒   无偏移量，方便*/</span></span><br><span class="line">    LocalDateTime time1 = LocalDateTime.of(<span class="number">2021</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">34</span>);</span><br><span class="line">    System.out.println(time1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*getXxx()*/</span></span><br><span class="line">    System.out.println(localDateTime.getYear());</span><br><span class="line">    System.out.println(localDateTime.getMonth());</span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">    System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">    System.out.println(localDateTime.getMinute());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象*/</span></span><br><span class="line">    LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(<span class="number">1</span>); <span class="comment">//不修改原来的日期,重新返回一个修改后的日期</span></span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line">    LocalDateTime localDateTime2 = localDateTime1.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*plus()/minus(): 增减日期*/</span></span><br><span class="line">    LocalDateTime localDateTime3 = localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime3);</span><br><span class="line">    LocalDateTime localDateTime4 = localDateTime.minusYears(<span class="number">2</span>);</span><br><span class="line">    System.out.println(localDateTime4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>类似于<code>java.util.Date</code>类</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态方法,返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td>ofEpochMilli(long epochMilli)</td>
<td>静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个OffsetDateTime</td>
</tr>
<tr>
<td>toEpochMilli()</td>
<td>返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*now(): 获取本初子午线对应的时间标准*/</span></span><br><span class="line">    Instant time1 = Instant.now();<span class="comment">//默认是 本初子午线 的时区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*atOffset()结合即时的偏移来创建一个OffsetDateTime量*/</span></span><br><span class="line">    OffsetDateTime time2 = time1.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//改成东八区</span></span><br><span class="line">    System.out.println(time1);</span><br><span class="line">    System.out.println(time2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*toEpochSecond():返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳*/</span></span><br><span class="line">    <span class="keyword">long</span> l = time2.toEpochSecond();</span><br><span class="line">    System.out.println(l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*ofEpochMilli()静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象*/</span></span><br><span class="line">    Instant instant = Instant.ofEpochMilli(<span class="number">1532324124325L</span>);</span><br><span class="line">    System.out.println(instant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><p>1.方式一:预定义的标准格式<br><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/fbce2f0eaa654fb983fce7738ee031ab.png" width=100%><br>2.本地化相关的格式<br><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/b37e9f32887744b0bc1349993c1f2767.png" alt="在这里插入图片描述"></p>
<p>3.<strong>自定义的格式</strong>(一般都用这个)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义格式</span></span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    String format = formatter.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(format);</span><br><span class="line">    <span class="comment">//解析</span></span><br><span class="line">    TemporalAccessor parse = formatter.parse(<span class="string">&quot;2021-08-25 09:34:46&quot;</span>);   <span class="comment">//LocalDateTime,LocalDate,LocalTime都实现了TemporalAccessor接口</span></span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h3><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/7e50b194a59c4f3ab77971be9f5487e4.png" alt="在这里插入图片描述"><br><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/1f12c768903643f2ab209cb65deaf7a7.png" alt="在这里插入图片描述"></p>
<h2 id="2-4-Java比较器"><a href="#2-4-Java比较器" class="headerlink" title="2.4 Java比较器"></a>2.4 Java比较器</h2><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><ol>
<li>String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方法</li>
<li>重写comparaTo()的规则：如果当前对象this大于形参对象obj，则返回正整数；当前对象this小于形参对象obj，则返回负数；相等返回0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student s=(Student)o;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.id,s.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;比较的数据类型不是Student&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student[] arr=<span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;小小余&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        arr[<span class="number">1</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;余丰旭&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        arr[<span class="number">2</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;陈香玉&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>1.当元素的类型没有实现java.lang.Comparable接口又不方便修改代码，或者实现饿了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序，强行对多个对象进行整体排序的比较。</p>
<p>2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<strong>如果方法返回正整数，则表示o1大于o2来；如果返回0，则表示相等；返回负数，表示o1小于o2</strong></p>
<p>3.可以将Comparator传递给sort方法（如Collections.sort或Arrays.sort)，从而允许在排序上实现精确控制。</p>
<p>4.还可以使用Comparator来控制某些数据结构（如有序set或者有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student[] arr=<span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;小小余&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        arr[<span class="number">1</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;余丰旭&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        arr[<span class="number">2</span>]=<span class="keyword">new</span> Student(<span class="string">&quot;陈香玉&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//Arrays.sort(arr);</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(o1.id,o2.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种比较器对比"><a href="#两种比较器对比" class="headerlink" title="两种比较器对比"></a>两种比较器对比</h3><ol>
<li>Comparable具有永久性，Comparator是临时使用的<ul>
<li>Comparable接口一旦指定，保证其实现类对象在任何位置都可以比较大小；Comparator接口属于临时性的比较</li>
</ul>
</li>
</ol>
<h2 id="2-5-System类"><a href="#2-5-System类" class="headerlink" title="2.5 System类"></a>2.5 System类</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015165822331.png" alt="image-20211015165822331"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170036496.png" alt="image-20211015170036496"></p>
<h2 id="2-6-Math类"><a href="#2-6-Math类" class="headerlink" title="2.6 Math类"></a>2.6 Math类</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170515904.png" alt="image-20211015170515904"></p>
<h2 id="2-7-BigInteger和BigDecimal类"><a href="#2-7-BigInteger和BigDecimal类" class="headerlink" title="2.7 BigInteger和BigDecimal类"></a>2.7 BigInteger和BigDecimal类</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170758744.png" alt="image-20211015170758744"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170832228.png" alt="image-20211015170832228"></p>
<hr>
<p>BigInteger对应的是整型，BigDecimal对应的是浮点型</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211015170923073.png" alt="image-20211015170923073"></p>
<h1 id="3-枚举类"><a href="#3-枚举类" class="headerlink" title="3.枚举类"></a>3.枚举类</h1><p>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类。</p>
<p>2.当需要定义一组常量时，强烈建议使用枚举类。</p>
<p>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018115847328.png" alt="image-20211018115847328"></p>
<p><strong>如何定义枚举类</strong></p>
<p>1.JDK5.0前，自定义枚举类</p>
<p>2.JDK5.0开始，可以使用enum关键字自定义枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName=seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc=seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//常量内容（带final的需要赋值）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">//静态对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING=<span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春天开花&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER=<span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏天下雨&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN=<span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋天收麦子&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER=<span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冬天堆雪人&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season s1=Season.AUTUMN;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Family father = Family.Father;</span><br><span class="line">        Family mother=Family.Mather;</span><br><span class="line">        System.out.println(father); <span class="comment">//打印当前对象的名字</span></span><br><span class="line">        System.out.println(mother);</span><br><span class="line"></span><br><span class="line">        Family[] values = Family.values();</span><br><span class="line">        System.out.println(Arrays.toString(values));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看Family的父类是什么</span></span><br><span class="line">        System.out.println(Family.class.getSuperclass());</span><br><span class="line">        System.out.println(Family.class.getSuperclass().getSuperclass());</span><br><span class="line">        System.out.println(Object.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Country[] values = Country.values();</span><br><span class="line">        System.out.println(Arrays.toString(values));</span><br><span class="line">        Country china = Country.valueOf(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        System.out.println(china.name());</span><br><span class="line">        System.out.println(china);  <span class="comment">//toString方法默认返回name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果没有属性，则连小括号也不需要*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Country</span></span>&#123;</span><br><span class="line">    China,USA,Canada,India;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Family</span></span>&#123;</span><br><span class="line">    Father(<span class="string">&quot;男生&quot;</span>,<span class="string">&quot;挣钱养家&quot;</span>),    <span class="comment">//注意这里是逗号</span></span><br><span class="line">    Mather(<span class="string">&quot;女生&quot;</span>,<span class="string">&quot;貌美如花&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name,duty;</span><br><span class="line"></span><br><span class="line">    Family(String mem,String duty)&#123;     <span class="comment">//默认是private的</span></span><br><span class="line">        <span class="keyword">this</span>.name=mem;</span><br><span class="line">        <span class="keyword">this</span>.duty=duty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDuty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Family father = Family.Father;</span><br><span class="line">        Family mother=Family.Mather;</span><br><span class="line">        System.out.println(father); <span class="comment">//打印当前对象的名字</span></span><br><span class="line">        System.out.println(mother);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看Family的父类是什么</span></span><br><span class="line">        System.out.println(Family.class.getSuperclass());</span><br><span class="line">        System.out.println(Family.class.getSuperclass().getSuperclass());</span><br><span class="line">        System.out.println(Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Family</span></span>&#123;</span><br><span class="line">    Father(<span class="string">&quot;男生&quot;</span>,<span class="string">&quot;挣钱养家&quot;</span>),    <span class="comment">//注意这里是逗号</span></span><br><span class="line">    Mather(<span class="string">&quot;女生&quot;</span>,<span class="string">&quot;貌美如花&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name,duty;</span><br><span class="line"></span><br><span class="line">    Family(String mem,String duty)&#123;     <span class="comment">//默认是private的</span></span><br><span class="line">        <span class="keyword">this</span>.name=mem;</span><br><span class="line">        <span class="keyword">this</span>.duty=duty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDuty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>enum类的主要方法</strong></p>
<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211018200409123.png" alt="image-20211018200409123" style="zoom: 80%;" />

<blockquote>
<p>重点关注values()（返回常量对象数组） ,valueOf(String str), toString()方法</p>
</blockquote>
<p><strong>枚举类实现接口</strong>  </p>
<p>1.在enum类中实现抽象方法</p>
<p>2.让枚举类的对象分别实现接口中的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;    <span class="comment">//默认是public abstract的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由枚举类来实现抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    Earth,Mars,Sun,Moon;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;     <span class="comment">//必须是public，因为抽象方法是public，重写权限必须大于等于原来的权限</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这颗星球是&quot;</span>+<span class="keyword">this</span>.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个对象分别实现接口的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Lanuage</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    Chinese&#123;</span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,English&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;英文&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,French &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;法语&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h1><h2 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h2><ul>
<li>从JDK5开始，java增加了对元数据（MetaData）的支持，也就是Annotation（注解）</li>
<li>Annotation其实就是代码里的<strong>特殊标记</strong>，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中<strong>嵌入一些补充信息</strong>。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li>
<li>Annotation可以像修饰符一样被使用，可用于<strong>修饰包、类、构造器、方法、成员变量、参数、局部变量的声明</strong>，这些信息被保存在Annotation的“name=value”对中。</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
<li>未来的开发模式都是基于注解的，JPA（Java Persistence API持久层API）是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.X以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：<strong>框架=注解+反射+设计模式</strong></li>
</ul>
<h2 id="4-2常见的Annotation示例"><a href="#4-2常见的Annotation示例" class="headerlink" title="4.2常见的Annotation示例"></a>4.2常见的Annotation示例</h2><p>常见的三种用法：</p>
<ol>
<li>生成文档相关注释</li>
<li>在编译时进行格式检查（JDK内置的三个基本的注解）</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
</ol>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205807182.png" alt="image-20211019205807182"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205833959.png" alt="image-20211019205833959"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019205905165.png" alt="image-20211019205905165"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210011651.png" alt="image-20211019210011651"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211019210314315.png" alt="image-20211019210314315"></p>
<h2 id="4-3自定义Annotation"><a href="#4-3自定义Annotation" class="headerlink" title="4.3自定义Annotation"></a>4.3自定义Annotation</h2><ol>
<li>注解声明为<code>@interface</code></li>
<li>内部定义成员，通常使用value标识</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没有成员，表明是一个标识作用</li>
<li>如果注解有成员，在使用注解时，需要指明成员的值（除非有默认值）</li>
</ol>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020185549611.png" alt="image-20211020185549611"></p>
<h2 id="4-4JDK中的元注解"><a href="#4-4JDK中的元注解" class="headerlink" title="4.4JDK中的元注解"></a>4.4JDK中的元注解</h2><p>jdk提供了四种元注解，<strong>元Annotation用于修饰其他Annotation定义</strong>。</p>
<ul>
<li><p>Retention：指定所修饰的Annotation的生命周期：SOURCE\CLASS（默认行为）\RUNTIME</p>
<ul>
<li>只有声明为RUNTIME生命周期的注解，才能通过反射获取</li>
</ul>
</li>
<li><p>Target：用于修饰Annotation定义，用于指定被修饰Annatation能用于哪些程序元素。<code>@Target</code>也包含了一个名为value的成员变量</p>
<ul>
<li><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020193009794.png" alt="image-20211020193009794"></li>
</ul>
</li>
<li><p>Documented：用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的。</p>
<ul>
<li>定义为Documented的注解必须设置Retention值为Runtime。</li>
</ul>
</li>
<li><p>Interited：被它修饰的Annotation将具有<strong>继承性</strong>。如果某个类使用了被<code>Inherited</code>修饰的Annotation，则其子类自动具有该注解。</p>
<ul>
<li><p>实际应用中，使用较少</p>
</li>
<li><p>```java<br>@Inherited<br>@Retention(RetentionPolicy.RUNTIME)<br>@interface MyAnnotation{</p>
<pre><code>String values() default &quot;aaa&quot;;
</code></pre>
<p>}</p>
<p>@MyAnnotation(values = “hello”)<br>public class p1 {</p>
<pre><code>@Test
public void test() &#123;
    for(Annotation a:p2.class.getAnnotations())
        System.out.println(a);
&#125;
</code></pre>
<p>}</p>
<p>class p2 extends p1{</p>
<p>}</p>
<p>//执行结果：@October.day04.MyAnnotation(values=”hello”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 自定义注解一般都会指明Retention，Target</span><br><span class="line"></span><br><span class="line">## 4.5利用反射获取注解信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4.6JDK8中的新注解</span><br><span class="line"></span><br><span class="line">## 可重复注解</span><br><span class="line"></span><br><span class="line">1.在`OneAnnotation`上声明`@Repeatable`，成员值为`OneAnnotations.class`</span><br><span class="line"></span><br><span class="line">2.`OneAnnotation`的Target和Retention，必须和`OneAnnotations`相同</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Repeatable(OneAnnotations.class)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line">@interface OneAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line">@interface OneAnnotations &#123;</span><br><span class="line">    OneAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><ul>
<li><p>JDK1.8以后，关于元注解<code>@Target</code>的参数类型ElementType枚举值多了两个：<code>TYPE_PARAMETER,TYPE_USE</code></p>
</li>
<li><p>在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P4</span>&lt;@<span class="title">SecondAnnotation</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> @SecondAnnotation RuntimeException</span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@SecondAnnotation</span> String&gt;list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num=(<span class="meta">@SecondAnnotation</span> <span class="keyword">int</span>)<span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER,ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> SecondAnnotation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Java集合"><a href="#5-Java集合" class="headerlink" title="5.Java集合"></a>5.Java集合</h1><h2 id="Java集合框架概述"><a href="#Java集合框架概述" class="headerlink" title="Java集合框架概述"></a>Java集合框架概述</h2><p>Java集合可以分为<code>Collection</code>和<code>Map</code>两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系<code>key-value</code>对的集合</li>
</ul>
<blockquote>
<p>Collection接口中存储自定义类的对象，除了TreeSet(自然排序重写compareTo，定制排序重写compare)，其他基本都需要重写equals，Set中需要重写hashCode和equals自不用说， List中要重写equals，主要是后续用于remove，contents等方法。</p>
</blockquote>
<p>Collection接口继承树</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213052703.png" alt="image-20211020213052703"></p>
<p>Map接口继承树</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211020213128277.png" alt="image-20211020213128277"></p>
<h2 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211021093805529.png" alt="image-20211021093805529"></p>
<blockquote>
<p>注意 contains(target)内部比较调用的是equals方法，<strong>不需要</strong>target和内部对应元素拥有相同的引用。</p>
<p>A.retainAll(B)求交集，结果存放在A</p>
<p>col1.equals(col2)，要求两者元素相同，并且顺序相同</p>
<p>hashcode()，根据内容返回哈希值；内容不同，哈希值也不同。</p>
</blockquote>
<ul>
<li>将数组元素全部读入ArrayList中<ul>
<li><code>List&lt;Integer&gt; col = new ArrayList&lt;&gt;(Arrays.asList(123,456));</code></li>
<li>注意Arrays.asList返回的不是ArrayList类型，而是<code>java.util.Arrays$ArrayList</code>类型，实现了List接口。</li>
<li>而ArrayList的构造函数可以传入一个Collection类型的数据。</li>
</ul>
</li>
</ul>
<h2 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h2><p>1.Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</p>
<p>2.<strong>GOF给迭代器模式的定义为：提供一种方法访问一个容器（Collection）对象中各个元素，而又无需暴露该对象的内部细节。迭代器模式，就是为容器而生</strong>。类似于公交车上的售票员，火车上的乘务员。</p>
<p>3.Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象。</p>
<p>4.<strong>Iterator仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</p>
<p>5.<strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Collection col=<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;...&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Iterator it= col.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default void remove()</code>方法的使用</p>
<blockquote>
<p>注：default方法指的是接口中可以写方法体的方法，实现类直接继承，无需重写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;String&gt;col=<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;yfx&quot;</span>,<span class="string">&quot;cxy&quot;</span>));</span><br><span class="line">    Iterator&lt;String&gt;it=col.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Object obj=it.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;abc&quot;</span>.equals(obj))</span><br><span class="line">            it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//col.removeIf(&quot;abc&quot;::equals); //等价写法</span></span><br><span class="line">    it=col.iterator();  <span class="comment">//需要从头获取</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法</p>
<p>2.如果还未调用next()或者在上一次调用next方法之后已经调用了remove方法，再调用remove都会报<code>IllegalStateException</code></p>
<p><strong>Iterator的执行原理</strong>：</p>
<p>iterator首先指向第一个对象之前的位置。</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211026101834161.png" alt="image-20211026101834161"></p>
<blockquote>
<p>注：Iterator不可用于Map集合</p>
</blockquote>
<p><strong>增强for循环，内部也是使用了Iterator来实现的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s:arr)	<span class="comment">//将arr中的元素赋值给s</span></span><br><span class="line">    s=<span class="string">&quot;abc&quot;</span>;	<span class="comment">//无法改变原有的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="Collection子接口一：List"><a href="#Collection子接口一：List" class="headerlink" title="Collection子接口一：List"></a>Collection子接口一：List</h2><p>List集合类中元素<strong>有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。</p>
<p>List三个实现类的不同点：</p>
<ul>
<li>ArrayList：作为List接口的主要实现类；线程不安全，效率高；底层使用<code>Object[] elementData</code>存数组储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储；</li>
<li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用<code>Object[] elementData</code>数组存储</li>
</ul>
<p>相同点：</p>
<ul>
<li>都实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>源码分析</strong>（jdk7和jdk8中有所不同）</p>
<blockquote>
<p>IDEA ctrl+f12 查看类的所有方法</p>
</blockquote>
<p>结论：建议开发中使用带参的构造器：<code>new ArrayList(int capacity);</code>，如果使用空参构造器，可能会发生频繁扩容（复制数组），降低效率</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>略</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>略</p>
<p>作为List接口的古老实现类；线程安全；效率低；底层使用<code>object[]</code></p>
<h3 id="List接口中的常用测试方法"><a href="#List接口中的常用测试方法" class="headerlink" title="List接口中的常用测试方法"></a>List接口中的常用测试方法</h3><p>List中除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法</p>
<ul>
<li><code>void add(int index,Object ele)</code></li>
<li><code>Object get(int index)</code></li>
<li><code>Object remove(int index)</code></li>
<li><code>Object set(int index,Object ele)</code></li>
</ul>
<h2 id="Collection子接口二：Set"><a href="#Collection子接口二：Set" class="headerlink" title="Collection子接口二：Set"></a>Collection子接口二：Set</h2><p>Set：存储无序的、不可重复的数据</p>
<p>以HashSet为例（TreeSet底层不是数组，是二叉树了）</p>
<ol>
<li>无序性：不等于随机性，存储的数据在底层数组（TreeSet底层不是数组）中并非按照数据索引的顺序添加，而是根据数据的hash值</li>
<li>不可重复性：hash值不同，或者hash值相同，但equals不同<ul>
<li>底层是用数组+链表/二叉树，来实现存储的。</li>
<li>向HashSet中添加元素a，先调用a的HashCode()方法，计算a的hash值，然后通过某种算法计算出a在底层数组中的存放位置（索引位置），判断数组在此位置上是否已经有元素，如果没有则添加成功，如果有则跟此位置挂载的链表/红黑树，上的元素进行比较（调用equals），如果均不相同则插入，否则产生重复不插入。</li>
</ul>
</li>
</ol>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层用的是HashMap</p>
<p>特点：</p>
<ol>
<li>线程不安全</li>
<li> 可以存储null值</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>是HashSet的子类，可以按照添加顺序遍历元素。</p>
<p>底层是hash表+双向链表（leetcode有一题LRU算法就是用这个数据结构来实现的）</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>特点：</p>
<ol>
<li><strong>只能放同一类的对象</strong></li>
<li>两种排序方式：自然排序（Comparable）、定制排序(Comparator)<ul>
<li><strong>自然排序，自定义类型必须实现Comparable接口</strong></li>
</ul>
</li>
<li>可以按照添加对象的指定属性，进行排序</li>
<li><strong>TreeSet中判断是否相同，使用的是CompareTo（自然排序）/compare（定制排序），而非equals</strong></li>
<li>TreeSet底层用的是TreeMap</li>
</ol>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map中的key：无序、不可重复，使用Set存储所有key（key的类要重写equals和hashCode方法，TreeMap则需要自然排序或定制排序）</p>
<p>Map中的value：无序、可重复，使用Collection存储所有的value</p>
<p><code>key-value</code>键值对：构成了一个Entry对象</p>
<p>Map中的entry：无序、不可重复，使用Set存储所有的entry</p>
<p><strong>注意，Map没有Iterator，不可直接迭代，需要使用元视图keySet()、entrySet()、values()的结果才能迭代</strong></p>
<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211224214935079.png" alt="image-20211224214935079" style="zoom:67%;" />

<blockquote>
<p>注意，Hashtable的t是小写</p>
</blockquote>
<p><strong>Map接口常用方法</strong></p>
<ol>
<li>增删改<ul>
<li><code>Object put(Object key,Object value)</code></li>
<li><code>void putAll(Map m)</code></li>
<li><code>Object remove(Object key)</code></li>
<li><code>void clear（）</code></li>
</ul>
</li>
<li>查询操作<ul>
<li><code>Object get(Object key)</code></li>
<li><code>boolean containsKey(Object key)</code></li>
<li><code>boolean containsValue(Object value)</code></li>
<li><code>int size()</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>boolean equals(Object obj)</code></li>
</ul>
</li>
<li>元视图操作<ul>
<li><code>Set keySet()</code>：返回所有key构成的set集合</li>
<li><code>Collection values()</code>：返回所有value构成的Collection集合</li>
<li><code>Set entrySet</code>：返回所有key-value构成的Set集合</li>
</ul>
</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是Map接口的主要实现类</p>
<p>HashMap特点：</p>
<ol>
<li>线程不安全</li>
<li>效率高</li>
<li>可以存储null的key和value</li>
<li><strong>和ArrayList一样，即使涉及线程安全问题，也可以用Collections来改造使之线程安全</strong></li>
</ol>
<p>HashMap存储数据的过程：</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150203537.png" alt="image-20211225150203537"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211225150801352.png" alt="image-20211225150801352"></p>
<p>读源码注释的收获：</p>
<ol>
<li>扩容会将原有的hash表结构破坏，所有key的位置需要重新计算，因此代价非常高。如果HashMap需要存储的数据量很大，则最好预先制定好capacity。</li>
<li>capacity大小需要合适，如果太大占用空间且迭代效率低（迭代时间复杂度O(N+capacity)，N是key的数量），如果太小需要经常扩容，扩容需要全部重新计算hash，即重新计算key的位置，代价非常大。</li>
<li>状态因子，如果大了，空间利用率高，但是容易产生冲突；如果小了，空间利用率低，但不容易产生冲突；一般用0.75比较合适</li>
<li>threshold阈值=capacity*loadfactor，hash表上元素个数（不包括链表/红黑树上的元素）超过此阈值要扩容（两倍）</li>
</ol>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable是古老实现类。</p>
<p>其子类Properties常用来处理配置文件。</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226093527904.png" alt="image-20211226093527904"></p>
<p><strong>LinkedHashMap</strong></p>
<p>保证在遍历map元素时，可以按照添加的顺序实现遍历。</p>
<p>原理：hash表+双向链表</p>
<p>对频繁的遍历操作，此类执行效率高于HashMap（支持LRU算法）</p>
<p>HashMap的底层：</p>
<ol>
<li>数组+链表（jdk7及之前）</li>
<li>数字+链表/红黑树（jdk8）</li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>按照key-value中的key进行排序（<strong>要求key是同一个类的对象</strong>），需要实现自然排序/定制排序</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>使用分段锁（数据分段加lock），在多线程使用时安全且高效</p>
<h2 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h2><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>默认是小根堆</p>
<p>如果要生成大根堆，则传入比较器，重写compare方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o2-o1;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者用lamdba表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B=<span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y-x));</span><br><span class="line"><span class="comment">//注意，lambda表达式内部不用写逗号</span></span><br></pre></td></tr></table></figure>



<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是操作<strong>Set,List,Map</strong>等集合的工具类</p>
<ol>
<li>排序操作（均为static方法）<ul>
<li>reverse(List)</li>
<li>shuffle(List)</li>
<li>sort(List)</li>
<li>sort(List,Comparator)</li>
<li>swap(List,int,int)</li>
</ul>
</li>
<li>查找、替换<ul>
<li>Object max(Collection)</li>
<li>Object max(Collection, Comparator)</li>
<li>Object min(Collection)</li>
<li>Object min(Collection, Comparator)</li>
<li>int frequency(Collection, Object) ：返回指定集合中指定元素出现的次数</li>
<li>void copy(List dest, List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值</li>
</ul>
</li>
<li>同步控制（将对应类型扔进参数即可），底层仅仅用synchronized包装了原有的方法<ul>
<li>synchronizedCollection</li>
<li>synchronizedList</li>
<li>synchronizedMap</li>
<li>synchronizedSet</li>
<li>synchronizedSortedMap</li>
<li>synchronizedSortedSet</li>
</ul>
</li>
</ol>
<h1 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6.泛型"></a>6.泛型</h1><ol>
<li>泛型类可能有多个参数，此时应该将多个参数一起放在尖括号内，如<code>E1,E2,E3</code></li>
<li>泛型类的构造器如下：<code>public GenericClass()&#123;&#125;</code><ul>
<li>这种写法是错误的：<code>public GenericClass&lt;E&gt;()&#123;&#125;</code></li>
</ul>
</li>
<li>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</li>
<li>泛型不同的引用不能相互赋值<ul>
<li>尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是在运行时都只会被当做ArrayList被加载到JVM中。</li>
</ul>
</li>
<li>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object<ul>
<li>即泛型要用，就一路都用；要不用，就都不用</li>
</ul>
</li>
<li>如果泛型类是一个接口或抽象类，则不可创建泛型类的对象</li>
<li>泛型的指定中不能使用基本数据类型，可以使用包装类替换</li>
<li>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。<strong>但在静态方法中，不能使用类的泛型</strong>（本质原因：泛型是在生成对象的时候指定的，静态结构早于对象创建）<ul>
<li>泛型方法可以是静态方法，因为泛型参数是在调用方法时确定的，并非在实例化类的时候确定。</li>
</ul>
</li>
<li>异常类，不能是泛型的</li>
<li>不能使用<code>new E[]</code>，但是可以<code>E[]elements=(E[])new Object[capacity]</code><ul>
<li>参考：ArrayList源码中生命：<code>Object[] elementData</code>，而非泛型参数类型数组</li>
</ul>
</li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型<ul>
<li>子类不保留父类的泛型，按需实现<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型，泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 没有类型，擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2. 具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">String</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//3. 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">//3.1 全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;<span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//3.2 部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt;<span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>,<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226143304180.png" alt="image-20211226143304180"></p>
<h2 id="为何需要泛型"><a href="#为何需要泛型" class="headerlink" title="为何需要泛型"></a>为何需要泛型</h2><ol>
<li>解决元素存储的安全性问题</li>
<li>解决获取数据元素时，需要强制类型转换的问题</li>
</ol>
<h2 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h2><p>如果没有使用泛型，默认是java.lang.Object类型</p>
<h2 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h2><p>泛型类、泛型接口、泛型方法</p>
<p>泛型方法：在方法中出现了泛型的结构，<strong>泛型参数与类的泛型参数没有任何关系！</strong></p>
<ul>
<li>换句话说，类中指明了<code>&lt;E&gt;</code>，而方法中用到了<code>&lt;T&gt;</code>，才能叫泛型方法。<strong>泛型方法所属的类是不是泛型类都没有关系</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">//最前面需要声明泛型E，否则编译器认为E是一个类名，会报错</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型方法可以是静态的！泛型方法可以是静态方法，因为泛型参数是在调用方法时确定的，并非在实例化类的时候确定。</strong></p>
<h2 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h2><p>子类在继承泛型时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">//SubOrder:不是泛型类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;	<span class="comment">//SubOrder&lt;T&gt;仍然是泛型类</span></span><br></pre></td></tr></table></figure>

<ol>
<li>类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;二者不具备子父类关系，二者是并列关系</li>
</ol>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226145634905.png" alt="image-20211226145634905"></p>
<ol start="2">
<li>下面这个是可以的</li>
</ol>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150152685.png" alt="image-20211226150152685"></p>
<h2 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h2><p> <img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211226150512810.png" alt="image-20211226150512810"></p>
<p>需要泛型通配符的根本原因在于，泛型之间都平行关系（即使两个泛型类型自身存在父子关系），因此如果没有泛型的话，要兼容同一子类下的所有所有类型，必须要重载很多函数。</p>
<h3 id="有限制条件的通配z符"><a href="#有限制条件的通配z符" class="headerlink" title="有限制条件的通配z符"></a>有限制条件的通配z符</h3><ul>
<li><code>&lt;?&gt;</code>允许所有泛型的引用调用</li>
<li>通配符指定上限，上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即<code>&lt;=</code></li>
<li>通配符指定下限，下限super：使用时指定的类型不能小于操作的类，即<code>&gt;=</code></li>
<li>举例<ul>
<li><code>&lt;? extends Number&gt;</code></li>
<li><code>&lt;? super Number&gt;</code></li>
<li><code>&lt;? externds Comparable&gt;</code> 只允许泛型为实现了Comparable接口的实现类的引用调用</li>
</ul>
</li>
</ul>
<h1 id="7-IO流"><a href="#7-IO流" class="headerlink" title="7.IO流"></a>7.IO流</h1><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><ul>
<li><p>绝对路径与相对路径</p>
<ul>
<li>File中的相对路径（IDEA）：<ul>
<li>如果在main方法中写，则是相对于工程的根目录（一个工程下可以有多个module）</li>
<li>如果是使用Junit单元测试测试方法，相对路径即为当前module下</li>
</ul>
</li>
<li>Eclipse中，均是相对于Project根目录下</li>
</ul>
</li>
<li><p>路径分隔符</p>
<ul>
<li><p>windows和DOS系统采用<code>\</code>来标识</p>
</li>
<li><p>UNIX和URL使用<code>/</code>来标识</p>
</li>
<li><p>为了解决这个隐患，File类提供一个常量<code>public static final String separator</code>，根据操作系统，动态地提供分隔符</p>
</li>
<li><p>注：在windows下写成<code>/</code>也能识别</p>
</li>
</ul>
</li>
<li><p>三种构造器</p>
<ol>
<li>直接写地址</li>
<li>parent地址+child地址</li>
<li>File+child地址</li>
</ol>
</li>
<li><p>创建File时，若硬盘中有对应文件，则File对象的各属性会显式赋值；否则，除了指定目录和路径外，其余属性都取默认值。</p>
</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>File类的获取功能<ul>
<li><code>public String getAbsolutePath()</code>：获取绝对路径</li>
<li><code>public String getPath()</code>：获取路径</li>
<li><code>public String getName()</code>：获取名称</li>
<li><code>public String getParent()</code>：获取上层文件目录路径，若无，返回null<ul>
<li>如果用相对路径创建File，路径名只有一级的话，返回null</li>
</ul>
</li>
<li><code>public long length()</code>：获取文件长度（字节数）不能获取目录的长度</li>
<li><code>public long lastModified</code>：获取最后一次的修改时间，毫秒值</li>
<li><code>public String[]list()</code>：获取指定目录下的所有文件或文件目录的<strong>名称</strong>数组</li>
<li><code>public File[]listFiles()</code>：获取指定目录下的所有文件或文件目录的File数组</li>
</ul>
</li>
<li>File类的重命名功能<ul>
<li><code>public boolean renameTo(File des)</code>：把文件重命名为指定的文件路径<ul>
<li>底层是native方法，跟平台相关</li>
<li>linux下des只能在同一文件夹下，我的理解：其目的是重命名，所以只能在同一目录下进行。</li>
</ul>
</li>
</ul>
</li>
<li>File类的判断功能<ul>
<li><code>public boolean isDirectory()</code>：判断是否是文件目录</li>
<li><code>public boolean isFile()</code>：判断是否是文件</li>
<li><code>public boolean exists()</code>是否存在</li>
<li><code>public boolean canRead()</code>是否可读</li>
<li><code>public boolean canWrite()</code>是否可写</li>
<li><code>public boolean isHidden()</code>是否隐藏</li>
</ul>
</li>
</ul>
<h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流，字符流</li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>字节流</strong></th>
<th><strong>字符流</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入流</strong></td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td><strong>输出流</strong></td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<ul>
<li>Java的IO流共40多个类，实际上非常规则，都是以上四个抽象基类派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为后缀</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件/节点流</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputstream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>字符流一次读几个字节？</p>
<ul>
<li>我的理解：看到FileReader源码中提到字符集的问题，应该是根据字符集来的</li>
</ul>
</li>
<li><p>为什么不能用字符流处理图片（如复制图片后会损坏打不开）？</p>
<ul>
<li>我的理解：字符流在读取文件后，会根据指定的（或默认）字符集转换原有的编码，因此二进制文件已经被改变，所以图片损坏。（如utf-32是4字节一个字符，utf-8是可变长编码字符）</li>
</ul>
</li>
<li><p>文本文件：<code>.txt</code> <code>.java</code> <code>.c</code> 使用字符流进行处理</p>
</li>
<li><p>非文本文件：<code>.jpg</code> <code>.mp3</code> <code>.doc</code> <code>.ppt</code> 使用字节流进行处理</p>
</li>
</ul>
<h2 id="节点流（又叫文件流）"><a href="#节点流（又叫文件流）" class="headerlink" title="节点流（又叫文件流）"></a>节点流（又叫文件流）</h2><p><strong>FileReader如果要一个一个读，直接用read()方法，不加参数，返回的是int类型，如果值是-1代表文件末尾，如果不是-1则转化为char类型即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data = reader.read()) != -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reader!=<span class="keyword">null</span>)</span><br><span class="line">                reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不推荐使用throws IOException?</p>
<ul>
<li>因为一共有三个地方抛异常，如果中间抛异常，会导致流没有close</li>
<li>java垃圾回收机制，只能回收JVM堆内存里的对象空间；对于其他物理连接，比如数据库连接、输入输出流、Socket连接无能为力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">char</span>[] buff = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len;<span class="comment">//需要len的原因是，结尾处可能读不满buff</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buff)) != -<span class="number">1</span>) &#123; <span class="comment">//每次按照buff的长度来读取字符，返回读取的字符的数量</span></span><br><span class="line">            <span class="comment">//for (int i = 0; i &lt; len; i++)</span></span><br><span class="line">            	<span class="comment">//System.out.print(buff[i]);</span></span><br><span class="line">            <span class="comment">//方式二</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buff, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为什么流需要关闭？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为当我们用了虚拟机以外的资源，比如端口、显存、文件的时候（访问本地资源），超出了虚拟机能够释放资源的界限，这时候虚拟机并不能通过垃圾回收机制对你占用的资源进行释放，如果在没有关闭的情况下第一次运行程序是不会发生问题的，但是随着资源占有量逐渐增多而你又不自己进行close释放资源的话，垃圾只会越积越多，导致系统无法存储其他的资源，甚至会导致系统崩溃。如果你再次对未关闭流的文件进行读写，编译就会报错，告诉你这个文件被占用。</span><br><span class="line"></span><br><span class="line">举例说明：如果你再堆区new一个对象的时候，如果等号左边是对端口、显存、文件进行操作的时候，虚拟机就无法利用垃圾回收机制对堆区占用的资源进行释放。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">虽然都是 InputStream，但不同的物理实现，close() 的物理作用也有所不同，所以忘记了 close() 的后果也不一样。</span><br><span class="line"></span><br><span class="line">比如 ByteArrayInputStream 这种输入流，close() 与否就没什么关系。</span><br><span class="line"></span><br><span class="line">楼主的例子中，实际的输入流是一个网络连接。如果忘记 close() 的话，它会一直占用着，直到 timeout 后系统自动关闭这个网络连接。也就是说，如果你忘记了关闭这个资源，到了一定的时候，系统会替你关闭。但如果类似这样的程序被执行很多次，就会有大量资源被长时间无效占用，极端情况下可能导致后续程序资源不足而失败。</span><br><span class="line"></span><br><span class="line">也不是所有的资源都能自动回收，比如 FileInputStream，你要是忘记关闭了，它就一直占用着，直到 JVM 退出。</span><br><span class="line"></span><br><span class="line">所以，回过来说，好的编程习惯是：主动用程序严格控制对资源的释放，而不必区分其具体的物理实现，不要指望系统级的回收机制。这样能保证程序的可读性和可靠性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结一下，针对内存的流可以不关闭，但是使用了JVM外界的资源的流如文件、端口、数据库连接等，JVM无法在垃圾回收时进行关闭并清理对应的内存对象，因此需要手动close（可以使用try-with-resources方式进行关闭）。如果一直不关，会导致外界资源一直被占用，对应的内存对象无法回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(file,<span class="keyword">true</span>); <span class="comment">//第二个参数表示是否追加写入</span></span><br><span class="line">        fw.write(<span class="string">&quot;\n你在赣神魔！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么close要放在finally中？</p>
<ul>
<li><p>如果不写在finally中，如写在try或catch或try-catch代码块后面，try或者catch中可能会出现跳过close的代码，如thow、return、continue、break(如下代码所示)</p>
</li>
<li><p>不放在catch中，是因为可能有多个具体的异常（多个catch），需要写很多close，不如统一写在finally中</p>
</li>
</ul>
<blockquote>
<p>注意：try-catch的目的就是为了处理异常，使得后续代码可以继续运行。因此try-catch中出现了异常，程序不会直接退出，后续代码会继续执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(..)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    close();	<span class="comment">//如果continue执行，则无法close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用filereader和filewriter进行文件的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*复制文件*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;src.txt&quot;</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(f1);</span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(f2,<span class="keyword">true</span>);   <span class="comment">//true:追加写入，false：清空文件重新写入</span></span><br><span class="line">        <span class="keyword">char</span>[]buf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用字节流复制图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用字节流复制图片*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;皮卡丘.jfif&quot;</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">&quot;皮卡丘副本.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(f1);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line">        <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len=fis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>处理流的一种</p>
<p>缓冲流是为了提高文件的读写效率</p>
<ul>
<li>我认为其效果就如同中断方式的IO和DMA方式的IO</li>
</ul>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231155043835.png" alt="image-20211231155043835"></p>
<p>没有缓冲意味着：包工头指着一块砖头对着工人说你给我从A搬到B地，然后再发出命令你把下一块砖头从A搬到B，重复直至搬完；有了缓冲，包工头可以说你把这100块砖头从A搬到B，然后等工人搬完再下达命令，直到所有砖头搬完（方法二节省了很多无效时间）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByBuf</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(url);</span><br><span class="line">    File copy = <span class="keyword">new</span> File(<span class="string">&quot;副本&quot;</span> + file.getName());</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(copy);</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];	<span class="comment">//buf的大小影响文件读写效率</span></span><br><span class="line">        <span class="keyword">while</span>((len=bis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>)</span><br><span class="line">                bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，将外层处理流关闭后，内层的节点流会自动关闭</strong></p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>处理流的一种</p>
<ol>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流<ul>
<li><code>InputStreamReader</code>：将InputStream转换为Reader</li>
<li><code>OutputStreamWriter</code>：将Writer转换为OutputStream</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转换成字符流操作更高效（为什么？没查到原因）</li>
<li>很多时候我们使用转换流来处理<strong>文件乱码</strong>的问题，实现编码和解码的功能</li>
<li>字符集<ul>
<li>ASCII：美国标准信息交换码</li>
<li>ISO8895-1：拉丁码表：欧洲码表。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li>
<li>GBK:中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每一个字符分配唯一的字符码。<ul>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是<strong>UTF-8和UTF-16</strong>。</li>
</ul>
</li>
<li>UTF-8:变长的编码方法，可用1-4个字节来表示一个字符。</li>
</ul>
</li>
</ol>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20211231163746622.png" alt="image-20211231163746622"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    OutputStreamWriter osw=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">        osw=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;gbk_src.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//                System.out.println(new String(buf, 0, len));</span></span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isr!=<span class="keyword">null</span>)</span><br><span class="line">                isr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(osw!=<span class="keyword">null</span>)</span><br><span class="line">                osw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103822036.png" alt="image-20220101103822036"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101103915239.png" alt="image-20220101103915239"></p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从键盘输入字符串，要求将读取到的整行字符串转换成大写输出。然后继续进行输入操作</span></span><br><span class="line"><span class="comment">     * 直至输入e和exit时，退出程序*/</span></span><br><span class="line"><span class="comment">/*方法1：使用Scanner实现</span></span><br><span class="line"><span class="comment">     * 方法2：使用System.in实现。 System.in --&gt; 转换流 --&gt; BufferedReader的readline()*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in, StandardCharsets.UTF_8);</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String t = br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(t) || <span class="string">&quot;exit&quot;</span>.equals(t.toLowerCase())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(t.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟实现Scanner效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MyInput myInput = <span class="keyword">new</span> MyInput(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//            int a= myInput.readInt();</span></span><br><span class="line">        <span class="comment">//            System.out.println(a);</span></span><br><span class="line">        <span class="comment">//            System.out.println(myInput.readString());</span></span><br><span class="line">        System.out.println(myInput.readFloat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInput</span><span class="params">(InputStream input)</span> </span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出字符，直到遇到空格或回车停止*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) reader.read();</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sb.length() == <span class="number">0</span>)   <span class="comment">//防止返回空的数字</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) reader.read();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sb.length() == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                sb.append(c);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=(<span class="keyword">char</span>)reader.read();</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span> || c==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sb.length()==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/*输入的浮点数格式不正确*/</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Float.parseFloat(sb.toString());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>了解即可</p>
<p>Sytem.out就是一个打印流</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220101134612613.png" alt="image-20220101134612613"></p>
<p><strong>将System.out的打印流从控制台重定向到自定义的输出流中，然后写入文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;testSystemOutRedirect.txt&quot;</span>,<span class="keyword">true</span>);	<span class="comment">//追加写入</span></span><br><span class="line">PrintStream ps=<span class="keyword">new</span> PrintStream(fos);	</span><br><span class="line">System.setOut(ps);	<span class="comment">//重定向System输出，到自定义的ps打印流</span></span><br><span class="line">InputStreamReader reader=<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span>((t=reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> c=(<span class="keyword">char</span>)t;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>了解即可</p>
<ul>
<li><p>作用：为了方便操作Java语言的基本数据类型和String的数据，可以使用数据流（<strong>可以理解为专门为Java基本数据类型和String类型持久化和读取的流，其生成的文件可以理解为一种特殊文件，用于持久化存储java基本数据类型和String</strong>）</p>
</li>
<li><p>读取不同类型的数据的顺序，要与当初写入文件时的顺序一致！</p>
</li>
<li><p>数据流有两个类：用于读取和写出基本数据类型、String类的数据</p>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream子类的流上</li>
</ul>
</li>
<li><p>DataInputStream中的方法</p>
<ul>
<li><code>boolean readBoolean()</code></li>
<li><code>char readChar()</code></li>
<li><code>double readDouble</code></li>
<li>…</li>
<li><code>String readUTF()</code></li>
<li><code>void readFully(byte[] b)</code></li>
</ul>
</li>
<li><p>DataOutputStream中的方法</p>
<ul>
<li>将上述的方法中的read改为相应的write即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流进行java基本数据类型和String的持久化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;dataflow&quot;</span>));</span><br><span class="line">    dos.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">12345</span>);</span><br><span class="line">    dos.flush();    <span class="comment">//将内存中的数据写入文件</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据流进行java基本数据类型和String的持久化文件的读取</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    DataInputStream dis=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;dataflow&quot;</span>));</span><br><span class="line">    <span class="keyword">boolean</span> b=dis.readBoolean();</span><br><span class="line">    String s=dis.readUTF();</span><br><span class="line">    <span class="keyword">int</span> i=dis.readInt();</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于：可将任何实现了Serializable接口的对象转换成字节数据，使其在保存和传输时可以被还原。</li>
<li>序列化是RMI（Remote Method Invoke 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则会抛出<code>NotSerializableException</code>异常。<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
</li>
<li><strong>对象序列化需要满足两个要求</strong><ol>
<li>实现接口Serializable（仅仅是个标识接口，无具体内容）</li>
<li>当前类提供一个全局常量：serialVersionUID<ul>
<li>serialVersionUID用来表示类的不同版本之间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成。<strong>若类的实例变量做了修改，serialVersionUID可能发生变化</strong>。所以，建议使用显式声明。</li>
<li>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本的一致性的。在进行反序列化时，JVM会把传过来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常（InvalidCastException）</li>
</ul>
</li>
<li>必须保证内部所有属性可序列化（默认情况下，基本数据类型可序列化）</li>
</ol>
</li>
</ul>
<h3 id="对象流-1"><a href="#对象流-1" class="headerlink" title="对象流"></a>对象流</h3><ul>
<li>ObjectInputStream, ObjectOutputStream</li>
<li>用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用ObjectOutputStream类保存基本数据类型或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本数据类型或对象的机制</li>
<li>不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java对象序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;serializationObjects&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="string">&quot;你是什么念&quot;</span>);</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Date());</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java对象反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;serializationObjects&quot;</span>));</span><br><span class="line">    Object o1=ois.readObject();</span><br><span class="line">    Object o2=ois.readObject();</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="随机存取文件流"><a href="#随机存取文件流" class="headerlink" title="随机存取文件流"></a>随机存取文件流</h2><p>RandomAccessFile类</p>
<ul>
<li>声明在<code>java.io</code>包下，但直接继承于java.lang.Object类。（而非继承于流的四个基类）并且它实现了DataInput、DataOutput这两个接口，意味着既可以读也可以写（但是要造两个对象）</li>
<li><code>RandomAccessFile</code>类支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><code>RandomAccessFile</code>对象包含一个记录指针，可以标示当前读写处的位置。该对象可以自由移动记录指针<ul>
<li><code>long getFilePointer()</code>：获取文件记录指针的当前位置</li>
<li><code>void seek(long pos)</code>：将文件记录指针定位到pos位置</li>
</ul>
</li>
<li>创建对象需要指定一个mode参数，该参数指定RandomAccessFIle对象的访问模式<ul>
<li><code>r</code>：以只读方式打开</li>
<li><code>rw</code>：打开以便读取和写入</li>
<li><code>rwd</code>：打开以便读取和写入；同步文件的内容的更新</li>
<li><code>rws</code>：打开以便进行读取和写入；同步文件内容和元数据的更新</li>
<li>注：如果模式为r，则不会创建文件，而是会读取一个已存在的文件，如果读取的文件不存在则会抛出异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建，而是覆盖。</li>
</ul>
</li>
</ul>
<h2 id="NIO-2中Path、Paths、Files类的使用"><a href="#NIO-2中Path、Paths、Files类的使用" class="headerlink" title="NIO.2中Path、Paths、Files类的使用"></a>NIO.2中Path、Paths、Files类的使用</h2><ul>
<li>Java NIO(Non-Blocking IO)是从java1.4开始引入的一套新的IO API，可以替代标准Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作。<strong>NIO将以更高效的方式进行文件的读写操作</strong>。</li>
<li>Java API中提供了两套NIO，一套是针对标准输入输出的NIO，另一套是网络编程NIO<ul>
<li><code>java.nio.channels.Channel</code>：<ul>
<li><code>FileChannel</code>：处理本地文件</li>
<li><code>SocketChannel</code>：TCP网络编程的客户端Channel</li>
<li><code>ServerSocketChannel</code>：TCP网络编程的服务器端的Channel</li>
<li><code>DatagramChannel</code>：UDP网络编程中发送端和接收端的Channel</li>
</ul>
</li>
</ul>
</li>
<li>随着JDK7的发布，Java对NIo进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2，因为NIO提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</li>
</ul>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103453508.png" alt="image-20220103103453508"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103515417.png" alt="image-20220103103515417"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103526943.png" alt="image-20220103103526943"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103543846.png" alt="image-20220103103543846"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103603452.png" alt="image-20220103103603452"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220103103611895.png" alt="image-20220103103611895"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>一般实际工作中，会导入第三方jar包，如Apache的<code>commons-io</code>中的FileUitls来实现文件的操作。</p>
<h1 id="8-网络编程"><a href="#8-网络编程" class="headerlink" title="8.网络编程"></a>8.网络编程</h1><h2 id="网络通信要素概述"><a href="#网络通信要素概述" class="headerlink" title="网络通信要素概述"></a>网络通信要素概述</h2><p>如何实现网络中的主机相互通信</p>
<ul>
<li>通信双方地址<ul>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
<li>一定的规则（网络通信协议）<ul>
<li>OSI参考模型：模型过于理想化，未在因特网上进行广泛推广</li>
<li>TCP/IP参考模型（TCP/IP协议）：事实上的国际标准</li>
</ul>
</li>
</ul>
<h2 id="通信要素1：IP和端口号"><a href="#通信要素1：IP和端口号" class="headerlink" title="通信要素1：IP和端口号"></a>通信要素1：IP和端口号</h2><p>在Java中使用InetAddress类代表IP</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105095131010.png" alt="image-20220105095131010"></p>
<ul>
<li>端口号标识正在计算机上运行的进程<ul>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个16位的整数0~65535</li>
<li>端口分类<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如HTTP80，FTP21，Telnet23）</li>
<li>注册端口：1024~49151.分配给用户进程或应用程序。（如Tomcat8080，MySQL3306，Oracle1521）</li>
<li>动态/私有端口：49152~65535</li>
</ul>
</li>
<li>端口号和IP地址的组合得出一个网络套接字：Socket</li>
</ul>
</li>
</ul>
<h2 id="通信要素2：网络协议"><a href="#通信要素2：网络协议" class="headerlink" title="通信要素2：网络协议"></a>通信要素2：网络协议</h2><p>TCP和UDP</p>
<p>TCP协议：</p>
<ul>
<li>使用前须建立TCP连接，形成传输通道</li>
<li>传输前，采用<strong>三次握手</strong>方式，点对点通信，可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中可进行大量数据的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
</ul>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220105100554138.png" alt="image-20220105100554138"></p>
<p>UDP协议：</p>
<ul>
<li>将数据、源、目的封装成数据包，无需建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方也收不到确认，故不可靠</li>
<li>可以广播发送</li>
<li>发送结束后无需释放资源，开销小，速度快</li>
</ul>
<p>为什么TCP需要三次握手、四次挥手?</p>
<ul>
<li>B站掌知识：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kV411j7hA?from=search&amp;seid=5623693464798890863&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1kV411j7hA?from=search&amp;seid=5623693464798890863&amp;spm_id_from=333.337.0.0</a></li>
</ul>
<h2 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h2><p>注：用教研室电脑作为服务器端进行测试，由于ISP会动态给路由器分配IP地址，需要临时查看路由器IP；此外需要固定路由器给本机MAC分配的IP地址，然后固定NAT内外端口映射。</p>
<p>注：为何使用节点流、缓冲流，有时接收方的read无法结束，持续阻塞？而使用DataOutputStream和DataInputStream则没问题？</p>
<ul>
<li>答：因为如果不关闭流，接收方read无法得知何时结束接收（貌似关闭流，接收方read就会返回-1，结束while）。因此如果发送方的发送文件代码下方没有别的代码阻塞，则函数结束，自动关闭流；如果下方有别的代码在阻塞，则不会自动关闭流，此时需要手动关闭流。</li>
<li>答：DataOutputStream的writeUTF和DataInputStream的readUTF，每次传输后会自动关闭流。</li>
</ul>
<p><strong>客户端/服务器聊天案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端：监听指定端口号，一旦有socket请求，则创建两个持续执行的线程，一个用来接收消息，一个用来发送消息</span></span><br><span class="line"><span class="keyword">package</span> MyChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>; <span class="comment">//服务端socket</span></span><br><span class="line">        Socket clientSocket = <span class="keyword">null</span>;   <span class="comment">//客户端socket</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;    <span class="comment">//监听端口，一旦收到新的scoket，则建立两个线程用于接收和发送消息</span></span><br><span class="line">                clientSocket = serverSocket.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> SendMessageToClient(clientSocket)).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReceiveClientMessage(clientSocket)).start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(clientSocket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clientSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendMessageToClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    DataOutputStream dataOutputStream=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendMessageToClient</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataOutputStream=<span class="keyword">new</span> DataOutputStream(s.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                message=sc.nextLine();</span><br><span class="line">                dataOutputStream.writeUTF(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveClientMessage</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiveClientMessage</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataInputStream = <span class="keyword">new</span> DataInputStream(s.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;    <span class="comment">//一直运行，一旦接收到消息，就打印</span></span><br><span class="line">                message=dataInputStream.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端消息：&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端：向指定ip和端口发起socket请求，创建两个线程，一个用于发送消息，一个用于接收消息</span></span><br><span class="line"><span class="keyword">package</span> MyChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ip = <span class="string">&quot;219.230.70.7&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port=<span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MessageToServer(serverSocket)).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MessageFromServer(serverSocket)).start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageToServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageToServer</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(s.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            message=sc.nextLine();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataOutputStream.writeUTF(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageFromServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageFromServer</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataInputStream = <span class="keyword">new</span> DataInputStream(s.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String info=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                info=dataInputStream.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到服务端消息：&quot;</span>+info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>客户端/服务器文件传输案例</strong></p>
<p>注：</p>
<ul>
<li><p>只有发送端关闭outputstream，接收端的read才能返回-1</p>
</li>
<li><p><strong>失败经验</strong>：我采用在发送数据的前4个字节添加数据长度，接收方根据长度来判断何时终止while循环，来解决read阻塞的问题（不阻塞，则接受完文件可以继续向发送方反馈信息）。但是失败了，文件没接受完就一直阻塞。</p>
<ul>
<li><p>我思考可能的原因是：底层tcp协议有个缓冲区，每次缓冲区接收满，或者收到FIN包，才会将缓冲区中内容复制到用户程序缓冲区。（这样做的原因是，数据包不是按顺序接收的，要保证这一段数据全部完整接收才会交给应用程序）。因此我的程序依然会阻塞在read处。</p>
</li>
<li><p>```java<br>while((len=bufferedInputStream.read(buf))!=-1){</p>
<pre><code>bufferedOutputStream.write(buf,0,len);
fileLength-=len;
System.out.println(&quot;本轮传输&quot;+len+&quot;B，剩余&quot;+fileLength+&quot;B&quot;);
if(fileLength&lt;=0)
    break;
</code></pre>
<p>}</p>
<p>//控制台消息<br>文件长度为12850B<br>本轮传输1024B，剩余11826B<br>本轮传输1024B，剩余10802B<br>本轮传输1024B，剩余9778B<br>本轮传输1024B，剩余8754B<br>本轮传输1024B，剩余7730B<br>本轮传输1024B，剩余6706B<br>本轮传输1024B，剩余5682B<br>//卡在这里不动了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 解决办法：使用NIO。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//服务器端：监听指定端口，一旦有socket请求，则创建一个线程发送文件</span><br><span class="line">package day05;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class TransferFileServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //持续监测端口，一旦发现socket连接，则启动发送文件的线程</span><br><span class="line">        int port=12345;</span><br><span class="line">        ServerSocket serverSocket=null;</span><br><span class="line">        Socket socket=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            serverSocket=new ServerSocket(port);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                socket= serverSocket.accept();  //阻塞线程</span><br><span class="line">                new Thread(new SendFileThread(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(serverSocket!=null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket!=null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SendFileThread implements Runnable &#123;</span><br><span class="line">    private final Socket socket;</span><br><span class="line">    private final String filename=&quot;副本曼达洛人.The.Mandalorian.S01E01.中英字幕.WEB.1080p-人人影视.V4.mp4&quot;;</span><br><span class="line"></span><br><span class="line">    public SendFileThread(Socket s) &#123;</span><br><span class="line">        this.socket = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedOutputStream output=null;</span><br><span class="line">        BufferedInputStream input=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            output=new BufferedOutputStream(socket.getOutputStream());</span><br><span class="line">            input=new BufferedInputStream(new FileInputStream(filename));</span><br><span class="line">            byte[]buf=new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            while((len=input.read(buf))!=-1)&#123;</span><br><span class="line">                output.write(buf,0,len);</span><br><span class="line">//                System.out.println(&quot;len=&quot;+len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;本次传输完成！&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(input!=null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    input.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(output!=null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    output.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端：向指定ip地址和端口发起socket请求，接收文件</span></span><br><span class="line"><span class="keyword">package</span> day05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferFileClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ip=<span class="string">&quot;219.230.74.51&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> port=<span class="number">12345</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReceiveFileThread(ip,port)).start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接收文件*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveFileThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiveFileThread</span><span class="params">(String ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream bufferedInputStream=<span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line">            bufferedInputStream=<span class="keyword">new</span> BufferedInputStream(socket.getInputStream());</span><br><span class="line">            <span class="keyword">int</span> tmp=count;</span><br><span class="line">            bufferedOutputStream=<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;File_&quot;</span>+tmp+<span class="string">&quot;.mp4&quot;</span>));</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len=bufferedInputStream.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bufferedOutputStream.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端接收文件&quot;</span>+tmp+<span class="string">&quot;结束！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bufferedOutputStream!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bufferedInputStream!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h2><h2 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h2><h1 id="9-反射"><a href="#9-反射" class="headerlink" title="9.反射"></a>9.反射</h1><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><p>反射：通过对象得知其类的信息</p>
<p>为什么需要反射:有些类无法在编译时确定,需要在运行时动态确定,比如Spring管理各种Bean,不可能预知.</p>
<p>反射相关的主要API</p>
<ul>
<li><code>java.lang.Class</code>:代表一个类</li>
<li><code>java.lang.reflect.Method</code>:代表类的方法</li>
<li><code>java.lang.reflect.Field</code>:代表类的成员变量</li>
<li><code>java.lang.reflect.Constructor</code>:代表类的构造器</li>
</ul>
<h2 id="获取Class的实例的四种方式"><a href="#获取Class的实例的四种方式" class="headerlink" title="获取Class的实例的四种方式"></a>获取Class的实例的四种方式</h2><p>方式1:调用<strong>运行时类</strong>的属性:<code>.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz=Student.class;	<span class="comment">//泛型可加可不加</span></span><br></pre></td></tr></table></figure>

<p>方式2:通过<strong>运行时类</strong>的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">Class clazz=stu.getClass();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>运行时类: .java文件被编译成.class文件之后,加载进内存中,生成Class类的对象的类(任何类都是Class类的对象).</p>
<p>加载到内存中的运行时类,会缓存一定的时间.在此时间之内,我们可以通过不同的方式来获取此运行时类.</p>
</blockquote>
<p>方式3:调用Class的静态方法(用的最多)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(<span class="string">&quot;com.njust.java.Student&quot;</span>); 	<span class="comment">//有异常要处理ClassNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>方式4:使用类的加载器:ClassLoader(了解)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader=Studetn.class.getClassLoader();</span><br><span class="line">Class clazz=classLoader.loadClass(<span class="string">&quot;com.njust.java.Student&quot;</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注:四种方式获取的运行时类,地址值相同.</p>
<p>即:Class的实例就对应着一个运行时类</p>
</blockquote>
<h2 id="哪些些类型可以有Class对象"><a href="#哪些些类型可以有Class对象" class="headerlink" title="哪些些类型可以有Class对象"></a>哪些些类型可以有Class对象</h2><ol>
<li>class 外部类,成员(成员内部类,静态内部类),局部内部类,匿名内部类</li>
<li>interface:接口</li>
<li>[] 数组 (只要数组元素类型和维度相同,就是同一个Class)</li>
<li>enum:枚举</li>
<li>annotation:注解@interface</li>
<li>primitive type:基本数据类型</li>
<li>void</li>
</ol>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164815175.png" alt="image-20220604164815175"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604164848679.png" alt="image-20220604164848679"></p>
<p> <img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165142642.png" alt="image-20220604165142642"></p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604165528449.png" alt="image-20220604165528449"></p>
<h2 id="使用ClassLoader加载配置文件"><a href="#使用ClassLoader加载配置文件" class="headerlink" title="使用ClassLoader加载配置文件"></a>使用ClassLoader加载配置文件</h2><p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604170541798.png" alt="image-20220604170541798"></p>
<h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz=Student.class;</span><br><span class="line">Student stu=clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>还可以通过获取构造器来创建实例</p>
<p><img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220604171910160.png" alt="image-20220604171910160"></p>
<h1 id="10-Java8新特性"><a href="#10-Java8新特性" class="headerlink" title="10.Java8新特性"></a>10.Java8新特性</h1><h1 id="11-Java9-amp-10-amp-11-新特性"><a href="#11-Java9-amp-10-amp-11-新特性" class="headerlink" title="11.Java9 &amp; 10 &amp; 11 新特性"></a>11.Java9 &amp; 10 &amp; 11 新特性</h1></div><div class="article-licensing box"><div class="licensing-title"><p>Java高级</p><p><a href="https://fxgood.gitee.io/2020/07/30/Java-java高级/">https://fxgood.gitee.io/2020/07/30/Java-java高级/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>余丰旭</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-06-30</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/25/%E9%9A%8F%E7%AC%94-%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">日常编程心得</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"><span class="level-item">单调队列解决滑动窗口最大值问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/icon.jpg" alt="余丰旭"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">余丰旭</p><p class="is-size-6 is-block">Stay hungry. Stay foolish.</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">145</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">36</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">我的项目</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">92</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-17T14:11:23.735Z">2022-07-17</time></p><p class="title"><a href="/2022/07/17/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E5%AD%97%E8%8A%82-%E7%94%A8%E6%88%B7%E5%96%9C%E5%A5%BD/">用户喜好</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-11T14:06:56.625Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/Java-java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/">Java知识点复习</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-06T11:39:32.312Z">2022-07-06</time></p><p class="title"><a href="/2022/07/06/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BE%8E%E5%9B%A2-%E4%BB%A3%E9%87%91%E5%88%B8/">小美的代金券要过期啦</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-02T07:17:42.239Z">2022-07-02</time></p><p class="title"><a href="/2022/07/02/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6/">删除字符</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-02T05:36:39.381Z">2022-07-02</time></p><p class="title"><a href="/2022/07/02/%E7%AE%97%E6%B3%95-%E5%81%9A%E9%A2%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">做题方法总结</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/B%E6%A0%91/"><span class="tag">B树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dfs/"><span class="tag">dfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86/"><span class="tag">二分</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="tag">二叉树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"><span class="tag">优先级队列</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%BA%E9%97%B4dp/"><span class="tag">区间dp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"><span class="tag">单调栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"><span class="tag">单调队列</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"><span class="tag">双指针</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%93%88%E5%B8%8C/"><span class="tag">哈希</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9E%E6%BA%AF/"><span class="tag">回溯</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86/"><span class="tag">堆</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"><span class="tag">字节跳动</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"><span class="tag">最小生成树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"><span class="tag">最短路径</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><span class="tag">滑动窗口</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"><span class="tag">笔试题</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BE%8E%E5%9B%A2/"><span class="tag">美团</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span class="tag">背包问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%85%BE%E8%AE%AF/"><span class="tag">腾讯</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B4%AA%E5%BF%83/"><span class="tag">贪心</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AC%E5%8C%96%E7%AD%89%E4%BB%B7%E9%97%AE%E9%A2%98/"><span class="tag">转化等价问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%92%E5%BD%92/"><span class="tag">递归</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%9F%E5%88%97/"><span class="tag">队列</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%BF%E9%87%8C/"><span class="tag">阿里</span><span class="tag">12</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="余丰旭的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 余丰旭</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>