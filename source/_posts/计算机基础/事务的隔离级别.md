---
title: 事务的隔离级别
categtory: 计算机基础
excerpt: 巩固一下数据库的四种隔离级别及对应的并发导致的问题
---

|          | 幻读 | 不可重复读 | 脏读 |
| -------- | ---- | ---------- | ---- |
| 串行化   |      |            |      |
| 可重复读 | √    |            |      |
| 读已提交 | √    | √          |      |
| 读未提交 | √    | √          | √    |

四种隔离级别

- 串行化：事务之间串行执行，不存在任何并发产生的问题

- 可重复读：同一个事务内，多次相同查询的结果相同（即使中途别人修改了数据库中实际的数据）
  - 其实就是事物内部**看不见别人（感知不到）别的事务的操作**（不管别人提没提交）
  - 因此别人对数据库进行了实际的操作（增删改），而我却不知道，于是在我增删改查的时候就会出现幻觉，例如
    - User表中用户名是唯一索引，事务A查询User老王，结果为空；然后B插入了User老王；接着A插入User老王，结果报错（事务A很懵，觉得自己发生了幻觉，明明我查询结果没有老王，为什么插入的时候会报错，产生唯一索引的冲突）
  - 我的理解，在可重复读隔离级别的事务内部，只要进行了查询，那么则会保存一份这个查询的副本在本地，下次进行相同查询的时候，不去看数据库，而是看本地我存的副本。
  - **Mysql默认的隔离级别**
- 读已提交：
  - 其实就是事务内部**看不见别人还没有提交的操作**
  - 会产生不可重复读的问题，很好理解，在事务A的过程中，在两次查询同一数据的过程中，B修改了它，则会产生不可重复读的问题。
- 读未提交
  - 其实就是事务内部可以看见别人没有提交的操作
  - 产生脏读的原因很简单，我读了某一数据，别人又回滚了，那么我就读到了脏数据

```
/**
* 1. 读未提交  存在 脏读,不可重复读,幻读的问题
* 2. 读已提交  存在 不可重复读,幻读的问题
* 3. 可重复读 存在 幻读
* 4. 串行化
*
* 脏读: 读了别人回滚的数据
* 不可重复读: 两次读数据的中途,有人修改了数据(增删改)
* 幻读: 为了保证可重复读,实际上看到的是隔离了数据库真实数据的视图,故读到的情况和数据库真实情况有出入,导致幻读
* /
```

