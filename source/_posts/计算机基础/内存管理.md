---
title: 内存管理
category: 计算机基础
tag: OS
excerpt: 复习内存的基础知识，包括内存管理方式、分页、分段、虚拟内存等。
---

# 内存的基础知识

## 什么是内存？有何作用

CPU运行速度大大快于硬盘，需要一个介于CPU和硬盘中间速度的介质来缓和这个矛盾，即内存。因此，程序执行前需要先放到内存中才能被CPU处理。

**思考**：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？

## 存储单元和内存地址

一个内存地址对应一个存储单元，存储单元的大小取决于计算机是**按字节编址**还是**按字编址**

## 进程运行的基本原理

### 从写程序到程序运行：编辑—编译—链接—装入

编译：由编译程序将用户源代码编译成若干目标模块（编译就是把高级语言翻译为机器语言）

链接：由链接程序将边以后形成的一组目标模块，以及所需要的库函数链接在一起，形成一个完成的装入模块装入（装在）：由装入程序将装入模块装入内存运行。（**链接后，形成完成的逻辑地址**）

![image-20210926110953819](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926110953819.png)

装入时才关心逻辑地址到物理地址的转换

### 三种链接方式

**静态链接**

在程序运行前，先将各自目标模块及它们所需的库函数连接成一个完成的可执行文件（装入模块），之后不再拆开。

![image-20210926114221784](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926114221784.png)

**装入时动态链接**

将各目标模块装入内存时，边装入边链接的链接方式

![image-20210926114329337](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926114329337.png)

![image-20210926114339868](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926114339868.png)

**运行时动态链接**

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

 ![image-20210926114532814](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926114532814.png)

### 三种装入方式

说白了，绝对装入就是编译完地址都是绝对地址；静态重定位就是装入的时候将逻辑地址改为物理地址；动态重定位是运行时才将逻辑地址转换为物理地址。

**绝对装入**

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码（指令）。装入程序按照装入模块中的地址，将程序和数据装入内存。

Eg：如果知道装入模块要从地址为100的地方开始存放，则

![image-20210926112111000](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926112111000.png)

绝对装入**只适用于单道程序环境**，灵活性很低。程序中使用的绝对地址，可以在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。

***

**静态重定位**

又称为**可重定位装入**。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行**重定位**，将逻辑地址变为物理地址（地址变换是在装入时一次性完成的）。

![image-20210926113122460](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926113122460.png)

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。

***

**动态重定位**

现在的计算机系统一般都采用动态重定位方式。

动态重定位：又称为动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。

![image-20210926113612755](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926113612755.png)

![image-20210926113900693](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210926113900693.png)

# 内存管理

## 内存空间的分配和回收

讨论的问题：操作系统要怎么记录哪些内存区域已经被分配出去了，哪些是空闲的？很多位置都可以放，进程那应该放在哪里？当进程运行结束之后，如何将进程占用的内存空间回收？

### 连续分配管理方式

连续分配：指为用户进程分配的必须是一个连续的内存空间。

####　单一连续分配

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210927201939354.png" alt="image-20210927201939354" style="zoom:50%;" align='left'/>

在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。

内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

优点：

- 实现简单；无外部碎片（不可利用的外部空间）；
- 可以采用覆盖技术扩充内存（程序分段，内存分固定区和覆盖区）；
- 不一定需要采用内存保护。

缺点：

- 只能用于单用户、单任务的操作系统中；
- 有内部碎片（分配给某个进程的内存区域中，如果有些部分没有利用，就是内部碎片）；
- 存储器利用率极低。

***

#### 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

（作业是应用层的概念，指的是某项任务，至少依赖一个进程来完成）

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928083059596.png" alt="image-20210928083059596" style="zoom:67%;" />

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928082748351.png" alt="image-20210928082748351" style="zoom:67%;" />

分区大小相等：缺乏灵活性，但是**很适合用于一台计算机控制多个相同对象的场合**（比如，钢铁厂有n个炼钢炉，就可以把内存分为n个大小相等的区域存放n炼钢炉控制程序）

分区大小不等：增加了灵活性，可根据实际需求划分内存。（使用分区说明表，记录每个分区的大小、起始地址、状态）



优点：

	- 实现简单
	- 无外部碎片

缺点：

- 当用户程序太大时，可能所有的分区都不满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能
- 会产生**内部碎片**，内存利用率低（所有内存已经被分区，不存在外部碎片）

***

#### 动态分区分配

动态分区分配又称为可变分区分配。这种分区方式**不会预先划分内存区域**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928084149405.png" alt="image-20210928084149405" style="zoom:67%;" />

**问题1：系统要用什么样的数据结构来记录内存的使用情况**？

![image-20210928084458473](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928084458473.png)

**问题2：当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？**

四种动态分区分配算法

1. 最佳适应 Best Fit
2. 最差适应 Worst Fit
3. 首次适应 First Fit
4. 循环适应(邻近适应算法) Next Fit

**问题3：如何进行分区的分配与回收操作？**

回收后与根据具体情况需要与前后合并。

分区分配增加表项，具体排列方式需要根据动态分区分配算法来确定。



动态分区分配**没有内部碎片**，但是有**外部碎片**。

（内部碎片：分配给某进程的内存区域中，某些没有利用上；外部碎片，指内存中的某些控线分区由于太小而难以利用）

![image-20210928085709240](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928085709240.png)

紧凑技术不能使用绝对装入（绝对装入在编译时即确定物理地址）和静态重定位（装入时确定物理地址），采用动态重定位的装入方式比较合适。

紧凑之后需要做什么处理：修改PCB，调整进程起始地址。

### 非连续分配管理方式

考虑支持多道程序设计的两种连续分配方式

1. 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低
2. 动态分区分配：会产生很多外部碎片，虽然可以用紧凑技术来处理，但是其时间代价很高

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928090432532.png" alt="image-20210928090432532" style="zoom:67%;" />

#### 基本分页存储管理

基本分页存储管理的思想：把内存分为一个一个相等的小分区，再按照分区大小把进程拆成一个个小部分

![image-20210928090910351](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928090910351.png)

![image-20210928091153997](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928091153997.png)

将进程地址**分页**之后，操作系统该如何实现逻辑地址到物理地址的转换？

![image-20210928091513083](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928091513083.png)

> 关于此问题我的想法：将进程地址空间分页后，不同页面映射到内存中的不同页框中，想要将某逻辑地址（某个存储单元，如果按字节编址则是一个字节，如果按字编址则是一个字）转换为物理地址，则先计算两样东西，1.在哪个页面 2.页内偏移量。 然后找出该页面对应的页框，再根据偏移量即可计算出最终的物理地址。
>
> 注：页号=逻辑地址/页面大小，业内偏移量=逻辑地址%页面大小

![image-20210928210526442](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928210526442.png)

![image-20210928211404187](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928211404187.png)

![image-20210928212602468](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928212602468.png)

**页表**

![image-20210928212815994](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928212815994.png)

#### *基本地址变换机构

用于实现逻辑地址到物理地址转换的一组硬件机构

![image-20210928213149965](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928213149965.png)

![image-20210928213702719](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928213702719.png)

> 这里可以看出CPU进行上下文切换时候，会从接下来要执行的进程的PCB中读取一系列信息并写入寄存器中，包括页表始址、页表长度，进程中下一条指令的逻辑地址（放入程序计数器PC中）

![image-20210928213639601](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928213639601.png)

![image-20210928214640300](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928214640300.png)

#### *具有快表的地址变换机构

**1.局部性原理**

时间局部性：如果执行了程序中的某条指令，那么不就后其很可能再次被执行；如果某个数据被访问过，不久之后其很可能再次被访问。（因为程序中存在大量的循环）

空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）。

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928215327209.png" alt="image-20210928215327209" style="zoom:67%;" />

**2.什么是快表TLB**

快表，又称为**联想寄存器**（TLB），**是一种访问速度比内存快很多的高速缓冲器**（不在内存中），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常成为慢表。

**3.引入快表后，地址的变换过程**

![image-20210928220056120](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928220056120.png)

![image-20210928220112940](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928220112940.png)

![image-20210928220358102](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928220358102.png)

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210928220446984.png" alt="image-20210928220446984" style="zoom:67%;" />

#### *两级页表

单级页表存在的问题

![image-20210929193102502](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929193102502.png)

需要给每个进程都分配连续的1024个页框，违背了离散分配的初衷。

 <img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929193152942.png" alt="image-20210929193152942" style="zoom:67%;" />

 如何解决单级页表的问题？

![image-20210929193818584](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929193818584.png)

![image-20210929193855597](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929193855597.png)

![image-20210930185305724](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930185305724.png)

#### 基本分段存储管理

![image-20210929204630751](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929204630751.png)

![image-20210929210241455](C:/Users/14259/AppData/Roaming/Typora/typora-user-images/image-20210929210241455.png)

#### *分段、分页管理的对比

![image-20210929210556116](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929210556116.png)

![image-20210929210816231](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929210816231.png)

![image-20210929211857520](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210929211857520.png)

#### 段页式存储管理

![image-20210930193830706](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930193830706.png)

![image-20210930194102504](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930194102504.png)

## 内存空间的扩充

GTA5大小超过60GB，而系统内存只有16GB，为什么这款游戏可以顺利运行呢？ 答：因为使用了虚拟技术（OS的虚拟性）

### 覆盖技术

思想：将**程序分为多个段**（多个模块）。常用的段常驻内存，不常用的段需要时调入内存。

内存中分为**一个固定区和若干覆盖区**。

需要常驻内存的段放在**固定区**中，调入后就不再调出（除非运行结束）。

不常用的段放在**覆盖区**，需要用到时调入内存，用不到时调出内存。

![image-20210927194349187](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210927194349187.png)

（注意：这里B、C不会被A同时调用，DEF也不会被同时调用）

优点：逻辑上，内存被拓展了。

缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。 

覆盖技术只用于早期的操作系统中，现在已经成为历史。

### 交换技术

思想：内存紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度），属于中级调度。

中级调度（内存调度）：就是要决定将哪个处于挂起状态的进程重新调入内存。

挂起状态：暂时换出外存等待的进程状态称之为**挂起状态suspend**，挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态。

![七状态模型](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210927195344608.png)

**三个问题**

**一.** 应该在外存的什么位置保存被换出的进程？

具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。**文件区**主要用于存放文件，**主要追求存储空间的利用率**，因此对文件区空间的管理**采用离散分配方式**；**对换区**空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。

由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出的速度，因此通常对换区**采用连续分配方式**。总之，**对换区的IO速度比文件区的更快**。



**二.**什么时候应该交换？

交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。

例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。‘



**三.**应该换出哪些进程？

可优先换出阻塞进程；

可换出优先级低的进程；

为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间；  

（**注意：PCB会常驻内存**，不会被换出外存，OS是根据PCB来对并发执行的进程进行控制和管理的）



覆盖技术与交换技术的区别：覆盖是在同一个程序或进程中的，交换是在不同进程（或作业）之间的。

### 虚拟存储技术

![image-20210930194639572](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930194639572.png)

传统存储管理方法的缺点：

- 一次性：**作业必须一次性全部装入内存后才能开始运行**（覆盖技术一定程度上可以缓解）。这会造成两个问题：
  1. 作业很大时，不能全部装入内存，**导致大作业无法运行**
  2. 大量作业要求运行时，由于内存无法容纳所有作业，因此只能有少量作业运行，**导致多道程序并发度下降**
- 驻留性：一单作业被装入内存，就会**一直驻留在内存中**，直到作业运行结束。事实上，根据局部性原理，在一个时间段内，只需要访问作业的一小部分数据就可以正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。



局部性原理：

- 时间局部性：如果一个指令或者数据被访问，那么稍后很可能还被访问（因为程序中存在大量循环）
- 空间局部性：如果一个数据被访问，内存中他附近的数据接下来很可能被访问（因为很多数据在内存中都是连续存储的）



**虚拟内存的定义和特征**：

基于局部性原理，在程序装入时，可以将程序中**很快会用到的部分装入内存，暂时用不到的部分留在外存**，就可以让程序开始执行。

在程序执行过程中，当所访问的**信息不在内存时**，由操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

若内存空间不够，由**操作系统负责**将内存中**暂时用不到的信息换出到外存**。

在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是**虚拟内存**。（操作系统虚拟性的一个提现，实际的物理内存大小没有变，知识在逻辑上进行了扩充）



**易混淆知识点**：

虚拟内存的**最大容量**：由CPU寻址范围确定（寻址，寻的是内存地址）

虚拟内存的**实际容量**：min(内存和外存容量之和，CPU寻址范围)



**虚拟内存三大特征**

1. 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2. 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3. 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量



**如何实现虚拟内存技术**

虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。



![image-20210930200639446](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930200639446.png)

虚拟内存最重要的两个技术：请求调页(段)，页面置换(段置换)。 一个进内存、一个出内存。

#### 请求分页存储管理

![image-20210930201735133](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930201735133.png)

![image-20210930201841976](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930201841976.png)

![image-20210930201951352](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930201951352.png)

![image-20210930202153526](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202153526.png)

![image-20210930202530431](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202530431.png)

![image-20210930202657958](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202657958.png)

![image-20210930202710962](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202710962.png)

![image-20210930202918308](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202918308.png)

![image-20210930202950552](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20210930202950552.png)

## 地址转换

为了使编程更方便，程序员写程序时应该只关注指令、数据的逻辑地址。而**逻辑地址到物理地址的转换**（地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

地址转换的实现方式 ，即三种装入方式：

1. 绝对装入：编译时产生绝对地址（单道程序阶段使用，还没产生操作系统，由编译器实现）
2. 可重定位装入（静态重定位）：装入时将逻辑地址转换为物理地址（用于早起的多道批处理操作系统）
3. 动态运行时装入（动态重定位）：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器（现代操作系统）

## 存储保护

操作系统需要提供**内存保护**功能，保证各进程在各自存储空间内运行，互不干扰。

内存保护可采取的两种方法：

1. 在CPU中**设置一对上下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。
2. 采用**重定位寄存器（又称为基址寄存器）和界地址寄存器（又称限长寄存器）**进行越界检查。重定位寄存器中存放的是进程的**起始物理地址**。界地址寄存器中存放的是进程的**最大逻辑地址**。



> 本博客所用图片，均来自B站王道操作系统视频的截图。







