---
title: 操作系统知识巩固
category: 计算机基础
tag: OS
excerpt: 对操作系统的知识进行系统性地梳理和巩固
date: 2021-07-11
---

# 概述
- 操作系统基本功能
	- 统一管理所有计算机资源
		处理器资源
		存储资源
		IO资源
		文件资源 
	- 实现了对计算机资源的抽象
		用户无需面向硬件接口编程
		IO设备管理软件，提供读写接口
		文件管理软件，提供操作文件接口
	- 提供了用户与计算机之间的接口
		图像窗口形式
		命令形式
		系统调用形式  
		<!-- more -->
- 操作系统四大特性
	- 并发
		并行：多个事件**同一时刻**发生
		并发： 多个事件**同一时间间隔**内交替发生（多道程序交替执行）
	- 共享
		- 共享性：操作系统中的资源可以供多个并发的程序共同使用
		- 分类：
			互斥共享
			同时共享
	- 虚拟
		- 虚拟性：把一个**物理实体**转变为若干个**逻辑实体**  	 
		- 虚拟技术又分为：时分复用和空分复用。
		- **时分复用技术**：资源在时间上进行复用，不同程序**并发**使用；多道程序分时使用计算机硬件资源 
			- 虚拟处理器技术 
				借助多道程序设计技术，为每个程序建立**进程**，多个程序（进程）**分时复用处理器**
			- 虚拟设备技术
				物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备**并发访问** 
		- **空分复用技术**：用来实现**虚拟磁盘、虚拟内存等**，提高资源的利用率，提升编程效率。
			- 虚拟磁盘技术
				物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 
			- 虚拟内存技术
				在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 
	- 异步 
		-  在多道程序环境下，允许多个进程并发执行
		- 进程在使用资源时可能需要等待或放弃
		- 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）
# 进程管理
- 为什么需要进程
	- 没有配置OS之前，资源属于当前运行的程序（单道程序设计）
	- 配置OS之后，引入**多道程序设计**的概念
	- 合理地隔离资源、运行环境，提升资源利用率
	<img src="https://img-blog.csdnimg.cn/20210720102741599.png" width=50%>
- 进程的作用
	-  进程是系统进行资源分配和调度的基本单位
	- 进程作为程序独立运行的载体，保障程序正常执行
	- 进程的存在使得操作系统资源的利用率大幅提升
```
面试官：请你谈一谈你对进程的认识。
答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。
首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。
那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。
```
## 进程的实体
 - 主存中的进程形态：
	- 标识符：唯一标记一个进程，用于区别其他进程
	- 状态：标记进程的进程状态，如：运行态
	- 程序计数器：进程即将被执行的下一条指令的地址
	- 内存指针：程序代码、进程数据相关指针
	- 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据）
	- IO状态信息：被进程IO操作所占用的文件列表
	- 记账信息：使用处理器事件、时钟数总和等
	<img src="https://img-blog.csdnimg.cn/20210720104445903.png" width=30%>
- 进程控制块(PCB)
	- 用于描述和控制进程运行的通用数据结构
	- 记录进程当前状态和控制进程运行的全部信息
	- PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） 
	- PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。
- 进程控制块(PCB)中记录的数据，可以分为四类
	- 进程标识符
	- 处理机状态
	- 进程调度信息
	- 进程控制信息
 ## 进程与线程
 一个进程(Process)可以有一个或多个线程(Thread)
 - 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位
 - 线程包含在进程之中，是进程中实际运行工作的单位
 - 一个进程可以并发多个线程，每个线程执行不同的任务
 - 线程共享进程资源
<img src="https://img-blog.csdnimg.cn/20210720111513111.png" width=60%>

|  |进程  |线程|
|--|--|--|
|资源  |资源分配的基本单位  |不拥有资源  |
|调度  |独立调度的基本单位  |独立调度的最小单位  |
|系统开销  |开销大  |开销小  |
|通信  |进程IPC  |读写同一进程数据通信  |

## 五状态模型
进程的五状态模型包括：创建，**就绪，执行，阻塞**，中止
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/c5d3e9135e2942febd5b539025b27958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
 - 就绪状态
	- **定义**：其他资源都准备好，只差CPU资源的状态称为就绪状态
	- 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行
	- 多个处于就绪状态的进程通常排列成一个队列，称为**就绪队列**
 - 执行状态
 	- **定义**：进程获得CPU，其程序正在执行，称为执行状态
 	- 在单处理机中，在某个时刻只能有一个进程是处于执行状态
 - 阻塞状态
 	- **定义**：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 
 	- 阻塞进程会组成一个队列，称为**阻塞队列**
 - 创建状态
 	- 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态
	<img src="https://img-blog.csdnimg.cn/558eb4359c864086878a858f591844ee.png" width=60%>
	- 操作系统提供fork函数接口创建进程
 - 终止状态
	- 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态
	<img src="https://img-blog.csdnimg.cn/495851953b4b44c7bf9a33cda4964fa1.png" width=60%> 
## 进程同步
- 为什么需要进程间同步
	- 需要进行进程同步的两个经典问题 	
	生产者消费者问题
	<img src="https://img-blog.csdnimg.cn/5304f639b5274e5a8437bb18892c95ca.png" width=60%> 
	哲学家就餐问题
	<img src="https://img-blog.csdnimg.cn/6ba499eabd9a433b954f297fcfac3955.png" width=60%> 
	- 上述两个模型发生问题的根源：彼此之间没有通信
	- 进程之间同步所解决的问题
	1.对竞争资源在多进程之间进行次序的协调
	2.使得并发执行的多个进程之间可以有效使用资源和相互合作
	- **临界资源**
	指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。
- 进程间同步的原则
1.空闲让进：资源无占用，允许使用
2.忙着等待：资源有占用，请求进程等待
3.有限等待：保证有限等待时间能够使用资源
3.让权等待：等待时，进程需要让出CPU
- 线程与线程的同步方法
	- 进程同步方法
	1.消息队列
	2.共享存储
	3.信号量
	- 线程同步方法
	1.互斥量
	2.读写锁
	3.自旋锁
	4.条件变量

## Linux的进程管理
### Linux进程的相关概念
- 进程的类型：
	- 前台进程：
		1.前台进程就是具有中断，可以与用户交互的进程
	- 后台进程：
		1.与前台进程相对，没有占用终端的就是后台进程；
		2.后台程序基本上不和用户交互，优先级比前台进程低
		3.将需要执行的命令以`&`符号结束
	- 守护进程：
		1.守护(daemon)进程是特殊的后台进程；
		2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭；
		3.linux有很多典型的守护进程；
		4.进程名字以`d`结尾的一般都是守护进程，如`crond`,`sshd`,`httpd`,`mysqld`
	- 操作系统提供fork函数接口创建进程
	<img src="https://img-blog.csdnimg.cn/03dff1823dc54adcb3c1ed5cd45577ff.png" width=60%>

	- 进程的标记
		- 进程ID
		1.唯一性
		2.负整数，最大值由操作系统限定
		3.ID为0的进程为idle进程，是系统创建的第一个进程
		4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化
		5.Init进程是所有用户进程的祖先进程 
		- 状态符号
		<img src="https://img-blog.csdnimg.cn/25a8c04bacd647548876b3c40266f8a6.png" width=80%>
### 操作Linux进程的相关命令
- ps命令
1.ps是process status的缩写
2.可以添加`-ef`或者`-aux`展示详细进程详细信息
3.搜索某个进程的详细信息`ps -ef | grep python3`
4.查询进程树`ps -ef --forest`
5.查询某个用户的进程`ps -u yfx`
6.按照cpu的使用频率进行排序`ps -aux --sort=-pcpu`
7.按照内存使用的状况进行排序`ps - aux --sort=-pmem`
- top命令
1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态
- kill命令 
1.`kill -9 进程号` 无条件终止进程

# 作业管理
作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。
## 进程调度
### 进程调度概述 
- 进程调度：计算机通过决策决定哪个**就绪进程**可以获得CPU的使用权（多道程序设计）
- 进程调度的步骤
1.保留旧进程的运行信息，请出旧进程
2.选择新进程，准备运行环境并分配cpu
- 新老进程的上下文切换机制
进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。
<img src="https://img-blog.csdnimg.cn/031200c57a624d418a305f9c5c73b5a2.png" width=60%>
### 进程调度算法
- 两种调度的方式
1.非抢占式的调度
2.抢占式的调度
- 进程调度算法
1.先来先服务
2.短进程优先
3.高优先权优先
4.时间片轮转
## 死锁 
死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。
### 死锁的产生
- 死锁产生的原因
1.竞争资源
2.进程调度顺序不当
- 死锁的四个**必要条件**（如果出现死锁，必然存在下边四个条件）
1. 互斥条件
资源同一时间只能允许一个进程访问
2. 请求保持条件
进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源
3. 不可剥夺条件
只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。
4. 循环等待条件
多个进程之间存在资源请求的环路
### 死锁的处理
- 预防死锁
	- 破坏请求保持条件
	1.进程运行之前，一次性申请所有需要的资源
	2.并且在运行期间不会提出新的资源请求
	- 破坏不可剥夺条件
	1.当一个进程请求新的资源得不到满足时，必须释放占有的资源
	2.进程运行时占用的资源可以被释放
	- 破坏环路等待条件 
	1.可用资源线性排序，申请必须按照需要递增申请
	<img src="https://img-blog.csdnimg.cn/01391ae5656e411ab7a53503ea10340c.png" width=60%>
	假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。
	但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。
- 避免死锁
	- 避免死锁和预防死锁的区别
	二者都是通过施加某些限制条件，来预防死锁发生。
		- 差别：
	1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个）
	2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态）

	- 银行家算法
		- 是一个可操作的著名的避免死锁的算法
		- 以银行借贷系统分配策略为基础的算法 
		![在这里插入图片描述](https://img-blog.csdnimg.cn/b1f23d7fdc784571a7b3ae32eb268d96.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
		![在这里插入图片描述](https://img-blog.csdnimg.cn/caf293a941384c4f88e5eaef9b895058.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)


# 存储管理
## 内存分配
### 单一连续分配
只能在单用户、单进程的操作系统中使用
### 固定分区分配
1.内存空间被划分为若干固定大小的区域
2.每个分区只提供给一个程序使用，互不干扰 
<img src="https://img-blog.csdnimg.cn/fecb0132fbeb44cab662564e8f9199d3.png" width=20%>

### 动态内存分配
根据进程实际需要，动态分配内存空间
- 动态分区空闲表数据结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/410a7918acb84746a933ab6a590209b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
- 动态分区空闲链数据结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/29cba6a04cee4ed4a0987620291e2e10.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
- 内存分配过程
1. 首次适应算法（First Fit)：
**算法思想**：将空闲分区链以**地址递增的顺序**连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。
**优点**：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件
**缺点**：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。
(2)每次都是从低址部分查找，使得查找空闲分区的开销增大
2. 循环首次适应算法(Next Fit) ：
**算法思想**：配内存时不是从链首进行查找可以分配内存的空闲分区，而是**从上一次分配内存的空闲分区的下一个分区**开始查找，直到找到可以为该进程分配内存的空闲分区；
**优点**：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小
**缺点**：高址部分的大空闲分区被分小，使得大作业进入无法分配内存
3. 最佳适应算法（Best Fist）
![在这里插入图片描述](https://img-blog.csdnimg.cn/53530d7b5f154102a0af1b16e8b6809e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
**算法思想**：将空闲分区链中的空闲分区按照空闲分区**由小到大的顺序排序**，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”
**优点**：第一次找到的空闲分区是大小最接近待分配内存作业大小的
**缺点**：产生大量难以利用的外部碎片。
4. 快速适应算法（Quick Fit）
**算法思想**：快速适应算法要求有**多个空闲区链表**，每个空闲区链表存储一种容量的空闲区
![在这里插入图片描述](https://img-blog.csdnimg.cn/fe710b41ec2f458697855281c1b4346b.png)
## 内存回收
一共有四中情况，如下图
![在这里插入图片描述](https://img-blog.csdnimg.cn/d19c89fdad4247f2812d85e89955e50d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可
2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址
3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址
4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去
## 页式存储管理
**管理方式**
1.将进程逻辑空间等分为若干大小的页面
2.相应地把物理内存空间分成与页面大小相同的物理块
3.以页面为单位把进程空间装进物理内存中分散的物理块

**页面大小**
1.过大难以分配，过小内存碎片过多
2.通常是512B~8K

**页表**
1.页表记录进程逻辑空间与物理空间的映射
2.某个页表项的地址=页表起始地址+页表项大小x页号
3.实际物理地址=字块大小x字块号+块内偏移地址
<img src="https://img-blog.csdnimg.cn/edeaf28e211540908dc4c5e975bbf903.png" width=70%>
<img src="https://img-blog.csdnimg.cn/0f4375253dcf4571b2a0ed3d8c3085f3.png" width=40%>

**多级页表**
页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。
但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/69bad90819994c6b8c2d62a7c899da2d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
**缺陷**
有一段连续的逻辑分布在多个页面中，将大大降低执行效率
## 段式存储管理
**管理方式**
1.将进程逻辑空间划分成若干段（非等分）
2.段的长度由连续逻辑的长度决定
3.主函数MAIN，子程序段X，子函数Y等
![在这里插入图片描述](https://img-blog.csdnimg.cn/64692627c1fa4af19258688b65c5e710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
## 段式和页式对比
1.二者都离散地管理了进程的逻辑空间
2.页是物理单位，段式逻辑单位
3.分页是为了合理利用空间，分段是满足用户要求
4.页大小由硬件固定，段长度可动态变化
5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度）
## 段页式存储管理
**为何需要段页式存储管理**
1.分页可以有效提高内存利用率
2.分段可以更好地满足用户需求
3.二者结合，形成段页式存储管理

**如何管理**
1.先将逻辑空间按按段式管理分成若干段
2.再把段内空间按页式管理分成若干页
![在这里插入图片描述](https://img-blog.csdnimg.cn/df0914c320d244fba93dc25a1fbe7977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/48e5370629f04a6695f37199ffeaf210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
## 虚拟内存
**问题**
一个游戏十几G，物理内存只有8G，游戏如何运行起来的？

**虚拟内存概述**
有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。
虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8033b27497c0468c9340fc0fcae5b4a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
**程序局部性原理**
指CPU访问存储器，无论是**存取指令**还是**存取数据**，所访问的存储单元都趋于聚集在一个较小的连续区域中。
那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。
虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。

**虚拟内存的置换算法**
1.先进先出算法FIFO
2.最不经常使用算法LFU
3.最近最少使用算法LRU

**与高速缓存的替换区别**
1.替换策略发生在Cache-主存层次、主存-辅存层次
2.Cache-主存层次的替换策略主要是为了解决**速度问题**
3.主存-辅存层次主要是为了解决**容量问题**
## Linux存储管理
### Buddy内存管理算法
**概述**
1.Buddy算法（伙伴算法）是经典的内存管理算法
2.基于计算机处理二进制的优势，效率极高
3.主要是为了解决**内存外碎片**的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB）
<img src="https://img-blog.csdnimg.cn/f37fdd76b0fa494c90e15fbe2f287744.png" width=60%>

<img src="https://img-blog.csdnimg.cn/a4f2396c6480423fac925651950eb235.png" width=15%>  <img src="https://img-blog.csdnimg.cn/69ac5ae8948e4d6f9284e888027f3fc1.png" width=10%>

**Buddy管理算法的目的**
努力让内存分配与相邻内存合并能够快速进行

**内存分配原则**
向上取整为2的幂大小（外碎片转化为内碎片）
(1)申请70k -> 分配128k
(2)申请129k -> 分配256k
(3)申请666k -> 分配1024k

**伙伴系统**
伙伴指的是内存的伙伴，一片连续内存的伙伴是**相邻的**另一片大小一样的连续内存

**内存分配过程**
1.创建一系列空闲块链表，每一种都是2的幂大小
<img src="https://img-blog.csdnimg.cn/d94ded0cb1a44d088bc453f0dc8f64a2.png" width=60%>
2.假设存储空间有1M大小
<img src="https://img-blog.csdnimg.cn/be2f3ec4fc82422eaf53e4a3f981ff42.png" width=20%>
3.分配100k内存
(1)100k向上取2的幂=128k
(2)查询是否有128k的空闲内存块？
(3)没有！查询是否有256k空闲内存块？
(4)没有！查询是否有512k空闲内存块？
(5)没有！查询是否有1M空闲块内存？
(6)有，摘下1M空闲内存块，分配出去
(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去
(8)拆下256K放在空闲链上，其余分配出去
(9)拆下128K放在空闲链上，其余分配出去
(10)分配完毕

4.回收内存过程
(1)判断刚才分配的内存伙伴在空闲链表上吗？
(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴...?
(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴...?
(4)在！移出伙伴，合并为1M空闲内存
(5)插入1M空闲链表，回收完成

### Linux交换空间
**概述**
1.交换空间（Swap）是磁盘的一个分区
2.Linux物理内存满时，会把一些内存交换到Swap空间

**作用**
1.冷启动内存依赖
许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。
2.系统睡眠依赖
Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。
3.大进程空间依赖
有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。

**Swap空间和虚拟内存的对比**
Swap空间
(1)存在于磁盘
(2)与主存发生置换
(3)是**操作系统概念**
(4)**解决系统物理内存不足问题**

虚拟内存
(1)存在于磁盘
(2)与主存发生置换
(3)是**进程概念**
(4)**解决进程物理内存不足问题**

# 文件管理
## 文件的逻辑结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/a6d2e24a912d4b7fb323750ed8097dc5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)

### 逻辑结构的文件类型
![在这里插入图片描述](https://img-blog.csdnimg.cn/a4f9274c5c1644bf8c74f0fde2c0711e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
**有结构文件**
1.文件内容由定长记录和可变长记录组成
2.定长记录存储文件格式、文件描述等结构化数据项
3.可变长记录存储文件的具体内容
<img src="https://img-blog.csdnimg.cn/4dfc5f1056834281b099caa401c74e6a.png" width=70%>

**无结构文件**
也成为流式文件，文件内容长度以**字节**为单位。如exe文件、dll文件、so文件
> linux静态链接库文件.a  动态链接库文件.so 
> windows静态链接库文件.lib 动态链接库文件.dll

### 顺序文件
1.顺序文件是指按照顺序存放在存储介质中的文件
2.磁带的存储特性使得磁带文件只能存储顺序文件
3.顺序文件是所有逻辑文件当中存储效率最高的
4.顺序文件的增删查改是比较困难的
### 索引文件
1.可变长的文件不适合用顺序文件格式存储
2.索引文件是为了解决可变长文件存储而发明的一种文件格式
3.索引文件需要配合**索引表**完成存储
<img src="https://img-blog.csdnimg.cn/680e3cab635b4ab8a558b7c239b23b3a.png" width=70%>
## 辅存的存储空间分配
<img src="https://img-blog.csdnimg.cn/604199f6a4af4558a3cfa007236495ee.png" width=90%>

### 连续分配 
<img src="https://img-blog.csdnimg.cn/6655fef0059c4bf39c02e3ceea304821.png" width=90%>
1.顺序读取文件非常容易，速度很快
2.对存储要求高，要求满足容量的连续存储空间

### 链接分配
1.链接分配可以将文件存储在离散的盘块中
2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中->隐式链接，记录在FAT中->显示分配）

**隐式链接分配**
![在这里插入图片描述](https://img-blog.csdnimg.cn/d26096f2adf84bc9b81afc3d375f89ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
**显式链接分配**
![在这里插入图片描述](https://img-blog.csdnimg.cn/bf0b857d85664acf8ea3077b50a65d60.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
缺点：
1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。
2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块）

### 索引分配
![在这里插入图片描述](https://img-blog.csdnimg.cn/7560a78a244c4331b8e044d15cf4cc40.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
1.每个文件拥有一个索引块，记录所有盘块信息
2.索引分配方式支持直接访问盘块
3.文件较大时，索引分配方式具有明显优势
4.现在主流文件系统都是使用索引分配
## (空闲块)存储空间管理
三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。

### 空闲表
![在这里插入图片描述](https://img-blog.csdnimg.cn/c029cb57d468480aae2bdc62884e89bf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
### 空闲链表
1.把所有空闲盘区组成一个空闲链表
2.每个链表节点存储空闲盘块和空闲的数目
### 位示图
![在这里插入图片描述](https://img-blog.csdnimg.cn/d3b5ebe1425641ca8ff5ef553bc8a5b5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
1.位示图维护成本低
2.非常容易找到空闲盘块
3.使用0/1比特，占用空间小

## 目录管理
![在这里插入图片描述](https://img-blog.csdnimg.cn/112e877a166f4857bf4d6d211095dc83.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
任何文件或目录都只有唯一路径
## Linux文件的基本操作
### Linux目录
![在这里插入图片描述](https://img-blog.csdnimg.cn/b841410348284ac9933f922ff4b588db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
|目录|描述  |
|--|--|
|/bin  |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里  |
|/etc  |存放系统管理和配置文件  |
|/home  |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user  |
|/usr  |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：`unix software resources`  |
|/opt  |额外安装的可选应用程序宝所放置的位置  |
|/proc  |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息  |
|root  |超级用户（系统管理员）的主目录  |
|/sbin  |存放二进制可执行文件，只有root才能访问  |
|/dev  |用于存放设备文件  |
|/mnt  |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。  |
|/boot  |存放用于系统引导时使用的各种文件  |
|/lib  |存放文件系统中的程序运行所需要的共享库及内核模块  |
|/var  |用于存放运行时需要改变数据的文件  |


### Linux文件常用操作
|命令|操作  |
|--|--|
|touch  |创建文件  |
|mkdir|创建文件夹|
|rm|删除文件|
|cat|查看文件|
|gedit|使用gedit编辑文件|

### Linux文件类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca2aa6fe1bb24ef49695b046b7195c5d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)
> 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信

使用`ls -al`命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型
![在这里插入图片描述](https://img-blog.csdnimg.cn/f0f9a31c139d480e96ea4f79d348c113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI1OTA4OA==,size_16,color_FFFFFF,t_70)

## Linux文件系统 

# 设备管理

