---
title: Java面试复习
category: Java
excerpt: 对java的面试知识点进行复习,主要包括java基础,容器,并发编程,jvm,新特性等.
---

# Java基础

## 基本概念

![image-20220613141652944](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220613141652944.png)

1. JDK,JRE和JVM
   - JDK>JRE>JVM
   - jdk包括jre,编译器javac,工具(如javadoc)等,能够创建和编译程序
   - jre包括jvm,标准类库等,是java运行时环境
   - jvm是java运行字节码的虚拟
     - 现在最常用的JVM规范的实现是:HotSpot VM
2. 什么是字节码?采用字节码的好处是什么?
   - 字节码是面向JVM的代码,既JVM可以理解的代码
   - 采用字节码的好处是: 跨平台行,一次编译,随处运行
   - 由于解释器逐行解释速度比较慢,后面引进了JIT编译器(just-in-time即时编译器),JIT在运行时编译.对于重复的字节码,jit可以将上次编译好的机器码直接拿过来用,加快了运行效率.
3. Java是编译型语言,还是解释型语言?
   - Java是编译和解释并存的语言. 
   - .java文件通过javac编译成.class文件,是编译过程
   - .class文件加载到jvm中会解释执行(解释成可以直接执行的机器码),这是解释过程
4. Java和C++的区别
   - C++是编译型语言,Java是编译和解释并存的语言
   - Java有垃圾回收机制GC
   - Java没有指针
   - Java的类是单继承,但是可以通过接口实现多继承
   - java不支持运算符重载
5. 权限修饰符?
   - public ,任何类中都能访问;修饰类的话,java源文件必须与public类名相同
   - protected,同一包和不同包的子类可以访问
   - default,无需修饰符,同一包下可以访问
   - private,只能在当前类中被访问
6. final, finally,finalize区别
   - final
     - 用在类上:不能继承
     - 用在方法上,不能初始化
     - 用在变量上:常量,不能修改,必须赋初值(直接赋值,构造函数,静态代码块,ps:这些都是在类的加载机制的初始化阶段对其进行赋值)
       - 基本数据类型:值不能改变
       - 引用数据类型:地址不能修改
   - finally: try-catch-finally,里边的代码无论发生什么都一定会执行
   - finalize: 是Object中的方法,也就意味着每个对象中都可以调用. 通知垃圾回收器回收此对象.但是不能保证会被回收.
7. 面向对象和面向过程?
   - 面向过程性能比较高,因为没有实例化等过程
   - 面向对象能实现高内聚,低耦合的代码设计,使得程序易维护,易扩展
8. 面向对象的三大特征?
   - 封装: 将数据和方法封装到类中,实现高内聚低耦合的设计
   - 继承:子类继承父类的成员变量和方法,并在此基础上进行拓展,提高了代码的复用性.
   - 多态:父类引用指向子类对象. 多态又叫延迟方法,指的是子类对象的类型在编译时无法确定,只有在运行时才能确定.

## 基本语法

1. 标识符和关键字的区别?

   - 标识符是类,变量,方法等的名字
   - 关键字是被赋予特殊含义的标识符

2. java语言的关键字有哪些

   - 访问控制: public private protected
   - 数据类型: byte short int long float double boolean char
   - 类,方法和变量修饰符: class interface enum abstract extends implements  
   - 错误处理: try catch finally throw throws

3. 静态方法为什么不能调用非静态成员?

   - 静态方法属于类,在类加载的时候就会分配内存
   - 非静态方法属于实例对象,只有对象实例化之后才会存在
   - 因此不能在内存中不存在非静态成员的时候调用它.

4. 重载和重写的区别?

   - 重载: 同名方法,参数列表不同
   - 重写:覆盖父类的相同方法
     - 方法重写要遵循"两同两小一大"原则: 即名称,参数列表相同; 返回值类型和异常类型应该比父类小或相同;访问权限应该比父类大或相同

5. 可变长参数?

   - 只能放在参数列表最右边

   - 编译后实际会被转换为一个数组
   - 在方法重载时不会被优先匹配

6. 基本类型和包装类型的区别?

   - 基本数据类型有默认值,而包装类型是对象类型,不赋值的话是null
   - 基本数据类型不能作为泛型
   - 包装类型在堆上分配内存,而基本数据类型**的局部变量**存放在java虚拟机栈的局部变量表中.(非静态成员变量如果用基本数据类型,那么会存放在堆中)

7. 包装类型的缓存机制了解吗?

## 集合

### ArrayList

底层结构:

- 底层是Object数组
- 如果不指定初始化长度,则先创建一个长度为0的数组,在第一次add的时候创建一个长度为10的Object数组(在源码grow方法中可以看到)
- 如果容量不够,会扩大1.5倍,底层用的是Arrays.copyOf(xx,xx)复制数组;

特点:

- 由于是顺序结构,所以具有顺序结构所有的优缺点
  - 优点:
    - 支持随机访问
    - 查询效率高
  - 缺点:
    - 扩容的话,涉及到数组的复制,效率非常低
      - 增删效率低
- 线程不安全
  - 如何变成线程安全的? 答:使用Collections.synchronizedList(List list)方法返回一个线程安全的List

### LinkedList

底层结构: 双向链表

特点:

- 实现了List和Deque双端队列接口

- 由于底层是双向链表,所以具有链表结构的所有优缺点
  - 优点
    - 增删效率高
    - 不需要连续的存储空间
  - 缺点:
    - 查询效率低,每次需要从头节点开始遍历找到目标节点
- 线程不安全
  - 如何变成线程安全的? 答:使用Collections.synchronizedList(List list)方法返回一个线程安全的List

### Vector

底层: 数组

特点:

- 与ArrayList最大区别就是线程同步(线程安全,其方法都是带有synchronized关键字)
- 每次扩容是原来的两倍

### Set

### HashMap

问题:

1. 为什么hashmap允许key和value为null(但只能有一个),但是hashtable均不允许?
   - 