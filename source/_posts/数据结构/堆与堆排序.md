---
date: 2020-07-26
title: 堆与堆排序
category: 数据结构
tag: 
- 堆
---

堆其实就是一种数组形式的**完全二叉树**，具体分为大根堆和小根堆
- 大根堆：父节点的值大于等于子节点的值
- 小根堆：父节点的值小于等于子节点的值

<!-- more -->

# 堆排序
利用堆的特点，根节点大于等于所有节点的值（大根堆），那么每次建堆后将根节点与末尾节点交换位置，然后再对末尾节点以外的所有节点重新建堆（**注意，这里不需要调用build_heap函数，只需要调用heapify函数即可**，因为根节点的做右子树已经是堆，正因为如此，堆排序才有nlogn的时间复杂度），这样不断重复即可完成排序。

**技巧**：逆序下第一个有子节点的节点的下标，无论什么情形，固定为$len/2-1$
> 原因：任意一个节点的父节点下标为(i-1)/2; 那么逆序第一个有子节点的节点，即为完全二叉树最后一个节点的父节点。故为(n-1-1)/2=n/2-1;
```cpp
#include<iostream>
using namespace std;

void swap(int tree[], int c1, int c2) {
    int t = tree[c1];
    tree[c1] = tree[c2];
    tree[c2] = t;
}

/**
 * n个节点的完全二叉树
 * 在第i个节点处建堆
 * 前提：左右子树已经是堆
 * @param tree
 * @param n 完全二叉树节点个数
 * @param i 进行heapify的根节点
 */
void heapify(int tree[], int n, int i) {
    int p = i;
    while (p < n) {
        int max = p;
        int l = 2 * p + 1, r = 2 * p + 2;
        if (l < n && tree[l] > tree[max]) {
            max = l;
        }
        if (r < n && tree[r] > tree[max]) {
            max = r;
        }
        if (max == p)
            break;
        swap(tree, p, max);
        p = max;
    }
}

/**
 * 对节点数为n的完全二叉树建堆
 * @param tree
 * @param n 完全二叉树节点个数
 */
void build_heap(int tree[], int n) {
    int p = n / 2 - 1;
    while (p >= 0) {
        heapify(tree, n, p);
        p--;
    }
}

/*堆排序*/
void heap_sort(int tree[], int n) {
    build_heap(tree, n);
    for (int i = n - 1; i > 0; i--) {
        swap(tree, 0, i);
        heapify(tree, i, 0);
    }
}

```

知识点:

1. 堆排序中,建堆(buildHeap)的时间复杂度是O(N),具体计算方法是计算每个节点的计算次数,然后用等比数列求和公式,最后得到.
2. 问:为什么堆排序不用小根堆?
   - 答:小根堆无法向下调整堆,向上调整堆的时间复杂度是O(N),整体时间复杂度是N<sup>2</sup>