---
title: 牛牛们吃糖果
category: 算法
tag:
- 笔试题
- 阿里
excerpt: 经典的01背包的变形
---

[牛客-阿里-牛牛们吃糖果](https://www.nowcoder.com/questionTerminal/e7a006abf5ec412a939f0d33725f06ed?answerType=1&f=discussion)

经典的01背包问题,唯一的区别在于,有些物品是绑定在一起的,那么就把他们当成一个物品来处理就好啦!

倒序更新dp可以减少一维的空间复杂度.

注意`dp[j]=Math.max(dp[j],dp[j-candy[i]]+1);`这里要有max!!之前有一次写的时候就忘记了

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();    //糖果数
        int[]candy=new int[n+1];
        boolean[]visit=new boolean[n+1];    //01背包中是否已经吃过糖果了
        for(int i=0;i<n;i++){
            candy[i+1]=sc.nextInt();
        }
        Map<Integer,Integer>hash=new HashMap<>();
        int k=sc.nextInt();
        while(k>0){
            k--;
            int a=sc.nextInt();
            int b=sc.nextInt();
            hash.put(a,b);
            hash.put(b,a);
        }
        int[]dp=new int[m+1];    //i个糖果最多有dp[i]个小朋友来吃
        for(int i=1;i<=n;i++){
            if(visit[i])
                continue;
            if(!hash.containsKey(i)){
                visit[i]=true;
                for(int j=m;j>=0;j--){
                    if(j-candy[i]>=0)
                        dp[j]=Math.max(dp[j],dp[j-candy[i]]+1);
                }        
            }else{
                int friend=hash.get(i);
                visit[i]=true;
                visit[friend]=true;
                int t=candy[i]+candy[friend];
                for(int j=m;j>=0;j--){
                    if(j-t>=0)
                        dp[j]=Math.max(dp[j],dp[j-t]+2);
                }
            }
        }
        System.out.println(dp[m]);
        
    }
}




```

