---
title: 最长递增子序列
date: 2021-05-30
category: 算法
tag:
- 动态规划
- 二分
---

> 这篇文章讲的很细：https://blog.csdn.net/lxt_Lucia/article/details/81206439
# 方法一：动态规划
- 时间复杂度$n\log{n}$
- `dp[i]`：以第i个元素为结尾的子序列的最大长度
- 状态转移方程：$dp[i]=max( dp[j]+1), 其中arr[i]>arr[j], i>j$

# 方法二：动态规划+二分
<font color='red'>注意，此方法只能用于求LIS的长度，如果需要求LIS，需要记录路径信息</font>

- $dp[i]$，表示长度为`i`的LIS结尾元素的最小值
- 算法思想：维护一个递增序列，让其每个位置的元素尽可能保持最小，这样就给后续添加递增元素让出了最大空间，其维护的最终结果**不一定是LIS**，但长度和LIS相同。
- 维护一个路径信息，可以推出所有LIS中字典序最小的一个。

原理: 

- 一个数字a在序列中,如果用一个比他小的数字b替换他,那么不影响比a大的数字在后边和它组成递增序列的最大长度.
- 后面比前面大的,可以增加维护序列的长度;而后面<=前面的,只能优化维护的队列,而不能增加长度; 换言之,在我右边还比我小的数字,是不能影响含有我的最终序列的最长长度的.
  - 例如 `1,3,2`
  - `1`->`1,3,`->`2,3`
  - 3根本不用担心2跑到前边会影响自己的长度,因为2是替换1,而不是插入一个2.
  - 我担心会出现`2,3,100`这样的序列,2跑到3前边去了然后跟后边的数字组成序列
    - !不用担心,因为你这里的`2,3,100`和`1,3,100`是等价的,最大长度不会有区别

例如: **4**,5,6,7 -> **0**,5,6,7

添加数字1

**4**,5,6,7 -> **0**,5,6,7 ->**0,1**,6,7

发现添加比7小的数字,并不影响原来的4,5,6,7的长度. 

继续添加2,3,4

**4**,5,6,7 -> **0**,5,6,7 ->**0,1**,6,7->**0,1,2,**7 ->**0,1,2,3** -> **0,1,2,3,4**

只有当0为首的递增序列长度大于原来的4,5,6,7的时候,才会替换掉



[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        //遍历的过程中，不断优化队列的结构（使每个元素尽可能小），这样给后序元素的添加提供了遍历
        vector<int>arr;
        for(auto&n:nums){
            auto it=lower_bound(arr.begin(),arr.end(),n);
            //所有元素都小于n（或为空）
            if(it==arr.end()){
                arr.push_back(n);
                continue;
            }
            //替换第一个大于等于它的元素，以优化结构（瘦身），使得后序元素有更大的数字空间来进栈
            *it=n;
        }
        return arr.size();
    }
};
```
# 方法三：树状数组 或 线段树