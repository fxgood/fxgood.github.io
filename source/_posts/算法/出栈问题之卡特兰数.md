---
title: 出栈问题之卡特兰数
category: 算法
tag: 动态规划
---

经典的出栈序列问题，可以用动态规划来解决，其中的递推思路非常精妙。

<!--more-->

[栈](https://www.luogu.com.cn/problem/P1044)

思路：建立dp数组，dp[i]表示i个数的全部可能性。

dp[0]=dp[1]=1，作为边界条件。

设x是当前序列最后出栈的数字，则x将该序列分为两部分（1~x-1, x, x+1~n)

<img src="https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/image-20220218132139214.png" alt="image-20220218132139214" style="zoom:50%;" />

如图，假如x=3是最后出栈的，则前面的1和2是独立进出栈的，其可能的方案数是dp[2];后边的4,5,6也是独立入栈出栈的，其可能的方案数是dp[3];故最后的方案数是dp[2]*dp[3]；

因此数字个数为6时，dp[6]=dp[0]\*dp[5]+dp[1]\*dp[4]+dp[2]\*dp[3]+dp[3]\*d[2]+dp[4]\*dp[1]+dp[5]\*dp[0];

```cpp
#include <iostream>
#include <vector>

using namespace std;
int main(){
    int n;
    cin>>n;
    vector<int>dp(n+1,0);   //dp[i]表示序列若为1~i，则最终方案有dp[i]个
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++){
        //选取1~i中的数字x作为最后出栈的，则1~x-1自由出栈，x+1~i自由出栈
        for(int j=0;j<i;j++){
            dp[i]+=dp[j]*dp[i-j-1];
        }
    }
    cout<<dp[n];
    return 0;
}
```

