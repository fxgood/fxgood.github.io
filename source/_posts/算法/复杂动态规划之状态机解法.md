---
title: 复杂动态规划之状态机解法
date: 2021-04-11
category: 算法
tag:
- leetcode
- 动态规划
excerpt: 刷到leetcode309 最佳买卖股票时机含冷冻期时，学习了一种状态机的解法，觉得很好用，遂记录一下。
---

> 刷到leetcode309 最佳买卖股票时机含冷冻期时，学习了一种状态机的解法，觉得很好用，遂记录一下。

![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/20210411150804138.png)
对于这类复杂的状态转移问题，可以通过建立多个状态以及他们之间的转移方程来解决。对于该题，则定义四种状态，买入，卖出，持有，和不持有，其值代表当前状态下最大的利润。

状态机及之间的转换如下：
![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/2021041115143938.png)

```cpp
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        if(n==0)
            return 0;
        //定义四种状态，买入，卖出，持有，和不持有，其值代表当前状态下最大的利润
        vector<int> buy(n), sell(n), hold(n), not_hold(n);
        //初始化
        hold[0]=buy[0]=-prices[0];  //意思是上来就买入/持有股票，的最大收益
        sell[0]=not_hold[0]=0; //意思是上来就卖出/不持有股票，的最大收益
        for(int i=1;i<n;i++){
            //只能在冻结期后进行买入
            buy[i]=not_hold[i-1]-prices[i];
            //可以在买入后和已经持有的情况下，继续持有
            hold[i]=max(buy[i-1],hold[i-1]);
            //只能在买入后和已经持有的情况下，卖出
            sell[i]=max(buy[i-1],hold[i-1])+prices[i];
            //只能在卖出后或者不持有后，保持不持有
            not_hold[i]=max(not_hold[i-1],sell[i-1]);
        }
        //只有卖出和非持有状态，才可能有最高的利润
        return max(sell[n-1],not_hold[n-1]);
    }
};

```