---
title: 对称飞行器
category: 算法
tag:
- 阿里
excerpt: 血的教训之bfs放入node进队列之前就修改visit,否则会造成大量冗余从而导致程序超时!
---

[牛客-阿里-对称飞行器](https://www.nowcoder.com/questionTerminal/ef231526f822489d879949226b4bed65)

**BFS里,务必务必放入node之前要先修改visit,否则会造成大量冗余!!**

这题虽然通过了全部10个用例,但是我认为还是存在问题的,因为同样到达一个位置,后到达的,如果路径更长的话,不一定就不可以

- 可能我路径比你长,但是我用的飞行器比你少,最后你没有足够飞行器到达不了终点,而我最后能到达!

一开始求对称坐标m写成了n,导致看了半天没看出来问题,写题的时候一定要严谨! x和y,m和n区分清楚.. 给定的矩阵如果没有强调是n阶的心里要默认长和宽不同!

```java
import java.util.*;

public class Main {
    int n, m;

    public static void main(String[] args) {
        new Main().solve();
    }

    char[][] land;
    boolean[][] visit;

    void solve() {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        land = new char[n][m];
        visit = new boolean[n][m];
        int[] start = new int[2];
        int[] end = new int[2];
        sc.nextLine();
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < m; j++) {
                land[i][j] = line.charAt(j);
                if (land[i][j] == 'S') {
                    start[0] = i;
                    start[1] = j;
                } else if (land[i][j] == 'E') {
                    end[0] = i;
                    end[1] = j;
                }
            }
        }
        Queue<Node> que = new LinkedList<>();
        que.offer(new Node(start[0], start[1], 0, 5));
        visit[start[0]][start[1]]=true;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!que.isEmpty()) {
            Node f = que.poll();
            if (f.x == end[0] && f.y == end[1]) {
                System.out.println(f.len);
                return;
            }

            //用飞行器 x+x'=n-1;
            int flyX = n - 1 - f.x;
            int flyY = m - 1 - f.y;
            if (f.fly > 0 && check(flyX, flyY) ) {
                visit[flyX][flyY]=true;
                que.offer(new Node(flyX, flyY, f.len + 1, f.fly - 1));
            }
            
            //不用飞行器
            for (int i = 0; i < 4; i++) {
                int nx = f.x + dir[i][0];
                int ny = f.y + dir[i][1];
                if (check(nx, ny)){
                    visit[nx][ny]=true;
                    que.offer(new Node(nx, ny, f.len + 1, f.fly));
                }
            }
            
        }
        System.out.println(-1);
    }

    boolean check(int x, int y) {
        return x >= 0 && x < n && y >= 0 && y < m && !visit[x][y] && land[x][y] != '#';
    }


    private class Node {
        int x, y;
        int len;
        int fly;

        Node() {
        }

        Node(int x, int y, int len, int fly) {
            this.x = x;
            this.y = y;
            this.len = len;
            this.fly = fly;
        }
    }
}



```



