---
title: 两种经典的最小生成树算法
date: 2021-05-14
category: 算法
tag:
- 最小生成树
---

> B站一个Up主的动画演示非常生动形象：https://www.bilibili.com/video/BV1Eb41177d1?from=search&seid=9719056953147312216
# 最小生成树
最小生成树要求
1. 无环图
2. 联通图（任意两点之间必须有通路）
3. N个顶点，N-1条边
4. 所有生成树之中权值和最小的那棵（MST不唯一）

<!--more-->

# Kruskal算法
> 基于贪婪算法思想，每次选择权值最小的边

算法过程
	1. 将所有边按照权值从小到大排序
	2. 每次选择最小的边试图加入结果集
	3. 如果加入后会形成环则遗弃该边（用并查集判环）
	4. 重复步骤2和3直到选择了N-1条边（N为顶点数）

**需要用到并查集和优先级队列**
```cpp
struct UFNode {
    UFNode *parent;

    UFNode() : parent(NULL) {}
};

UFNode *find(UFNode *p) {
    set<UFNode *> path;
    while (p->parent != NULL) {
        path.insert(p);
        p = p->parent;
    }
    for (set<UFNode *>::iterator it = path.begin(); it != path.end(); it++) {
        (*it)->parent = p;
    }
    return p;
}

bool isSame(UFNode *p1, UFNode *p2) {
    return find(p1) == find(p2);
}

void merge(UFNode *p1, UFNode *p2) {
    if (isSame(p1, p2))
        return;
    find(p1)->parent = find(p2);
}


struct Node {
    int src, des;
    int len;

    Node(int s, int d, int l) : src(s), des(d), len(l) {}

    bool operator<(const Node &node)const{
        return len>node.len;
    }
};
//kruskal算法：
void kruskal() {
    vector<UFNode> NodeArr(N);
    vector<Node> ans;
    int MSTLen = 0;
    int s, d, l;
    priority_queue<Node> pri_que;
    for (int i = 0; i < M; i++) {
        cin >> s >> d >> l;
        pri_que.push(Node(s, d, l));
    }
    while (!pri_que.empty()) {
        Node first = pri_que.top();
        pri_que.pop();
        //如果两个点已经在一个集合中，那么加入这条边会造成环
        if (isSame(&NodeArr[first.src], &NodeArr[first.des])) {
            continue;
        }
        merge(&NodeArr[first.src], &NodeArr[first.des]);
        MSTLen += first.len;
        ans.push_back(first);
    }
    cout << "MST total len is " << MSTLen << "\nthe path is :\n";
    for (int i = 0; i < ans.size(); i++) {
        cout << ans[i].src << "-" << ans[i].des << endl;
    }
}

```
# Prim算法
> 基于贪婪算法思想，每次选择已选定顶点集合到未选顶点集合权值最小的边

通过三个数组的不断更新来完成算法
![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/20210514112017414.png)
**注意**，minDist记录的是该顶点与**已选顶点集中距自己最近的顶点**的距离、

算法过程：
	1. 建立三个数组，`selected`,`minDIst`,`parent`，大小为N
	2. 选定0号节点为初始节点，更新其相邻节点距离信息
	3. 在剩下节点中选择距离**已选顶点集**最近的节点，加入已选顶点集
	4. 更新距离信息
	5. 重复步骤3和4，直到所有顶点都被选中

```cpp
#include <iostream>

#define N 9  //9个顶点
using namespace std;

struct Node {
    int key;
    int len;    //边长度
    Node *next;

    Node(int k, int l) : key(k), len(l), next(NULL) {};
};

//顶点
struct Vertex {
    int key;
    Node *next=NULL;
};

//邻接表
struct Graph {
    Vertex arr[N];    //存储顶点
};


//将一个边接上去
void addArc(Graph &G, int a, int b, int len) {
    //顶点a添加ab边
    if (G.arr[a].next == NULL) {
        G.arr[a].next = new Node(b, len);
    } else {   //找尾巴在哪
        Node *p = G.arr[a].next;
        while (p->next != NULL)
            p = p->next;
        p->next = new Node(b, len);
    }
    //顶点b添加ab边
    if (G.arr[b].next == NULL) {
        G.arr[b].next = new Node(a, len);
    } else {   //找尾巴在哪
        Node *p = G.arr[b].next;
        while (p->next != NULL)
            p = p->next;
        p->next = new Node(a, len);
    }
}

//初始化
void init(Graph &G) {
    for (int i = 0; i < N; i++) {
        G.arr[i].key = i;
    }
    addArc(G, 0, 1, 4);
    addArc(G, 0, 7, 8);
    addArc(G, 1, 2, 8);
    addArc(G, 1, 7, 11);
    addArc(G, 7, 8, 7);
    addArc(G, 7, 6, 1);
    addArc(G, 2, 8, 2);
    addArc(G, 6, 8, 6);
    addArc(G, 2, 3, 7);
    addArc(G, 2, 5, 4);
    addArc(G, 6, 5, 2);
    addArc(G, 3, 5, 14);
    addArc(G, 3, 4, 9);
    addArc(G, 4, 5, 10);
}

bool selected[N];
int minDist[N]; //距离已选顶点集的最短距离
int parent[N];




int main() {
    Graph G;
    init(G);

    //初始化三个数组
    for (int i = 0; i < N; i++) {
        selected[i] = false;
        minDist[i] = 999999;
        parent[i] = -1;
    }
    selected[0] = true;
    int count = 1;    //已选顶点数量
    int now=0;   //新增顶点
    //开始进行Prim算法，每次将距离已选定点集最近的顶点加入已选顶点
    while (count < N) {
        //更新当前能到达的(未选）节点的minDist信息
        Node*p=G.arr[now].next;
        while(p!=NULL){
            if(!selected[p->key] && p->len<minDist[p->key]){
                parent[p->key]=now;
                minDist[p->key]=p->len;
            }
            p=p->next;
        }
        //选出距离已选顶点集最近的顶点加入
        int d=999999;
        int t=-1;
        for(int i=0;i<N;i++){
            if(!selected[i] && minDist[i]<d){
                d=minDist[i];
                t=i;
            }
        }
        now=t;
        selected[t]=true;
        count++;
    }
    //计算一下权值和即可（注意不能用dist加，dist表示的是到已选顶点集的最短距离）
}
```

> 这是对视频中的最小生成树进行计算，注意：最小生成树不唯一。
