---
title: 两种经典的最短路径算法
date: 2021-05-25
category: 算法
tag:
- 最短路径
---

- dijkstra算法：**计算单源最短路径**（固定起点，计算出起点到其他所有顶点的最短路径）
	- 用贪心思想，每次找出距离起点最近的节点，直到找出所有节点
	- 动态规划：每次在已有结果的基础上自下而上进行拓展
	- 缺陷：无法计算存在负权值的情况。
- floyd算法：**计算任意两点之间的最短路径**
	- 基于动态规划思想
	- 三重循环遍历所有顶点，如果a到c再到b的距离，小于a到b的距离，那么将a到b原来的路径更换为a到c再到b
	- 其中路径信息parent矩阵，`parent[i][j]`代表的是，从i到j，i走过以后，下一步应该走哪个节点，如果`parent[i][j]==j`说明i、j相邻。

<!--more-->

[p4779](https://www.luogu.com.cn/problem/P4779)

这一题中使用了链式前向星存储图，使用了堆优化（减少未访问顶点集中搜寻最小dist[i]的时间，其中使用了惰性删除）。

```cpp
/*dijkstra算法，链式前向星与堆优化版*/
#include<iostream>
#include<queue>

using namespace std;
const int N = 100010;
const int M = 500010; //边的数量
const int MAX = 0x7fffffff;
struct Arc {    //两点之间的一条弧
    int to, next, d;  //next是兄弟边的下标，若为0说明没有
};
/*链式前向星*/
Arc edge[M];    //存放所有边
int head[N];    //head[i]表示i节点的第一条边是edge[head[i]]
int cnt = 0;  //现有边的数量

int n, m, s;

struct Node {
    int key, dist;
    bool operator<(const Node &node) const {
        return dist > node.dist;  //顺序存储中优先级高的在前边，堆中优先级中的在堆顶
    }
};

int dist[N];
bool visit[N];

int main() {

    cin >> n >> m >> s;
    for (int i = 1; i <= n; i++)
        dist[i] = MAX;
    for (int i = 0; i < m; i++) {
        int a, b, d;
        cin >> a >> b >> d;
        cnt++;
        edge[cnt].to = b;
        edge[cnt].d = d;
        edge[cnt].next = head[a]; //next指向兄弟节点
        head[a] = cnt;
    }
    priority_queue<Node> que;   //que维护一个按照所有节点dist排列的优先级队列，其中可能存在冗余无效数据
    /*因为更新dist后不方便删除que中原有的点，因此从que中取点，遇到已经访问过的，则直接删除（越短越先被访问，后访问的肯定是过时的数据）*/
    dist[s] = 0;
    que.push({s, dist[s]});
    while (!que.empty()) {
        Node first = que.top();
        que.pop();
        int u = first.key;
        if (visit[u])   //说明是过期数据
            continue;
        visit[u] = true;
        int t = head[u];    //u节点指向的第一条边
        while (t) {
            int v = edge[t].to;
            int d = edge[t].d;
            if (!visit[v] && d + dist[u] < dist[v]) {
                dist[v] = dist[u] + d;
                que.push({v, dist[v]});
            }
            t = edge[t].next; //兄弟边
        }
    }
    for (int i = 1; i <= n; i++)
        cout << dist[i] << " ";
    return 0;
}
```



```cpp
/*dijkstra算法，邻接矩阵标准版*/

#include <iostream>
#include <cstring>
#include <stack>
using namespace std;

const int N=5;
const int src=0;
const int des=N-1;
int edge[N][N];

void init(){
    //初始化邻接矩阵
    memset(edge,-1,sizeof(edge));
    edge[0][1]=10;
    edge[0][2]=1;
    edge[0][3]=3;
    edge[2][1]=1;
    edge[1][4]=20;
}


int main(){
    init();
    bool visit[N];
    int parent[N];
    int dist[N];
    memset(visit,false,sizeof(visit));
    memset(parent,-1,sizeof(parent));
    memset(dist,0x3f,sizeof(dist));
    int now=src;
    visit[src]=true;
    dist[src]=0;
    while(!visit[des]){
        //更新当前能到达的节点的dist信息
        for(int i=0;i<N;i++){
            if(!visit[i] && edge[now][i]!=-1 && dist[now]+edge[now][i]<dist[i]){
                parent[i]=now;
                dist[i]=dist[now]+edge[now][i];
            }
        }
        //在未选顶点中，选出距离远点最近的顶点，确定它的最短路径
        int minDist=0x3f3f3f3f;
        for(int i=0;i<N;i++){
            if(!visit[i] && dist[i]<minDist){
                minDist=dist[i];
                now=i;
            }
        }
        visit[now]=true;
    }
    //给出最短路径
    stack<int>path;
    int t=des;
    while(t!=-1){
        path.push(t);
        t=parent[t];
    }
    while(!path.empty()){
        cout<<path.top()<<" ";
        path.pop();
    }
    return 0;
}
```


```cpp
/*floyd算法*/
#include<iostream>
#include<cstring>

using namespace std;
const int N = 100;
const int MAX = 0x3fffffff;
int dist[N][N]; //i经过path[i][j]到j的路径长度
int link[N][N]; //link[i][j]表示i第一步从link[i][j]走
int n, m;

/*Floyd算法适用于点比较少的图，因为其时间复杂度是O(n^3)*/
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = MAX;
            link[i][j] = j;
        }
    }
    for (int i = 0; i < m; i++) {
        int a, b, d;
        cin >> a >> b >> d;
        dist[a][b] = d;
        dist[b][a] = d;
    }
    for (int k = 1; k <= n; k++)	//注意：k必须在最外层，因为它是dp的阶段
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    link[i][j] = link[i][k];
                }
            }

    while (1) {
        int src, des;
        cin >> src >> des;
        int res = dist[src][des];
        if (res == MAX) {
            cout << -1 << endl;
            continue;
        }
        cout << dist[src][des] << endl;
        /*打印路径*/
        int t = src; //t 表示第一步
//        cout<<src<<" ";
        while (t != des) {
            cout << t << " ";
            t = link[t][des];
        }
        cout << des << endl;

    }
    return 0;
}

```

> 这个视频讲解非常生动清晰：https://www.bilibili.com/video/BV1q4411M7r9