---
title: 最优二叉树Ⅱ
category: 算法
tag:
- 美团
- 笔试题
---
这一题我采用记忆化搜索来解决(也有人称之为树形dp,其实就是自下而上的记忆化搜索)

一开始我用的bestTree函数中,第三个参数root根结点下标,我采用的思路是,从`[l,r]`之间来选, 最后发现只能通过70%; 

看了一下题解,他的第三个参数root是`[l,r]`范围形成的树的共同根结点,最后测试全部通过

我思考了一下,为什么他的更优.我的猜想是: 如果我要计算`[0,n-1]`范围内的最优二叉树

- 使用我自己的方法,要先挑选根结点,然后在左右范围内再挑选根结点,然后形成连接.涉及两次挑选,只考虑本层的时间的话,复杂度是$O(N^2)$

- 使用题解的思路的话,由于根结点已定,那么只需要挑选一轮根结点即可形成连接,只考虑本层的时间的话,复杂度是$O(N)$



```java
import java.io.FileInputStream;
import java.io.*;
import java.util.*;

public class Main {
    int n;
    int[] nums;
    int[][][]dp;
    public static void main(String[] args){
        new Main().solve();
    }

    void solve(){
        Scanner sc=new Scanner(new BufferedInputStream(System.in));
        n = sc.nextInt();
        nums = new int[n];
        dp=new int[n][n][n+1];
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                for(int k=0;k<n+1;k++)
                    dp[i][j][k]=-1;
        for (int i = 0; i < n; i++)
            nums[i] = sc.nextInt();
        System.out.println(bestTree(0,n-1,n));
    }

    final int MAX = 0x3fffffff;


    int bestTree(int l, int r, int root) {
        if(l>r)
            return 0;
        if(dp[l][r][root]!=-1)
            return dp[l][r][root];
        int rootVal=root!=n?nums[root]:0;
        if (l == r){
            dp[l][r][root]=rootVal*nums[l];
            return dp[l][r][root];
        }
        int ans=0x3fffffff;
        for(int i=l;i<=r;i++){    //选当前的root
            int left=bestTree(l,i-1,i);
            int right=bestTree(i+1,r,i);
            ans=Math.min(ans,left+right+nums[i]*rootVal);
        }
        dp[l][r][root]=ans;
        return ans;
    }
}

```

