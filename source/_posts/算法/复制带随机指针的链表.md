---
title: 复制带随机指针的链表
category: 算法
excerpt: 在链表中如果涉及到相对位置的问题,可以模仿这一题使用原链表上挨个复制+拆分法!这一题拆分链表的递归写法也非常棒!
---

方法一:双哈希表

一个哈希表把节点映射到相对位置

另一个哈希表把相对位置映射到节点

然后拷贝+从哈希表中读数据即可.

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        Map<Node,Integer>origin=new HashMap<>();
        Node p=head;
        int index=0;
        while(p!=null){
            origin.put(p,index++);
            p=p.next;
        }
        Node pre=new Node(-1);
        p=head;
        Node q=pre;
        Map<Integer,Node>latter=new HashMap<>();
        index=0;
        while(p!=null){
            q.next=new Node(p.val);
            q=q.next;
            latter.put(index++,q);
            p=p.next;
        }
        p=head;
        q=pre.next;
        while(p!=null){
            q.random=latter.get(origin.get(p.random));
            p=p.next;
            q=q.next;
        }
        return pre.next;
    }
}
```



方法二: 在原链表上间隔复制节点

先在原链表上一个挨着一个复制节点,然后再给每个节点赋值random即可.

关于拆分链表的递归算法,我写的过程中忘记h.next已经修改过方向,结果直接返回导致报错.要注意一下.

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    //寄生大法,太妙了
    public Node copyRandomList(Node head) {
        if(head==null)
            return null;
        Node p=head;
        while(p!=null){
            Node t=new Node(p.val);
            t.next=p.next;
            p.next=t;
            p=p.next.next;
        }
        p=head;
        while(p!=null){
            Node t=p.next;
            if(p.random!=null)
                t.random=p.random.next;
            p=p.next.next;
        }
        return splitList(head)[1];
    }
    //拆分链表
    Node[]splitList(Node h){
        if(h==null)
            return new Node[]{null,null};
        Node[]twoHead=splitList(h.next.next);
        h.next.next=twoHead[1];
        Node t=h.next;
        h.next=twoHead[0];
        return new Node[]{h,t};
    }
}
```

