---
title: 毕业旅行问题
category: 算法
tag:
- 字节跳动
excerpt: 经典的TSP旅行商问题,但是这里需要小小优化一下,否则内存会超(dp中舍弃初始节点,否则(1<<20)会超内存)
---

[牛客网 字节-毕业旅行问题](https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d?f=discussion)

两种dp的方法dp[st]\[i] 一种是st中包含i,i是最后一个点;一种是不包含;

我的建议是: 包含,因为这样最后结算的时候方便. 

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[][]dis=new int[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                dis[i][j]=sc.nextInt();    //改变量名的时候记得一致性
            }
        }
        int[][]dp=new int[1<<19][20];    //二进制第0为是城市1
        //dp[st][i] 表示已经走过的城市是st,最后一步是i,此情况下的最小花费
        for(int st=1;st<(1<<(n-1));st++){
            for(int i=0;i<n-1;i++){
                if((st&(1<<i))==0)
                    continue;
                int last=st^(1<<i);
                if(last==0){
                     dp[st][i]=dis[0][i+1];   
                    continue;
                }
                for(int j=0;j<n-1;j++){
                    int t=last&(1<<j);
                    if(t!=0){
                        if(dp[st][i]==0)
                            dp[st][i]=dp[last][j]+dis[i+1][j+1];
                        else
                            dp[st][i]=Math.min(dp[last][j]+dis[i+1][j+1],dp[st][i]);
                    }
                }
            }
        }
        int ans=0x3fffffff;
        for(int i=0;i<n-1;i++){
            ans=Math.min(ans,dp[(1<<(n-1))-1][i]+dis[i+1][0]);
        }
        System.out.println(ans);
    }
}
```

