---
title: 合法连续子段
category: 算法
tag:
- 阿里
- 笔试题
excerpt: 解决区间问题的大杀器——滑动窗口.
---

滑动窗口的过程可以理解为

1. 寻找可行解(扩大右边界)
2. 优化可行解(缩小左边界)

这一题我想过滑动窗口,但是为什么没采用主要是

- 我既没有意识到滑动过程中是`l->xxxAxxxA<-r`形式,我当时认为的是`l->AxxxxA<-r`形式,前边一种形式中,正好可以缩小左边界.
- 也没有按照滑动窗口的过程去想问题(先扩大右边界,然后再缩小左边界)

我所采用的办法是大量hash表组成的数组来模拟前缀和,然后固定左边界,右边界进行二分,最后结果是内存超了

- 数组长度是4e5,如果弄个hash表数组,那么大概需要$4\times{10^{5}\times{10^5}}$字节,大概是40个G!

滑动窗口中的一个棘手问题就是开始怎么挪动,r是取0还是-1. 这道题中用-1做的,还可以.

**总之,滑动窗口是解决区间问题的大杀器!**

[牛客-阿里-合法连续子段](https://www.nowcoder.com/test/question/done?tid=57828606&qid=1664961#summary)

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int[]nums=new int[n];
        for(int i=0;i<n;i++){
            nums[i]=sc.nextInt();
        }
        Map<Integer,Integer>mp=new HashMap<>();
        int l=0,r=-1;
        long ans=0;
        while(r<n){
            //寻找可行解
            boolean flag=false;
            while(r<n){
                r++;
                if(r>=n)
                    break;
                int k=nums[r];
                if(mp.containsKey(k))
                    mp.put(k,mp.get(k)+1);
                else
                    mp.put(k,1);
                if(mp.get(k)>=m){
                    flag=true;
                    break;
                }
            }
            if(!flag)
                break;
            while(l<=r && nums[l]!=nums[r]){
                mp.put(nums[l],mp.get(nums[l])-1);
                ans+=n-r;
                l++;
            }
            if(l<=r){
                mp.put(nums[l],mp.get(nums[l])-1);
                ans+=n-r;
                l++;
            }
        }
        System.out.println(ans);
    }
}
```

