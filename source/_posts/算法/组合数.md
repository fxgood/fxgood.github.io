---
title: 组合数的更优秀的实现
category: 算法
excerpt: 这种组合数的实现方法比我之前用的更加优秀,速度更快.
---

效率更高的算法

效率高的原因在于: dfs(int x,int k)的含义是从下标x开始搜索k个数字,过程中可以直接调到下一步要选的数字,而不用像我之前的写法一样,一个一个查看

```java
class Solution {
    List<List<Integer>>ans=new ArrayList<>();
    
    List<Integer>path=new ArrayList<>();

    int n;

    public List<List<Integer>> combine(int n, int k) {
        this.n=n;
        dfs(1,k);
        return ans;
    }

    //从i~n中选k个数字
    void dfs(int i,int k){
        if(k==0){   //已经选了k个数字
            ans.add(new ArrayList<>(path));
            return;
        }
        if(i==n+1)    //已经结束了还没选到k个数字
            return;
        for(int x=i;x<=n;x++){   //下一个数字选哪个  可以直接跳过多个放弃的数字!
            path.add(x);
            dfs(x+1,k-1);
            path.remove(path.size()-1);
        }

    }
}
```

我之前的经典写法

```java
class Solution {
    List<List<Integer>>ans=new ArrayList<>();
    List<Integer>tmp=new ArrayList<>();
    int n;
    public List<List<Integer>> combine(int n, int k) {
        this.n=n;
        dfs(1,k);
        return ans;
    }

    void dfs(int x,int k){
        if(k==0){
            ans.add(new ArrayList<>(tmp));
            return;
        }
        if(x==n+1)
            return;
        dfs(x+1,k);
        tmp.add(x);
        dfs(x+1,k-1);
        tmp.remove(tmp.size()-1);
    }
}
```

