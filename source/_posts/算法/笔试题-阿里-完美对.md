---
title: 完美对
category: 算法
tag: 
- 笔试题
- 阿里
excerpt: 这一题做完收获巨多.需要好好回味!
---

[牛客-阿里-完美对](https://www.nowcoder.com/questionTerminal/f5a3b5ab02ed4202a8b54dfb76ad035e)

这一题的收获

- 对于$O(n^2)$复杂度要优化至$O(nlogn)$的,常规的三种方法1.hash2.二分3.dp前缀和 都用不了的话,那么要换一个角度思考问题:
  - 对于$O(n^2)$的问题,通常都是固定一个变量,然后去寻找另一个合适的变量;如果寻找这个过程一定无法用二分和dp来减少时间复杂度
  - **那么就不去找,而是发掘元素自身的特点,把我要找的另一半应该是什么样计算出来,然后在hash表中找是否有这样的元素.**
- 涉及hash表的计算,这题用第二种方法更优(两数之和的经典方法)
  - 一种思路,全部装进去,然后计算
  - **另一种思路,边装边计算,可以避免重复问题**

- 数组互相比较不能直接用equals,必须用`Arrays.equals`
- 如果用数组作为hash表的键,**最好替换成List**;否则需要自己包装数组,然后重写equals和hashCode
  - **注意,重写equals,其参数必须是Object类型**
  - 对数组hash用`Arrays.hashCode()`;对对象用`Objects.hashCode()`

```java
//减少时间复杂度的方法 1.hash空间换时间 2.二分 3.前缀和dp
import java.util.*;

class Arr{
    int[]arr;
    Arr(int k){
        arr=new int[k];
    }
    Arr(int[]t){
        arr=t;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(arr);
    }
    @Override 
    public String toString(){
        return Arrays.toString(arr);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Arr arr1 = (Arr) o;
        return Arrays.equals(arr, arr1.arr);
    }
}
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        Map<Arr,Integer>hash=new HashMap<>();
        for(int i=0;i<n;i++){
            int[]t=new int[m-1];
            int s=sc.nextInt();
            for(int j=0;j<m-1;j++){
                int s2=sc.nextInt();
                t[j]=s2-s;
                s=s2;
            }
            Arr arr=new Arr(t);
            if(hash.containsKey(arr))
                hash.put(arr,hash.get(arr)+1);
            else
                hash.put(arr,1);
        }
        long ans=0;
        for(Map.Entry<Arr,Integer>en:hash.entrySet()){
            int[]dir=en.getKey().arr;
            int val=en.getValue();
            int[]other=new int[m-1];
            for(int i=0;i<m-1;i++){
                other[i]=-dir[i];
            }
            Arr otherArr=new Arr(other);
            if(Arrays.equals(dir,other)){
                ans+=(long)val*(val-1);    //这里要/2再乘2,因为最后ans/2
            }else{
                if(hash.containsKey(otherArr))
                    ans+=(long)val*hash.get(otherArr);
            }
        }
        System.out.println(ans/2);
    }
}
```

