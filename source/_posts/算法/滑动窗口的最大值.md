---
title: leetcode滑动窗口的最大值
category: 算法
tag:
- leetcode
- 单调队列
---

[leetcode](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

方法一：单调队列

运用到单调队列和单调栈的题目，不要生硬地套用这两种数据结构，单调队列和单调栈其根本目的是**保留有用数据**，将无用数据丢弃，留下的数据有序且有用。

**小技巧**：单调队列里不是直接存数据，而是存下标，这样可以根据下标判断是否在滑动窗口内。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> deque = new LinkedList<Integer>();
        for (int i = 0; i < k; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }

        int[] ans = new int[n - k + 1];
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            while (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

方法二：堆

凡是求最小值、最大值的题目，要能想到用堆。

**小技巧**：因为堆中的元素不方便直接删除，所以我们采用**延迟删除**，当访问到的堆顶元素不在滑动窗口范围内（堆中存放下标，用下标判断），那么直接舍弃。

这里我用的是哈希表判断是否在堆中（用下标更优）

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(k==0)
            return new int[0];
        PriorityQueue<Integer> que=new PriorityQueue<>((x,y)->(y-x));   //大根堆
        Map<Integer,Integer> mp=new HashMap<>();
        List<Integer> res=new ArrayList<>();
        int r=0;
        while(r<k){
            que.offer(nums[r]);
            if(mp.containsKey(nums[r]))
                mp.put(nums[r],mp.get(nums[r])+1);
            else
                mp.put(nums[r],1);
            r++;
        }
        r--;
        while(r<nums.length){
            /*求当前的最大值*/
            int l=r-k+1;
            while(mp.get(que.peek())==0){   //延迟删除
                que.poll();
            }
            res.add(que.peek());
            /*删除左边*/
            mp.put(nums[l],mp.get(nums[l])-1);  //在hash表中删除左侧元素
            /*增加右边*/
            r++;
            if(r<nums.length){
                que.offer(nums[r]);
                if(mp.containsKey(nums[r]))
                    mp.put(nums[r],mp.get(nums[r])+1);
                else
                    mp.put(nums[r],1);
            }

        }
        int[]resArr=new int[res.size()];
        for(int i=0;i<res.size();i++){
            resArr[i]=res.get(i);
        }
        return resArr;
    }
}
```

