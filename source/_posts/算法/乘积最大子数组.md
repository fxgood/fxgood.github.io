---
title: 乘积最大子数组
category: 算法
excerpt: 这一题的动态规划的状态转移方程需要仔细推敲,非常有意思.
---

[leetcode 152 乘积最大数组](https://leetcode.cn/problems/maximum-product-subarray/)

**一个重要的事实**

若a>b,则同时乘上一个正数c,**不论a和b的符号**,那么ac>bc

若a>b,则同时乘上一个负数c,**不论a和b的符号**,ac<bc

虽然上面的结论小学生都知道,但是用于思考这一题的状态方程的时候可以去伪存真,简化思考. 我们要求的以下标i为结尾的子数组的最大连续乘积,考虑两种情况:

1. 不和前面相连
2. 和前面相连(如何才能连接出最大值呢)
   - 如果当前数字是正数,那么和与i-1结尾的**最大**连续乘积连接最优
   - 如果当前数字是负数,那么和与i-1结尾的**最小**连续乘积连接最优
3. 因此导出,我们需要的dp数组有两个,即以i结尾的连续数组的**最大连续积**和**最小连续积** (不需要考虑正负)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n=nums.length;
        int[]max=new int[n];
        int[]min=new int[n];
        max[0]=min[0]=nums[0];
        int ans=nums[0];
        for(int i=1;i<n;i++){
            if(nums[i]>0){
                max[i]=Math.max(nums[i],nums[i]*max[i-1]);
                min[i]=Math.min(nums[i],nums[i]*min[i-1]);
            }else if(nums[i]<0){
                max[i]=Math.max(nums[i],nums[i]*min[i-1]);
                min[i]=Math.min(nums[i],nums[i]*max[i-1]);
            }else{
                max[i]=min[i]=0;
            }
            ans=Math.max(ans,max[i]);
        }
        return ans;
    }
}
```

