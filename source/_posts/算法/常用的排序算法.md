---
title: 常用的排序算法
date: 2021-03-22
category: 算法
expcerpt: 记录一些常用排序算法的思想和代码。
---

## 堆排序

```java
class Solution {
    void swap(int[]nums,int l,int r){
        int t=nums[l];
        nums[l]=nums[r];
        nums[r]=t;
    }

    //前提是i的左右子树都已经是堆
    void heapify(int[]nums,int i,int n){    //在长度为n的堆，对下标为i的元素进行下降
        while(i<n){
            int p=i;
            int l=2*i+1;
            int r=2*i+2;
            if(l<n && nums[l]>nums[p]) p=l;
            if(r<n && nums[r]>nums[p]) p=r;
            if(i==p)
                return;
            swap(nums,i,p);
            i=p;
        }
    }
    //建立大根堆
    void buildHeap(int[]nums,int n){
        for(int i=n/2-1;i>=0;i--)
            heapify(nums,i,n);
    }
    //堆排序
    public int[] sortArray(int[] nums) {
        int n=nums.length;
        buildHeap(nums,n);
        for(int i=n-1;i>=0;i--){
            swap(nums,0,i);
            heapify(nums,0,i);  //重新调整成堆
        }
        return nums;
    }
}
```



## 拓扑排序

核心思想：每次将入度为0的节点加入结果集末尾，然后将其子节点入度减一
注意有环情况。
![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/20210513223434245.png)

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int>ans;
        queue<int>que;
        vector<int>inDegree(numCourses,0);  //记录入度
        vector<bool>visit(numCourses,false);    //记录是否已经访问过
        vector<vector<int> >postNode(numCourses);   //记录子节点
        for(int i=0;i<prerequisites.size();i++){
            int from=prerequisites[i][1];
            int to=prerequisites[i][0];
            inDegree[to]++;
            postNode[from].push_back(to);
        }
        //初始化，将所有入度为0的节点入队
        for(int i=0;i<numCourses;i++){
            if(!inDegree[i]){
                que.push(i);
                visit[i]=true;
            }
        }
        //进行主体逻辑
        while(!que.empty()){
            //取出来，归结果集
            int node=que.front();
            que.pop();
            ans.push_back(node);
            //子节点入度-1，
            for(int j=0;j<postNode[node].size();j++){
                int child=postNode[node][j];
                inDegree[child]--;
            }
            //将所有入度为0的节点入队
            for(int i=0;i<numCourses;i++){
                if(visit[i])
                    continue;
                if(!inDegree[i]){
                    que.push(i);A
                    visit[i]=true;
                }
            }
        }
        if(ans.size()==numCourses)
            return ans;
        vector<int>empty;
        return empty;

    }
};
```
## 快速排序

### 写法一：三指针

```cpp
/**
 * 快速排序：每次选取一个基准，小的放左边，大的放右边
 * @param arr
 */
void quickSort(int arr[],int left,int right){
    if(left>=right)
        return;
    int pivot=arr[left];	//可以增加随机选基准int pivot=arr[left~right];
    int p=left,l=left,r=right;  //p表示马上要处理的元素，l左边都小于基准，r右边都大于基准
    while(p<=r){
        if(arr[p]<pivot){
            swap(arr[p],arr[l]);
            p++;
            l++;
        }else if(arr[p]>pivot){
            swap(arr[p],arr[r]);
            r--;
        }else
            p++;
    }
    quickSort(arr,left,l-1);
    quickSort(arr,r+1,right);

}
```
### 写法二

```java

class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    void quickSort(int[]nums,int l,int r){
        if(l<r){
            int p=partition(nums,l,r);
            quickSort(nums,l,p-1);
            quickSort(nums,p+1,r);
        }
    }
    void swap(int[]nums,int l,int r){
        int t=nums[r];
        nums[r]=nums[l];
        nums[l]=t;
    }
    int partition(int[]nums,int l,int r){
        //随机选择基准元素
        int p=new Random().nextInt(r-l+1)+l;
        swap(nums,p,l);
        int pivot=nums[l];
        while(l<r){
            //从右边找一个比pivot小的
            while(l<r && nums[r]>=pivot)r--;
            swap(nums,l,r);	//注意这里一定要有swap，因为要利用nums[l]这个位置
            //从左边找一个比pivot大的
            while(l<r && nums[l]<=pivot)l++;
            swap(nums,l,r);
        }
        nums[l]=pivot;
        return l;
    }
}

```



## 二路归并排序

```cpp
/**
 * 二路归并排序：递归实现，每次将两边排序好的序列合并成一个新的顺序序列
 * @param arr
 * @param left
 * @param right
 */
void mergeSort(int arr[],int left,int right){
    //递归终止条件，当分组只有一个元素的时候就是终态
    if(left==right)
        return;
    int mid=(left+right)/2;
    //递归，分别对左右半边进行二路归并排序
    mergeSort(arr,left,mid);
    mergeSort(arr,mid+1,right);
    //将两个已经排序好的序列合并
    int l=left,r=mid+1;
    int temp[right-left+1];
    int i=0;
    while(l<=mid && r<=right){
        if(arr[l]<arr[r])
            temp[i++]=arr[l++];
        else
            temp[i++]=arr[r++];
    }
    while(l<=mid)
        temp[i++]=arr[l++];
    while(r<=right)
        temp[i++]=arr[r++];
    i=0;
    for(int j=left;j<=right;j++)
        arr[j]=temp[i++];
}
```
## 插入排序
```cpp
/**
 * 插入排序，每次将一个元素插入到已排序好的序列中
 * 这里使用的插入方法类似于冒泡法
 * 当前元素从右往左比较，如果左边的比我小，那么就交换
 * 直到左边的元素>=我，那么就停止，即找到最终位置
 * @param arr
 * @param len
 */
void insertSort(int arr[],int len){
    for(int i=0;i<len;i++)
        for(int j=i;j>0 && arr[j-1]>=arr[j];j--){    //j>0是因为每次要和前面一个比，所以只能到第二个
            swap(arr[j],arr[j-1]);
        }
}
```
## 冒泡排序
```cpp
/**
 * 冒泡排序：第i轮（0开始），确定len-1-i位置的元素
 * @param arr
 * @param len
 */
void bubbleSort(int arr[],int len){
    //一共len-1轮，每次把最大的元素挪到最右边
    for(int i=0;i<len-1;i++){
        bool flag=true;
        for(int j=0;j<len-1-i;j++){
            if(arr[j]>arr[j+1]){
                flag=false;
                swap(arr[j],arr[j+1]);
            }
        }
        if(flag)
            return;
    }
}
```

## 选择排序
```cpp
/**
 * 选择排序，每次选择i后边所有元素中的最小元素与i的交换
 * @param arr
 * @param len
 */
void selectSort(int arr[],int len){
    for(int i=0;i<len;i++){
        //在i到len-1中，把最小的选择出来放在i位置
        int min_index=i;
        for(int j=i+1;j<len;j++){
            if(arr[j]<arr[min_index])
                min_index=j;
        }
        swap(arr[i],arr[min_index]);
    }
}
```

## 计数排序

（说白了就算记录每个数有多少个，然后按照数轴顺序输出对应个数的数字）

用于所给数据范围不大的情况下

做法：

1. 找到最小和最大元素
2. 申请(max-min+1)这么大的空间，下标0代表数字min，下标1代表数字min+1...
3. 遍历数组，统计每个数字出现的次数
4. 遍历申请的额外空间，对应数字有多少个，就输出多少次。

## 桶排序

需要每个桶内的数量均匀，如果都集中到一个桶，则退化到普通排序

做法

1. 根据数据范围分为多个桶
2. 桶内排序
3. 合并