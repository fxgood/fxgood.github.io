---
title: 高精度加法和乘法
category: 算法
---

高精度的思想就在于用一个一个int型数组来逆序存储一个数字（数组低位存储数字低位）

<!--more-->

# 高精度加法

高精度加法有两种方式，一种是先边加边进位，一种是先加再进位（推荐使用这种，逻辑比较清晰）

[蜜蜂路线](https://www.luogu.com.cn/record/69638050)

其中最重要的一步就是在for循环中不断检测`dp[k][len]`来判断是否增加len

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int dp[1000][1000]; //第二维低位存储数字低位
int len = 1;    //第一个dp必为1，因此长度是1

void cal(int k) {    //计算dp[k]
    /*先加再进位*/
    for (int i = 0; i < len; i++)
        dp[k][i] = dp[k - 1][i] + dp[k - 2][i];
    for (int i = 0; i < len; i++) {
        dp[k][i + 1] += dp[k][i] / 10;
        dp[k][i] %= 10;
        if (dp[k][len] != 0)    /*为什么要写在for里边，因为len记得是之前数字的最长位数，后边有可能突然遇到一个特别长的，写在for里边可以边加边检测长度*/
            len++;
    }
}

int main() {
    fill(*dp, *dp + 1000 * 1000, 0);
    dp[0][0] = dp[1][0] = 1;
    int m, n;
    cin >> m >> n;
    for (int i = 2; i < n - m + 1; i++) {
        cal(i);
    }
    for (int i = len - 1; i >= 0; i--)
        cout << dp[n - m][i];
    return 0;
}
```



问题：为什么这题需要使用高精度加法？

因为`dp[i]=dp[i-1]+dp[i-2]`最后结果大约是2<sup>1000</sup>约等于10<sup>300</sup>左右，而long long最大值约为9*10<sup>18</sup>。

# 高精度乘法

[p1303 A*B problem](https://www.luogu.com.cn/problem/P1303)

几个要点：

1. len<=(len1+len2) 因为两数相乘长度最长就是len1+len2，但是有可能一个乘数为0，因此需要去除前导0
2. 采用先计算再进位/取余，其中计算的双层for循环中用的是`+=而不是`=`，这一点和高精度加法有所不同，因为其是模拟竖式乘法，n3[i]多层相加的结果的和组成
3. 输入字符串存储到int数组中，注意需要倒序

```cpp
#include <iostream>

using namespace std;
int n1[2000];
int n2[2000];
int n3[4000];
int main() {
    string s1,s2;
    cin>>s1>>s2;
    for(int i=0;i<s1.size();i++)
        n1[s1.size()-1-i]=s1[i]-'0';
    for(int i=0;i<s2.size();i++)
        n2[s2.size()-1-i]=s2[i]-'0';
    int len1=s1.size(),len2=s2.size();
    int len=len1+len2;
    for(int i=0;i<len1;i++)
        for(int j=0;j<len2;j++){
            n3[i+j]+=n1[i]*n2[j];
        }
    for(int i=0;i<len;i++){
        n3[i+1]+=n3[i]/10;
        n3[i]%=10;
    }
    while(n3[len-1]==0 && len>1) len--;
    for(int i=len-1;i>=0;i--)
        cout<<n3[i];
    return 0;
}
```

