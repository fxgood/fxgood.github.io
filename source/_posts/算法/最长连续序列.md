---
title: 最长连续序列
category: 算法
excerpt: 这一题对于理解空间换时间和通过减少冗余操作来提升效率有非常积极的用处
---

首先,第一个能想到的方法就是排序.但是它的时间复杂度是O(NlogN)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0)
            return 0;
        Arrays.sort(nums);
        int ans=1;
        int t=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]==nums[i-1]+1)
                t++;
            else if(nums[i]==nums[i-1])
                continue;
            else{
                ans=Math.max(ans,t);
                t=1;
            }   
        }
        ans=Math.max(ans,t);
        return ans;
    }
}



```

如果要减少**时间复杂度**的话,我们通常的思路有:

1. 二分
2. dp (避免重复计算)
3. **空间换时间**

对于此题,显然使用哈希表能够大大降低时间复杂度.

此外,如果想提升运行效率的话,我们应该考虑在程序运行中,是否有 冗余操作或不必要的操作. 这一题中,如果我们去看每个数字的上下的连续数字的话,显然是浪费的,我们只需要看每一条连续数字的最下面那个数字,看它的上方是否有连续数字即可.

因此,我们通过哈希表判断是否有比当前数字小一个的,如果有的话,则说明当前数字不是连续数字序列的最小数字,因此可以直接跳过.

```java
class Solution {
    //对于ON时间复杂度的算法,务必要想到哈希表 空间换时间!
    public int longestConsecutive(int[] nums) {
        if(nums.length==0)
            return 0;
        Set<Integer>set=new HashSet<>();
        for(int a:nums){
            set.add(a);
        }
        int ans=1;
        for(int a:set){
            if(!set.contains(a-1)){  
                int i=1;
                while(set.contains(a+i))i++;
                ans=Math.max(ans,i);
            }
            
        }
        return ans;
    }
}




```

