---
title: 二叉树最大宽度
category: 算法
excerpt: 做完这一题对BFS有了更加深入的理解.
---

[leetcode 662二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

这题的几个要点

1. 一开始我想的是根结点左右的节点用正负来表示,后来发现很麻烦,**全都当作坐标轴正数方向的节点不就好!**
2. bfs中,层序遍历是从上到下,从左到右的,因此第一次碰到新的高度的节点,肯定是下一层的第一个节点.后续同层的每一个节点的pos都可以覆盖r
3. 数据范围! 这一题中如果用int,虽然会溢出,但是由于我们需要的是r-l+1,溢出在一定范围内也是可以得到正确答案的.

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root==null)
            return 0;
        Queue<Node>que=new ArrayDeque<>();
        que.offer(new Node(root,0,0));
        int height=0;
        long l=0,r=0;
        long ans=0;
        while(!que.isEmpty()){
            Node f=que.poll();
            if(f.h==height){
                //l=Math.min(l,f.pos);
                r=Math.max(r,f.pos);
                //r=f.pos;
            }else{
                ans=Math.max(ans,r-l+1);
                height++;
                //height=f.h; //更换高度
                l=f.pos;
                r=f.pos;
            }
            if(f.t.left!=null)
                que.offer(new Node(f.t.left,2*f.pos,f.h+1));
            if(f.t.right!=null)
                que.offer(new Node(f.t.right,2*f.pos+1,f.h+1));
        }
        ans=Math.max(ans,r-l+1);
        return (int)ans;
    }
}

class Node{
    TreeNode t;
    long pos;
    int h;
    Node(){}
    Node(TreeNode t,long pos,int h){
        this.t=t;
        this.pos=pos;
        this.h=h;
    }
}
```

