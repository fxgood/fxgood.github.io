---
title: 双指针之滑动窗口
date: 2021-08-02
category: 算法
tag: 
- 双指针
- 滑动窗口
---

滑动窗口是双指针一个比较经典的应用，分为**固定窗口**和**变动窗口**，

对于变动窗口，其执行过程可以概括为：
1.初始`left=0;right=0`
2.向右移动`right`，**扩大窗口，寻找可行解**
3.找到可行解后，向右移动`left`，**收缩窗口，优化可行解**
4.循环执行第2步和第3步，直到right到达边界

**注意，如果逻辑比较复杂， 每次获得可行解，需要立马与临时记录的最优解进行比较**

<!--more-->

**变化滑动窗口：**[76最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```cpp
class Solution {
public:
//滑动窗口思想：每轮先找到可行解，然后优化可行解
    string minWindow(string s, string t) {
        //结果
        int len=s.size()+1,start=0;
        //统计t中的字符
        map<char,int>mp;
        for(auto&c:t)
            if(mp.find(c)==mp.end())
                mp[c]=1;
            else
                mp[c]++;
        //滑动窗口[left,right]
        int left=0,right=0;
        while(right<s.size()){
            char c=s[right];
            //处理当前字符
            if(mp.find(c)!=mp.end()){
                mp[c]--;
            }
            //如果当前是可行解，那么优化可行解
            while(check(mp)){
                //记录可行解
                if(right-left+1<len){
                    len=right-left+1;
                    start=left;
                }
                char c2=s[left];
                //优化可行解
                if(mp.find(c2)!=mp.end()){
                    mp[c2]++;
                }
                left++;
            }
            right++;
        }
        return len<=s.size()?s.substr(start,len):"";
    }
    
    bool check(map<char,int>&mp){
        for(auto&item:mp)
            if(item.second>0)
                return false;
        return true;
    }
};
```
***

**固定滑动窗口**：[567字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
此题利用长度为26的vector，来存放字符信息，非常巧妙。因为可以直接利用`==`符号，判断两个vecoter内容是否相同。
**注意**：本题不宜使用两个map，然后用`==`判断内容是否相同。因为map2[xx]=0时，仍然存留在map2中，此时如果map1中没有`xx`，则`==`结果为false。
```cpp
class Solution {
public:
    //固定大小的滑动窗口
    bool checkInclusion(string s1, string s2) {
        if(s2.size()<s1.size())
            return false;
        vector<int>cs1(26,0);
        vector<int>cs2(26,0);
        int len=s1.size();
        for(int i=0;i<len;i++){
            cs1[s1[i]-'a']++;
            cs2[s2[i]-'a']++;
        }
        if(cs1==cs2)
            return true;
        for(int i=0;i+len<s2.size();i++){
            cs2[s2[i+len]-'a']++;
            cs2[s2[i]-'a']--;
            if(cs1==cs2)
                return true;
        }
        return false;
    }
};
```
***
**固定滑动窗口**：[438找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if(s.size()<p.size())
            return {};
        vector<int>ans;
        //记录字符
        vector<int>char_s(26,0);
        vector<int>char_p(26,0);
        //初始化
        for(auto&c:p)
            char_p[c-'a']++;
        int len=p.size();
        for(int i=0;i<len;i++)
            char_s[s[i]-'a']++;
        if(char_p==char_s)
            ans.emplace_back(0);
        //滑动窗口
        for(int i=len;i<s.size();i++){
            char_s[s[i-len]-'a']--;
            char_s[s[i]-'a']++;
            if(char_s==char_p)
                ans.emplace_back(i-len+1);
        }
        return ans;
    }
};
```
***
**固定滑动窗口**：[最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```cpp

class Solution {
    public int lengthOfLongestSubstring(String s) {
        //记录每个字符上次出现的位置
        Map<Character, Integer> pos = new HashMap<>();
        int n = s.length();
        int l = 0, r = 0;
        int ans = 0;
        while (r < n) {
            char cur = s.charAt(r);
            if (pos.containsKey(cur)) {
                int lastPos = pos.get(cur);
                while (l <= lastPos)   //恢复至可行解
                    l++;    //注意，如果lastPos在滑动窗口l左侧，则while不执行
            }
            ans = Math.max(ans, r - l + 1);
            pos.put(cur, r);
            r++;
        }
        return ans;
    }
}
```