---
title: 小美的代金券要过期啦
category: 算法
tag:
- 美团
- 笔试题
- 区间dp
- 动态规划
excerpt: 这题不仅思路难,细节上也很多.
---

[牛客-美团-小美的代金券要过期啦](https://www.nowcoder.com/questionTerminal/5c9c7ea6f692438693a944962a3f71d8?f=discussion)

这题是`codeforces 1312e`原题,用dp来写的话,时间复杂度$O(N^3)$  

定义`dp[i][j]`表示下标i~j范围合并后的最小长度

定义`lastNum[i][j]`表示ij合并成最小长度后的最后一个数字(或者是若合并后长度为1,其数字是多少)

一个重要的结论是: 只有合并后长度为1的区间有资格进一步合并

那么$dp[i][j]=min(dp[i][k]+dp[k+1][j]) ,k \in [i,j)$

其中若$dp[i][k]==dp[k+1][j]==1$ 则可以合并$dp[i][j]=1, lastNum[i][j]=lastNum[i][k]+1$

> 开始我把初始化i==j的情况写在双重for循环中了,但是由于k的范围导致其并不执行;
>
> 另外一开始也没有对lastNum进行复制

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[]num=new int[n];
        for(int i=0;i<n;i++)
            num[i]=sc.nextInt();
        int[][]dp=new int[n][n];    //dp[i][j]表示i~j合并后的最小长度
        int[][]lastNum=new int[n][n];//lastNum[i][j]表示ij合并成最小长度后的最后一个数字
        for(int i=0;i<n;i++){
            Arrays.fill(dp[i],0x3fffffff);
            dp[i][i]=1;
        }
        for(int i=0;i<n;i++)
            for(int j=i;j<n;j++)
                lastNum[i][j]=num[j];

        for(int j=0;j<n;j++)    //右边界
            for(int i=j;i>=0;i--){    //左边界
                for(int k=i;k<j;k++){    //[i,k] [k+1,j]
                    int l=dp[i][k];
                    int r=dp[k+1][j];
                    if(l==1 && r==1 && lastNum[i][k]==lastNum[k+1][j]){
                        dp[i][j]=1;
                        lastNum[i][j]=lastNum[i][k]+1;
                    }else{
                        if(l+r<dp[i][j]){
                            dp[i][j]=l+r;
                            lastNum[i][j]=lastNum[k+1][j];
                        }
                    }

                }
            }
        System.out.println(n-dp[0][n-1]);
    }
}
```

