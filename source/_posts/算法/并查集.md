---
title: 并查集
category: 算法
---

记录并查集的实现方式，及其应用

<!--more-->

并查集可以用链表形式实现，也可以用数组实现，数组实现更简单；

并查集可以进行两种优化

1. 路径压缩：即在查询根结点的时候优化树的结构
2. 秩优化：在两个节点合并到同一个集合的时候，根据秩（即树高的上限）来决定连接方式



该例题使用克鲁斯卡尔算法求最小生成树的权值和。

Kruskal算法步骤：

1. 将所有边从小到大排序
2. 从小到大考虑每条边，如果一条边的加入不会在图中生成环，则加入该边，否则舍弃；
3. 当所有边考虑完成时，已选边就是最小生成树

**其中，判断一条边的加入是否会生成环，可以使用并查集来实现**：如果两点已经联通，再加入一条以这两点为端点的边，则会产生环；

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
const int N = 1000;

int parent[N];  //记录每个节点的直接父节点,初始值为自身
int Rank[N];  //以i节点为祖宗的树的高度(的上限)，初始为1
/*为什么说是上限，因为路径压缩之后，其并不是准确的树高
 * 但其仍然有意义，因为不会出现a比b树高，但是rank[a]<Rank[b]的情况*/

/*找到祖宗节点,并进行路径压缩*/
int findParent(int k) {
    if (parent[k] == k)
        return k;
    parent[k] = findParent(parent[k]);
    return parent[k];
}

/*将两个节点合并到一个集合中，并优化*/
void merge(int a, int b) {
    int pa = findParent(a); //根结点
    int pb = findParent(b); //根结点
    if (pa == pb)
        return;
    /*按照树高决定连接方式，可以优化搜索路径*/
    if (Rank[pa] > Rank[pb]) {
        parent[pb] = pa;
    } else {
        parent[pa] = pb;
        if (Rank[pa] == Rank[pb])
            Rank[pb]++;
    }
}

/*判断两个节点是否属于同一个集合*/
bool check(int a, int b) {
    return findParent(a) == findParent(b);
}


int n, m;

struct edge {
    int a, b, len;

    edge(int a_, int b_, int l) {
        a = a_, b = b_, len = l;
    }

    bool operator<(const edge &e) const {
        return len < e.len;
    }
};

vector<edge> edges;
int ans = 0;

int main() {
    for (int i = 0; i < N; i++) {
        parent[i] = i;
        Rank[i] = 1;
    }
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b, d;
        cin >> a >> b >> d;
        edges.push_back({a, b, d});
    }
    sort(edges.begin(), edges.end());
    for (int i = 0; i < edges.size(); i++) {
        /*判断是否能够加入已选边*/
        int u = edges[i].a;
        int v = edges[i].b;
        int d = edges[i].len;
        if (check(u, v)) { //此时加入边会导致成圈
            continue;
        }
        merge(u, v);
        ans += d;
    }
    cout << ans;
}
```

**简化版并查集**

```cpp
int parent[N];	//初始值parent[i]=i;

//查询根结点,并进行路径压缩
int find(int k){
    if(k==parent[k])
        return k;
    parent[k]=find(parent[k]);	
    return parent[k];
}

//合并
void merger(int a,int b){
    parent[find(a)]=find(b);
}
```

