---
title: 蚂蚁森林之王
category: 算法
tag: 
- 阿里
- 笔试题
excerpt: 遇到存在多种联系的题目,要能抽象为一个图或者树.知其一还要知其二:要想到进一步用图或者树中的常用方法来解决问题.
---

[牛客网-阿里-蚂蚁森林之王](https://www.nowcoder.com/questionTerminal/276be492542443139857d02198817c3e?answerType=1&f=discussion)

首先,遇到这种存在多种联系,存在链式关系的题目,要条件反射般地考虑到图或者树.

其次,进一步地,还要能想到用图和树中的常用方法来解决题目中的问题.

这一题中存在链式崇拜关系,显然是一个森林,其中每棵树是一个多叉树,进一步思考则用二叉树的递归算法求子树的节点数即可.

一开始我想用的是dp,用二维数组记录每个人向上崇拜链条中的所有人.但是显然空间会爆.$2*10^5*2*10^5*4/2=8*10^{10}字节=80G$

仔细想想这其中存在大量冗余. 所以树的自下而上的算法可以节省这些冗余存储和计算.

其实仔细想想,出题人一定是根据二叉树递归计算节点个数为原型,然后设计出的这个题目.所以都是套路.以后看到这种存在多种关系和链式联系的,一定要想到图和树,想到图和树的常用算法.

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        new Main().solve();
    }
    int n;
  
    int[]worship;
  
    List<List<Integer>>tree;
  
    long[]ans;
  
    void solve(){
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        worship=new int[n+1];
        for(int i=0;i<n;i++){
            worship[i+1]=sc.nextInt();
        }
        tree=new ArrayList<>(n+1);
        tree.add(null);
        for(int i=1;i<=n;i++){
            tree.add(new ArrayList<>());
        }
        for(int i=2;i<=n;i++){
            if(worship[i]!=0)
                tree.get(worship[i]).add(i);	//i是worship[i]的孩子
        }
        ans=new long[n+1];
        Arrays.fill(ans,-1);
        for(int i=1;i<=n;i++)
            dfs(i);
        for(int i=1;i<=n;i++)
            System.out.println(ans[i]);
    }
    //递归计算子树所含的节点个数
    long dfs(int k){
        if(ans[k]!=-1)	//避免重复计算
            return ans[k];
        List<Integer>children=tree.get(k);
        long sum=1;
        for(int i=0;i<children.size();i++){
            sum+=dfs(children.get(i));
        }
        ans[k]=sum;
        return sum;
    }
}

```

