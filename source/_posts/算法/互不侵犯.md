---
title: 互不侵犯
category: 算法
excerpt: 这一题太经典了,深入研究之后会对状态压缩、方向相关问题、位运算等知识点有更加深刻的理解！
---

[洛谷 p1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)

这一题给我带来的感悟:

1. dp,状态压缩dp或者其他各种形式的dp**,不一定dp的最后一个值就是答案,也可能需要再进一步处理得到**.比如这一题里边,最后需要把$sum=\sum_{st=0}^{(1<<n)-1} dp[n-1][st][k]$求出来才能得到最终答案
2. 对于dp的问题,要始终采用把问题分解为一个小问题和剩下所有问题来解决.对于本题来说,就是将n行分解为前面n-1行外加最后一行.
3. 对于多个方向的问题(如存在上下两个方向),如果从上到下构建问题,则只需要考虑一个方向.比如这一题上下两个方向上不能冲突,但是我一行一行从上向下构建,那么每次只需要考虑当前行和上一行的冲突.
   - 以前做的树相关问题,要求上下不能冲突,我们是通过自下而上构建整棵树来使双向问题考虑变成单向问题考虑.
4. 对于位置相关问题,用位运算进行计算是想当好的!
5. 计算一个数字中1的个数,可以采用lowbit操作进行加速.

>  注:洛谷中写java,主函数需要名字写成Main

```java
import java.util.*;

public class Main {
    static int lowbit(int x) {
//        return ~(x-1)&x;  //补码中-1再取反等于取相反数
        return x & -x;    //&优先级低
    }

    //计算二进制位中1的数量
    static int count(int x) {
        int ans = 0;
        while (x != 0) {
            ans++;
            x -= lowbit(x);
        }
        return ans;
    }


    public static void main(String[] args) {
        int n, k;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        k = sc.nextInt();
        //dp[i][state][j] 0~i行一共有j个国王 第i行的状态是state情况下,有多少种方案
        long[][][] dp = new long[n][1 << n][n * n];
        //初始化第一行状态
        for (int s = 0; s < (1 << n); s++) {
            if ((s & (s << 1)) == 0)   //说明左右方向上互不侵犯
                dp[0][s][count(s)] = 1;
        }
        //开始dp
        for (int i = 1; i < n; i++) {   //0~i行的情况
            for (int s1 = 0; s1 < (1 << n); s1++) {   //枚举第i行的所有状态
                if ((s1 & s1 << 1) != 0) continue;   //排除非法状态
                int thisRowK = count(s1);
                //枚举0~i-1行 国王数量为k-thisRowK个下的所有状态
                for (int s2 = 0; s2 < (1 << n); s2++) {
                    if ((s2 & s2 << 1) != 0 || (s1 & s2) != 0 || (s1 << 1 & s2) != 0 || (s1 >> 1 & s2) != 0) continue;
                    int lastRowK = count(s2);
                    for (int ks = lastRowK; ks <= k - thisRowK; ks++) {
                        dp[i][s1][ks + thisRowK] += dp[i - 1][s2][ks];
                    }
                }
            }
        }
        //最后核算
        long ans = 0;
        for (int s = 0; s < (1 << n); s++)
            ans += dp[n - 1][s][k];
        System.out.println(ans);
    }
}
```

