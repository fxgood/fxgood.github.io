{"pages":[],"posts":[{"title":"自建博客过程记录","text":"本博客采用hexo+gitee page+阿里云图床(阿里云对象存储oss)来建立的，主题选用的是基于hexo的icarus主题。一开始用的是hexo+githubpage，存在两个问题：1.博客部署在github部署和访问不稳定2.图片的使用和访问不方便。 建站过程 下载node.js、git等工具。进入在windows命令行 配置npm的国内源 12npm config set registry https://registry.npm.taobao.org #配置国内的镜像源npm info hexo # 测试查看hexo的安装信息，是否是taobao.org的源 安装hexo 12npm install -g hexo # 通过npm安装hexo# -g 指定全局安装，可以使用hexo命令 在自选的路径下，进行以下操作 123hexo init test # 初始化创建，会再桌面创建test文件夹cd test # 进入test目录npm install # 进一步安装hexo所需文件 hexo安装完成，启动hexo 123hexo clean # 清除所有记录hexo generate # 生成静态网页hexo server -p 80 # 在80端口启动服务，如果写-p xx 则在默认端口 浏览器访问localhost:端口号，可以查看博客当前的样子 主题配置：将下载的hexo主题（可以去github或者百度知乎上搜喜欢的）放在themes文件夹下，然后修改_config.yml配置文件 1theme: xxx # 这里与theme下主题文件夹的名称相同 在gitee中创建和用户名相同的仓库，然后修改_config.yml中的仓库url 123deploy: type: git repo: https://gitee.com/fxgood/fxgood # gitee的仓库地址 cd到博客根目录下，输入命令hexo generate &amp;&amp; hexo deploy 或者hexo g &amp;&amp;hexo d ，即可将博客部署到gitee page 阿里云购买域名，进行域名绑定 Typora绑定阿里云图床过程参考 https://zhuanlan.zhihu.com/p/138878534 注意事项 通过gitee page来建博客，仓库名一定要与gitee用户名一致，这样可以采用https://用户名.gitee.io/的方式来访问博客。 每次更新博客内容需要手动在gitee page上进行刷新（氪金会员据说可以自动刷新） hexo配置和主题配置，分别在_config.yml和_config.xxx主题名xx.yml中 写文章，就在source/_posts/下，可以再创建文件夹进行分类存放 生成文章摘要有两种方法 在文章中某一行添加&lt;-- more --&gt;，则该行以上的内容会作为摘要 在md文件开头添加属性excerpt:xxx内容填写摘要即可 添加代码实现文章首页顺序控制,修改node_modules/hexo-generator-index/lib/generator.js文件（没有top属性则比较日期，有则比较top大小，top越大文章在首页越靠前） 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';const pagination = require('hexo-pagination');const { sort } = require('timsort');module.exports = function(locals) { const config = this.config; const posts = locals.posts.sort(config.index_generator.order_by); //添加这一段 posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); //到此截止 sort(posts.data, (a, b) =&gt; (b.sticky || 0) - (a.sticky || 0)); const paginationDir = config.pagination_dir || 'page'; const path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; hexo常用命令 注：首先要用cmd或者git来到本地博客根目录 hexo init初始化博客 hexo clean 刷新部署 hexo generate 更新博客内容后，需要重新生成 hexo deploy 部署到远程服务器上 hexo c &amp;&amp;hexo g &amp;&amp;hexo d 可以一键完成上述三个功能 文章常用yaml front matter title: xxx标题 category: 分类 tag: 标签 1234# 多个标签下tag:- 二叉树- 递归 excerpt: 文章摘要 updated: 2020-04-01 00:00:00 更新时间，（注意在_config.icarus.yml中article中可以设置update_time以实现控制) date: 2020-1-1 00:00:00 创建时间 top: num 根据num的大小，决定在首页的排列顺序，num越大优先级越高","link":"/2021/09/09/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/"},{"title":"Java相关的思考","text":"看到一个知乎的回答讲jvm、jre、jdk，讲的很好，将其主要观点记录下来，来自知乎用户圆胖肿： 现在java现在已经不再强调jvm概念了 以前，jvm是跨平台所需要部分的最小子集，也就是主要用来封装OS差异用的，每一种操作系统，都弄一个jvm，这样提供给上层的接口就统一了。 在jvm的基础上，再加上一些常见的类库，工具，就做成了jre，也就是java的运行时runtime 然后再在jre的基础之上，添加一些编译器等工具，这就是java的sdk（软件开发工具包）了，简称jdk。因此jdk是jre的超集，jre是jvm的超集，反过来，jvm是jre的子集，jre是jdk的子集。 以前java提供jre和jdk两个下载，如果只是运行java的字节码，jar那些的话，只下载安装jre就行，无需安装jdk，只有开发者才需要jdk。 java在9的jsgsaw之后，就不再使用jvm的概念，因为jre可以被定制了，jvm和jre被拆成了一个又一个模块，可以根据需要，删减或者加入自己编写的模块。","link":"/2021/04/26/Java-java%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"O(1)时间插入、删除和获取随机元素的数据结构","text":"今天做到了这一题O(1) 时间插入、删除和获取随机元素，其利用了哈希的O(1)查找，和数组O(1)的随机访问特点来实现题目所要求的数据结构。 并且，做这道题目，纠正了我一个很大的误区，数组的删除，只有在要求顺序不变的情况下，其最坏时间复杂度才是O(N)，否则可以通过交换当前数和数组尾部的数字，然后pop_back()，来实现O(1)时间复杂度的删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*利用哈希的O(1)查找和数组的随机访问*/class RandomizedSet {private: map&lt;int,int&gt;mp; vector&lt;int&gt;nums; //O(1)时间复杂度删除一个数字 void deleteNum(int n){ int index=mp[n]; nums[index]=nums[nums.size()-1]; mp[nums[index]]=index; //删除 mp.erase(n); nums.pop_back(); }public: /** Initialize your data structure here. */ RandomizedSet() { srand((unsigned)time(NULL)); } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(mp.find(val)==mp.end()){ mp[val]=nums.size(); nums.emplace_back(val); return true; } return false; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(mp.find(val)!=mp.end()){ deleteNum(val); return true; } return false; } /** Get a random element from the set. */ int getRandom() { return nums[rand()%nums.size()]; }};/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"单调队列解决滑动窗口最大值问题","text":"今天遇到一道滑动窗口最大值问题239滑动窗口最大值，发现单调队列是解决这类问题的高效方法，遂加以记录。 单调队列：即保持单调有序的队列。底层数据结构使用双端队列比较好，C++需要添加&lt;deque&gt;头文件。 滑动窗口最大值问题中，我们关心的是滑动窗口内的最大值，当滑动窗口向右移动一位时，需要删除一个元素和添加一个元素。对于添加元素来说比较好办，如果添加的元素大于当前最大值则替换其为最大值。而删除元素，如果删除的是最大值，则需要重新遍历滑动窗口内容，造成效率的低下。 研究此问题发现，如下图，当添加的元素是4,时，前面的所有小于4的元素均变成无效数据（如果删除5，则4是最大值，轮不到123当最大值；如果删除了5又删除了4，因为123在4之前进入滑动窗口，所以删除4之前123已经被删除，所以也轮不到123当最大值）。 因此滑动窗口右移，一：删除窗口左端元素，如果和队首元素相同，则队首元素出队，否则什么也不做；二：添加窗口右边元素，新元素入队时，都将前面所有比自己小的元素删除再入队 1234567891011121314151617181920212223242526272829303132333435//单调队列struct MonotonicQue{ deque&lt;int&gt;que; void push(int n){ while(!que.empty() &amp;&amp; que.back()&lt;n){ que.pop_back(); } que.push_back(n); } void pop(int n){ if(n==que.front()) que.pop_front(); } int top(){ return que.front(); }};class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MonotonicQue monQue; //添加前k个元素到单调队列 for(int i=0;i&lt;k;i++) monQue.push(nums[i]); vector&lt;int&gt;ans; ans.push_back(monQue.top()); for(int i=k;i&lt;nums.size();i++){ monQue.pop(nums[i-k]); monQue.push(nums[i]); ans.push_back(monQue.top()); } return ans; }};","link":"/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"},{"title":"双栈模拟队列","text":"使用第一个栈存储push的元素，只有当需要pop时，才将第二个栈中的元素全部倒入到第二个栈中。n次操作总复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyQueue {private: stack&lt;int&gt; st1,st2; int popSt2(){ int ans=st2.top(); st2.pop(); return ans; } void transfer(){ while(!st1.empty()){ st2.push(st1.top()); st1.pop(); } }public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { st1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if(!st2.empty()){ return popSt2(); } transfer(); return popSt2(); } /** Get the front element. */ int peek() { if(!st2.empty()){ return st2.top(); } transfer(); return st2.top(); } /** Returns whether the queue is empty. */ bool empty() { return st1.empty() &amp;&amp; st2.empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"title":"单调栈的应用案例","text":"单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序。 单调栈模板单调栈一般用来解决一类问题：Next Greater Number。比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。即找到每个元素之后，第一个大于它的元素，如果没有则设置为-1。 解决方式：使用一个栈st，然后逆序来看nums数组，先将所有栈中比当前元素小的全部弹出（比当前元素矮的元素都是后续无法利用的无效信息,如图，矮个子会被高个子挡住，因此丢弃），然后如果此时栈空，则结果是-1；如果不为空，为结果是栈顶元素。最后将当前元素入栈；循环执行，最后得出结果数组。 例题1496下一个更大元素I 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int,int&gt;mp; stack&lt;int&gt;st; for(int i=nums2.size()-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; st.top()&lt;nums2[i]){ st.pop(); } if(st.empty()){ mp[nums2[i]]=-1; }else{ mp[nums2[i]]=st.top(); } st.push(nums2[i]); } vector&lt;int&gt;ans; for(auto&amp;n:nums1){ ans.push_back(mp[n]); } return ans; }}; 例题2739每日温度 12345678910111213141516171819class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt;st; vector&lt;int&gt;ans(temperatures.size()); //如果不预先申请长度，则会因为频繁扩容和复制数组，导致超时 for(int i=temperatures.size()-1;i&gt;=0;i--){ int n=temperatures[i]; while(!st.empty() &amp;&amp; n&gt;=temperatures[st.top()]){ st.pop(); } if(st.empty()) ans[i]=0; else ans[i]=st.top()-i; st.push(i); } return ans; }}; 例题3503下一个更大元素II 解决循环数组问题的常用解决方法就是数组翻倍。这里并没有直接构建一个双倍数组，而是通过下标小技巧实现的，形成逻辑上的二倍数组。 1234567891011121314151617class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int len=nums.size(); vector&lt;int&gt;ans(len,-1); stack&lt;int&gt;st; for(int i=2*len-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; nums[i%len]&gt;=st.top()) st.pop(); if(i&lt;len &amp;&amp; !st.empty()){ ans[i]=st.top(); } st.push(nums[i%len]); } return ans; }};","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"实现一个优先级队列(堆)","text":"手动实现一个优先级队列，拥有插入、弹出、判空功能。核心代码是对维护堆结构的代码：从完全二叉树逆序第一个有子节点的节点开始调整。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//手动实现一个二叉堆（优先级队列）#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class PriorityQueue{public: //插入 void push(int n){ arr.push_back(n); makeHeap(); } //弹出队首元素 int pop(){ int ans=arr[0]; swap(arr[0],arr[arr.size()-1]); arr.pop_back(); makeHeap(); return ans; } //判断队空 bool empty(){ return arr.size()==0; }private: //底层数组 vector&lt;int&gt;arr; //调整堆结构 void makeHeap(){ int len=arr.size(); int first=len/2-1; //固定是此位置 for(int i=first;i&gt;=0;i--){ //如果存在右子节点 if(2*i+2&lt;len){ if(arr[2*i+2]&lt;arr[2*i+1] &amp;&amp; arr[2*i+2]&lt;arr[i]) swap(arr[2*i+2],arr[i]); else if(arr[2*i+1]&lt;arr[2*i+2] &amp;&amp; arr[2*i+1]&lt;arr[i]) swap(arr[2*i+1],arr[i]); } //只有左子节点 else{ if(arr[2*i+1]&lt;arr[i]){ swap(arr[2*i+1],arr[i]); } } } }};int main(){ PriorityQueue que; que.push(1); que.push(1); que.push(4); que.push(3); que.push(2); while(!que.empty()){ cout&lt;&lt;que.pop()&lt;&lt;&quot; &quot;; }}","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8F%89%E5%A0%86%EF%BC%89/"},{"title":"队列模拟栈","text":"栈模拟队列需要两个，而队列模拟栈最少只需要一个。即每次需要出栈时，把队尾元素返回即可（其他元素出队再入队）。 下面给出用双队列模拟栈的代码，其中now标记的使用，比较巧妙 12345678910111213141516171819202122232425262728293031323334353637class MyStack {private: queue&lt;int&gt; qArr[2]; int now=0;public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { qArr[1-now].push(x); while(!qArr[now].empty()){ qArr[1-now].push(qArr[now].front()); qArr[now].pop(); } now=1-now; } /** Removes the element on top of the stack and returns that element. */ int pop() { int ans=qArr[now].front(); qArr[now].pop(); return ans; } /** Get the top element. */ int top() { return qArr[now].front(); } /** Returns whether the stack is empty. */ bool empty() { return qArr[now].empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E6%A0%88/"},{"title":"非递归实现树的三种遍历","text":"三种非递归遍历都使用一种框架,代码如下 123456789101112131415void traversal(TreeNode* root) { TreeNode*p=root; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜入栈 while(p!=NULL){ st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } } 中序遍历其核心思想在于：每次把一棵树的根节点、根节点的左孩子、左孩子的左孩子…一直到最左下角，这一条斜线上的所有节点入栈。每次取出并打印栈顶节点的值，然后对其右子树进行上述入栈操作。 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt;st; while(root){ st.push(root); root=root-&gt;left; } vector&lt;int&gt;ans; while(!st.empty()){ //取出栈顶元素 TreeNode*t=st.top(); st.pop(); ans.emplace_back(t-&gt;val); //将栈顶元素右孩子一直到其最下角的左孩子全部入栈 TreeNode*p=t-&gt;right; while(p){ st.push(p); p=p-&gt;left; } } return ans; }}; 前序遍历1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { TreeNode*p=root; vector&lt;int&gt;ans; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜先打印，再入栈 while(p!=NULL){ //打印 ans.push_back(p-&gt;val); //cout&lt;&lt;st.top()-&gt;val //入栈 st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使它为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } return ans; }}; 后序遍历后序遍历非递归的关键在于，栈顶元素何时打印，何时不打印。 当栈顶元素右子树全部访问完了（pre==top()-&gt;right)或为空时，根据后序遍历的定义，此时可以打印栈顶元素；这里的pre指向上次打印的节点，由于后序遍历根最后打印，所以当pre==top()-&gt;right时，能够判断出栈顶元素的右子树所有节点已经访问完毕。 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt;st; TreeNode*pre=NULL; vector&lt;int&gt;ans; TreeNode*p=root; while(p || !st.empty()){ while(p){ st.push(p); p=p-&gt;left; } //如果栈顶元素的右子树为空 或者 右子树存在且已经全部访问过了，则直接打印 if(st.top()-&gt;right==NULL || st.top()-&gt;right==pre){ ans.push_back(st.top()-&gt;val); pre=st.top(); st.pop(); p=NULL; //让下一轮直接访问栈顶元素 }else p=st.top()-&gt;right; } return ans; }};","link":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"},{"title":"算法题之戳气球","text":"leetcode312 戳气球 这一题可以用动态规划来解决,但是dp含义的设置和状态转移方程的设计很有意思。 首先,一维dp难以实现的，应该考虑二维dp，尤其在一个数组中，要考虑到双指针移动来解决复杂问题。 如果将dp[i][j]的含义设置为戳爆下标[i,j]之间所有的气球能获得的最大钱币,会发现由于涉及到与i左边和j右边数字相乘,难以书写状态转移方程。 将dp[i][j]的含义设置为:戳爆下标i和j之间（开区间）的所有气球能获得的最大钱币。此时，如果将状态转移方程写为$dp[i][j]=max(先戳气球k,再戳剩下所有气球,获得的最大钱币) i&lt;k&lt;j$,会造成子问题之间相互牵连,不具有独立性,也就无法完成动态规划的设计。 因此将状态转移方程方程写成dp[i][j]=max(先戳剩下所有气球,再戳气球k,获得的最大钱币) i&lt;k&lt;j,这样每次左右两边的计算互不干扰,即可完成动态规划的设计。 （本质是由于，如果先戳爆气球k，则气球k-1右侧的气球改变，气球k+1左侧的气球也改变，造成钱币获取公式的改变,而最后戳爆气球k,则不会出现这个问题,即固定了dp[i][j]中i和j这两个气球) 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt;nums; int stab(int t){ if(t==0 || t==nums.size()+1) return 1; return nums[t-1]; } //一维dp不行,就整二维 int maxCoins(vector&lt;int&gt;&amp; nums) { this-&gt;nums=nums; int n=nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n+2,vector&lt;int&gt;(n+2,-1)); for(int i=0;i&lt;=n+1;i++) for(int j=i;j&gt;=0;j--){ if(i==j || i==j+1){ dp[j][i]=0; } else{ int m=0; //最后戳爆气球k for(int k=j+1;k&lt;i;k++){ m=max(m,dp[j][k]+dp[k][i]+stab(i)*stab(k)*stab(j)); } dp[j][i]=m; } } return dp[0][n+1]; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%88%B3%E6%B0%94%E7%90%83/"},{"title":"JDBC学习笔记","text":"JDBC基本概念 Java DataBase Connectivity Java数据库连接，Java语言操作数据库 JDBC本质：是Sun公司定义的一套操作关系型数据库的接口，各个数据库厂商去实现了这套接口，提供数据库驱动jar包。我们可以使用这套接口编程 快速入门 步骤 导入驱动jar包 复制文件到libs目录下(记得把数据库驱动也复制过去) 右键add as library 注册驱动 获取数据库的连接对象Connection（java与数据库的连接桥梁） 定义sql 获取执行sql语句的对象Statement 执行sql，接收返回结果 处理结果 释放资源 如果自定义JDBCUtils，则须在src下创建jdbc.properties 1234url=jdbc:mysql:///db1user=rootpassword=rootdriver=com.mysql.jdbc.Driver 代码实现 12345678910111213141516//1.导入jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db1&quot;, &quot;root&quot;, &quot;123&quot;); //4.定义sql语句 String sql =&quot;update user set name='goodboy' where id=1&quot;; //5.获取执行sql的对象 Statement statement = connection.createStatement(); //6.执行sql int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); connection.close(); 详解各个对象 DriverManager：驱动管理对象 功能： 注册驱动：告诉程序该使用哪个数据库驱动jar（！mysql5以后自动注册） static void registerDriver(Driver driver)：注册与给定的驱动程序DriverManager 写代码使用：Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在存在静态代码块 获取数据库连接 ： 方法：getConnection(String url,String user,String password) 参数 url:指定连接的路径 mysql语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称 例子：jdbc:mysql:..localhost(127.0.0.1):3306/bd1 细节：如果连接的是本机的mysql服务器，并且mysql服务默认端口是3306，则url可以简写为jdbc:mysql:///数据库名称 user：数据库用户名 password：数据库密码 Connection：数据库连接对象 功能 获取执行sql的对象 createStatement() prepareStatement(String sql) 管理事务 开启事务： setAutoCommit(boolean autoCommit)：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql)：可以执行任意sql，了解即可不常用 int excuteUpdate(String sql)：执行DML（增删改insert，update，delete）语句，（DDL不常用）DDL（create,alter,drop) 返回值：影响的行数。&gt;0执行成功 （最常用）ResultSet excuteQuery(String sql)：执行DQL（Select）语句 ResultSet：结果集对象,封装查询结果 boolean next()：游标向下移动衣阿华那个 getXxx(参数)：获取数据 Xxx：代表数据类型 如getInt() getString() 参数： int：代表列的编号，从1开始 String：代表列名称。如getString(“name”); 使用步骤 游标向下移动一行 判断是否有数据(看next的返回结果，如果为false则该行没数据 ) 获取数据 练习 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回（注意double类型接收数据库的小数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 查询emp表然后将结果封装成一个对象，然后放入集合，返回*/public class JDBC_demo05 { /*查询emp所有对象*/ public static List&lt;User&gt; findAll(){ Connection connection=null; Statement statement=null; ResultSet resultSet=null; ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 connection= DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //3.创建sql String sql=&quot;select*from user&quot;; //4.执行sql statement=connection.createStatement(); resultSet = statement.executeQuery(sql); //5.处理结果 while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(statement!=null) statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } return list; } public static void main(String[] args) { List&lt;User&gt; all = JDBC_demo05.findAll(); for(User user:all){ System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getGender()); } }} PreparedStatement：执行sql的对象（是Statement的子接口） SQL注入问题：在拼接sql时，有一些sql的特殊关键词参与字符串的拼接。会造成安全性问题 用户名随便，密码输入 a’ or ‘a’=’a’ sql: select*from user where username=xxx and password=’a’ or ‘a’=’a’,查询条件变成了恒等式 解决：使用PreparedStatement对象来解决 预编译的SQL：参数？作为占位符 步骤： 导入驱动jar包 注册驱动 获取数据库连接对象COnnection 定义sql 注意：sql的参数使用？作为占位符 获取PreparedStatement对象：Connection.getPreparedStatement(String sql) 给？赋值 方法：setXxx（参数1，参数2） 参数1：？的位置编号，从1开始 参数2：？的值 注意：后期都会使用PreparedStatement来完成增删改查的所有工作 可以防止SQL注入 效率更高 代码实现 1234567891011121314151617181920212223242526272829303132333435public class JDBC_demo03_标准 { public static void main(String[] args) { Connection connection=null; Statement statement=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;insert into user values(3,'小小余','男')&quot;; //5.执行 statement = connection.createStatement(); int result = statement.executeUpdate(sql); //6.打印结果 if(result&gt;0) System.out.println(&quot;执行成功！&quot;); else System.out.println(&quot;执行失败！&quot;); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041public class JDBC_demo04_excuteQuery { public static void main(String[] args) { Connection connection=null; Statement statement=null; ResultSet resultSet=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;select*from user&quot;; //5.执行 statement = connection.createStatement(); resultSet=statement.executeQuery(sql); //6.打印结果 while(resultSet.next()){ int id=resultSet.getInt(&quot;id&quot;); String name=resultSet.getString(&quot;name&quot;); String gender=resultSet.getString(&quot;gender&quot;); System.out.println(id+&quot;/&quot;+name+&quot;/&quot;+gender); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 抽取JDBC工具类：JDBCUtils 目的：简化书写 案例： User: 封装了数据库表的JavaBean 1234567891011121314151617181920212223242526272829303132333435363738394041public class User { private int id; private String name; private String gender; @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, gender='&quot; + gender + '\\'' + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public User() { }} JDBCUtils工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; //静态代码块加载配置文件,**静态代码块随着类的加载而加载，只执行一次** static { Properties properties=new Properties(); //获取src路径下的文件的方式——&gt;ClassLoader类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL propertiesURL = classLoader.getResource(&quot;jdbc.properties&quot;); try { properties.load(new FileReader(propertiesURL.getPath())); } catch (IOException e) { e.printStackTrace(); } url=properties.getProperty(&quot;url&quot;); user=properties.getProperty(&quot;user&quot;); password=properties.getProperty(&quot;password&quot;); driver=properties.getProperty(&quot;driver&quot;); //注册驱动 try { Class.forName(driver); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //获取Connection对象 public static Connection getConnection(){ Connection connection=null; try { connection= DriverManager.getConnection(url, user, password); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //执行sql语句,实现增删改 public static void update(String sql){ Connection connection=getConnection(); Statement statement=null; int result=-1; try { statement = connection.createStatement(); result = statement.executeUpdate(sql); if(result&gt;0) System.out.println(&quot;执行成功！&quot;); } catch (SQLException throwables) { throwables.printStackTrace(); }finally { closeUpdate(connection,statement); } } //update后关闭资源 public static void closeQuery(Connection connection, ResultSet resultSet, Statement statement){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } } //query后关闭资源 public static void closeUpdate(Connection connection,Statement statement){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 实现增删改 1234567public class JDBC_demo06 { public static void main(String[] args) { Connection connection= JDBCUtils.getConnection(); String sql=&quot;insert into user values(4,'小小余','女')&quot;; JDBCUtils.update(sql); }} 实现查询 12345678910111213141516171819202122232425262728public class JDBC_demo07 { public static void main(String[] args) { Statement statement=null; ResultSet resultSet=null; String sql=&quot;select*from user&quot;; Connection connection= JDBCUtils.getConnection(); ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { statement=connection.createStatement(); resultSet=statement.executeQuery(sql); while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (SQLException throwables) { throwables.printStackTrace(); } JDBCUtils.closeQuery(connection,resultSet,statement); for(User user:list){ System.out.println(user); } }} JDBC控制事务 事务：一个包含多个步骤的业务操作 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 setAutoCommit(boolean autoCommit（）：调用该方法，设置参数为false，即开启事务 在执行sql之前开启事务 commit()：提交事务 当所有sql都执行完提交事务 rollback()：回滚事务 在catch中回滚事务 数据库连接池 概念：其实就是一个容器（集合）：存放数据库连接的容。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户访问数据库时，从容器中获取连接对象，用户访问完后，会将对象归还给容器 好处 节约资源 高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：如果连接对象COnnection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还到连接池中 一般我们不去实现它，由数据库厂商来实现 C3P0：数据库连接池技术（老） Druid（德鲁伊）：由阿里巴巴来实现的 C3P0 略 Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂类来获取DruidDataSourceFactory 获取连接：getConnection() 代码实现 1234567891011//1.导入jar包，放入libs，右键add as library//2.定义配置文件，赋值，放在src下(记得修改一下url）//3.加载配置文件Properties properties=new Properties();InputStream inputStream = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);properties.load(inputStream);//4.获取连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//5.获取连接Connection connection=dataSource.getConnection();System.out.println(connection); 定义工具类 定义一个类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源： 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*Druid连接池的工具类*/public class JDBCUtils_Druid { //1.定义成员变量DataSource private static DataSource dataSource; static{ //1.加载配置文件 Properties properties=new Properties(); InputStream inputStream = JDBCUtils_Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); try { properties.load(inputStream); dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } //2.获取连接的方法 public static Connection getConnection(){ Connection connection=null; try { connection=dataSource.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //3.释放资源 public static void close(Statement statement,Connection connection){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); //归还连接 } catch (SQLException throwables) { throwables.printStackTrace(); } } } public static void close(ResultSet resultSet,Statement statement, Connection connection){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } close(statement,connection); } //4.获取连接池的方法 public static DataSource getDataSource(){ return dataSource; }} Spring JDBC Spring框架提供的JDBC简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 (记得还导入mysql驱动) 创建JdbcTemplate对象。依赖于数据源DataSource（数据库连接池） JdbcTemplate template=new JdbcTemplate(ds); 调用方法来完成crud操作 update()：执行DML语句 （增删改） queryForMap（）：查询结果将结果集封装为Map集合，只能查询结果为1个的语句 queryForList（）：查询结果将结果集封装为List集合 query()：查询结果，将结果封装为JavaBean对象 query的参数：RowMapper接口 一般我们使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装 例：new BeanPropertyRowMapper(Person.class) queryForObject（）：查询结果，将结果封装为对象（一般用于聚合函数的查询） ```java //1.导入jar包，加入library //2.创建JdbcTemplate对象，参数是数据库连接池 JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); //3.调用方法 String sql=&quot;update account set balance =100 where id=?&quot;; int result = jdbcTemplate.update(sql, 2); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* 练习： * **注意！JavaBean在封装时成员变量最好写成封装类型Integer Double等，否则在调用template进行封装时会出现，如果某个值为null就会报错** * 需求 1. 修改数据 2. 增加记录 3. 删除记录 4. 查询一定条件的结果，封装为map集合 5. 查询所有记录，分装为list 6. 查询所有记录，封装为emp对象的list集合 7. 查询总记录数（count聚合函数） ```java public class demo04_test { @Test public void test01(){ //查询结果以map的方式返回,**查询结果只能为1个** JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(&quot;select*from account where id=1&quot;); System.out.println(stringObjectMap); } @Test public void test02(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select*from account&quot;); System.out.println(list); } @Test public void test03(){ //遍历所有，将每行的结果封装为一个JavaBean JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new RowMapper&lt;Person&gt;() { @Override public Person mapRow(ResultSet resultSet, int i) throws SQLException { Person p = new Person(); p.setId(resultSet.getInt(&quot;id&quot;)); p.setBalance(resultSet.getInt(&quot;balance&quot;)); p.setName(resultSet.getString(&quot;name&quot;)); return p; } }); System.out.println(personList); } //简化版封装JavaBean @Test public void test04(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new BeanPropertyRowMapper&lt;Person&gt;(Person.class)); System.out.println(personList); } //查询记录条数 @Test public void test05(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Integer integer = jdbcTemplate.queryForObject(&quot;select count(*)from account&quot;, Integer.class); System.out.println(integer); } }","link":"/2020/05/12/Java-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java基础","text":"1. 概述 冯诺依曼体系结构 组成：运算器，控制器，存储器，输入设备，输出设备 SUN公司1995年推出的一门高级编程语言 JDK：Java Development Kit （java开发工具包） 包括jre 其他开发工具：编译工具javac.exe，打包工具jar.exe JRE：Java Runtime Environmen（java运行时环境 ） 包括Java虚拟机（Java Virtual Machine）和Java程序所需要的核心类库等。 如果想运行一个开发好的java程序，计算机中只需要安装JRE即可。 Java内存模型 2. 基本语法2.1 关键字和标识符关键字 关键字的定义和特点 定义：被Java语言赋予了特殊含义的字符串 特点：都是小写 用于定义数据类型的关键字byte,short,int,long,float,double,boolean,void,class,interface,enum 用于流程控制的关键字if,else,switch,for,while,case,default,do,break,continue,return 用于定义访问权限修饰符的关键字public,protected,private 定义类，函数，变量修饰符的关键字abstract,final,static,synchronized 用于定义类与类之u见关系的关键字extends,implements 用于定义简历实例及引用实例，判断实例的关键字new,this,super,instanceof 用于异常处理的关键词try,catch,finally,throw,throws 用于包的关键字package,import 其他修饰符关键字native,strictfp,transient,volatile,assert 保留字现有Java版本尚未使用，但以后版本可能会作为关键字使用，如goto，const 标识符命名规范 包名：全部小写,xxxyyyzzz 类名、接口名：大驼峰 变量名、方法名：小驼峰 常量名：全部大写，多个单词用下划线连接 2.2 变量基本数据类型 Java语言数据类型的长度和表示范围不受OS影响 基本数据类型(primitive type) 数值型 整数类型 byte:1字节，范围：-128-127 short:2字节，范围:$-2^{15}$ ~ $2^{15}+1$ int:4字节，范围$-2^{31}$ ~ $2^{31}-1$（约21亿） long:8字节，范围$-2^{63}$ ~ $2^{63}-1$声明long类型常量须加小写l或者大写L 浮点类型 单精度float，占4字节，尾数可以精确到7位有效数字 float类型表示范围比long还大！ 因为float类型底层存储方式不同，$2^E*M$ 浮点数关注的是精度，整数类型关心的是范围，。 双精度double，占8字节，精度是float的两倍。通常采用此类型 java的浮点型常量默认为double类型，声明float类型，须后加小写f或者大写F 两种表示形式 十进制数形式：2.12, 512.0f, .34 科学计数法形式：5.12e2, 512E2, 100E-2 字符型 char，占2个字节 三种表示方式 单引号 转义字符\\r回车符，\\n换行符 Unicode值直接表示，\\uXXXX，XXXX代表一个十六进制整数 char类型可以运算，因为有对应的Unicode码 UTF-8是使用最广的一种Unicode的实现方式 布尔型 boolean 引用数据类型(reference type) 类(包括String） 接口 数组 基本数据类型之间的转换除了boolean类型，其他7种基本数据类型之间的转换自动类型提升 当容量（表示数的范围）小的数据类型的变量与容量大的数据类型的变量之间做运算时，结果自动提升为容量大的数据类型。 如果用int=int+long则会报错 容量（表示数的范围）从小到大是：byte（1字节）-&gt; char、short （2字节）-&gt; int -&gt; long -&gt; float -&gt; double (注意，float虽然是4个字节，但是比8个字节的long，能表示的数据范围要更大） 特别地，byte、char、short三种类型的变量之间做运算时（包括自己和自己，如byte+byte），结果为int类型 书上：java在做运算地时候，如果操作数均在int范围内，那么一律在int的空间内运算强制类型转换 需要使用强转符号() 可能造成精度损失 不加l或者L的整数，默认是int型 比如 long a=213214332143254324; 会报错，整数超过int类型 不加f或者F，默认是double类型 比如float b=12.3; 会报错 因为12.3默认是double类型，不能直接赋值给精度小的float类型常量 整型常量，默认类型为int型 浮点型常量，默认类型为double型String 声明String时，用双引号即可 不是基本数据类型，属于引用数据类型 字符串可以拼接其他字符串，也可以拼接其他数据类型的数据 可以与基本数据类型，直接做+运算 进制转换 对于整数，有四种表示方式 二进制binary，以0b或者0B开头 十进制decimal 八进制octal，以数字0开头 十六进制hex，以0x或者0X开头 二进制的整数有如下三种形式 原码：直接将一个数值转换成二进制。最高位是符号位 反码： 正数：和原码一样 负数：除符号位外，其他位对原码按位取反 补码： 正数：和原码一样 负数：反码+1 -127补码是1000 0001，-128补码是1000 0000，用-127减一即可 2.3 运算符Java中的运算符有 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 位运算符&gt;&gt;&gt;无符号右移 移位运算符和位运算符优先级如下~，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，^，| 2.4 数组对char型数组，System.out.println()打印的结果是内容的字符串形式对于其他类型的数组，打印的结果是类型@地址值，如[I@ed9d034 3. 封装面向对象的三大特征 封装 继承 多态3.1 java内存模型 堆Heap唯一目的是存放对象实例， 几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈Stack通常所说的栈Stack，指的是虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型(byte,short,char,int,long,boolean,float,double)、对象引用(reference类型，是对象在堆内存的首地址）。方法执行完，自动释放。 Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）， Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。对于我们来说，主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。 方法区Method Area用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(JDK8以后改成了元数据空间metaspace） 程序计数器1234程序计数器是一个记录着当前线程所执行的 字节码的行号指示器。JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。 首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，**每个线程工作时都有属于自己的独立计数器。** 运行时数据区包括：方法区、虚拟机栈、本地方法栈、堆、程序计数器 3.2 对象 对象的内存解析 对象数组的内存解析 注意： 此处的字符串“Tom”，是字符串常量，实际上是在方法区 引用类型的变量，只可能存储两类值：null 或 地址值（包含变量的类型）3.3 方法 方法重载概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数 或 参数类型不同即可。特点：与返回值类型无关，只看参数列表。 可变形参的方法允许直接定义能和多个实参相匹配的形参。从而，可以使用一种更简单的方式，来传递个数可变(任意个，包括0个）的参数。具体使用 格式：数据类型 ... 变量名 传入参数个数可以是：0个，1个，2个… 可以与形参不同的方法之间形成重载 与形参类型相同的数组，不能共存 在形参列表中，必须声明在末尾 形参列表中，最多只能声明一个可变形参定义123456public void show(String ... strs){ //可以像使用数组一样使用参数strs for(int i=0;i&lt;str.length();i++){ System.out.println(strs[i]); }} 方法参数的值传递机制Java里的方法的参数传递方式只有一种：值传递。即将实际参数值的副本传入方法内，而参数本身不受影响。 形参是基本数据类型：将其数据值传递给形参 形参是引用数据类型：将其地址值传递给形参 关于字符串作为形参的情况 123456789101112public class p1 { static void change(String s2) { s2 = &quot;bbb&quot;; } public static void main(String[] args) { String s1 = &quot;aaa&quot;; change(s1); System.out.println(s1); }}//打印结果：aaa Java中的String对象具有不可改变性，这里java在常量池中开辟了一块区域给aaa，s1指向aaa。change函数的形参仍然是地址传递（String是引用数据类型），s2也指向aaa，然后s2=&quot;bbb&quot;即将s2指向bbb，s1的指向并未改变。因此最终打印的结果仍然是aaa 3.4 四种权限修饰符封装性的体现： 我们将类的属性xxx私有化，同时，提供公共方法来获取和设置它。 不对外暴露的私有的方法 单例模式 … 我们设计程序追求“高内聚、低耦合” 高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅对外暴露少量的方法用于使用 Java规定了4种权限：private, (default), protected, public| 修饰符 | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 || ——— | —— | ——– | ———— | ———- || private | Yes | | | || (default) | Yes | Yes | | || protected | Yes | Yes | Yes | || public | Yes | Yes | Yes | Yes | 四种权限可以用来修饰类以及类的内部结构：属性、方法、构造器、内部类 对于class的权限修饰，只可以用public和default（缺省） public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 3.5 构造方法说明 如果没有显示地定义类的构造器的话，系统默认会提供一个空参的构造器；一旦我们显示定义了类的构造器之后，系统就不再提供默认的空参构造器。 定义构造器的格式：权限修饰符 类名(形参列表){...} 构造器可以重载 3.6 JavaBean说明 JavaBean是一种Java语言写成的可重用组件 所谓JavaBean，是指符合以下标准的Java类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get和set方法3.7 UML类图3.8 this说明 它在方法内部使用，即这个方法所属对象的引用 它在构造器内部使用，表示该构造器正在初始化的对象 用于构造器调用其他构造器（必须声明在当前构造器的首行，且最多只能使用一次）1234567891011public Person{ public Person(){...} public Person(int age){ this(); ... } public Person(int age,string name){ this(age); ... } } 3.9 JDK中主要的包介绍 java.lang：包含Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能 java.net：包含执行与网络相关操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用的工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具及(abstract window toolkits）的多个类，用于构建和管理应用程序的GUI，现在不常用了。3.10 MVC设计模式MVC是常用的设计模式之一，将整个程序分为三个层次：视图、控制器、数据模型。3.11 import关键字说明 可以使用xxx.*方式，导入xxx包下的所有结构（子包除外，需要再显示声明） java.lang包或本宝下定义的类和接口，可以省略import 如果在源文件中，使用了两个不同包下的同名的类，则至少有一个要以全类名的方式书写（xxx.xxx.类名) import static ：导入指定类或接口中的静态结构（落脚点不是类，而是某个结构，属性或方法，或者写*），用的少。12345import static java.lang.System.*;import static java.Math.*;//这样可以省略System、Mathout.println(&quot;abc&quot;);long a=round(1.23); 4. 继承Java对继承的规定 单继承：一个子类只能有一个父类 直接继承的是直接父类，间接继承的是间接父类 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法，但是能否访问还得看权限修饰符。 4.1 Object类 如果我们没有显示地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除了java.lang.Object类）都直接或间接继承于java.lang.Object类4.2 方法重写 定义：在子类中可以根据需要对从父类继承来的方法进行改造。在程序执行时，子类的方法将覆盖父类的方法 要求： 重写的方法必须与父类具有相同的方法名和参数列表 重写的方法的返回值类型不能大于父类被重写的方法的返回值；如果父类返回的是基本数据类型，那么子类也必须是。 子类重写的方法使用的访问权限不能小于父类被重写的方法的权限 子类不能重写父类中声明为private权限的方法 子类方法跑出的异常不能大于父类被重写的方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static（不是重写）。因为static方法属于类，子类无法覆盖父类的static方法。 4.3 super关键字 说明 可以在子类的方法或构造其中，使用super.属性或者super.方法的方式，显示地调用父类中声明的方法或属性。通常情况下， 省略super 特殊情况下，当子类和父类方法名或属性名重名时，显示调用super super调用构造器 可以在子类的构造器中显示地使用super(形参列表)的方式，调用父类中声明的指定的构造器 必须在子类构造器的首行 类的构造器中，this(形参列表)和super(形参列表)只能二选一，不能同时出现 在构造器的首行，如果没有显示地声明 this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器；注意，子类构造器必须直接或间接地调用父类构造器，如果没有声明，则调用父类的默认空参构造器（如果父类没有，则报错）。4.4 子类对象实例化过程 从结果上看子类继承父类之后，就获取了父类中声明的属性和方法；创建子类的对象，在堆空间中，就会加载所有父类中声明的属性 从过程上看当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 4.5 抽象类与抽象方法4.6 接口5. 多态5.1 概述 理解多态性：是面向对象中最重要的概念，在Java中的体现就是父类的引用指向子类的对象。可以直接应用在抽象类和借口上。 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际给该变量赋值的对象决定。简而言之：编译时看左，运行时看右。 若编译时和运行时类型不一致，就出现了对象的多态性（Polymorphism） 多态情况下： 看左边：看的是父类的引用（父类中不具备子类特有的方法） 看右边：看的是子类的对象（实际运行的是子类重写父类的方法） 多态使用的前提 类的继承关系 方法的重写 多态性不适用于属性（编译和运行时都看左边） 多态的意义：多态是面向对象中最重要的概念，没有多态性，就没有后面的抽象类、接口等概念。 虚拟方法调用：子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。 如何证明多态是运行时行为？（编译时无法确定类型，动态绑定） 12345678910111213141516171819202122232425262728293031323334353637383940414243package July.demo01;import java.util.Random;public class Animal { void speak(){ } static Animal getInstance(int key){ switch(key){ case 0: return new Dog(); case 1: return new Cat(); default: return new Rabbit(); } } public static void main(String[] args) { int key= new Random().nextInt(3); Animal animal=getInstance(key); animal.speak(); }}class Dog extends Animal{ void speak(){ System.out.println(&quot;Dog!&quot;); }}class Cat extends Animal{ void speak(){ System.out.println(&quot;Cat!&quot;); }}class Rabbit extends Animal{ void speak(){ System.out.println(&quot;Rabbit!&quot;); }} 5.2 重载和重写 5.3 instanceof 操作符与向下转型如何才能调用子类特有的方法和属性？向下转型，使用强制类型转换符。使用强转的时候，可能出现ClassCastException异常。a instanceof A：如果a是A的实例，或者是A的子类的实例，则返回true 对于引用数据类型来说，强制类型转换的前提是，堆内存中存在转换后类型（或子类）的对象，否则不能转换。 123456//Man是Person的子类Person p=new Person();Man m=(Man)p; //错误！堆内存中是Person类型对象Object obj=new Man();Person p=(Person)obj; //可以执行！内存中有Man类型对象，也是Person子类的实例。 6. 补充内容6.1 Object类 Object类是所有Java的根父类 如果定义一个类没有声明父类，则默认继承java.lang.Object Object类只声明了一个空参的构造器 Object类方法（所有类的通用方法） equals toString getClass hashCode clone finalize6.2 ==和equals ==运算符 1.比较基本数据类型：比较值。注意可以类型不同，如int a=1; float b=1.0，a和b==运算的结果是true。（boolean不能参与运算） 2.比较引用数据类型：比较在内存中的地址值。 为何有些情况下，直接定义String的时候，可以直接用==判断两个String值相等？因为String存在字符串常量池的问题（但不是所有String都在里边，也有可能两个相同的String不指向同一个引用）。 equals方法 1.只能用于引用数据类型2.Object中的equals是用==实现的3.IDE自动生成的equals方法 6.2 包装类 基本数据类型、包装类和String之间的转换 自动装箱与自动拆箱包装类和基本数据类型之间可以直接进行互相赋值 123int a=1;Integer b=a;a=b; 基本数据类型、包装类–&gt;String方式一：使用&quot;&quot;+连接方式二：String.valueOf() String–&gt;基本数据类型、包装类 包装类的一些问题 6.3 关键字：static 修饰属性 修饰方法 单例设计模式 饿汉式： 优点：线程安全 缺点：资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类，那么这个实例仍然初始化 懒汉式： 优点：延迟加载，需要用到实例的时候再加载 缺点：线程不安全（有改进的方法） 12345678910111213141516171819202122//单例之饿汉式public class House { private static House house=new House(); public static House getInstance(){return house;} private House(){}}//单例之懒汉式class Country{ private Country(){} private static Country count=null; public static Country getInstance(){ if(count==null) count=new Country(); return count; }} 单例模式应用场景6.4 类的成员：代码块 代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 可以定义多个，按照声明的先后顺序执行 分类： 静态代码块：随着类的加载而加载，并执行；随着类的加载而执行，而且只执行一次 非静态代码块：随着对象的创建而加载，并执行；每创建一个对象，就执行一次6.5 关键字：final 修饰类：不能被继承 修饰方法：不能被重写 修饰变量：此时的变量变为了一个常量。 基本数据类型：变量一旦赋值后，不能被重新赋值。 引用数据类型：引用指向不能发生改变。6.6 抽象类与抽象方法abstract可以用来修饰类、方法，不能修饰私有方法、静态方法、final的类、方法 修饰类：抽象类 此类不能实例化 仍然提供构造器（子类要调用），类中一定有构造器。 修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之不然。 子类重写父类中的所有抽象方法后，此子类方可实例化 抽象类的匿名子对象模板方法设计模式 抽象类和接口的区别 1抽象类是一种对事物的抽象，而接口是一种对行为的抽象； 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 抽象类是一种模板式设计，而接口是一种行为规范，是一种辐射式设计。 6.7 接口 Java不支持多继承，但是有了接口，就可以实现多重继承的效果。接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。 说明： interface接口不能定义构造器，意味着接口不能实例化。 类implements接口 如果类没有实现接口中的所有抽象方法，则此类仍然是一个抽象类 接口和接口之间可以继承，而且可以多继承 JDK8之后，除了定义全局常量public static final和抽象方法以外，还可以定义静态方法、默认方法。 接口中的所有属性（全局静态常量）和方法，都是public的，即使不加，系统也自动声明为public。 接口匿名实现类6.8 接口应用：代理模式（Proxy） 概述：代理模式是Java开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制这个对象的访问。如明星（被代理类）和经纪人（代理类），租房者（被代理类）和中介（代理类）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class proxyPatternDemo { public static void main(String[] args) { Proxy proxy=new Proxy(new Server()); while(true){ proxy.browse(); System.out.println(); } }}//浏览网页的接口interface NetWork { void browse();}//被代理类class Server implements NetWork{ @Override public void browse() { System.out.println(&quot;正在访问该网站&quot;); }}//代理类class Proxy implements NetWork{ private NetWork netWork; public Proxy(NetWork netWork){ this.netWork=netWork; } private boolean check() throws InterruptedException { System.out.println(&quot;正在做访问网络前的检查...&quot;); Thread.sleep(1000); return new Random().nextInt(100)%2==0; } @Override public void browse(){ try { boolean res=check(); if(res){ System.out.println(&quot;校验通过，允许访问！&quot;); netWork.browse(); }else{ System.out.println(&quot;校验不通过，不允许访问！&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} 应用场景 分类 静态代理（静态定义代理类） 动态代理 （动态生成代理类） JDK自带的动态代理，需要反射等知识。 6.9 接口的应用：工厂设计模式 工厂模式概念：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 核心本质：实例化对象，用工厂方法代替new操作；将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 工厂模式的分类 简单工厂模式：用来生产同一等级结构中的任意产品。（对于新增加的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） //简单工厂模式 123456789101112131415161718192021222324252627282930313233343536public interface Car { public void run();}class BMW implements Car{ @Override public void run(){ System.out.println(&quot;BMW is running~&quot;); }}class Mercedes_Benz implements Car{ @Override public void run(){ System.out.println(&quot;Benz is running~&quot;); }}//Car工厂类class carFactory{ public static BMW getBMW(){ return new BMW(); } public static Mercedes_Benz getBenz(){ return new Mercedes_Benz(); }}class Test{ public static void main(String[] args) { Car car1=carFactory.getBenz(); Car car2=carFactory.getBMW(); car1.run(); car2.run(); }} //工厂方法模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Car { void run();}class Benz implements Car{ @Override public void run() { System.out.println(&quot;Benz is running...&quot;); }}class Audi implements Car{ @Override public void run() { System.out.println(&quot;Audi is running...&quot;); }}//工厂接口interface carFactory{ Car getCar();}//宝马工厂class BenzFactory implements carFactory{ @Override public Benz getCar() { return new Benz(); }}//奥迪工厂class AudiFactory implements carFactory{ @Override public Car getCar() { return new Audi(); }}class Test{ public static void main(String[] args) { Car car1=new AudiFactory().getCar(); Car car2=new BenzFactory().getCar(); car1.run(); car2.run(); }} 6.10 JDK8接口静态方法、默认方法 静态方法：接口中定义的静态方法，只能通过接口来调用（不能用实现类来调用） 默认方法：类似让接口拥有类的功能，让实现类拥有该方法。通过实现类对象来调用（可以重写）。 public即使不加，系统也会自动加上1234567891011121314151617public interface Test { public static void method1(){ //... } static void method2(){ //... } public default void method3(){ //... } default void method4(){ //... }} 6.11 内部类 概念：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 Inner class 一般用在定义它的类或者语句块之内，在外部引用它时必须给出完整的名称。 分类 成员内部类：static成员内部类和非static成员内部类 局部内部类（不谈修饰符）：匿名内部类 1234567891011public class Person { //静态成员内部类 static class Cat{} //非静态成员内部类 class Dog{} void f(){ //局部内部类 class Fish{} } } 7. 异常处理7.1 异常概述与异常体系结构 为什么需要异常处理因为有很多问题不是靠代码能够避免的，比如：用户输入数据的格式，读取文件是否存在，网络是否始终保持畅通等等 异常：在程序执行过程中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常） 分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。如：StackOverflowError和OOM。一般不编写针对性的代码进行处理 Excepetion：其他因编程错误或者偶然的外在因素导致的一般性稳提，可以使用针对性的代码进行处理，例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组访问越界 Exception又分为：编译时异常(checked受检异常）和运行时异常 7.2 常见异常编译时异常 IOException —-FileNotFoundException ClassNotFoundException 运行时异常（编程实践中，一般对运行时异常不做处理） NuLLPointerException12345678//试图堆一个空对象调用方法时，就会产生空指针异常public class Main { @Test public void test(){ Date date=null; date.getTime(); }} ArrayIndexOutOfBoundsException ClassCastException1234567public class Main { @Test public void test(){ Object obj=new String(&quot;abc&quot;); Main main=(Main)obj; }} NumberFormatException123456public class Main { @Test public void test(){ int num=Integer.parseInt(&quot;abc&quot;); }} InputMismatchExceptionScanner输入int，结果用户输入abc，会报此异常 ArithmeticException123456public class Main { @Test public void test(){ int a=10/0; }} 7.3 异常处理机制一：try-catch-finally使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于把一个编译时可能出现的异常，延时到运行时出现（转变为运行时异常）。所以，对于运行时异常，一般不做处理。使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的类，并且终止try中代码的执行，根据此异常的类型去catch中进行匹配。try-catch-finally执行完了，继续执行下面的其他代码。 常用的异常对象处理的方式1.String getMessage()2.void printStackTrace() try-catch-finally结构可以嵌套 注意：如果catch多个异常存在父子关系的话，子类要放在上边 7.4 异常处理机制二：throws1.使用throws向上抛出异常，出现异常时，异常后序的代码将不再执行2.throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 注意：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（或者不抛）（原因：多态时，父类引用指向子类对象，调用同名方法，并且进行异常处理时，如果子类方法异常类型大于父类类型，则无法处理） 1234567891011121314151617181920212223242526public class Main { @Test public void test() { f(new Son()); } public void f(Father person){ try { person.method(); } catch (IOException e) { e.printStackTrace(); } }}class Father{ void method()throws IOException{ }}class Son extends Father{ void method()throws FileNotFoundException{ }} 7.5 两种异常处理方式的选择1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理2.执行的方法A中，先后又调用了另外几个方法bcd，这几个方法是递进关系的（需要利用上一个方法的返回值）。建议这几个方法使用throws进行处理。而执行的方法A考虑使用try-catch-finally方式进行处理。（如果在b直接进行try-catch处理，cd会正常执行，但是利用的返回值是无效的） 7.6 手动抛出异常：throw关于异常对象的产生：1.系统自动生成的异常对象2.手动的生成一个异常对象，并throw 123456789101112131415public class ThrowTest { public static void main(String[] args) { new Student(-100); }}class Student{ private int id; Student(int id){ if(id&gt;0) this.id=id; else throw new RuntimeException(&quot;输入的id非法&quot;); }} 运行结果 12345678910111213141516171819public class ThrowTest { public static void main(String[] args) { try { new Student(-100); } catch (Exception e) { System.out.println(e.getMessage()); } }}class Student{ private int id; Student(int id) throws Exception{ if(id&gt;0) this.id=id; else throw new Exception(&quot;输入的id非法&quot;); }} 运行结果 7.7 用户自定义异常类如何自定义异常类?1.继承于现有的异常结构：RuntimeException, Exception2.提供全局常量序列号: serialVersionUID (类的唯一标识）3.提供重载的构造器 12345678910class MyException extends RuntimeException { static final long serialVersionUID = 123L; public MyException() { } public MyException(String msg) { super(msg); }}","link":"/2020/07/11/Java-java%E5%9F%BA%E7%A1%80/"},{"title":"Java高级","text":"1.多线程1.1 基本概念：程序、进程、线程程序：一段静态的代码进程：正在运行的程序，是资源分配的基本单位。线程：是CPU执行和调度的最小单位，每个线程拥有独立的运行栈和程序计数器pc，线程切换的开销比较小。多个线程共享一个进程的资源（共享进程的方法区和堆，但存在安全隐患）。 在Java的内存区域中，栈区（虚拟机栈）和程序计数器是每个线程一份，方法区和堆区，是每个进程一份，各个线程共享。 使用多线程的优点1.资源利用率提升，程序处理效率提高2.改善程序结构，代码会相对简单3.软件运行速度提升，提升应用程序的响应速度 何时需要多线程1.程序需要同时执行两个或多个任务2.程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等3.需要一些后台运行的程序时 Java程序至少有3个线程1.主线程2.垃圾回收线程3.异常处理线程（会影响主线程） 1.2 线程的创建和使用Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 Thread类的特性1.每个线程都是通过特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run()3.Thread类实现了Runnable接口 start方法作用1.启动当前线程2.调用当前线程的run方法 注意1.不能通过调用run方法来启动线程（仍然在主线程中执行）2.额外再启动一个线程，需要重新创建一个线程的对象 两种创建线程的方法1.继承Thread类，重写run方法2.实现Runnable接口，实现run方法，在Thread构造器中传入一个Runnable接口实现对象 两种创建线程方法的比较开发中，优先选择Runnable接口的方法1.实现的方式没有类单继承性的限制2.实现的方式更适合来处理多个线程共享数据的情况 注意，这里ticket没有加static，就实现了三个线程共享ticket 1234567891011121314151617181920212223242526class Sell implements Runnable { private int ticket = 100; @Override public void run() { while (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖&quot; + ticket + &quot;号票&quot;); ticket--; } }}/* * 死锁的四个必要条件 * 1.互斥访问：共享资源互斥访问 * 2.请求并保持：已经持有资源的情况下，申请别的资源未果，也不释放自己持有的资源 * 3.不可剥夺：进程申请的资源除了完成任务释放，别人无法将其释放 * 4.循环等待：系统中存在资源循环等待的链条*/public class Demo { public static void main(String[] args) { Sell sell = new Sell(); new Thread(sell).start(); new Thread(sell).start(); new Thread(sell).start(); } Thread类常用方法1.void start()：启动当前线程；调用当前线程的run()2.run()：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中3.String getName()4.void setName()5.static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。6.yield()：释放cpu的执行权（有可能紧接着又获取了cpu的执行权）7.h.join()：在线程a中执行h.join()，会阻塞当前线程a，直到h线程执行完，线程a才结束阻塞状态8.stop()：强制线程生命周期结束，deprecated 不推荐使用，因为不安全，过时的api9.static void sleep(long millis)：睡眠(阻塞)若干毫秒；静态方法，可以直接调用。注意：如果是在run方法中使用sleep，则处理sleep的异常只能try-catch，无法throws；因为是重写Thread的run方法，其并无异常抛出，故子类重写也无法抛出异常。10.bool isAlive()：判断当前线程是否存活（是否执行完了），阻塞状态下返回值也是true。 获取线程名称Thread.currentThread().getName(); 更改线程名称1.通过Thread.currentThread().setName();2.通过构造器 123456789class MyThread extends Thread{ public MyThread(String name){ super(name); } public static void main(String[] args) { Thread t1=new MyThread(&quot;一号线程&quot;); }} 使用匿名对象执行开启线程 12345678new Thread(){ private int count=0; @Override public void run(){ while(true) System.out.println(count++); } }.start(); 1.3 线程的调度 Java的调度方法 1.同优先级线程组成先进先出队列（先到先服务），使用时间片策略2.对于高优先级，使用优先调度的抢占式策略 线程的优先级 1.线程的优先级等级：MAX_PRIORITY:10,MIN_PRIORITY:1,NORM_PRIORITY:52.获取和设置当前线程的优先级：getPriority(),setPriority(int p) 注意：并不是优先级高的执行完再执行优先级低的，而是优先级高的获取CPU的概率更高 1.4 线程的分类在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆： 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。下面的方法就是用来设置守护线程的。 1234567Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 1.5 线程的生命周期 1.6 线程的同步线程同步，主要用来解决线程的安全问题。 例：创建三个线程卖票，总共100张1.问题：卖票过程中，出现了重票、错票（0，-1号票）–&gt;出现了线程的安全问题2.问题出现的原因：某线程操作车票时，别的线程也参与进来3.如何解决：某线程操作车票时，即使出现阻塞（例如sleep(100);)，别人也不能参与进来。4.在Java中，我们通过同步机制，来解决线程的安全问题 解决方式 同步代码块a.同步监视器（又叫锁）：任何一个对象都可以作为锁；要求多个线程必须要共用同一把锁。b.同步原理：当一个线程执行代码碰到一个锁时，如果已经有别的线程使用了锁并且没有归还，那么本线程就阻塞在这里。 继承Thread方式 1234567891011121314151617181920212223242526public class p1 { public static void main(String[] args) { Sell s1 = new Sell(); Sell s2 = new Sell(); Sell s3 = new Sell(); s1.start(); s2.start(); s3.start(); }}class Sell extends Thread { public static int ticket = 10000; @Override public void run() { while (true) { synchronized(Sell.class) { if (ticket &gt; 0) { System.out.println(getName() + &quot;出售第&quot; + ticket + &quot;张票&quot;); ticket--; } else break; } } }} 这里的Sell.class充分说明了，在Java中类也是对象 实现Runnable接口方式 1234567891011121314151617181920212223242526public class p2 { public static void main(String[] args) { Sell2 sell=new Sell2(); Thread t1=new Thread(sell); Thread t2=new Thread(sell); Thread t3=new Thread(sell); t1.start(); t2.start(); t3.start(); }}class Sell2 implements Runnable { private int ticket=10000; @Override public void run() { while(true){ synchronized(this){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); else break; } } }} 同步方法如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。 实现Runnable接口方式 1234567891011121314151617181920212223242526272829public class p3 { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; @Override public void run() { while (ticket &gt; 0) { sell(); } } private synchronized void sell() { if (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); } }} 继承Thread方式，注意这里的sell方法必须要加static，否则会出现安全问题（不加static，同步方法所用的锁，不是同一个） 同步方法不加static，使用的是this作为锁。加了static，使用的是类名.class作为锁 1234567891011121314151617181920212223242526public class p4 { public static void main(String[] args) { Window4 w1=new Window4(); Window4 w2=new Window4(); Window4 w3=new Window4(); w1.start(); w2.start(); w3.start(); }}class Window4 extends Thread{ private static int ticket=10000; @Override public void run(){ while(ticket&gt;0) sell(); } private static synchronized void sell(){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); }} 使用同步锁1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t3.setName(&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); if (ticket &gt; 0) System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); else break; } finally { /*保证无论发生什么特殊情况，一定能够释放锁*/ lock.unlock(); } } }} 可重入锁 ReentrantLock 1一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；如果有两个不同的方法用到同一个锁，其中方法A里面又调用了方法B，那就不会死锁了 面试题：synchronized和Lock的区别？synchronized在执行完同步代码以后，自动释放同步监视器Lock方式手动加锁和释放锁，更加灵活。 1.7 改造懒汉单例模式使之线程安全**注意，写了两次判断instance==null**，这样效率最高。只在首次访问的时候进行同步，后续已经有instance的情况下无需同步，直接返回instance，最大化效率。 1234567891011121314151617181920//单例模式之懒汉式class Tool { private static Tool instance = null; //私有化构造方法 private Tool() { } public static Tool getInstance() { if (instance == null) { synchronized (Tool.class) { if (instance == null) instance = new Tool(); } } return instance; }} 1.8 线程的死锁问题死锁：1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续（操作系统中学到的定义：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，这些永远都在互相等待的进程，称为死锁进程） 解决方法1.专门的算法、原则2.尽量减少同步资源的定义3.尽量避免嵌套同步 死锁发生的四个必要条件1.互斥：共享资源互斥访问2.请求并保持：进程请求资源未果，不会释放自身已经占有的资源3.不可剥夺：只有进程自身使用完资源后才会释放，别人无法将其释放4.循环等待：多个进程之间存在资源请求的环路 预防死锁1.破坏请求并保持条件：一次性请求所有需要的资源，否则就不申请2.破坏不可剥夺条件：请求资源未果，释放自身占有的资源3.破坏循环等待条件：可用资源线性排序，只能从低到高申请资源 避免死锁银行家算法：已分配资源表、可用资源表、所需资源表；每次分配给一个能够满足其需求的进程，该进程执行完后返还所有的资源，不断循环。 1在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 预防死锁和避免死锁的区别预防死锁是通过破坏死锁发生的必要条件中的一个，限制条件比较严格，可能造成系统资源利用率和系统吞吐率的下降。避免死锁施加的条件比较宽松，在资源的动态分配中，避免系统出现不安全状态。 1.9 线程的通信例题：使用两个线程打印1~100。线程1，线程2交替打印 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r = new Count(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; @Override public void run() { while (true) { synchronized (this) { notify(); //或者this.notify, 如果用的是某个obj，则obj.notify if (num &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;数&quot; + num--); } else break; try { wait(); /*自我阻塞，wait会自动释放锁（与sleep的区别）*/ } catch (InterruptedException e) { e.printStackTrace(); } } } }} 涉及到的三个方法1.wait()：一旦执行此方法，当前线程就进入阻塞状态， 并释放同步监视器2.notify()：一旦执行此方法。就会唤醒被wait的一个线程。如果有多个，则唤醒优先级最高的3.notifyAll()：唤醒所有wait的线程 说明1.wait(), notify(), notifyAll() 三个方法必须使用在同步代码块或者同步方法中2.三者的调用者必须是同步代码块或同步方法中的同步监视器，否则会报异常，不加调用者默认是this.3.三者是定义在java.lang.Object类中的 上述例题也可以使用公平锁来实现（存在一个等待队列，先进先出）,注意要使用finally来保证unlock的执行 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r=new Count(); Thread t1=new Thread(r); Thread t2=new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; ReentrantLock lock = new ReentrantLock(true);/*fair lock*/ @Override public void run() { while(true){ try{ lock.lock(); if(num&gt;0) System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num--); else break; } finally { lock.unlock(); } } }} 生产者消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Main { public static void main(String[] args) { Clerk clerk = new Clerk(); new Thread(new Consumer(clerk)).start(); new Thread(new Consumer(clerk)).start(); new Thread(new Producer(clerk)).start(); }}class Clerk { private int products = 0; public synchronized void produce() { //notity(); 也可以写这里 if (products &lt; 20) { System.out.println(&quot;生产者生产第&quot; + (++products) + &quot;个商品&quot;); this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void consume() { if (products &gt; 0) { System.out.println(&quot;消费者消费第&quot; + products-- + &quot;个商品&quot;); if (products &lt; 20) this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produce(); } }}class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consume(); } }} 这里有个疑问：如果把sleep写在两个同步方法中，while中只有调用，则会出现每次生产者生产满20个消费者才去消费，每次消费者消费完了生产者才开始生产。即每轮while循环结束同步方法都不释放锁。（在while中随意加入一个语句如print，则此现象消失，正常交替执行） 1.10 JDK5.0新增线程创建方式新增方式一：实现Callable接口与Runnable相比，Callable功能更强大1.相比run()方法，可以有返回值2.方法可以抛出异常（重写Runnable中的run不能抛出异常，因为Runnable接口中的run没有抛 ）3.支持泛型的返回值4.需要借助FutureTask类，比如获取返回值 123456789101112131415161718192021222324252627282930import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask futureTask = new FutureTask(count); new Thread(futureTask).start(); Object ans = null; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 使用泛型 12345678910111213141516171819202122232425public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(count); new Thread(futureTask).start(); int ans = 0; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable&lt;Integer&gt; { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 新增方式二：使用线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中的线程，不需要每次都创建）3.便于线程管理：corePoolSize核心池的大小maximumPoolSize最大线程数keepAliveTime 线程没有任务时最多保持多长时间后会终止 线程池相关API1.JDK5.0起提供了线程池相关API：ExecutorService和Executors2.ExecutorService 真正的线程池接口.常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令,没有返回值,一般用来执行Runnable &lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):执行任务,有返回值,一般用来执行Callable void shutdown():关闭连接池 3.Executors:工具类、线程池的工厂类,用于创建并返回不同类型的线程池 Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n):创建一个线程池,它可以安排在给定延迟后运行命令或者定期地执行 1234567891011121314151617181920212223242526272829303132333435363738public class Main { public static void main(String[] args) { /*Executors是线程池的工厂类*/ ExecutorService server= Executors.newFixedThreadPool(10); server.execute(new Count()); server.submit(new Calculate()); /*或者使用FutureTask包装Calculate()以获取线程返回值*/ FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Calculate()); server.submit(task); try { System.out.println(task.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }}class Count implements Runnable{ @Override public void run() { int i=0; while(i++&lt;100) System.out.print(i+&quot; &quot;); }}class Calculate implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;100;i++) sum+=i; return sum; }} 练习题 谈谈你对程序、进程、线程的理解 程序：一段静态代码进程：关于进程我想谈两点，一个是为什么需要进程这个概念，另一个是进程的作用。首先，现代操作系统的一大特点就是多道程序设计，那么在此之前是单道程序设计，一个程序运行时占有所有的资源，那么就无需资源的分配和调度，也就无需进程这个概念。到了多道程序设计中，多个程序并发执行，这就涉及到了系统资源的分配和调度，诸如CPU资源、存储资源、IO资源、文件资源，那么进程这个概念就应运而生。因此进程的作用有两大点，第一，它是资源分配和调度的基本单位。第二，它是程序独立运行的载体，保障程序正常执行。线程：线程是CPU调度的基本单位，多个线程之间共享进程的资源；线程包含在进程之中，是进程中实际运行工作的单位。 操作系统四大特性：虚拟、异步、共享、并发。2. 对比两种线程的创建方式3. sleep和wait方法的异同？相同点：都能使当前线程阻塞不同点：1.sleep声明在Thread类中，wait声明在Object类中 2.sleep()可以在任何地方使用，wait()需要在同步方法或者同步代码块中调用 3.如果都使用在同步代码块或者同步方法中，sleep方法不会释放锁，wait会释放锁 2.常用类2.1 字符串相关的类String类String特性1.String类:代表字符串.Java程序中,所有字符串的字面值(如”abc”)都是String类的实例2.String是一个final类,不可以继承3.字符串是常量,值在创建之后不可改变,字符内容是存储在一个字符数组value[]中的4.通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中5.字符串常量池(位于方法区中,后来改叫meta space)中是不会存储相同内容的字符串的String对象的创建1.字面量的方式,String str=&quot;abc&quot;;2.String s=new String()3.String s=new String(String s2)4.String s=new String(char[] arr)5.String s=new String(char[] arr,int startIndex, int count) 字符串常量池存储在字符串常量池,目的是共享; 字符串非常量的对象存储在堆中 面试题1:下面的p1.name==p2.name? 123456789101112131415public class Main { public static void main(String[] args) { Person p1 = new Person(&quot;yfx&quot;); Person p2 = new Person(&quot;yfx&quot;); System.out.println(p1.name == p2.name); //true 地址相同 }}class Person { String name; Person(String name) { this.name = name; }} 面试题2:String s=new String(&quot;abc&quot;); 在内存中创建了几个对象? 答:如果常量池中没有abc,则创建了两个,有的话则创建一个(现在常量池创建”abc”,然后在堆中创建一个String对象,内容fianl char[]value指向常量池的”abc”) 面试题3:下面几种字符串连接后,在内存中实际是怎么样的? 123456789101112131415161718192021public static void main(String[] args) { String s1 = &quot;java&quot;, s2 = &quot;docker&quot;; String s3=&quot;javadocker&quot;; String s4=&quot;java&quot;+&quot;docker&quot;; //编译阶段会直接合成&quot;javadocker&quot; String s5=s1+&quot;docker&quot;; String s6=&quot;java&quot;+s2; System.out.println(s3==s4); //true System.out.println(s3==s5); //false System.out.println(s3==s6); //false System.out.println(s5==s6); //false String s7=s5.intern(); //intern():如果常量池中没有s5的字符串值,那么就在常量池中创建该字符串常量,并返回其引用;如果常量池中已经有,则直接返回引用 System.out.println(s3==s7); //true final String s8=&quot;java&quot;; //final修饰的变成常量 String s9=s8+&quot;docker&quot;; System.out.println(s3==s9); //true} 涉及到对象的连接,则都在堆中产生新的String对象; 面试题4:java的值传递 123456789101112131415161718public class Main { String str = new String(&quot;good&quot;); char[] ch = {'t', 'e', 's', 't'}; public void change(String str, char ch[]) { str = &quot;test ok&quot;; //将常量池中&quot;test ok&quot;的地址赋值给str ch[0] = 'b'; } @Test public void test() { Main obj = new Main(); obj.change(obj.str, obj.ch); System.out.println(obj.str); //good System.out.println(obj.ch); //best }} String类常用方法1.int length()2.char charAt(int index)3.boolean isEmpty()4.String toLowerCase()5.String toUpperCase()6.String trim():返回字符串的副本,忽略前导空白和尾部空白7.boolean equalsIgnoreCase(String s)8.String concat(String str):将指定字符串连接到此字符串的结尾,等价于+9.int compareTo(String s):比较两个字符串字典序10.String substring(int beginIndex):11.String substring(int beginIndex, int endIndex):按照下标截取字符串,左闭右开12.boolean endsWith(String suffix):是否以指定的后缀结束13.boolean startsWith(String prefix):是否以指定的前缀开始14.boolean startsWith(String prefix,int offset):测试此字符串从指定索引开始的子串是否以指定前缀开始 15.boolean contains(CharSequence s):当且仅当此字符串包含指定的char值序列时,返回true16.int indexOf(String str):返回子串第一次出现的索引,未找到返回-117.int indexOf(String s,int fromIndex):返回子串从偏移下标开始首次出现的索引18.int lastIndexOf(String s):反向搜索19.int lastIndexOf(String s,int fromIndex),从指定偏移量开始反向搜索 20.String replace(char oldChar,char newChar):替换所有指定字符21.String replace(CharSequence target, CharSequence replacement):替换所有指定子串22.String replaceAll(String regex, String replacement):使用给定的子串替换所有匹配正则表达式的子串23.String replaceFirst(String regex, String replacement): 24.boolean matches(String regex):告知此字符串是否匹配给定的正则表达式 25.String[] split(String regex):根据给定正则表达式的匹配拆分此字符串26.String[] split(String regex, int limit):根据给定正则表达式来拆分此字符串,最多不超过limit个,如果超过了,剩下的全部放到最后一个元素中 String与基本数据类型转换1.String转基本数据类型、包装类: 调用包装类的静态方法:parseXXX(str)2.基本数据类型、包装类转Stirng:String.valueOf(xxx)3.String转char[]:str.toCharArray()4.char[]转String:new String(char[] arr)5.String转byte[]:str.getBytes()6.byte[]转String:new String(bytes[] arr) 重载函数new String(bytes[]arr,字符集) 123456789101112131415161718public class Main { public static void main(String[] args) throws UnsupportedEncodingException { String s=&quot;abc123中国&quot;; byte[] bytes = s.getBytes();//使用默认的字符集 System.out.println(Arrays.toString(bytes)); //[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67] utf-8编码一个汉字3个字节 byte[] gbks = s.getBytes(&quot;gbk&quot;); System.out.println(Arrays.toString(gbks)); //[97, 98, 99, 49, 50, 51, -42, -48, -71, -6] gbk编码一个汉字2个字节 System.out.println(new String(bytes)); //abc123中国 System.out.println(new String(gbks)); //abc123�й� 字符集指定错误,出现乱码 System.out.println(new String(gbks,&quot;gbk&quot;)); //abc123中国 }} StringBuffer,StringBuilderString:1.不可变字符序列 StringBuffer:1.可变字符序列2.线程安全,效率低 (除了构造方法,所有方法都加了synchronized) StringBuilder:1.可变字符序列2.线程不安全,效率高 三者底层都是用char[]存储 StringBuffer和StringBuilder的扩容默认情况下,扩容为原来的2倍+2,同时将原有数组中的元素复制到新的数组中指导意义: 如果需要对字符串进行频繁的添加, 建议使用此构造器StringBuffer(int capacity) 或 StringBuilder(int capacity),提前指定容量,以免频繁扩容,降低效率 三者效率对比 123456789101112131415161718192021@Testpublic void testTimeConsume() { String s = &quot;&quot;; StringBuffer buffer = new StringBuffer(); StringBuilder builder = new StringBuilder(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) { buffer.append(i); } System.out.println(&quot;StringBuffer use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { builder.append(i); } System.out.println(&quot;StringBuilder use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { s += i; } System.out.println(&quot;String use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;);} 2.2 JDK8之前的时间APISystem静态方法System.currentTimeMillis(): 返回1970年1月1日0点到现在经历了多少毫秒,返回值是long类型 Date类有两个Date类java.util.Date和java.sql.Date(继承前边的类) java.util.Date1.构造器一:Date() 创建了一个对应当前时间的Date对象 2.构造器二Date(long time) 创建指定毫秒数的Date类 java.sql.Date对应着数据库中的日期 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Date date=new Date(); System.out.println(date); //Wed Aug 25 10:49:42 CST 2021 System.out.println(date.getTime()); //1629859782884 Date date2=new Date(1629859782884L); System.out.println(date2); //Wed Aug 25 10:49:42 CST 2021 Date date3=new java.sql.Date(2131243242334L); System.out.println(date3); //2037-07-15 /*java.util.Date转换为java.sql.Date*/ //情形一 多态,对象本身就是sql下的Date Date date4=new java.sql.Date(2315432424345L); java.sql.Date date5= (java.sql.Date) date4; //情形二 对象本身就是util下的Date,无法直接强制转换.但是他们拥有一个共同的东西,就是毫秒数 Date date6=new Date(); java.sql.Date date7=new java.sql.Date(date6.getTime()); }} Calendar类Calendar是一个抽象基类,主要用于完成日期字段之间相互操作的功能 获取Calendar实例的方法1.使用Calendar.getInstance()方法 (抽象类无法实例化,这里返回的是子类GregorianCalendar的对象,多态,用Calendar接收)2.调用它的子类GregorianCalendar的构造器 一个Canlendar的实例是系统时间的抽象表示,通过get(int field)方法来取得想要的时间信息.比如YEAR, MONTH, DAY_OF_WEEK, HOUR_OF_DAY,MINUTE, SECOND1.public void set(int field, int value)2.public void add(int field, int amount)3.public final Date getTime()4.public final void setTime(Date date) 注意1.获取月份时:一月是0, 二月是1, 以此类推, 12月是112.获取星期时,周日是1,周二是2,…,周六是7 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); //多态 System.out.println(calendar.getClass()); //java.util.GregorianCalendar //get() System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //add() calendar.add(Calendar.DAY_OF_MONTH, -10); //往前倒10个月 //getTime() Date date=calendar.getTime(); //setTime() calendar.setTime(date); //用date来设置calendar calendar.setTimeInMillis(23214325798L); //用毫秒数设置calendar }} SimpleDateFormat类用于对Date类的格式化和解析 Date类的API不易于国际化,大部分都被废弃了,java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化: 日期-&gt;文本, 解析: 文本-&gt;日期 1.格式化SimpleDateFormat(): 默认的模式和语言环境创建对象public SimpleDateFormat(String pattern) 该构造方法可以用参数pattern指定的格式创建一个对象,该对象调用public String format(Date date): 方法格式化时间对象date 2.解析public Date parse(String source): 从给定字符串的开始解析文本,以生成一个日期 1234567891011public class Main { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); /*格式化:date转String*/ String format = sdf.format(new Date()); System.out.println(format); //2021-08-25 04:00:54 /*解析*:String转Date*/ Date date = sdf.parse(&quot;2021-08-25 16:30:20&quot;); System.out.println(date); //Wed Aug 25 16:30:20 CST 2021 }} 如果用SimpleDateFormat类解析字符串成java.sql.Date,就先解析为java.util.Date,在用毫秒数转换为java.util.Date 例题1990-01-01开始,三天打鱼两天晒网,请问给定日期在做什么事情?答:用SimpleDateFomart类解析两个日期,算出毫秒值之差,然后向上整除1000*3600*24(这里用向上除法$(m+n-1)/n$), 然后结果+1(代表一共有多少天), 然后对5取模. 0~2在打渔,3~4在晒网 2.3 JDK8中新日期的APIJDK1.0包含了一个java.util.Date类,但是它的大多数方法已经在JDK1.1引入Calendar类后被弃用了.而Calendar类并不比Date号多少.它们面临的问题是:1.可变性:像日期和事件这样的类,应该是不可变得2.偏移性:Date中的年份是从1900开始的,而月份是从0开始的3.格式化:格式化只对Date有用,Calendar则不行此外,它们也不是线程安全的; 不能处理润秒等 总结:对日期和时间的操作一直是Java程序员最痛苦的地方之一 第三次引入的API是成功的,并且Java8中引入的java.timeAPI已经纠正了过去的缺陷,将在很长一段时间内它都会为我们服务 LocalDate,LocalTime,LocalDateTime其中LocalDateTime最常用 1.now(): 当前的日期、时间2.of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便3.getXxx(): 获取某项时间信息4.with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象5.plus()/minus(): 增减日期 1234567891011121314151617181920212223242526272829303132333435public void test(){ /*now(): 当前的日期、时间*/ LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); //LocalDateTime用的最频繁 System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); /*of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便*/ LocalDateTime time1 = LocalDateTime.of(2021, 8, 25, 20, 34); System.out.println(time1); /*getXxx()*/ System.out.println(localDateTime.getYear()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getDayOfYear()); System.out.println(localDateTime.getMinute()); /*with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象*/ LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(1); //不修改原来的日期,重新返回一个修改后的日期 System.out.println(localDateTime1); System.out.println(localDateTime1); LocalDateTime localDateTime2 = localDateTime1.withHour(4); System.out.println(localDateTime2); /*plus()/minus(): 增减日期*/ LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusYears(2); System.out.println(localDateTime4);} Instant类似于java.util.Date类 方法 描述 now() 静态方法,返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳 1234567891011121314151617public void test2(){ /*now(): 获取本初子午线对应的时间标准*/ Instant time1 = Instant.now();//默认是 本初子午线 的时区 /*atOffset()结合即时的偏移来创建一个OffsetDateTime量*/ OffsetDateTime time2 = time1.atOffset(ZoneOffset.ofHours(8));//改成东八区 System.out.println(time1); System.out.println(time2); /*toEpochSecond():返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳*/ long l = time2.toEpochSecond(); System.out.println(l); /*ofEpochMilli()静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象*/ Instant instant = Instant.ofEpochMilli(1532324124325L); System.out.println(instant);} DateTimeFormatter1.方式一:预定义的标准格式2.本地化相关的格式 3.自定义的格式(一般都用这个) 12345678910public void test3(){ //自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format = formatter.format(LocalDateTime.now()); System.out.println(format); //解析 TemporalAccessor parse = formatter.parse(&quot;2021-08-25 09:34:46&quot;); //LocalDateTime,LocalDate,LocalTime都实现了TemporalAccessor接口 System.out.println(parse);} 其他类 2.4 Java比较器Comparable接口Comparator接口2.5 System类2.6 Math类2.7 BigInteger和BigDecimal类3.枚举类 &amp; 注解4.Java集合5.泛型6.IO流7.网络编程8.反射9.Java8新特性10.Java9 &amp; 10 &amp; 11 新特性","link":"/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"},{"title":"操作系统知识巩固","text":"概述 操作系统基本功能 统一管理所有计算机资源 处理器资源 存储资源 IO资源 文件资源 实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统四大特性 并发 并行：多个事件同一时刻发生 并发： 多个事件同一时间间隔内交替发生（多道程序交替执行） 共享 共享性：操作系统中的资源可以供多个并发的程序共同使用 分类： 互斥共享 同时共享 虚拟 虚拟性：把一个物理实体转变为若干个逻辑实体 虚拟技术又分为：时分复用和空分复用。 时分复用技术：资源在时间上进行复用，不同程序并发使用；多道程序分时使用计算机硬件资源 虚拟处理器技术 借助多道程序设计技术，为每个程序建立进程，多个程序（进程）分时复用处理器 虚拟设备技术 物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问 空分复用技术：用来实现虚拟磁盘、虚拟内存等，提高资源的利用率，提升编程效率。 虚拟磁盘技术 物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 异步 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）进程管理 为什么需要进程 没有配置OS之前，资源属于当前运行的程序（单道程序设计） 配置OS之后，引入多道程序设计的概念 合理地隔离资源、运行环境，提升资源利用率 进程的作用 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体，保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升1234面试官：请你谈一谈你对进程的认识。答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。 进程的实体 主存中的进程形态： 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据） IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器事件、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。 进程控制块(PCB)中记录的数据，可以分为四类 进程标识符 处理机状态 进程调度信息 进程控制信息进程与线程一个进程(Process)可以有一个或多个线程(Thread) 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位 线程包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程资源 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 开销大 开销小 通信 进程IPC 读写同一进程数据通信 五状态模型进程的五状态模型包括：创建，就绪，执行，阻塞，中止 就绪状态 定义：其他资源都准备好，只差CPU资源的状态称为就绪状态 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行 多个处于就绪状态的进程通常排列成一个队列，称为就绪队列 执行状态 定义：进程获得CPU，其程序正在执行，称为执行状态 在单处理机中，在某个时刻只能有一个进程是处于执行状态 阻塞状态 定义：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 阻塞进程会组成一个队列，称为阻塞队列 创建状态 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态 操作系统提供fork函数接口创建进程 终止状态 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态 ## 进程同步 为什么需要进程间同步 需要进行进程同步的两个经典问题生产者消费者问题 哲学家就餐问题 上述两个模型发生问题的根源：彼此之间没有通信 进程之间同步所解决的问题 1.对竞争资源在多进程之间进行次序的协调 2.使得并发执行的多个进程之间可以有效使用资源和相互合作 临界资源指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。 进程间同步的原则 1.空闲让进：资源无占用，允许使用2.忙着等待：资源有占用，请求进程等待3.有限等待：保证有限等待时间能够使用资源3.让权等待：等待时，进程需要让出CPU 线程与线程的同步方法 进程同步方法 1.消息队列 2.共享存储 3.信号量 线程同步方法 1.互斥量 2.读写锁 3.自旋锁 4.条件变量 Linux的进程管理Linux进程的相关概念 进程的类型： 前台进程： 1.前台进程就是具有中断，可以与用户交互的进程 后台进程： 1.与前台进程相对，没有占用终端的就是后台进程； 2.后台程序基本上不和用户交互，优先级比前台进程低 3.将需要执行的命令以&amp;符号结束 守护进程： 1.守护(daemon)进程是特殊的后台进程； 2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭； 3.linux有很多典型的守护进程； 4.进程名字以d结尾的一般都是守护进程，如crond,sshd,httpd,mysqld 操作系统提供fork函数接口创建进程 进程的标记 进程ID 1.唯一性 2.负整数，最大值由操作系统限定 3.ID为0的进程为idle进程，是系统创建的第一个进程 4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 5.Init进程是所有用户进程的祖先进程 状态符号 ### 操作Linux进程的相关命令 ps命令 1.ps是process status的缩写2.可以添加-ef或者-aux展示详细进程详细信息3.搜索某个进程的详细信息ps -ef | grep python34.查询进程树ps -ef --forest5.查询某个用户的进程ps -u yfx6.按照cpu的使用频率进行排序ps -aux --sort=-pcpu7.按照内存使用的状况进行排序ps - aux --sort=-pmem top命令 1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态 kill命令 1.kill -9 进程号 无条件终止进程 作业管理作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。 进程调度进程调度概述 进程调度：计算机通过决策决定哪个就绪进程可以获得CPU的使用权（多道程序设计） 进程调度的步骤 1.保留旧进程的运行信息，请出旧进程2.选择新进程，准备运行环境并分配cpu 新老进程的上下文切换机制进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 ### 进程调度算法 两种调度的方式 1.非抢占式的调度2.抢占式的调度 进程调度算法 1.先来先服务2.短进程优先3.高优先权优先4.时间片轮转 死锁死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。 死锁的产生 死锁产生的原因 1.竞争资源2.进程调度顺序不当 死锁的四个必要条件（如果出现死锁，必然存在下边四个条件） 互斥条件资源同一时间只能允许一个进程访问 请求保持条件进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源 不可剥夺条件只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。 循环等待条件多个进程之间存在资源请求的环路死锁的处理 预防死锁 破坏请求保持条件 1.进程运行之前，一次性申请所有需要的资源 2.并且在运行期间不会提出新的资源请求 破坏不可剥夺条件 1.当一个进程请求新的资源得不到满足时，必须释放占有的资源 2.进程运行时占用的资源可以被释放 破坏环路等待条件 1.可用资源线性排序，申请必须按照需要递增申请 假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。 但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。 避免死锁 避免死锁和预防死锁的区别二者都是通过施加某些限制条件，来预防死锁发生。 差别： 1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个） 2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态） 银行家算法 是一个可操作的著名的避免死锁的算法 以银行借贷系统分配策略为基础的算法 存储管理内存分配单一连续分配只能在单用户、单进程的操作系统中使用 固定分区分配1.内存空间被划分为若干固定大小的区域2.每个分区只提供给一个程序使用，互不干扰 动态内存分配根据进程实际需要，动态分配内存空间 动态分区空闲表数据结构 动态分区空闲链数据结构 内存分配过程 首次适应算法（First Fit)： 算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件缺点：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。(2)每次都是从低址部分查找，使得查找空闲分区的开销增大2. 循环首次适应算法(Next Fit) ：算法思想：配内存时不是从链首进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；优点：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存3. 最佳适应算法（Best Fist）算法思想：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的缺点：产生大量难以利用的外部碎片。4. 快速适应算法（Quick Fit）算法思想：快速适应算法要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区 内存回收一共有四中情况，如下图1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去 页式存储管理管理方式1.将进程逻辑空间等分为若干大小的页面2.相应地把物理内存空间分成与页面大小相同的物理块3.以页面为单位把进程空间装进物理内存中分散的物理块 页面大小1.过大难以分配，过小内存碎片过多2.通常是512B~8K 页表1.页表记录进程逻辑空间与物理空间的映射2.某个页表项的地址=页表起始地址+页表项大小x页号3.实际物理地址=字块大小x字块号+块内偏移地址 多级页表页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。 缺陷有一段连续的逻辑分布在多个页面中，将大大降低执行效率 段式存储管理管理方式1.将进程逻辑空间划分成若干段（非等分）2.段的长度由连续逻辑的长度决定3.主函数MAIN，子程序段X，子函数Y等 段式和页式对比1.二者都离散地管理了进程的逻辑空间2.页是物理单位，段式逻辑单位3.分页是为了合理利用空间，分段是满足用户要求4.页大小由硬件固定，段长度可动态变化5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度） 段页式存储管理为何需要段页式存储管理1.分页可以有效提高内存利用率2.分段可以更好地满足用户需求3.二者结合，形成段页式存储管理 如何管理1.先将逻辑空间按按段式管理分成若干段2.再把段内空间按页式管理分成若干页 虚拟内存问题一个游戏十几G，物理内存只有8G，游戏如何运行起来的？ 虚拟内存概述有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。程序局部性原理指CPU访问存储器，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。 虚拟内存的置换算法1.先进先出算法FIFO2.最不经常使用算法LFU3.最近最少使用算法LRU 与高速缓存的替换区别1.替换策略发生在Cache-主存层次、主存-辅存层次2.Cache-主存层次的替换策略主要是为了解决速度问题3.主存-辅存层次主要是为了解决容量问题 Linux存储管理Buddy内存管理算法概述1.Buddy算法（伙伴算法）是经典的内存管理算法2.基于计算机处理二进制的优势，效率极高3.主要是为了解决内存外碎片的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB） Buddy管理算法的目的努力让内存分配与相邻内存合并能够快速进行 内存分配原则向上取整为2的幂大小（外碎片转化为内碎片）(1)申请70k -&gt; 分配128k(2)申请129k -&gt; 分配256k(3)申请666k -&gt; 分配1024k 伙伴系统伙伴指的是内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存 内存分配过程1.创建一系列空闲块链表，每一种都是2的幂大小2.假设存储空间有1M大小3.分配100k内存(1)100k向上取2的幂=128k(2)查询是否有128k的空闲内存块？(3)没有！查询是否有256k空闲内存块？(4)没有！查询是否有512k空闲内存块？(5)没有！查询是否有1M空闲块内存？(6)有，摘下1M空闲内存块，分配出去(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去(8)拆下256K放在空闲链上，其余分配出去(9)拆下128K放在空闲链上，其余分配出去(10)分配完毕 4.回收内存过程(1)判断刚才分配的内存伙伴在空闲链表上吗？(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴…?(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴…?(4)在！移出伙伴，合并为1M空闲内存(5)插入1M空闲链表，回收完成 Linux交换空间概述1.交换空间（Swap）是磁盘的一个分区2.Linux物理内存满时，会把一些内存交换到Swap空间 作用1.冷启动内存依赖许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。2.系统睡眠依赖Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。3.大进程空间依赖有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。 Swap空间和虚拟内存的对比Swap空间(1)存在于磁盘(2)与主存发生置换(3)是操作系统概念(4)解决系统物理内存不足问题 虚拟内存(1)存在于磁盘(2)与主存发生置换(3)是进程概念(4)解决进程物理内存不足问题 文件管理文件的逻辑结构 逻辑结构的文件类型有结构文件1.文件内容由定长记录和可变长记录组成2.定长记录存储文件格式、文件描述等结构化数据项3.可变长记录存储文件的具体内容 无结构文件也成为流式文件，文件内容长度以字节为单位。如exe文件、dll文件、so文件 linux静态链接库文件.a 动态链接库文件.sowindows静态链接库文件.lib 动态链接库文件.dll 顺序文件1.顺序文件是指按照顺序存放在存储介质中的文件2.磁带的存储特性使得磁带文件只能存储顺序文件3.顺序文件是所有逻辑文件当中存储效率最高的4.顺序文件的增删查改是比较困难的 索引文件1.可变长的文件不适合用顺序文件格式存储2.索引文件是为了解决可变长文件存储而发明的一种文件格式3.索引文件需要配合索引表完成存储 辅存的存储空间分配 连续分配 1.顺序读取文件非常容易，速度很快 2.对存储要求高，要求满足容量的连续存储空间 链接分配1.链接分配可以将文件存储在离散的盘块中2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中-&gt;隐式链接，记录在FAT中-&gt;显示分配） 隐式链接分配显式链接分配缺点：1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块） 索引分配1.每个文件拥有一个索引块，记录所有盘块信息2.索引分配方式支持直接访问盘块3.文件较大时，索引分配方式具有明显优势4.现在主流文件系统都是使用索引分配 (空闲块)存储空间管理三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。 空闲表 空闲链表1.把所有空闲盘区组成一个空闲链表2.每个链表节点存储空闲盘块和空闲的数目 位示图1.位示图维护成本低2.非常容易找到空闲盘块3.使用0/1比特，占用空间小 目录管理任何文件或目录都只有唯一路径 Linux文件的基本操作Linux目录|目录|描述 ||–|–||/bin |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里 ||/etc |存放系统管理和配置文件 ||/home |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user ||/usr |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：unix software resources ||/opt |额外安装的可选应用程序宝所放置的位置 ||/proc |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息 ||root |超级用户（系统管理员）的主目录 ||/sbin |存放二进制可执行文件，只有root才能访问 ||/dev |用于存放设备文件 ||/mnt |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。 ||/boot |存放用于系统引导时使用的各种文件 ||/lib |存放文件系统中的程序运行所需要的共享库及内核模块 ||/var |用于存放运行时需要改变数据的文件 | Linux文件常用操作 命令 操作 touch 创建文件 mkdir 创建文件夹 rm 删除文件 cat 查看文件 gedit 使用gedit编辑文件 Linux文件类型 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信 使用ls -al命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型 Linux文件系统设备管理","link":"/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%B7%A9%E5%9B%BA/"},{"title":"Java入门","text":"第一章 IDEA基本配置和快捷键IDEA快捷键 快捷键 功能 shift+F6 选中目标内容后，更改所有用到它的内容 ctrl+Y 删除当前行 ctrl+D 复制当前行 Alt+Enter 导入包自动修正代码 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消 ctrl+shift+/ 选中代码注释，再按取消 Alt+Ins 自动生成代码：如toString,set,get等方法 Alt+Shift+上下箭头 移动当前行 Shift+F6 更改类文件名称 ctrl+alt+t 包括代码块，添加try-catch等信息 ## 操作技巧 5.fori 可以快速输入循环体 for(int i=0;i&lt;5;i++) arryA.fori可以快速输入循环体for(int i=0;i&lt;arr.length;i++) Alt+Enter 快速为对象.方法 创建一个接收者 IDEA注释最好看的颜色#088D52 第二章 JAVA基本知识基础知识 所有的引用类型都可以赋值为null，代表其中什么都没有 获取数组长度 数组名称.length方法使用方法的注意事项 1.方法应该定义在类中，不能在方法中定义方法 2.方法定义的前后顺序无所谓方法重载 1.要求具有不同的参数列表（参数个数不同，参数数据类型不同，参数的数据类型排列顺序不同，满足其一即可） 修饰符如public,static等无关数组数组的初始化 动态初始化（指定长度） 1234int[]arr=new int[10];//或者拆分成两个步骤int[]arr;arr=new int[10]; 静态初始化（指定内容） 1234int[]arr=new int[]{1,2,3};//或者分为两步int[]arr;arr=new int[]{1,2,3}; 数组省略格式(无法拆分成两个步骤） 1int[]arr={1,2,3}; 数组的访问 使用动态初始化时，其中的元素会自动拥有一个默认值，规则如下: 如果是整数类型，默认为0 如果是浮点类型，默认为0.0 如果是字符类型，默认为’\\u0000’ （是一个不可见字符） 如果是布尔类型，默认为false 如果是引用类型，那么默认为null(空常量）利用数组实现多个返回值 JAVA内存 java的内存需要划分为5个部分： 栈(Stack):存放的都是方法中的局部变量，方法的运行一定要在栈中 局部变量：方法的参数，或者是方法内部的变量 作用域：一旦超出作用域，立刻从栈内存当中消失 堆(Heap):凡是new出来的东西，都在堆当中 堆内存里面的东西都有一个地址值：16进制 堆内存里面的数据，都有默认值，规则在上 面。 方法区(Method Area):存储.class(.java编译之后用来运行的字节码文件)是相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register):与CPU相关数组在内存中的存储 内存中的两个不同数组 两个引用指向同一个数组对象在内存中的存储 当一个对象作为参数传递到方法中时，实际上传递进去的是地址值 当一个对象类型作为方法的返回值时，返回值其实就是对象的地址值 一个对象在内存中的存储 两个引用指向同一个对象final关键字概念和四种用法 常见四种用法：1.修饰一个类 2.修饰一个方法3.修饰一个局部变量4.修饰一个成员变量 注意事项：对于类和方法来说，abstract和final不能同时使用，因为矛盾 final修饰一个类时public final class...含义：当前类不能有任何子类 final修饰一个方法时修饰符 final 返回值类型‘含义：该方法不能被覆盖重写 final修饰变量，一次赋值，终身不变含义：1.对于基本数据类型来说，不可改变的是数值 2.对于引用数据类型来说，不可改变的是地址值 final修饰成员变量，这个变量也是不可变的 1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值2.对于final成员变量，要么直接赋值，要么通过构造方法赋值（必须保证所有重载的构造都对final成员变量赋值） 四种权限修饰符public &gt; protected &gt; (default) &gt; private 同一个类中 同一个包中 不同包子类（父子关系） 不同包非子类（无关系） public protected (default) private 同一个类 √ √ √ √ 同一个包 √ √ √ × 不同包子类 √ √ × × 不同包非子类 √ × × × ## 内部类 分类：1.成员内部类 2.局部内部类（包含匿名内部类） ### 成员内部类 格式：直接定义在类体内就行 注意：内用外，随意访问；外用内，需要内部类对象 如何使用内部类？有两种方式： 1.间接方式：在外部类的方法中使用内部类，然后main方法中调用外部类的方法 2.直接方法，公式：外部类名称.内部类名称 对象名=new 外部类名称().new 内部类名称(); 内部类的同名变量访问1234567891011public class Outer { int num=10; public class Inner{ int num=20; public void method(){ int num=30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); } } 局部内部类如果一个类是定义在方法内部的，那么这就是一个局部内部类 *局部的含义**：只有当前的方法能使用它，出了这个方法就不能使用格式:123456修饰符 class 外部类名称{ 修饰符 返回值 外部类方法名称(参数列表){ class 局部内部类名称{ ... }} 局部内部类使用方法在成员方法中new局部内部类对象，然后调用成员方法即可 小结：类的权限修饰符1.外部类：public / (default)2.成员内部类:public / protected / (default) / private3.局部内部类：什么都不能写 局部内部类的final问题局部内部类中，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的.备注：从JAVA8+开始，只要局部变量事实不变，那么final关键字可以省略原因：1.new出来的对象是在堆当中的2.局部变量是跟着方法走的，在栈内存中3.方法运行结束后，立刻出栈，局部变量就会立刻消失4.但是new出来的对象会一直存在于栈内存中，直到垃圾回收消失。因此该对象会copy一份使用到的变量，方法消失后保证数据依旧存在。故该方法的局部变量不能改变。 匿名内部类（重点）如果接口的实现类（或父类的子类）只需要使用唯一的一次，那么就可以省略掉该类的定义，而改为使用匿名内部类匿名内部类的使用格式：其中，obj是匿名内部类的对象，匿名内部类省略了繁琐地完整创建一个.class文件 1234567891011public class Temp { public static void main(String[] args) { MyInterface obj=new MyInterface() { @Override public void method() { System.out.println(&quot;使用了匿名内部类！&quot;); } }; obj.method(); }} 使用匿名内部类的注意事项对格式*new 接口名称(){…}*进行解析 1.new代表创建对象的动作2.接口名称就是匿名内部类需要实现的接口3.*{…}*这才是匿名内部类的内容 还需注意 1.匿名内部类，在创建对象时，只能使用一次（但不是匿名对象，创建出来的对象可以一直使用）2.匿名内部类和匿名对象不是一回事3.匿名内部类和匿名对象同时使用 123456789public static void main(String[] args) { new MyInterface(){ @Override public void method() { System.out.println(&quot;使用了匿名内部类和匿名对象&quot;); } }.method(); } 第三章 面向对象程序设计 面向对象技术三大特性：继承性、封装性、多态性基础知识 成员变量是直接定义在类中的，在方法体外边 成员方法不要写static关键词 通常情况下，需要根据类创建一个对象才能使用 使用一个类的步骤 导包 import 包名称.类名称; import cn.hhu.day06.demo01.Student; 若位于同一包下无需导入 创建 Student stu=new Student(); 使用 如果成员变量没有赋值，那么将会有一个默认值，规则和数组一样 成员变量和局部变量的区别 定义的位置不同 局部变量：在方法的内部 成员变量：在方法的外部，直接写在类当中 作用域不同 局部变量：只有方法当中才可以使用 成员变量：整个类全都可以用 默认值不同 局部变量：没有默认值，必须手动赋值 成员变量：有默认值，规则和数组相同 内存的位置不同（了解） 局部变量：位于栈内存 成员变量：位于堆内存（new出来的都放在堆里，赋初值） 生命周期不同 局部变量：随着方法进栈诞生，随着方法出栈消失 成员变量：随着对象创建诞生，随着对象被垃圾回收而消失 匿名对象的说明匿名对象就是只有右边的对象，没有左边的名字和赋值运算符 12new Person().name=&quot;赵丽颖&quot;; //只能使用这一次 抽象 抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束 抽象类：抽象方法所在的类必须是抽象类。在class之间写上abstract即可 如何使用抽象类和抽象方法 不能直接new抽象类对象，必须用一个子类继承抽象父类 子类必须覆盖重写（也叫实现）父类中的所有抽象方法 注意事项 抽象类中，可以有构造方法，供子类创建对象时，初始化父类成员时使用 抽象类中不一定包含抽象方法，但是包含抽象方法的必须是抽象类 除非子类也是抽象类，否则必须重写抽象父类中的所有抽象方法 抽象类不能创建对象，无论是否含有抽象方法继承性 JAVA语言是单继承的（一个类只能有一个直接父类），但是可以多级继承 如果类的定义中不含选项extends父类名，则java虚拟机一般会自动给当定义的类添加默认的选项extends java.lang.Object。故除了类java.lang.Object之外，任何类都有父类，而且类java.lang.Object是除它自身之外的所有类的父类。 当前定义的类的构造方法必须调用其父类的构造方法，而且该调用语句必须是当前定义的类的构造方法的第一句语句，其调用格式是 如果发生重名，成员方法属于谁，就优先用谁的成员变量12super(调用参数列表)//其中super是关键字，表示直接父类的构造方法。 java.lang.Object类是所有类的 公共最高父类三种重名 成员变量重名父类成员变量使用super.子类成员变量使用this.局部变量直接写 1234567891011121314151617//Father.javapublic class Father { int num=30;}//Son.javapublic class Son extends Father { int num = 20; public void method() { int num = 10; System.out.println(&quot;Father:&quot; + super.num); System.out.println(&quot;Son:&quot; + this.num); System.out.println(&quot;Temp:&quot; + num); }} 成员方法重名 方法覆盖 必须保证父子类之间方法的名称相同，参数列表也相同 子类方法的返回值必须小于等于父类方法的返回值范围 @Override:这叫做注解，写在方法前面，用来检测是否有效地正确覆盖。（如果报错说明未发生覆盖） 子类方法的权限必须大于等于父类方法的权限修饰符。 public&gt;protected&gt;留空(default)&gt;private继承中构造方法的访问特点 子类构造方法当中，有一个默认隐含的super()调用，所以一定是先调用父类构造方法，后执行子类构造方法 可以通过super关键字在子类中调用父类重载构造函数 super的父类构造调用，必须是子类构造方法的第一个语句。不能多次调用super构造。super关键字的三种用法this关键字的三种用法 在本类的成员方法中，访问本类的成员变量（成员方法中含有重名的局部变量，也生效） 在本类的成员方法中，访问本类的另一个成员方法 在本类的构造方法中，访问本类的另一个重载构造方法 1234567public Temp01(){ System.out.println(&quot;调用无参构造函数&quot;);}public Temp01(int n){ this(); System.out.println(&quot;调用重载构造函数&quot;);} 第三种方法中注意：this()构造方法也必须是语句的第一句注意：this和super两种构造调用不能同时使用，因为构造方法必须放在第一句，也就必须要保证唯一性 子类与父类之间的类型转换 隐式类型转换：无需强制类型转换符，将子类型的数据转换成父类型数据 12Teacher tom=new Teacher();Employee a=tom; 显式类型转换：需要强制类型转换符()，将父类型数据转换为子类型数据 123Teacher tom=new Teacher();Employee a=tom;Teacher b=(Teacher)a; 如果两个类型不存在子类型与父类型之间的关系，则一般不能进行类型转换。可以使用引用类型表达式instanceof引用类型来判断一个引用表达式所指向的实例对象是否是某种引用类型的实例对象 123Teacher a=new Teacher();Employee b=new Employee();Employee c=a; 则表达式a instanceof Teacher返回true表达式a instanceof Employee返回true表达式b instanceof Teacher返回false表达式c instanceof Employee返回true表达式c instanceof Teacher返回true instanceof运算符可以用再引用类型转换中，即先判断一个引用表达式所指向的实例对象是否是目标类型的实例对象，可以避免错误如 123if(a instanceof Teacher) b=(Teacher)a;else b=new Teacher(); 多态性 多态性指的是：在类定义中出现多个构造方法或者出现多个同名的成员方法。对于同名的成员方法，多态性还包括在当前定义的类型中出现与其父类型的成员方法同名的成员方法。多态性包括：静态多态性和动态多态性。 静态多态性 静态多态性指的是在同一个类中同名方法在功能上的重载overload，这也包括一个类对其父类同名方法在功能上的重载，而且在方法声明的形式上要求同名的方法具有不同的参数列表。这里的方法，可以是成员方法，也可以是构造方法。一般建议，重载的方法应当具有相似的功能。 动态多态性 动态多态性指的是在子类和父类的类体中均定义了具有基本相同声明的非静态成员方法。所谓非静态成员方法指的是在成员方法定义中成员方法的声明不包含方法修饰词static，这时也称为子类的成员方法对其父类进本相同声明的成员方法的覆盖override。（基本相同声明的成员方法要求具有相同的方法名，相同的参数个数，对应参数的类型也相同，而且子类的成员方法应当比其父类对应的成员方法有更广的访问控制方式） 利用动态多态性使得可以通过父类型的引用调用子类型的成员方法。这里要求父类型的引用 所指向的实例对象实际上是其子类型的实例对象，而且调用的子类型的成员方法是对父类型同名成员方法的覆盖。 由于动态多态性使得子类型的成员方法屏蔽了父类型的被覆盖的成员方法，因此通过关键字super可以解决在子类型的成员方法中调用父类型的被覆盖的成员方法的问题。 在子类型的非静态成员方法中访问其父类型的成员与，格式： super.父类型的成员域 在子类型的非静态成员方法中调用其父类型的成员方法，其格式： super.父类型的成员方法(调用参数列表) 在子类的构造方法的第一条语句处调用其父类的构造方法，其格式： super(父类构造方法的调用参数列表); 与super对应的关键字是this，其调用的是同一个类的成员域或成员方法。 需要注意的是，动态多态性只针对非静态的成员方法。 封装性 封装性在JAVA中的体现 方法是一种封装 关键字private也是一种封装 一旦使用private进行修饰，在本类中可以随意访问，但是超出本类范围就不能再直接访问了。 间接访问private成员变量，就是定义一对儿get/set方法，必须叫getXXX/setXXX。对于基本数据类型中的boolean类型，get方法必须写成isXXX。 当方法的局部变量（如参数）和类的成员变量重名的时候，根据就近原则，优先使用局部变量。如果需要访问本类当中的成员变量，需要使用this.成员变量名 **通过谁调用的方法，谁就是this ** 构造方法 构造方法注意事项 构造方法的名称必须和所在的类名完全一样 构造方法无返回值 如果没有编写任何构造方法，那么编译器会默认一个构造方法，没有参数，方法体什么事都不做 构造方法可以进行重载一个标准的类 一个标准的类要拥有下面四个部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对get/set方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做 Java Bean. 可以使用快捷键Alt+Insert或菜单中Code-Generate Static关键字 Static修饰成员field只在类中保存一份，所有本类对象共享一份。属于类而不是属于单独某一个对象。可以利用这一点，自动给对象顺序赋id 123456789private String name;private int id;static String teacher=&quot;胡景月&quot;;private static int idCount=0; //给成员变量赋初值public Student(String name) { this.name = name; id=++idCount;} Static修饰方法 静态方法属于类，不属于对象 如果没有static，必须创建对象才能使用方法 如果有static，对于静态方法来说，可以通过对象调用方法（不推荐），也可以通过类名调用方法。 本类当中的静态方法可以省略类名 静态不能直接访问非静态（原因：内存中先有的静态内容，后有的非静态内容） 静态方法中不能用this，因为this指的是当前对象，而静态内容属于类而不属于对象 静态Static的内存图静态内容与对象无关，即使写成对象.静态内容,也会被编译成为类.静态内容 静态代码块特点：1. 第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优于非静态，所以静态代码块比构造方法先执行 静态代码块的典型用途 一次性地对静态成员进行赋值 第四章 APIAPI概念API全程Application Programming Interface,应用程序编程接口。API使用步骤 打开帮助文档 点击显示，找到索引，看到输入框 输入框里输入想找的类 看包。java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法Scanner类——键盘输入类 基本功能：可以实现键盘输入数据到程序当中 引用类型的一般使用步骤： 导包 如果需要使用的目标类和当前类位于同一包下，则可以省略导包语句；只有java.lang包下的内容(如java.lang.String)不需要导包，其它的包都需要import语句。 创建 Scanner sc=new Scanner(System.in); //代表从键盘输入 使用 获取键盘输入的一个int数字：int num=sc.nextInt(); 其实键盘输入的都是字符串， nextInt是将输入的字符串里的数字转换成int型数 获取键盘输入的一个字符串：String str=sc.next();如果只需使用一次，可以使用匿名对象 12345678910111213141516int num=new Scanner(System.in).nextInt();//还可以使用匿名对象作为参数public class Demo04Anonymous { public static void printInt(Scanner sc){ int temp=sc.nextInt(); System.out.println(&quot;Num is &quot;+temp); } public static void main(String[] args) { printInt(new Scanner(System.in)); }}//匿名对象还可以作为返回值public static Scanner methodReturn() { return new Scanner(System.in); } Random类——产生随机数字 random类的使用 12Random r=new Random(); int a=r.nextInt(); //范围-21亿到+21亿 Random生成指定范围的随机数12345678910Random r=new Random(); for (int i = 0; i &lt; 10; i++) { int temp = r.nextInt(10); //范围是[0,10) 左闭右开 System.out.print(temp); System.out.print(&quot; &quot;); }//若想1~10就 r.nextInt(10)+1; 对象数组 1234567Person[]arr=new Person[3]; Person one=new Person(&quot;余丰旭&quot;,22); Person two=new Person(&quot;陈香玉&quot;,24); Person three=new Person(&quot;小小余&quot;,1); arr[0]=one; arr[1]=two; arr[2]=three; ArrayList 数组的长度不能改变，但是ArrayList集合的长度是可以随意变化的 对于ArrayList来说，有一个尖括号代表泛型，也就是装在集合当中的所有元素，全都是的什么类型。 注意：泛型只能是引用类型，不能是基本类型。原因是：ArrayList中存储的都是引用类型对象的地址，而基本数据类型没有地址。解决方案：使用基本类型对应的包装类。包装类：都位于java.lang包下（无需导包）从JDK1.5+开始，支持自动装箱、自动拆箱。自动装箱：基本类型–&gt;包装类型自动拆箱：包装类型–&gt;基本类型 基本类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 对于ArrayList集合来说，直接打印的到的不是地址值，而是内容 12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;余丰旭&quot;); list.add(&quot;陈香玉&quot;); list.add(&quot;小小余&quot;); System.out.println(list); ArrayList常用方法 public boolean add(E e):向集合当中添加元素，类型与泛型一致 public E get(int index):从集合中获取元素，参数是索引编号 public E remove(int index):从集合中删除元素 public int size():获取集合的尺寸长度（集合中的元素个数） 注意，ArrayList作为方法参数时，不要忘了&lt;E(泛型)&gt;String一.String类基本知识 java中只要是” “中的内容，都是String实例，无论new否 字符串特点 字符串的内容永不可变 正是因为字符串不可改变，所以字符串是可以共享使用的 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组 字符串的构造方法和直接创建，常见3+1种方式三种构造方法： public String():创建一个空白字符串，不含有任何内容 public String(char[ ]array):根据字符数组的内容，来创建对应的字符串 public String(byte[ ] array):根据字节数组的内容，来创建对应的字符串1234567891011121314public static void main(String[] args) { String str = new String(); System.out.println(&quot;First String is &quot; + str); char[] arr = {'a', 'b', 'c'}; String str2 = new String(arr); System.out.println(&quot;Second String is &quot; + str2); byte[] arr_byte = {97, 98, 99}; String str3 = new String(arr_byte); System.out.println(&quot;Third String is &quot; + str3); String str4=&quot;abc&quot;; System.out.println(&quot;Forth String is &quot;+str4); 二.字符串的常量池 字符串常量池：程序中直接写上的双引号字符串，就在字符串常量池中对于基本类型来说，==是进行数值的比较；对于引用类型来说，==是进行地址值的比较。 1234567String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);System.out.println(str1==str2); //tureSystem.out.println(str1==str3); //falseSystem.out.println(str2==str3); //false 双引号直接写的字符串在常量池中，new的不在池当中 三.字符串的比较相关方法 ==是进行对象的地址值的比较，如果确实需要字符串的内容比较，可以使用两个方法public boolean equals(Object obj):参数可以是任何对象public boolean equalsIgnoreCase(String str):忽略大小写，进行内容比较 123456789101112String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);if(str1.equals(str2)) System.out.println(&quot;str1=str2&quot;);if(str1.equals(str3)) System.out.println(&quot;str1=str3&quot;);if(str1.equals(&quot;abc&quot;)) System.out.println(&quot;str1=abc&quot;);if(&quot;abc&quot;.equals(str1)) System.out.println(&quot;abc=str1&quot;); ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200122191346564.png) 字符串的获取相关方法String当中与获取相关的常用方法有： public int Length():获取字符串中含有的字符个数 public String concat(String str):将当前字符串和参数字符串拼接成为返回值新的字符串 public char charAt(int index):获取指定索引位置的单个字符 public int indexOf(String str):查找参数字符串在本字符串中首次出现的索引位置，如果没有返回-1字符串的截取方法 public String substring(int index):从参数位置一直到末尾，返回新字符串 public String substring(int begin,int end):从begin开始，一直到end结束，中间的字符串，左闭右开字符串的转换方法 public char[ ] toCharArray():将当前字符串拆分成为字符数组作为返回值 public byte[ ] getBytes():获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString):将所有出现的老字符串替换成为新的字符串，返回替换后的结果新字符串备注：CharSequence就是说可以接受字符串类型字符串的分割方法分割字符串的方法;public String[ ] split(String regex):根据参数的规则，将字符串切分为若干部分 12String str=&quot;Yu,Feng,XU&quot;;String[]strString=str.split(&quot;,&quot;); 注意事项:split方法的参数其实是一个正则表达式，今后学习，今天要注意，如果按照英文句点.进行切分，必须写\\\\.两个反斜杠 ArraysArrays是一个与数组相关的工具类，里面提供了大量静态方法，来实现数组的常见操作（方便，静态方法不用new）常用方法 public static String toString(数组) 功能：将参数数组变成字符串（按照默认格式，即[xx,xx,xx..]） public static void sort(数组) 功能：按照默认升序对数组元素进行排序 备注：1. 如果是数值，sort默认按升序从小到大 2. 如果是字符串，sort默认按字母升序 3. 如果是自定义类型，**那么这个自定义类需要有Comparable或Comparator接口的支持 数学工具类Math常用方法： public static double abc(double num) abc是absolute的缩写，计算绝对值 public static double ceil(double num) 向上取整 public static double floor(double num) 向下取整4.public static long round(double num) 四舍五入 Math.PI 代表近似的圆周率值Object类重写equals方法(可以使用快捷键Alt+Insert)因为java中==对于基本数据类型比较的是数值，对于引用数据类型比较的是地址值，所以对于自己创建的对象，继承了Object类的equals方法，需要对equals方法进行重写1234567891011121314151617@Overridepublic boolean equals(Object obj) { //如果传递进来的是自身，直接返回true,提高程序效率 if(obj==this) return true; //如果传空，直接返回false，提高程序效率 if(obj==null) return false; //如果不是Student对象，直接返回false if (!(obj instanceof Student)) return false; //向下转型，并进行比较 Student stu = (Student) obj; if (this.age == stu.age &amp;&amp; this.name == stu.name) return true; return false;} Objects类有一个equals方法，可以容忍空指针（注意不是Object类，是Objects类）123456public static void main(String[] args) { Student stu=new Student(&quot;余丰旭&quot;,22); Student stu2=null; boolean b=Objects.equals(stu,stu2); System.out.println(b);} 因为其Objects.equals(再次注意不是Object类是Objects类）方法如下123public static boolean equals(Object a,Object b){ return (a==b)||(a!=null&amp;&amp;a.equals(b)); } 重写toString方法（也可以快捷键）1234@Overridepublic String toString() { return name+&quot;:&quot;+age+&quot;岁&quot;;} Object类位于java.util.objects JDK7中添加了Objects工具类，它有一些静态方法，这些方法是null-save(空指针安全的）或null-tolerant(容忍空指针的），用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象 在比较两个对象时，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题 源码如下12public static boolean equals(Object a,Object b){return (a==b)||(a!=null&amp;&amp;a.equals(b)); Date类 System.currentTimeMillis()获取当前系统时间到1970年1月1日00：00：00（英国格林威治时间）经历了多少毫秒（long类型）构造方法 1.无参构造 1234Date date=new Date();System.out.println(date);输出结果Mon Jan 27 19:47:17 CST 2020 2.带参构造（long类型）即毫秒值 1234Date date2=new Date(1580125811479L);System.out.println(date2);输出结果Mon Jan 27 19:50:11 CST 2020 常用方法 long getTime()把日期转换为毫秒值DateFormat类DateFormat类是抽象类，不能直接使用。所以需要常用子类java.text.SimpleDateFormat，这个类需要一个模式来指定格式化或解析的标准，构造方法为： public SimpleDateFormat(String pattern):用给定的模式和默认语言环境的日期符号构造SimpleDateFormat 格式规则| 标识字母（区分大小写） | 含义 || ———————- | —- || y | 年 || M | 月 || d | 日 || H | 时 || m | 分 || s | 秒 | 备注：更详细的格式规则，请见API文档 写对应的模式，会把模式替换为对应的日期和时间：yyyy-MM-dd HH:mm:ss或yyyy年MM月dd日 HH时mm分ss秒其中连接符可以任意写 format方法传入date类型的参数，按照SimpleDateFormat中指定的模式输出字符串 12345Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);System.out.println(sdf.format(today));输出结果2020年02月04日 11时55分41秒 parse方法把符合模式的字符串解析为Date日期public Date parse(String source)throws ParseExceptionparse方法声明了一个异常叫ParseException解析异常，如果字符串和构造方法中的模式不一样，那么程序就会抛出异常，调用一个抛出了异常的方法，就必须处理这个异常，那么throws继续声明抛出这一个异常，要么try..catch自己处理这个异常（暂时用Alt+enter 让虚拟机自己处理） 12345678Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);Date day=sdf.parse(&quot;2020年02月04日 11时55分41秒&quot;);System.out.println(&quot;parse方法将符合指定模式的字符串转换为Date类型数据:\\n&quot;+day);输出结果：parse方法将符合指定模式的字符串转换为Date类型数据:Tue Feb 04 11:55:41 CST 2020 小练习：计算距出生多少天12345678910111213public class demo02 { public static void main(String[] args) throws ParseException { System.out.println(&quot;请按照格式输入出生日期: yyyy-MM-dd&quot;); Scanner sc=new Scanner(System.in); String birthString=sc.next(); SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date birthday=sdf.parse(birthString); long birthdayMS=birthday.getTime(); long nowMS=new Date().getTime(); long distance=nowMS-birthdayMS; System.out.println(&quot;此人距出生已经历&quot;+distance/1000/60/60/24+&quot;天&quot;); }} Calendar抽象类很多Date类的方法已被Calendar类替代，java.util.Calendar类是一个抽象类，提供了很多操作日历字段的方法（YEAR,MONTH,DAY_OF_MONTH,HOUR)Calendar类无法直接创建对象使用，其含有静态方法getInstance(),该方法返回一个Calendar类的子类对象static Calendar getInstance()使用默认时区和语言环境获得一个日历 12使用了多态，用父类型接收子类对象Calendar c=Calendar.getInstance(); Calendar类常用方法public int get(int field)：返回给定日历字段的值public void set(int field,int value)：将给定日历字段设置为给定值public abstract void add(int field,int amout)：根据日历的规则，为给定的日历字段添加或减去指定的时间量public Date getTime()：转换为Date类对象 System类常用方法 public static long currentTimeMillis()：返回以毫秒值为单位的当前时间 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)：将数组中指定的数据拷贝到另一个数组中。参数含义：src-源数组、srcPos-源数组中的起始位置、dest-目标数组、destPos-目标数组中的起始位置、length-复制的元素数量StringBuilder类 字符串是常量，它们的值在创建之后不能改变。字符串的底层是一个被final修饰的数组，不能改变，是一个常量。因此会导致一个问题：拼接多个字符串时会产生大量字符串占用内存（如拼接a+b+c,内存中会产生a,b,c,ab,abc五个字符串 为了提高效率，可以使用字符串缓冲区（可以看成长度可以变化的字符串），底层也是数组，但是没有被final修饰，可以改变长度。 StringBuilder在内存中始终是一个数组，占用空间少，效率高；如果超出StringBuilder的容量，会自动扩容*构造方法 public StringBuilder()：构造一个空的StringBuilder容器 public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去常用成员方法 public StringBuilder append(...)：添加任意类型数据，并返回当前对象自身（可以链式编程） public String toString()：将当前StringBuilder对象转换为String对象第五章 包装类基本数据类型使用方便，效率高，但是缺少对应的方法来操作这些数据，故有时采用包装类。（除了char-Character和int-Integer,其他包装类都是首字母大写）装箱与拆箱 装箱：基本类型转换为对应包装类对象 通过构造方法(已过时）：Integer(int i)Integer(String s)：其中s必须时基本类型字符串，否则抛出异常 静态方法：static Integer valueOf(int i)：返回一个Integer实例static Integer valueOf(String s) 拆箱：包装类对象转换为基本类型成员方法：int intValue()自动装箱与拆箱从JDK1.5开始，基本类型和包装类的装箱与拆箱可以自动完成如ArrayList&lt;Integer&gt;中只能存储Integer包装类，但是可以直接写123ArrayList&lt;Integer&gt;list;list.add(999); //自动装箱int a=list[0]; //自动拆箱 基本数据类型与字符串之间的转换基本类型转字符串总共三种方式 基本数据类型+””即可 使用包装类中的静态方法toString（参数) 重载了Object的toString方法 使用String类中的静态方法valueOf(参数)String转基本数据类型除了Character类以外，所有包装类都具有parseXxx静态方法，可以将字符串参数转换为对应的基本类型 第六章 接口基础知识 接口就是一种公共的规范标准，如全中国的插座都一样。只要符合标准就可以大家通用 代码中，接口就是多个类的公共规范 接口是一种引用数据类型，其中最重要的内容就是抽象方法 接口的格式 123public interface 接口名称{接口内容} 备注：换成了关键字interface后，编译生成的字节码文件仍然是.java-&gt;.class 如果是JAVA7，则接口中可以包含的内容有：1.常量 2.抽象方法 如果是JAVA8，则：3.默认方法 4.静态方法 如果是JAVA9，则：5.私有方法接口使用步骤 注意事项： 1.接口中的抽象方法，修饰符必须是两个固定的关键词：public abstract2.这两个关键字可以选择性地省略，忽略任意一个或者两个一起省略都可以 接口使用步骤 接口不能直接使用，必须有一个实现类(类似子类）来实现该接口public class 实现类名称 implements 接口名称{...} 接口的实现类必须覆盖重写（实现）接口中的所有抽象方法 创建实现类的对象，进行使用接口的默认方法定义 接口中的默认方法可以解决接口升级的问题（已经实现了原有接口的类，在接口添加了新的抽象类后，由于实现类必须实现接口所有的抽象方法，而不能再使用）使用带方法体的默认方法即可解决这个问题 格式 1public default 返回值类型 方法名称（参数列表）{方法体} 注意事项 1.接口的默认方法，可以通过接口实现类对象直接调用2.接口的默认方法，也可以被接口实现类进行覆盖重写 接口中的Static方法 从JAVA8开始，接口中允许定义Static方法 格式 1public static 返回值类型 方法名称（参数列表）{方法体} 不能通过接口实现类的对象来调用接口当中的静态方法；正确用法：通过接口名称直接调用静态方法（静态只与类/接口，有关系）接口中的私有方法 通过抽取一个共有方法，用来解决两个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。 从JAVA9开始，接口中可以定义私有方法 1.普通私有方法 ：解决多个默认方法之间重复代码问题 1private 返回值类型 方法名称（参数列表）{方法体} 2.静态私有方法 ：解决多个静态方法之间重复代码问题 1private static 返回值类型 方法名称（参数列表）{方法体} 接口的常量定义 接口中也可以定义“成员变量”，但必须加上public static final三个修饰符（可以省略，但是不写也照样是这样，不能写别的），从效果上来说，这就是接口的常量*(final关键词修饰，说明不可改变） 格式1public static final 常量名称=数据值; 接口中的常量，要完全大写，下划线分割，必须赋初值 使用时，直接用接口名称.常量即可使用接口的注意事项 接口是没有静态代码块或构造方法的 一个类只有一个直接父类，但是一个类可以同时实现多个接口格式：123public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{ //覆盖重写所有抽象方法 } 如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是一个抽象类。 如果实现类所实现的多个接口中，存在着重复的默认方法，则实现类一定要对冲突的默认方法进行覆盖重写。 继承优先于接口实现：一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先使用父类中的方法接口之间的多继承 类与类之间是多继承的，直接父类只有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的注意事项： 1.多个父接口当中的抽象方法如果重复，没关系（因为抽象方法没有方法体）2.多个父接口当中的默认方法如果重复，那么子接口必须对重复的默认方法进行覆盖重写，default关键字不能省略 第七章 多态多态的基本概念 学生类继承人类，小明是一个学生对象，那么小明：既是一个学生，也是一个人，体现了对象的多态性 代码中体现多态性就是：父类引用指向子类对象格式(左父右子）： 123父类名称 对象名=new 子类名称();或者接口名称 对象名称=new 实现类名称(); 多态中成员方法的使用特点 看new的是谁，就优先用谁，没有则向上找 父子都有，优先用子 成员方法：编译看左，运行看右 成员变量：编译看左，运行还看左 使用多态的好处等号左边形式统一 1234Worker teacher=new Teacher(); Worker cooker=new Cooker(); teacher.work(); cooker.work(); 对象的向上转型对象的向上转型，其实就是多态写法父类名称 对象名=new 子类名称()含义：右侧创建一个子类对象，把它当作父类来看待使用注意事项：向上转型一定是安全的 对象的向下转型 因为对象的向上转型有个缺点：无法通过父类引用指向子类对象的方式，调用子类特有方法 对象的向下转型，其实是一个还原动作，这样就可以调用子类独特方法 格式：子类名称 对象名=（子类名称）父类对象 注意事项：必须保证对象创建的时候本来就是猫，才能向下转型为猫instanceof的使用cat instanceof Cat第八章 Collection集合集合是JAVA提供的一种容器，可以存储多个数据与数组的区别： 集合长度可变 集合存储的是对象，且对象类型可以不一致一、Collection集合 集合框架 Collection常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可以操作所有的单列集合 public boolean add(E e):给定对象添加到集合中 public void clear()：清空集合中所有元素 public boolean remove(E e)：把给定的对象在当前集合中删除 public boolean contains(E e)：判断当前集合中是否包含给定对象 public boolean isEmpty()：判断集合是否为空 public int size()：返回集合元素数量 public Object[ ] toArray() ：把集合中的元素存储到数组中二、Iterator迭代器JDK中提供的专门用来遍历集合的接口（不是所有集合都有索引，即有些不能直接用for循环遍历） *迭代：即Collection集合元素通用的获取方式。取出元素前先判断集合中有没有元素，如果有则取出，再继续判断，一直到取完。这种取出方法的专业术语成为迭代Iterator迭代器是一个接口，无法直接使用，需要接口的实现类对象。其获取实现类的方式特殊**，Collection类中有一个方法叫iterator(),返回的就是Iterator的实现类对象常用方法boolean hasNext()：如果仍有元素可以迭代，返回trueE next()：返回迭代的下一个元素1234567891011121314Collection&lt;String&gt;coll=new ArrayList&lt;&gt;();coll.add(&quot;我爱你&quot;);coll.add(&quot;中国&quot;);coll.add(&quot;我爱你&quot;);coll.add(&quot;塞北的雪&quot;);Iterator&lt;String&gt;iter=coll.iterator();while(iter.hasNext()){ System.out.print(iter.next());}或者for(Iterator&lt;String&gt;iter=coll.iterator();iter.hasNext();){ System.out.print(iter.next());} 三、增强for增强for循环也称为for each循环，是JDK1.5以后出来的高级循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历中不能对集合中的元素进行增删操作。12345678910111213//foreach遍历数组 （注意只能遍历，不能增删，因为其只是Iterator遍历的简化格式）String[]arr={&quot;我爱你&quot;,&quot;中国&quot;,&quot;亲爱的宝宝&quot;};for(String i:arr){System.out.println(i);}//增强for循环遍历集合Collection&lt;Integer&gt;coll=new ArrayList&lt;&gt;();coll.add(1);coll.add(2);coll.add(3);for(Integer i:coll){System.out.println(i);} 四、List接口三个特点：1.有序 2.有索引 3.允许重复List接口中带索引的方法（特有） public void add(int index,E element)：将指定元素插入到指定位置 public E get(int index)：获取指定位置上的元素 public E remove(int index)：删除指定位置上的元素，并返回该元素 public E set(int index,E element)：用指定元素替换指定位置，并返回原来的元素List的子类1.ArrayList底层是数组，查询快，增删慢。增加元素时需要创建一个比原来数组大1的新数组，再调用System.arraycopy将原有数组拷贝到新数组，效率低。因此开发中，增删用的多不建议使用ArrayList2.LinkedList特点： 底层是链表结构：查询慢，增删快 包含大量操作首尾元素方法 常用方法 public void addFirst(E e) public void addList(E e) public E getFirst() public E getLast() public E removeFirst() public E removeLast()：等效于add方法 public E pop()：从此列表所表示的堆栈处弹出一个元素等效于removeFirst public void push(E e)：将元素推入此列表所表示的堆栈 等效于addFirst public boolean isEmpty() 注意：获取元素时注意如果集合中没有元素，则会报错，需要用isEmpty先判断一下 3.Vector集合单线程的，速度慢，JDK1.2后被ArrayList取代。了解即可 五、Set接口 特点： 不重复 没索引HashSet 特点： 不允许重复 没有索引 是无序集合，存储和取出的顺序可能不同 底层是一个哈希表结构（查询速度很快） 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址，是一个逻辑地址，不是实际地址）Object类中有一个方法，可以获取对象的哈希值int hashCode() 返回该对象的哈希值 hashCode源码：public native int hashCode(); *native**代表调用的是本地OS的方法 String类重写了Object类的hashCode方法HashSet集合存储数据的结构——哈希表JDK1.8之前：哈希表=数组+链表JDK1.8之后：哈希表=数组+链表/红黑树（提高查询速度）超过8个用红黑树 哈希表的特点：速度快 HashSet集合不重复原理 HashSet集合不允许存储重复元素的原理：在Set集合调用add方法时，会先调用hashCode方法，如果没有发生哈希冲突则存储到集合中；若发生冲突，则再调用equals方法与冲突位置上的各元素比较，如果有相同的则不存储。 *前提**：存储的元素必须重写hashCode方法和equals方法HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一12345678910111213@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } LinkedHashSetLinkedHashSet继承了HashSet，底层是哈希表（数组+红黑树/链表）和一条链表（记录元素存储顺序），HashSet是无序的（不能保证存储和取出顺序一致），LinkedHashSet额外实现了有序（存储和取出顺序一致），也不允许重复 可变参数使用前提： 参数列表的类型已经确定，但参数个数不确定时 一个方法的参数列表只能有一个可变参数 如果参数有多个，可变参数必须写在参数列表的末尾 底层原理：可变参数底层是一个数组，根据传入参数个数会创建不同长度的数组终极形式：object...obj 1234567891011public static void main(String[] args) { System.out.println(add(1,2)); System.out.println(add(1,2,3,4));}public static int add(int...arr){ int sum=0; for(int i:arr){ sum+=i; } return sum;} 六、Collections工具类常用功能java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。（使用前提，必须实现Comparable，重写接口中的compareTo方法/自己-目标是升序/） public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparable与Comparator的区别Comparable：即该类自身带有Comparable方法，可以实现本类的比较，需要实现Comparable接口，重写比较规则compareTo方法Comparator：相当于找一个第三方裁判，无需实现接口；规则：o1-o2升序 例子： 12345678910111213141516171819202122232425import java.util.*;public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); ArrayList&lt;String&gt;list=new ArrayList&lt;&gt;(); while(n--&gt;0) list.add(sc.next()); Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { int a=Integer.parseInt(o1+o2); int b=Integer.parseInt(o2+o1); if(a&gt;=b) return -1; return 1; } }); StringBuilder sb=new StringBuilder(); for(String e:list) sb.append(e); System.out.println(sb); }} 第九章 Map集合Map集合特点 Map集合是双列集合，一个元素包含两个值 key不可以重复，value可以重复 一个key唯一对应一个value常用子类HashMap集合特点： 底层是哈希表（查询速度快）JDK1.8之前：数组+单向链表 JDK1.8及以后：数组+单项链表/红黑树（8个+用红黑树） HashMap是无序集合（存储和取出顺序有可能不同）LinkedHashMap集合继承了HashMap集合特点： LinkedHashMap底层：哈希表+链表（保证迭代顺序） 有序（存储和取出顺序一致）Hashtable集合特点： 不允许存储null键-null值 线程安全的（同步的、单线程、速度慢）HashMap是多线程的，非线程安全，不同步，速度快 和Vector集合一样在JDK1.2后被取代（ArrayList，HashMap）但是Hashtable的子类Properties依然活跃，它是唯一一个与IO流结合的集合 Map接口中常用的方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。如果key重复则替换value（返回被替换的值），不重复则添加（返回null） public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。123456789101112131415Map&lt;String,String&gt; map=new HashMap&lt;&gt;();map.put(&quot;大伯&quot;,&quot;大妈&quot;);map.put(&quot;二伯&quot;,&quot;二妈&quot;);map.put(&quot;老爸&quot;,&quot;老妈&quot;);//利用keySet遍历MapSet&lt;String&gt; set = map.keySet();Iterator&lt;String&gt; iter = set.iterator();while(iter.hasNext()){ System.out.println(map.get(iter.next()));} 或者使用灵活版的foreach循环 for(String i:map.keySet()){ String value=map.get(i); System.out.println(i+&quot;和&quot;+value); } Entry（项）键值对对象Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718Map&lt;String,Integer&gt;map=new HashMap&lt;&gt;();map.put(&quot;余丰旭&quot;,171);map.put(&quot;陈香玉&quot;,160);map.put(&quot;小小余&quot;,180);//遍历Map的第二种方法，使用Entey键值对对象//使用迭代器进行遍历Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator();while(iter.hasNext()){ Map.Entry&lt;String,Integer&gt; entry=iter.next(); String key=entry.getKey(); Integer value=entry.getValue(); System.out.println(key+&quot;身高是&quot;+value+&quot;厘米&quot;);}//使用增强for循环for(Map.Entry&lt;String,Integer&gt; i:map.entrySet()){ System.out.println(i.getKey()+&quot;身高为&quot;+i.getValue()+&quot;cm&quot;);} HashMap存储自定义类型键值Map集合保证key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 第十章 泛型当我们不知道使用什么数据类型的时候，我们可以使用泛型。创建集合对象的时候就会确定泛型的数据类型 一、泛型概述 创建集合对象，不使用泛型 *好处**：元素类型不必一致，默认类型是Object类 *弊端**：不安全，使用了多态导致子类独特内容被屏蔽，需要向下转型（循环中又无法统一向下转型） 创建集合对象，使用泛型 *好处**： 1.避免了类型转换的麻烦，存储的什么类型，取出来就是什么类型2.把运行期异常（代码运行之后抛出的异常），提升到编译期。不使用泛型，需要向下转型，循环中会出现类型转换异常 弊端：泛型是什么类型，就只能存储什么类型 二、定义和使用有泛型的类定义了带泛型的类，创建对象时不写则默认为Object类 123456789101112131415161718public class One&lt;E&gt; { private E data; public One() { } public One(E data) { this.data = data; } public E getData() { return data; } public void setData(E data) { this.data = data; }} 1234567public static void main(String[] args) { One&lt;String&gt;one=new One&lt;&gt;(&quot;使用了泛型&quot;); System.out.println(one.getData()); One&lt;Integer&gt;two=new One&lt;&gt;(); two.setData(12); System.out.println(two.getData());} 含有泛型的方法含有泛型的方法，在调用方法时确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型 格式：修饰符&lt;泛型&gt; 返回值类型 方法名（参数列表*(使用泛型)*）{方法体} 含有泛型的接口 定义格式： 1修饰符 interface 接口名 &lt;代表泛型的变量&gt;{}共有两种使用方式 接口的抽象方法以泛型为参数 接口的实现类的泛型跟着接口的泛型走1public class Two&lt;E&gt;implements MyInterface&lt;E&gt; 泛型通配符用来表示暂时未知的类型1234567891011121314151617181920212223public class Demo { public static void main(String[] args) { ArrayList&lt;Integer&gt;list1=new ArrayList&lt;&gt;(); list1.add(1); list1.add(2); list1.add(3); ArrayList&lt;String&gt;list2=new ArrayList&lt;&gt;(); list2.add(&quot;我爱你&quot;); list2.add(&quot;塞北的雪&quot;); traverseList(list1); traverseList(list2); } public static void traverseList(ArrayList&lt;?&gt;list){ /*for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); }*/ //使用迭代器遍历 Iterator&lt;?&gt;iterator=list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } }} 通配符高级使用——受限泛型 泛型的上限* 格式：类型名称 &lt;? extends 类&gt; 对象名称 意义：只能接收该类型及子类型 泛型的下限* 格式：类型名称 &lt;? super 类&gt; 对象名称 意义：只能接收该类型及其父类型java 此时参数只能接收Person类及其子类对象 public static void func(Collection&lt;? extends Person&gt; coll) 此时参数只能接收Person类及其父类对象 public static void func(Collection&lt;? super Person&gt; coll) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EKBUBlAi-1580906486394)(img\\Collection与Map.bmp)]","link":"/2020/01/29/Java-java%E5%85%A5%E9%97%A8/"},{"title":"使用优先级队列合并K个升序链表","text":"在做23合并K个升序链表这题时，发现使用优先级队列（堆）能够高效地解决此问题。 思路：直接无脑地将所有节点扔进优先级队列中（小根堆），然后依次取出所有节点，按照头插法构建结果链即可。 注意：这里C++优先级队列对于自定义数据类型的比大小的实现，是通过一个结构体内实现()运算符重载来实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */struct cmp{ bool operator()(ListNode*&amp;p1,ListNode*&amp;p2){ return p1-&gt;val&lt;p2-&gt;val; }};class Solution {private: priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;que; //传入自定义比较器cmppublic: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { //将所有节点指针，放入大根堆中 for(int i=0;i&lt;lists.size();i++){ ListNode*p=lists[i]; while(p){ que.push(p); p=p-&gt;next; } } ListNode*res=new ListNode(0); while(!que.empty()){ //头插法 ListNode*t=que.top(); que.pop(); t-&gt;next=res-&gt;next; res-&gt;next=t; } return res-&gt;next; }};","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"利用双堆找中位数","text":"今天做了一题堆相关的题目295数据流的中位数，题解巧妙地用一个大根堆和一个小根堆来快速计算中位数。 其中添加新数字的写法十分精妙：如果一个数字要添加到小根堆，就先添加到大根堆，再将大根堆堆顶的元素转移至小根堆；反之亦然，以此能够保证小根堆中的元素永远大于大根堆中的元素。 其中，C++优先级队列底层默认是一个大根堆（使用了less&lt;xxx&gt;，更换成greater&lt;xxx&gt;，即变为小根堆）。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(que1.size()&gt;=que2.size()){ que1.push(num); que2.push(que1.top()); que1.pop(); }else{ que2.push(num); que1.push(que2.top()); que2.pop(); } } double findMedian() { if(que1.size()&gt;que2.size()) return que1.top(); if(que1.size()==que2.size()) return (double)(que1.top()+que2.top())/2; return que2.top(); }private: priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;que1; //大根堆 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;que2; //小根堆};/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%A9%E7%94%A8%E5%8F%8C%E5%A0%86%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"堆与堆排序","text":"堆其实就是一种数组形式的完全二叉树，具体分为大根堆和小根堆 大根堆：父节点的值大于等于子节点的值 小根堆：父节点的值小于等于子节点的值 堆排序利用堆的特点，根节点大于等于所有节点的值（大根堆），那么每次建堆后将根节点与末尾节点交换位置，然后再对末尾节点以外的所有节点重新建堆（注意，这里不需要调用build_heap函数，只需要调用heapify函数即可，因为根节点的做右子树已经是堆，正因为如此，堆排序才有nlogn的时间复杂度），这样不断重复即可完成排序。 技巧：逆序下第一个有子节点的节点的下标，无论什么情形，固定为$len/2-1$ 原因：任意一个节点的父节点下标为(i-1)/2; 那么逆序第一个有子节点的节点，即为完全二叉树最后一个节点的父节点。故为(n-1-1)/2=n/2-1; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;void swap(int tree[], int c1, int c2) { int t = tree[c1]; tree[c1] = tree[c2]; tree[c2] = t;}/** * n个节点的完全二叉树 * 在第i个节点处建堆 * 前提：左右子树已经是堆 * @param tree * @param n 完全二叉树节点个数 * @param i 进行heapify的根节点 */void heapify(int tree[], int n, int i) { int p = i; while (p &lt; n) { int max = p; int l = 2 * p + 1, r = 2 * p + 2; if (l &lt; n &amp;&amp; tree[l] &gt; tree[max]) { max = l; } if (r &lt; n &amp;&amp; tree[r] &gt; tree[max]) { max = r; } if (max == p) break; swap(tree, p, max); p = max; }}/** * 对节点数为n的完全二叉树建堆 * @param tree * @param n 完全二叉树节点个数 */void build_heap(int tree[], int n) { int p = n / 2 - 1; while (p &gt;= 0) { heapify(tree, n, p); p--; }}/*堆排序*/void heap_sort(int tree[], int n) { build_heap(tree, n); for (int i = n - 1; i &gt; 0; i--) { swap(tree, 0, i); heapify(tree, i, 0); }}","link":"/2020/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"最大频率栈","text":"今天写到一到数据结构的题目，觉得很有意思，遂记录下leetcode895最大频率栈。这题既需要记录每个数字的频率，又需要记录每种频率拥有的数字，故采用两个map来实现。 执行过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FreqStack {public: FreqStack() { maxFreq=0; } void push(int val) { /*查询是否已存在*/ if(numFreq.find(val)==numFreq.end()){ numFreq[val]=1; freqNums[1].push(val); if(maxFreq==0) maxFreq=1; }else{ numFreq[val]++; freqNums[numFreq[val]].push(val); if(numFreq[val]&gt;maxFreq) maxFreq++; } } int pop() { int ans=freqNums[maxFreq].top(); freqNums[maxFreq].pop(); if(freqNums[maxFreq].empty()) maxFreq--; if(numFreq[ans]==1){ numFreq.erase(ans); }else{ numFreq[ans]--; } return ans; }private: map&lt;int,int&gt;numFreq; //每个数字的频率 map&lt;int,stack&lt;int&gt;&gt;freqNums; //每种频率含有的数字 int maxFreq; //最大频率};/** * Your FreqStack object will be instantiated and called as such: * FreqStack* obj = new FreqStack(); * obj-&gt;push(val); * int param_2 = obj-&gt;pop(); */","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"},{"title":"实现一个LRU缓存结构","text":"LRU：最近最少使用算法。LRU缓存算法，由哈希表和双向链表构成，能以O(1)时间复杂度获取缓存的键值，也能以O(1)的时间复杂度存储键值。 Java中有内置类型LinkedHashMap，可以直接用于LRUCache的实现。C++没有，需要手动实现，这里我手动实现一个。 leetcode有一题LRU题目LRU缓存机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//双向链表+哈希表struct Node{ int key,val; Node*pre,*next; Node(int k,int v):key(k),val(v),pre(NULL),next(NULL){}};class DoubleList{ public: DoubleList(){ size=0; head=new Node(0,0); tail=new Node(0,0); head-&gt;next=tail; tail-&gt;pre=head; } //在链表尾部添加节点 void addTail(Node*x){ x-&gt;next=tail; x-&gt;pre=tail-&gt;pre; tail-&gt;pre-&gt;next=x; tail-&gt;pre=x; size++; } //删除某个节点(根据地址) void deleteNode(Node*x){ x-&gt;pre-&gt;next=x-&gt;next; x-&gt;next-&gt;pre=x-&gt;pre; size--; //return x; } //删除首节点，并返回其键值，用于反向删除map中的键 int deleteFirst(){ int key=head-&gt;next-&gt;key; deleteNode(head-&gt;next); return key; } int getSize(){ return size; } private: int size; Node*head,*tail; //tail处是最近访问的};class LRUCache {public: LRUCache(int capacity) { this-&gt;capacity=capacity; } int get(int key) { if(node_map.find(key)==node_map.end()) return -1; Node*p=node_map[key]; makeRecent(p); return p-&gt;val; } void put(int key, int value) { //如果已经存在，则更新值 if(node_map.find(key)!=node_map.end()){ Node*p=node_map[key]; makeRecent(p); p-&gt;val=value; return; } //不存在的情况下： //如果满了 if(capacity==cache.getSize()){ removeLRU(); } Node*p=new Node(key,value); cache.addTail(p); //放入哈希表 node_map[key]=p; } //将某个节点提升到recent void makeRecent(Node*x){ cache.deleteNode(x); cache.addTail(x); } //删除LRU节点缓存 void removeLRU(){ int key=cache.deleteFirst(); node_map.erase(key); }private: int capacity; DoubleList cache; unordered_map&lt;int,Node*&gt;node_map;}; 123456789101112131415161718192021222324252627282930313233343536373839404142class LRUCache { int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() &gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); }}","link":"/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"优先级队列","slug":"优先级队列","link":"/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"OS","slug":"OS","link":"/tags/OS/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"速决结构","slug":"速决结构","link":"/categories/%E9%80%9F%E5%86%B3%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}