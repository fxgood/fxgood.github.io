{"pages":[],"posts":[{"title":"算法题之戳气球","text":"leetcode312 戳气球 这一题可以用动态规划来解决,但是dp含义的设置和状态转移方程的设计很有意思。 首先,一维dp难以实现的，应该考虑二维dp，尤其在一个数组中，要考虑到双指针移动来解决复杂问题。 如果将dp[i][j]的含义设置为戳爆下标[i,j]之间所有的气球能获得的最大钱币,会发现由于涉及到与i左边和j右边数字相乘,难以书写状态转移方程。 将dp[i][j]的含义设置为:戳爆下标i和j之间（开区间）的所有气球能获得的最大钱币。此时，如果将状态转移方程写为$dp[i][j]=max(先戳气球k,再戳剩下所有气球,获得的最大钱币) i&lt;k&lt;j$,会造成子问题之间相互牵连,不具有独立性,也就无法完成动态规划的设计。 因此将状态转移方程方程写成dp[i][j]=max(先戳剩下所有气球,再戳气球k,获得的最大钱币) i&lt;k&lt;j,这样每次左右两边的计算互不干扰,即可完成动态规划的设计。 （本质是由于，如果先戳爆气球k，则气球k-1右侧的气球改变，气球k+1左侧的气球也改变，造成钱币获取公式的改变,而最后戳爆气球k,则不会出现这个问题,即固定了dp[i][j]中i和j这两个气球) 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt;nums; int stab(int t){ if(t==0 || t==nums.size()+1) return 1; return nums[t-1]; } //一维dp不行,就整二维 int maxCoins(vector&lt;int&gt;&amp; nums) { this-&gt;nums=nums; int n=nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n+2,vector&lt;int&gt;(n+2,-1)); for(int i=0;i&lt;=n+1;i++) for(int j=i;j&gt;=0;j--){ if(i==j || i==j+1){ dp[j][i]=0; } else{ int m=0; //最后戳爆气球k for(int k=j+1;k&lt;i;k++){ m=max(m,dp[j][k]+dp[k][i]+stab(i)*stab(k)*stab(j)); } dp[j][i]=m; } } return dp[0][n+1]; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%88%B3%E6%B0%94%E7%90%83/"},{"title":"操作系统知识巩固","text":"概述 操作系统基本功能 统一管理所有计算机资源 处理器资源 存储资源 IO资源 文件资源 实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统四大特性 并发 并行：多个事件同一时刻发生 并发： 多个事件同一时间间隔内交替发生（多道程序交替执行） 共享 共享性：操作系统中的资源可以供多个并发的程序共同使用 分类： 互斥共享 同时共享 虚拟 虚拟性：把一个物理实体转变为若干个逻辑实体 虚拟技术又分为：时分复用和空分复用。 时分复用技术：资源在时间上进行复用，不同程序并发使用；多道程序分时使用计算机硬件资源 虚拟处理器技术 借助多道程序设计技术，为每个程序建立进程，多个程序（进程）分时复用处理器 虚拟设备技术 物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问 空分复用技术：用来实现虚拟磁盘、虚拟内存等，提高资源的利用率，提升编程效率。 虚拟磁盘技术 物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 异步 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）进程管理 为什么需要进程 没有配置OS之前，资源属于当前运行的程序（单道程序设计） 配置OS之后，引入多道程序设计的概念 合理地隔离资源、运行环境，提升资源利用率 进程的作用 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体，保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升1234面试官：请你谈一谈你对进程的认识。答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。 进程的实体 主存中的进程形态： 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据） IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器事件、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。 进程控制块(PCB)中记录的数据，可以分为四类 进程标识符 处理机状态 进程调度信息 进程控制信息进程与线程一个进程(Process)可以有一个或多个线程(Thread) 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位 线程包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程资源 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 开销大 开销小 通信 进程IPC 读写同一进程数据通信 五状态模型进程的五状态模型包括：创建，就绪，执行，阻塞，中止 就绪状态 定义：其他资源都准备好，只差CPU资源的状态称为就绪状态 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行 多个处于就绪状态的进程通常排列成一个队列，称为就绪队列 执行状态 定义：进程获得CPU，其程序正在执行，称为执行状态 在单处理机中，在某个时刻只能有一个进程是处于执行状态 阻塞状态 定义：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 阻塞进程会组成一个队列，称为阻塞队列 创建状态 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态 操作系统提供fork函数接口创建进程 终止状态 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态 ## 进程同步 为什么需要进程间同步 需要进行进程同步的两个经典问题生产者消费者问题 哲学家就餐问题 上述两个模型发生问题的根源：彼此之间没有通信 进程之间同步所解决的问题 1.对竞争资源在多进程之间进行次序的协调 2.使得并发执行的多个进程之间可以有效使用资源和相互合作 临界资源指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。 进程间同步的原则 1.空闲让进：资源无占用，允许使用2.忙着等待：资源有占用，请求进程等待3.有限等待：保证有限等待时间能够使用资源3.让权等待：等待时，进程需要让出CPU 线程与线程的同步方法 进程同步方法 1.消息队列 2.共享存储 3.信号量 线程同步方法 1.互斥量 2.读写锁 3.自旋锁 4.条件变量 Linux的进程管理Linux进程的相关概念 进程的类型： 前台进程： 1.前台进程就是具有中断，可以与用户交互的进程 后台进程： 1.与前台进程相对，没有占用终端的就是后台进程； 2.后台程序基本上不和用户交互，优先级比前台进程低 3.将需要执行的命令以&amp;符号结束 守护进程： 1.守护(daemon)进程是特殊的后台进程； 2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭； 3.linux有很多典型的守护进程； 4.进程名字以d结尾的一般都是守护进程，如crond,sshd,httpd,mysqld 操作系统提供fork函数接口创建进程 进程的标记 进程ID 1.唯一性 2.负整数，最大值由操作系统限定 3.ID为0的进程为idle进程，是系统创建的第一个进程 4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 5.Init进程是所有用户进程的祖先进程 状态符号 ### 操作Linux进程的相关命令 ps命令 1.ps是process status的缩写2.可以添加-ef或者-aux展示详细进程详细信息3.搜索某个进程的详细信息ps -ef | grep python34.查询进程树ps -ef --forest5.查询某个用户的进程ps -u yfx6.按照cpu的使用频率进行排序ps -aux --sort=-pcpu7.按照内存使用的状况进行排序ps - aux --sort=-pmem top命令 1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态 kill命令 1.kill -9 进程号 无条件终止进程 作业管理作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。 进程调度进程调度概述 进程调度：计算机通过决策决定哪个就绪进程可以获得CPU的使用权（多道程序设计） 进程调度的步骤 1.保留旧进程的运行信息，请出旧进程2.选择新进程，准备运行环境并分配cpu 新老进程的上下文切换机制进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 ### 进程调度算法 两种调度的方式 1.非抢占式的调度2.抢占式的调度 进程调度算法 1.先来先服务2.短进程优先3.高优先权优先4.时间片轮转 死锁死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。 死锁的产生 死锁产生的原因 1.竞争资源2.进程调度顺序不当 死锁的四个必要条件（如果出现死锁，必然存在下边四个条件） 互斥条件资源同一时间只能允许一个进程访问 请求保持条件进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源 不可剥夺条件只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。 循环等待条件多个进程之间存在资源请求的环路死锁的处理 预防死锁 破坏请求保持条件 1.进程运行之前，一次性申请所有需要的资源 2.并且在运行期间不会提出新的资源请求 破坏不可剥夺条件 1.当一个进程请求新的资源得不到满足时，必须释放占有的资源 2.进程运行时占用的资源可以被释放 破坏环路等待条件 1.可用资源线性排序，申请必须按照需要递增申请 假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。 但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。 避免死锁 避免死锁和预防死锁的区别二者都是通过施加某些限制条件，来预防死锁发生。 差别： 1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个） 2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态） 银行家算法 是一个可操作的著名的避免死锁的算法 以银行借贷系统分配策略为基础的算法 存储管理内存分配单一连续分配只能在单用户、单进程的操作系统中使用 固定分区分配1.内存空间被划分为若干固定大小的区域2.每个分区只提供给一个程序使用，互不干扰 动态内存分配根据进程实际需要，动态分配内存空间 动态分区空闲表数据结构 动态分区空闲链数据结构 内存分配过程 首次适应算法（First Fit)： 算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件缺点：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。(2)每次都是从低址部分查找，使得查找空闲分区的开销增大2. 循环首次适应算法(Next Fit) ：算法思想：配内存时不是从链首进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；优点：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存3. 最佳适应算法（Best Fist）算法思想：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的缺点：产生大量难以利用的外部碎片。4. 快速适应算法（Quick Fit）算法思想：快速适应算法要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区 内存回收一共有四中情况，如下图1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去 页式存储管理管理方式1.将进程逻辑空间等分为若干大小的页面2.相应地把物理内存空间分成与页面大小相同的物理块3.以页面为单位把进程空间装进物理内存中分散的物理块 页面大小1.过大难以分配，过小内存碎片过多2.通常是512B~8K 页表1.页表记录进程逻辑空间与物理空间的映射2.某个页表项的地址=页表起始地址+页表项大小x页号3.实际物理地址=字块大小x字块号+块内偏移地址 多级页表页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。 缺陷有一段连续的逻辑分布在多个页面中，将大大降低执行效率 段式存储管理管理方式1.将进程逻辑空间划分成若干段（非等分）2.段的长度由连续逻辑的长度决定3.主函数MAIN，子程序段X，子函数Y等 段式和页式对比1.二者都离散地管理了进程的逻辑空间2.页是物理单位，段式逻辑单位3.分页是为了合理利用空间，分段是满足用户要求4.页大小由硬件固定，段长度可动态变化5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度） 段页式存储管理为何需要段页式存储管理1.分页可以有效提高内存利用率2.分段可以更好地满足用户需求3.二者结合，形成段页式存储管理 如何管理1.先将逻辑空间按按段式管理分成若干段2.再把段内空间按页式管理分成若干页 虚拟内存问题一个游戏十几G，物理内存只有8G，游戏如何运行起来的？ 虚拟内存概述有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。程序局部性原理指CPU访问存储器，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。 虚拟内存的置换算法1.先进先出算法FIFO2.最不经常使用算法LFU3.最近最少使用算法LRU 与高速缓存的替换区别1.替换策略发生在Cache-主存层次、主存-辅存层次2.Cache-主存层次的替换策略主要是为了解决速度问题3.主存-辅存层次主要是为了解决容量问题 Linux存储管理Buddy内存管理算法概述1.Buddy算法（伙伴算法）是经典的内存管理算法2.基于计算机处理二进制的优势，效率极高3.主要是为了解决内存外碎片的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB） Buddy管理算法的目的努力让内存分配与相邻内存合并能够快速进行 内存分配原则向上取整为2的幂大小（外碎片转化为内碎片）(1)申请70k -&gt; 分配128k(2)申请129k -&gt; 分配256k(3)申请666k -&gt; 分配1024k 伙伴系统伙伴指的是内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存 内存分配过程1.创建一系列空闲块链表，每一种都是2的幂大小2.假设存储空间有1M大小3.分配100k内存(1)100k向上取2的幂=128k(2)查询是否有128k的空闲内存块？(3)没有！查询是否有256k空闲内存块？(4)没有！查询是否有512k空闲内存块？(5)没有！查询是否有1M空闲块内存？(6)有，摘下1M空闲内存块，分配出去(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去(8)拆下256K放在空闲链上，其余分配出去(9)拆下128K放在空闲链上，其余分配出去(10)分配完毕 4.回收内存过程(1)判断刚才分配的内存伙伴在空闲链表上吗？(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴…?(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴…?(4)在！移出伙伴，合并为1M空闲内存(5)插入1M空闲链表，回收完成 Linux交换空间概述1.交换空间（Swap）是磁盘的一个分区2.Linux物理内存满时，会把一些内存交换到Swap空间 作用1.冷启动内存依赖许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。2.系统睡眠依赖Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。3.大进程空间依赖有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。 Swap空间和虚拟内存的对比Swap空间(1)存在于磁盘(2)与主存发生置换(3)是操作系统概念(4)解决系统物理内存不足问题 虚拟内存(1)存在于磁盘(2)与主存发生置换(3)是进程概念(4)解决进程物理内存不足问题 文件管理文件的逻辑结构 逻辑结构的文件类型有结构文件1.文件内容由定长记录和可变长记录组成2.定长记录存储文件格式、文件描述等结构化数据项3.可变长记录存储文件的具体内容 无结构文件也成为流式文件，文件内容长度以字节为单位。如exe文件、dll文件、so文件 linux静态链接库文件.a 动态链接库文件.sowindows静态链接库文件.lib 动态链接库文件.dll 顺序文件1.顺序文件是指按照顺序存放在存储介质中的文件2.磁带的存储特性使得磁带文件只能存储顺序文件3.顺序文件是所有逻辑文件当中存储效率最高的4.顺序文件的增删查改是比较困难的 索引文件1.可变长的文件不适合用顺序文件格式存储2.索引文件是为了解决可变长文件存储而发明的一种文件格式3.索引文件需要配合索引表完成存储 辅存的存储空间分配 连续分配 1.顺序读取文件非常容易，速度很快 2.对存储要求高，要求满足容量的连续存储空间 链接分配1.链接分配可以将文件存储在离散的盘块中2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中-&gt;隐式链接，记录在FAT中-&gt;显示分配） 隐式链接分配显式链接分配缺点：1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块） 索引分配1.每个文件拥有一个索引块，记录所有盘块信息2.索引分配方式支持直接访问盘块3.文件较大时，索引分配方式具有明显优势4.现在主流文件系统都是使用索引分配 (空闲块)存储空间管理三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。 空闲表 空闲链表1.把所有空闲盘区组成一个空闲链表2.每个链表节点存储空闲盘块和空闲的数目 位示图1.位示图维护成本低2.非常容易找到空闲盘块3.使用0/1比特，占用空间小 目录管理任何文件或目录都只有唯一路径 Linux文件的基本操作Linux目录|目录|描述 ||–|–||/bin |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里 ||/etc |存放系统管理和配置文件 ||/home |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user ||/usr |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：unix software resources ||/opt |额外安装的可选应用程序宝所放置的位置 ||/proc |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息 ||root |超级用户（系统管理员）的主目录 ||/sbin |存放二进制可执行文件，只有root才能访问 ||/dev |用于存放设备文件 ||/mnt |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。 ||/boot |存放用于系统引导时使用的各种文件 ||/lib |存放文件系统中的程序运行所需要的共享库及内核模块 ||/var |用于存放运行时需要改变数据的文件 | Linux文件常用操作 命令 操作 touch 创建文件 mkdir 创建文件夹 rm 删除文件 cat 查看文件 gedit 使用gedit编辑文件 Linux文件类型 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信 使用ls -al命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型 Linux文件系统设备管理","link":"/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%B7%A9%E5%9B%BA/"},{"title":"自建博客记录与心得","text":"本博客采用hexo+gitee page+阿里云图床(阿里云对象存储oss)来建立的，主题选用的是基于hexo的icarus主题。一开始用的是hexo+githubpage，存在两个问题：1.博客部署在github部署和访问不稳定2.图片的使用和访问不方便。 建站过程 下载node.js、git等工具。进入在windows命令行 配置npm的国内源 12npm config set registry https://registry.npm.taobao.org #配置国内的镜像源npm info hexo # 测试查看hexo的安装信息，是否是taobao.org的源 安装hexo 12npm install -g hexo # 通过npm安装hexo# -g 指定全局安装，可以使用hexo命令 在自选的路径下，进行以下操作 123hexo init test # 初始化创建，会再桌面创建test文件夹cd test # 进入test目录npm install # 进一步安装hexo所需文件 hexo安装完成，启动hexo 123hexo clean # 清除所有记录hexo generate # 生成静态网页hexo server -p 80 # 在80端口启动服务，如果写-p xx 则在默认端口 浏览器访问localhost:端口号，可以查看博客当前的样子 主题配置：将下载的hexo主题（可以去github或者百度知乎上搜喜欢的）放在themes文件夹下，然后修改_config.yml配置文件 1theme: xxx # 这里与theme下主题文件夹的名称相同 在gitee中创建和用户名相同的仓库，然后修改_config.yml中的仓库url 123deploy: type: git repo: https://gitee.com/fxgood/fxgood # gitee的仓库地址 cd到博客根目录下，输入命令hexo generate &amp;&amp; hexo deploy 或者hexo g &amp;&amp;hexo d ，即可将博客部署到gitee page 阿里云购买域名，进行域名绑定 Typora绑定阿里云图床过程参考 https://zhuanlan.zhihu.com/p/138878534 注意事项 通过gitee page来建博客，仓库名一定要与gitee用户名一致，这样可以采用https://用户名.gitee.io/的方式来访问博客。 每次更新博客内容需要手动在gitee page上进行刷新（氪金会员据说可以自动刷新） hexo配置和主题配置，分别在_config.yml和_config.xxx主题名xx.yml中 写文章，就在source/_posts/下，可以再创建文件夹进行分类存放 生成文章摘要有两种方法 在文章中某一行添加&lt;-- more --&gt;，则该行以上的内容会作为摘要 在md文件开头添加属性excerpt:xxx内容填写摘要即可 hexo常用命令 注：首先要用cmd或者git来到本地博客根目录 hexo init初始化博客 hexo clean 刷新部署 hexo generate 更新博客内容后，需要重新生成 hexo deploy 部署到远程服务器上 hexo c &amp;&amp;hexo g &amp;&amp;hexo d 可以一键完成上述三个功能 文章常用yaml front matter title: xxx标题 category: 分类 tag: 标签 excerpt: 文章摘要 updated: 2020-04-01 00:00:00 更新时间，（注意在_config.icarus.yml中article中可以设置update_time以实现控制) date: 2020-1-1 00:00:00 创建时间","link":"/2021/09/09/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/"},{"title":"Java基础","text":"1. 概述 冯诺依曼体系结构 组成：运算器，控制器，存储器，输入设备，输出设备 SUN公司1995年推出的一门高级编程语言 JDK：Java Development Kit （java开发工具包） 包括jre 其他开发工具：编译工具javac.exe，打包工具jar.exe JRE：Java Runtime Environmen（java运行时环境 ） 包括Java虚拟机（Java Virtual Machine）和Java程序所需要的核心类库等。 如果想运行一个开发好的java程序，计算机中只需要安装JRE即可。 Java内存模型 2. 基本语法2.1 关键字和标识符关键字 关键字的定义和特点 定义：被Java语言赋予了特殊含义的字符串 特点：都是小写 用于定义数据类型的关键字byte,short,int,long,float,double,boolean,void,class,interface,enum 用于流程控制的关键字if,else,switch,for,while,case,default,do,break,continue,return 用于定义访问权限修饰符的关键字public,protected,private 定义类，函数，变量修饰符的关键字abstract,final,static,synchronized 用于定义类与类之u见关系的关键字extends,implements 用于定义简历实例及引用实例，判断实例的关键字new,this,super,instanceof 用于异常处理的关键词try,catch,finally,throw,throws 用于包的关键字package,import 其他修饰符关键字native,strictfp,transient,volatile,assert 保留字现有Java版本尚未使用，但以后版本可能会作为关键字使用，如goto，const 标识符命名规范 包名：全部小写,xxxyyyzzz 类名、接口名：大驼峰 变量名、方法名：小驼峰 常量名：全部大写，多个单词用下划线连接 2.2 变量基本数据类型 Java语言数据类型的长度和表示范围不受OS影响 基本数据类型(primitive type) 数值型 整数类型 byte:1字节，范围：-128-127 short:2字节，范围:$-2^{15}$ ~ $2^{15}+1$ int:4字节，范围$-2^{31}$ ~ $2^{31}-1$（约21亿） long:8字节，范围$-2^{63}$ ~ $2^{63}-1$声明long类型常量须加小写l或者大写L 浮点类型 单精度float，占4字节，尾数可以精确到7位有效数字 float类型表示范围比long还大！ 因为float类型底层存储方式不同，$2^E*M$ 浮点数关注的是精度，整数类型关心的是范围，。 双精度double，占8字节，精度是float的两倍。通常采用此类型 java的浮点型常量默认为double类型，声明float类型，须后加小写f或者大写F 两种表示形式 十进制数形式：2.12, 512.0f, .34 科学计数法形式：5.12e2, 512E2, 100E-2 字符型 char，占2个字节 三种表示方式 单引号 转义字符\\r回车符，\\n换行符 Unicode值直接表示，\\uXXXX，XXXX代表一个十六进制整数 char类型可以运算，因为有对应的Unicode码 UTF-8是使用最广的一种Unicode的实现方式 布尔型 boolean 引用数据类型(reference type) 类(包括String） 接口 数组 基本数据类型之间的转换除了boolean类型，其他7种基本数据类型之间的转换自动类型提升 当容量（表示数的范围）小的数据类型的变量与容量大的数据类型的变量之间做运算时，结果自动提升为容量大的数据类型。 如果用int=int+long则会报错 容量（表示数的范围）从小到大是：byte（1字节）-&gt; char、short （2字节）-&gt; int -&gt; long -&gt; float -&gt; double (注意，float虽然是4个字节，但是比8个字节的long，能表示的数据范围要更大） 特别地，byte、char、short三种类型的变量之间做运算时（包括自己和自己，如byte+byte），结果为int类型 书上：java在做运算地时候，如果操作数均在int范围内，那么一律在int的空间内运算强制类型转换 需要使用强转符号() 可能造成精度损失 不加l或者L的整数，默认是int型 比如 long a=213214332143254324; 会报错，整数超过int类型 不加f或者F，默认是double类型 比如float b=12.3; 会报错 因为12.3默认是double类型，不能直接赋值给精度小的float类型常量 整型常量，默认类型为int型 浮点型常量，默认类型为double型String 声明String时，用双引号即可 不是基本数据类型，属于引用数据类型 字符串可以拼接其他字符串，也可以拼接其他数据类型的数据 可以与基本数据类型，直接做+运算 进制转换 对于整数，有四种表示方式 二进制binary，以0b或者0B开头 十进制decimal 八进制octal，以数字0开头 十六进制hex，以0x或者0X开头 二进制的整数有如下三种形式 原码：直接将一个数值转换成二进制。最高位是符号位 反码： 正数：和原码一样 负数：除符号位外，其他位对原码按位取反 补码： 正数：和原码一样 负数：反码+1 -127补码是1000 0001，-128补码是1000 0000，用-127减一即可 2.3 运算符Java中的运算符有 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 位运算符&gt;&gt;&gt;无符号右移 移位运算符和位运算符优先级如下~，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，^，| 2.4 数组对char型数组，System.out.println()打印的结果是内容的字符串形式对于其他类型的数组，打印的结果是类型@地址值，如[I@ed9d034 3. 封装面向对象的三大特征 封装 继承 多态3.1 java内存模型 堆Heap唯一目的是存放对象实例， 几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈Stack通常所说的栈Stack，指的是虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型(byte,short,char,int,long,boolean,float,double)、对象引用(reference类型，是对象在堆内存的首地址）。方法执行完，自动释放。 Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）， Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。对于我们来说，主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。 方法区Method Area用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(JDK8以后改成了元数据空间metaspace） 程序计数器1234程序计数器是一个记录着当前线程所执行的 字节码的行号指示器。JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。 首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，**每个线程工作时都有属于自己的独立计数器。** 运行时数据区包括：方法区、虚拟机栈、本地方法栈、堆、程序计数器 3.2 对象 对象的内存解析 对象数组的内存解析 注意： 此处的字符串“Tom”，是字符串常量，实际上是在方法区 引用类型的变量，只可能存储两类值：null 或 地址值（包含变量的类型）3.3 方法 方法重载概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数 或 参数类型不同即可。特点：与返回值类型无关，只看参数列表。 可变形参的方法允许直接定义能和多个实参相匹配的形参。从而，可以使用一种更简单的方式，来传递个数可变(任意个，包括0个）的参数。具体使用 格式：数据类型 ... 变量名 传入参数个数可以是：0个，1个，2个… 可以与形参不同的方法之间形成重载 与形参类型相同的数组，不能共存 在形参列表中，必须声明在末尾 形参列表中，最多只能声明一个可变形参定义123456public void show(String ... strs){ //可以像使用数组一样使用参数strs for(int i=0;i&lt;str.length();i++){ System.out.println(strs[i]); }} 方法参数的值传递机制Java里的方法的参数传递方式只有一种：值传递。即将实际参数值的副本传入方法内，而参数本身不受影响。 形参是基本数据类型：将其数据值传递给形参 形参是引用数据类型：将其地址值传递给形参 关于字符串作为形参的情况 123456789101112public class p1 { static void change(String s2) { s2 = &quot;bbb&quot;; } public static void main(String[] args) { String s1 = &quot;aaa&quot;; change(s1); System.out.println(s1); }}//打印结果：aaa Java中的String对象具有不可改变性，这里java在常量池中开辟了一块区域给aaa，s1指向aaa。change函数的形参仍然是地址传递（String是引用数据类型），s2也指向aaa，然后s2=&quot;bbb&quot;即将s2指向bbb，s1的指向并未改变。因此最终打印的结果仍然是aaa 3.4 四种权限修饰符封装性的体现： 我们将类的属性xxx私有化，同时，提供公共方法来获取和设置它。 不对外暴露的私有的方法 单例模式 … 我们设计程序追求“高内聚、低耦合” 高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅对外暴露少量的方法用于使用 Java规定了4种权限：private, (default), protected, public| 修饰符 | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 || ——— | —— | ——– | ———— | ———- || private | Yes | | | || (default) | Yes | Yes | | || protected | Yes | Yes | Yes | || public | Yes | Yes | Yes | Yes | 四种权限可以用来修饰类以及类的内部结构：属性、方法、构造器、内部类 对于class的权限修饰，只可以用public和default（缺省） public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 3.5 构造方法说明 如果没有显示地定义类的构造器的话，系统默认会提供一个空参的构造器；一旦我们显示定义了类的构造器之后，系统就不再提供默认的空参构造器。 定义构造器的格式：权限修饰符 类名(形参列表){...} 构造器可以重载 3.6 JavaBean说明 JavaBean是一种Java语言写成的可重用组件 所谓JavaBean，是指符合以下标准的Java类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get和set方法3.7 UML类图3.8 this说明 它在方法内部使用，即这个方法所属对象的引用 它在构造器内部使用，表示该构造器正在初始化的对象 用于构造器调用其他构造器（必须声明在当前构造器的首行，且最多只能使用一次）1234567891011public Person{ public Person(){...} public Person(int age){ this(); ... } public Person(int age,string name){ this(age); ... } } 3.9 JDK中主要的包介绍 java.lang：包含Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能 java.net：包含执行与网络相关操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用的工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具及(abstract window toolkits）的多个类，用于构建和管理应用程序的GUI，现在不常用了。3.10 MVC设计模式MVC是常用的设计模式之一，将整个程序分为三个层次：视图、控制器、数据模型。3.11 import关键字说明 可以使用xxx.*方式，导入xxx包下的所有结构（子包除外，需要再显示声明） java.lang包或本宝下定义的类和接口，可以省略import 如果在源文件中，使用了两个不同包下的同名的类，则至少有一个要以全类名的方式书写（xxx.xxx.类名) import static ：导入指定类或接口中的静态结构（落脚点不是类，而是某个结构，属性或方法，或者写*），用的少。12345import static java.lang.System.*;import static java.Math.*;//这样可以省略System、Mathout.println(&quot;abc&quot;);long a=round(1.23); 4. 继承Java对继承的规定 单继承：一个子类只能有一个父类 直接继承的是直接父类，间接继承的是间接父类 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法，但是能否访问还得看权限修饰符。 4.1 Object类 如果我们没有显示地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除了java.lang.Object类）都直接或间接继承于java.lang.Object类4.2 方法重写 定义：在子类中可以根据需要对从父类继承来的方法进行改造。在程序执行时，子类的方法将覆盖父类的方法 要求： 重写的方法必须与父类具有相同的方法名和参数列表 重写的方法的返回值类型不能大于父类被重写的方法的返回值；如果父类返回的是基本数据类型，那么子类也必须是。 子类重写的方法使用的访问权限不能小于父类被重写的方法的权限 子类不能重写父类中声明为private权限的方法 子类方法跑出的异常不能大于父类被重写的方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static（不是重写）。因为static方法属于类，子类无法覆盖父类的static方法。 4.3 super关键字 说明 可以在子类的方法或构造其中，使用super.属性或者super.方法的方式，显示地调用父类中声明的方法或属性。通常情况下， 省略super 特殊情况下，当子类和父类方法名或属性名重名时，显示调用super super调用构造器 可以在子类的构造器中显示地使用super(形参列表)的方式，调用父类中声明的指定的构造器 必须在子类构造器的首行 类的构造器中，this(形参列表)和super(形参列表)只能二选一，不能同时出现 在构造器的首行，如果没有显示地声明 this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器；注意，子类构造器必须直接或间接地调用父类构造器，如果没有声明，则调用父类的默认空参构造器（如果父类没有，则报错）。4.4 子类对象实例化过程 从结果上看子类继承父类之后，就获取了父类中声明的属性和方法；创建子类的对象，在堆空间中，就会加载所有父类中声明的属性 从过程上看当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 4.5 抽象类与抽象方法4.6 接口5. 多态5.1 概述 理解多态性：是面向对象中最重要的概念，在Java中的体现就是父类的引用指向子类的对象。可以直接应用在抽象类和借口上。 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际给该变量赋值的对象决定。简而言之：编译时看左，运行时看右。 若编译时和运行时类型不一致，就出现了对象的多态性（Polymorphism） 多态情况下： 看左边：看的是父类的引用（父类中不具备子类特有的方法） 看右边：看的是子类的对象（实际运行的是子类重写父类的方法） 多态使用的前提 类的继承关系 方法的重写 多态性不适用于属性（编译和运行时都看左边） 多态的意义：多态是面向对象中最重要的概念，没有多态性，就没有后面的抽象类、接口等概念。 虚拟方法调用：子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。 如何证明多态是运行时行为？（编译时无法确定类型，动态绑定） 12345678910111213141516171819202122232425262728293031323334353637383940414243package July.demo01;import java.util.Random;public class Animal { void speak(){ } static Animal getInstance(int key){ switch(key){ case 0: return new Dog(); case 1: return new Cat(); default: return new Rabbit(); } } public static void main(String[] args) { int key= new Random().nextInt(3); Animal animal=getInstance(key); animal.speak(); }}class Dog extends Animal{ void speak(){ System.out.println(&quot;Dog!&quot;); }}class Cat extends Animal{ void speak(){ System.out.println(&quot;Cat!&quot;); }}class Rabbit extends Animal{ void speak(){ System.out.println(&quot;Rabbit!&quot;); }} 5.2 重载和重写 5.3 instanceof 操作符与向下转型如何才能调用子类特有的方法和属性？向下转型，使用强制类型转换符。使用强转的时候，可能出现ClassCastException异常。a instanceof A：如果a是A的实例，或者是A的子类的实例，则返回true 对于引用数据类型来说，强制类型转换的前提是，堆内存中存在转换后类型（或子类）的对象，否则不能转换。 123456//Man是Person的子类Person p=new Person();Man m=(Man)p; //错误！堆内存中是Person类型对象Object obj=new Man();Person p=(Person)obj; //可以执行！内存中有Man类型对象，也是Person子类的实例。 6. 补充内容6.1 Object类 Object类是所有Java的根父类 如果定义一个类没有声明父类，则默认继承java.lang.Object Object类只声明了一个空参的构造器 Object类方法（所有类的通用方法） equals toString getClass hashCode clone finalize6.2 ==和equals ==运算符 1.比较基本数据类型：比较值。注意可以类型不同，如int a=1; float b=1.0，a和b==运算的结果是true。（boolean不能参与运算） 2.比较引用数据类型：比较在内存中的地址值。 为何有些情况下，直接定义String的时候，可以直接用==判断两个String值相等？因为String存在字符串常量池的问题（但不是所有String都在里边，也有可能两个相同的String不指向同一个引用）。 equals方法 1.只能用于引用数据类型2.Object中的equals是用==实现的3.IDE自动生成的equals方法 6.2 包装类 基本数据类型、包装类和String之间的转换 自动装箱与自动拆箱包装类和基本数据类型之间可以直接进行互相赋值 123int a=1;Integer b=a;a=b; 基本数据类型、包装类–&gt;String方式一：使用&quot;&quot;+连接方式二：String.valueOf() String–&gt;基本数据类型、包装类 包装类的一些问题 6.3 关键字：static 修饰属性 修饰方法 单例设计模式 饿汉式： 优点：线程安全 缺点：资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类，那么这个实例仍然初始化 懒汉式： 优点：延迟加载，需要用到实例的时候再加载 缺点：线程不安全（有改进的方法） 12345678910111213141516171819202122//单例之饿汉式public class House { private static House house=new House(); public static House getInstance(){return house;} private House(){}}//单例之懒汉式class Country{ private Country(){} private static Country count=null; public static Country getInstance(){ if(count==null) count=new Country(); return count; }} 单例模式应用场景6.4 类的成员：代码块 代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 可以定义多个，按照声明的先后顺序执行 分类： 静态代码块：随着类的加载而加载，并执行；随着类的加载而执行，而且只执行一次 非静态代码块：随着对象的创建而加载，并执行；每创建一个对象，就执行一次6.5 关键字：final 修饰类：不能被继承 修饰方法：不能被重写 修饰变量：此时的变量变为了一个常量。 基本数据类型：变量一旦赋值后，不能被重新赋值。 引用数据类型：引用指向不能发生改变。6.6 抽象类与抽象方法abstract可以用来修饰类、方法，不能修饰私有方法、静态方法、final的类、方法 修饰类：抽象类 此类不能实例化 仍然提供构造器（子类要调用），类中一定有构造器。 修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之不然。 子类重写父类中的所有抽象方法后，此子类方可实例化 抽象类的匿名子对象模板方法设计模式 抽象类和接口的区别 1抽象类是一种对事物的抽象，而接口是一种对行为的抽象； 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 抽象类是一种模板式设计，而接口是一种行为规范，是一种辐射式设计。 6.7 接口 Java不支持多继承，但是有了接口，就可以实现多重继承的效果。接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。 说明： interface接口不能定义构造器，意味着接口不能实例化。 类implements接口 如果类没有实现接口中的所有抽象方法，则此类仍然是一个抽象类 接口和接口之间可以继承，而且可以多继承 JDK8之后，除了定义全局常量public static final和抽象方法以外，还可以定义静态方法、默认方法。 接口中的所有属性（全局静态常量）和方法，都是public的，即使不加，系统也自动声明为public。 接口匿名实现类6.8 接口应用：代理模式（Proxy） 概述：代理模式是Java开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制这个对象的访问。如明星（被代理类）和经纪人（代理类），租房者（被代理类）和中介（代理类）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class proxyPatternDemo { public static void main(String[] args) { Proxy proxy=new Proxy(new Server()); while(true){ proxy.browse(); System.out.println(); } }}//浏览网页的接口interface NetWork { void browse();}//被代理类class Server implements NetWork{ @Override public void browse() { System.out.println(&quot;正在访问该网站&quot;); }}//代理类class Proxy implements NetWork{ private NetWork netWork; public Proxy(NetWork netWork){ this.netWork=netWork; } private boolean check() throws InterruptedException { System.out.println(&quot;正在做访问网络前的检查...&quot;); Thread.sleep(1000); return new Random().nextInt(100)%2==0; } @Override public void browse(){ try { boolean res=check(); if(res){ System.out.println(&quot;校验通过，允许访问！&quot;); netWork.browse(); }else{ System.out.println(&quot;校验不通过，不允许访问！&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} 应用场景 分类 静态代理（静态定义代理类） 动态代理 （动态生成代理类） JDK自带的动态代理，需要反射等知识。 6.9 接口的应用：工厂设计模式 工厂模式概念：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 核心本质：实例化对象，用工厂方法代替new操作；将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 工厂模式的分类 简单工厂模式：用来生产同一等级结构中的任意产品。（对于新增加的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） //简单工厂模式 123456789101112131415161718192021222324252627282930313233343536public interface Car { public void run();}class BMW implements Car{ @Override public void run(){ System.out.println(&quot;BMW is running~&quot;); }}class Mercedes_Benz implements Car{ @Override public void run(){ System.out.println(&quot;Benz is running~&quot;); }}//Car工厂类class carFactory{ public static BMW getBMW(){ return new BMW(); } public static Mercedes_Benz getBenz(){ return new Mercedes_Benz(); }}class Test{ public static void main(String[] args) { Car car1=carFactory.getBenz(); Car car2=carFactory.getBMW(); car1.run(); car2.run(); }} //工厂方法模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Car { void run();}class Benz implements Car{ @Override public void run() { System.out.println(&quot;Benz is running...&quot;); }}class Audi implements Car{ @Override public void run() { System.out.println(&quot;Audi is running...&quot;); }}//工厂接口interface carFactory{ Car getCar();}//宝马工厂class BenzFactory implements carFactory{ @Override public Benz getCar() { return new Benz(); }}//奥迪工厂class AudiFactory implements carFactory{ @Override public Car getCar() { return new Audi(); }}class Test{ public static void main(String[] args) { Car car1=new AudiFactory().getCar(); Car car2=new BenzFactory().getCar(); car1.run(); car2.run(); }} 6.10 JDK8接口静态方法、默认方法 静态方法：接口中定义的静态方法，只能通过接口来调用（不能用实现类来调用） 默认方法：类似让接口拥有类的功能，让实现类拥有该方法。通过实现类对象来调用（可以重写）。 public即使不加，系统也会自动加上1234567891011121314151617public interface Test { public static void method1(){ //... } static void method2(){ //... } public default void method3(){ //... } default void method4(){ //... }} 6.11 内部类 概念：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 Inner class 一般用在定义它的类或者语句块之内，在外部引用它时必须给出完整的名称。 分类 成员内部类：static成员内部类和非static成员内部类 局部内部类（不谈修饰符）：匿名内部类 1234567891011public class Person { //静态成员内部类 static class Cat{} //非静态成员内部类 class Dog{} void f(){ //局部内部类 class Fish{} } } 7. 异常处理7.1 异常概述与异常体系结构 为什么需要异常处理因为有很多问题不是靠代码能够避免的，比如：用户输入数据的格式，读取文件是否存在，网络是否始终保持畅通等等 异常：在程序执行过程中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常） 分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。如：StackOverflowError和OOM。一般不编写针对性的代码进行处理 Excepetion：其他因编程错误或者偶然的外在因素导致的一般性稳提，可以使用针对性的代码进行处理，例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组访问越界 Exception又分为：编译时异常(checked受检异常）和运行时异常 7.2 常见异常编译时异常 IOException —-FileNotFoundException ClassNotFoundException 运行时异常（编程实践中，一般对运行时异常不做处理） NuLLPointerException12345678//试图堆一个空对象调用方法时，就会产生空指针异常public class Main { @Test public void test(){ Date date=null; date.getTime(); }} ArrayIndexOutOfBoundsException ClassCastException1234567public class Main { @Test public void test(){ Object obj=new String(&quot;abc&quot;); Main main=(Main)obj; }} NumberFormatException123456public class Main { @Test public void test(){ int num=Integer.parseInt(&quot;abc&quot;); }} InputMismatchExceptionScanner输入int，结果用户输入abc，会报此异常 ArithmeticException123456public class Main { @Test public void test(){ int a=10/0; }} 7.3 异常处理机制一：try-catch-finally使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于把一个编译时可能出现的异常，延时到运行时出现（转变为运行时异常）。所以，对于运行时异常，一般不做处理。使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的类，并且终止try中代码的执行，根据此异常的类型去catch中进行匹配。try-catch-finally执行完了，继续执行下面的其他代码。 常用的异常对象处理的方式1.String getMessage()2.void printStackTrace() try-catch-finally结构可以嵌套 注意：如果catch多个异常存在父子关系的话，子类要放在上边 7.4 异常处理机制二：throws1.使用throws向上抛出异常，出现异常时，异常后序的代码将不再执行2.throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 注意：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（或者不抛）（原因：多态时，父类引用指向子类对象，调用同名方法，并且进行异常处理时，如果子类方法异常类型大于父类类型，则无法处理） 1234567891011121314151617181920212223242526public class Main { @Test public void test() { f(new Son()); } public void f(Father person){ try { person.method(); } catch (IOException e) { e.printStackTrace(); } }}class Father{ void method()throws IOException{ }}class Son extends Father{ void method()throws FileNotFoundException{ }} 7.5 两种异常处理方式的选择1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理2.执行的方法A中，先后又调用了另外几个方法bcd，这几个方法是递进关系的（需要利用上一个方法的返回值）。建议这几个方法使用throws进行处理。而执行的方法A考虑使用try-catch-finally方式进行处理。（如果在b直接进行try-catch处理，cd会正常执行，但是利用的返回值是无效的） 7.6 手动抛出异常：throw关于异常对象的产生：1.系统自动生成的异常对象2.手动的生成一个异常对象，并throw 123456789101112131415public class ThrowTest { public static void main(String[] args) { new Student(-100); }}class Student{ private int id; Student(int id){ if(id&gt;0) this.id=id; else throw new RuntimeException(&quot;输入的id非法&quot;); }} 运行结果 12345678910111213141516171819public class ThrowTest { public static void main(String[] args) { try { new Student(-100); } catch (Exception e) { System.out.println(e.getMessage()); } }}class Student{ private int id; Student(int id) throws Exception{ if(id&gt;0) this.id=id; else throw new Exception(&quot;输入的id非法&quot;); }} 运行结果 7.7 用户自定义异常类如何自定义异常类?1.继承于现有的异常结构：RuntimeException, Exception2.提供全局常量序列号: serialVersionUID (类的唯一标识）3.提供重载的构造器 12345678910class MyException extends RuntimeException { static final long serialVersionUID = 123L; public MyException() { } public MyException(String msg) { super(msg); }}","link":"/2020/07/11/Java/java%E5%9F%BA%E7%A1%80/"},{"title":"Java基础","text":"1.多线程1.1 基本概念：程序、进程、线程程序：一段静态的代码进程：正在运行的程序，是资源分配的基本单位。线程：是CPU执行和调度的最小单位，每个线程拥有独立的运行栈和程序计数器pc，线程切换的开销比较小。多个线程共享一个进程的资源（共享进程的方法区和堆，但存在安全隐患）。 在Java的内存区域中，栈区（虚拟机栈）和程序计数器是每个线程一份，方法区和堆区，是每个进程一份，各个线程共享。 使用多线程的优点1.资源利用率提升，程序处理效率提高2.改善程序结构，代码会相对简单3.软件运行速度提升，提升应用程序的响应速度 何时需要多线程1.程序需要同时执行两个或多个任务2.程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等3.需要一些后台运行的程序时 Java程序至少有3个线程1.主线程2.垃圾回收线程3.异常处理线程（会影响主线程） 1.2 线程的创建和使用Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 Thread类的特性1.每个线程都是通过特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run()3.Thread类实现了Runnable接口 start方法作用1.启动当前线程2.调用当前线程的run方法 注意1.不能通过调用run方法来启动线程（仍然在主线程中执行）2.额外再启动一个线程，需要重新创建一个线程的对象 两种创建线程的方法1.继承Thread类，重写run方法2.实现Runnable接口，实现run方法，在Thread构造器中传入一个Runnable接口实现对象 两种创建线程方法的比较开发中，优先选择Runnable接口的方法1.实现的方式没有类单继承性的限制2.实现的方式更适合来处理多个线程共享数据的情况 注意，这里ticket没有加static，就实现了三个线程共享ticket 1234567891011121314151617181920212223242526class Sell implements Runnable { private int ticket = 100; @Override public void run() { while (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖&quot; + ticket + &quot;号票&quot;); ticket--; } }}/* * 死锁的四个必要条件 * 1.互斥访问：共享资源互斥访问 * 2.请求并保持：已经持有资源的情况下，申请别的资源未果，也不释放自己持有的资源 * 3.不可剥夺：进程申请的资源除了完成任务释放，别人无法将其释放 * 4.循环等待：系统中存在资源循环等待的链条*/public class Demo { public static void main(String[] args) { Sell sell = new Sell(); new Thread(sell).start(); new Thread(sell).start(); new Thread(sell).start(); } Thread类常用方法1.void start()：启动当前线程；调用当前线程的run()2.run()：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中3.String getName()4.void setName()5.static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。6.yield()：释放cpu的执行权（有可能紧接着又获取了cpu的执行权）7.h.join()：在线程a中执行h.join()，会阻塞当前线程a，直到h线程执行完，线程a才结束阻塞状态8.stop()：强制线程生命周期结束，deprecated 不推荐使用，因为不安全，过时的api9.static void sleep(long millis)：睡眠(阻塞)若干毫秒；静态方法，可以直接调用。注意：如果是在run方法中使用sleep，则处理sleep的异常只能try-catch，无法throws；因为是重写Thread的run方法，其并无异常抛出，故子类重写也无法抛出异常。10.bool isAlive()：判断当前线程是否存活（是否执行完了），阻塞状态下返回值也是true。 获取线程名称Thread.currentThread().getName(); 更改线程名称1.通过Thread.currentThread().setName();2.通过构造器 123456789class MyThread extends Thread{ public MyThread(String name){ super(name); } public static void main(String[] args) { Thread t1=new MyThread(&quot;一号线程&quot;); }} 使用匿名对象执行开启线程 12345678new Thread(){ private int count=0; @Override public void run(){ while(true) System.out.println(count++); } }.start(); 1.3 线程的调度 Java的调度方法 1.同优先级线程组成先进先出队列（先到先服务），使用时间片策略2.对于高优先级，使用优先调度的抢占式策略 线程的优先级 1.线程的优先级等级：MAX_PRIORITY:10,MIN_PRIORITY:1,NORM_PRIORITY:52.获取和设置当前线程的优先级：getPriority(),setPriority(int p) 注意：并不是优先级高的执行完再执行优先级低的，而是优先级高的获取CPU的概率更高 1.4 线程的分类在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆： 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。下面的方法就是用来设置守护线程的。 1234567Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 1.5 线程的生命周期 1.6 线程的同步线程同步，主要用来解决线程的安全问题。 例：创建三个线程卖票，总共100张1.问题：卖票过程中，出现了重票、错票（0，-1号票）–&gt;出现了线程的安全问题2.问题出现的原因：某线程操作车票时，别的线程也参与进来3.如何解决：某线程操作车票时，即使出现阻塞（例如sleep(100);)，别人也不能参与进来。4.在Java中，我们通过同步机制，来解决线程的安全问题 解决方式 同步代码块a.同步监视器（又叫锁）：任何一个对象都可以作为锁；要求多个线程必须要共用同一把锁。b.同步原理：当一个线程执行代码碰到一个锁时，如果已经有别的线程使用了锁并且没有归还，那么本线程就阻塞在这里。 继承Thread方式 1234567891011121314151617181920212223242526public class p1 { public static void main(String[] args) { Sell s1 = new Sell(); Sell s2 = new Sell(); Sell s3 = new Sell(); s1.start(); s2.start(); s3.start(); }}class Sell extends Thread { public static int ticket = 10000; @Override public void run() { while (true) { synchronized(Sell.class) { if (ticket &gt; 0) { System.out.println(getName() + &quot;出售第&quot; + ticket + &quot;张票&quot;); ticket--; } else break; } } }} 这里的Sell.class充分说明了，在Java中类也是对象 实现Runnable接口方式 1234567891011121314151617181920212223242526public class p2 { public static void main(String[] args) { Sell2 sell=new Sell2(); Thread t1=new Thread(sell); Thread t2=new Thread(sell); Thread t3=new Thread(sell); t1.start(); t2.start(); t3.start(); }}class Sell2 implements Runnable { private int ticket=10000; @Override public void run() { while(true){ synchronized(this){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); else break; } } }} 同步方法如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。 实现Runnable接口方式 1234567891011121314151617181920212223242526272829public class p3 { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; @Override public void run() { while (ticket &gt; 0) { sell(); } } private synchronized void sell() { if (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); } }} 继承Thread方式，注意这里的sell方法必须要加static，否则会出现安全问题（不加static，同步方法所用的锁，不是同一个） 同步方法不加static，使用的是this作为锁。加了static，使用的是类名.class作为锁 1234567891011121314151617181920212223242526public class p4 { public static void main(String[] args) { Window4 w1=new Window4(); Window4 w2=new Window4(); Window4 w3=new Window4(); w1.start(); w2.start(); w3.start(); }}class Window4 extends Thread{ private static int ticket=10000; @Override public void run(){ while(ticket&gt;0) sell(); } private static synchronized void sell(){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); }} 使用同步锁1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t3.setName(&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); if (ticket &gt; 0) System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); else break; } finally { /*保证无论发生什么特殊情况，一定能够释放锁*/ lock.unlock(); } } }} 可重入锁 ReentrantLock 1一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；如果有两个不同的方法用到同一个锁，其中方法A里面又调用了方法B，那就不会死锁了 面试题：synchronized和Lock的区别？synchronized在执行完同步代码以后，自动释放同步监视器Lock方式手动加锁和释放锁，更加灵活。 1.7 改造懒汉单例模式使之线程安全**注意，写了两次判断instance==null**，这样效率最高。只在首次访问的时候进行同步，后续已经有instance的情况下无需同步，直接返回instance，最大化效率。 1234567891011121314151617181920//单例模式之懒汉式class Tool { private static Tool instance = null; //私有化构造方法 private Tool() { } public static Tool getInstance() { if (instance == null) { synchronized (Tool.class) { if (instance == null) instance = new Tool(); } } return instance; }} 1.8 线程的死锁问题死锁：1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续（操作系统中学到的定义：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，这些永远都在互相等待的进程，称为死锁进程） 解决方法1.专门的算法、原则2.尽量减少同步资源的定义3.尽量避免嵌套同步 死锁发生的四个必要条件1.互斥：共享资源互斥访问2.请求并保持：进程请求资源未果，不会释放自身已经占有的资源3.不可剥夺：只有进程自身使用完资源后才会释放，别人无法将其释放4.循环等待：多个进程之间存在资源请求的环路 预防死锁1.破坏请求并保持条件：一次性请求所有需要的资源，否则就不申请2.破坏不可剥夺条件：请求资源未果，释放自身占有的资源3.破坏循环等待条件：可用资源线性排序，只能从低到高申请资源 避免死锁银行家算法：已分配资源表、可用资源表、所需资源表；每次分配给一个能够满足其需求的进程，该进程执行完后返还所有的资源，不断循环。 1在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 预防死锁和避免死锁的区别预防死锁是通过破坏死锁发生的必要条件中的一个，限制条件比较严格，可能造成系统资源利用率和系统吞吐率的下降。避免死锁施加的条件比较宽松，在资源的动态分配中，避免系统出现不安全状态。 1.9 线程的通信例题：使用两个线程打印1~100。线程1，线程2交替打印 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r = new Count(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; @Override public void run() { while (true) { synchronized (this) { notify(); //或者this.notify, 如果用的是某个obj，则obj.notify if (num &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;数&quot; + num--); } else break; try { wait(); /*自我阻塞，wait会自动释放锁（与sleep的区别）*/ } catch (InterruptedException e) { e.printStackTrace(); } } } }} 涉及到的三个方法1.wait()：一旦执行此方法，当前线程就进入阻塞状态， 并释放同步监视器2.notify()：一旦执行此方法。就会唤醒被wait的一个线程。如果有多个，则唤醒优先级最高的3.notifyAll()：唤醒所有wait的线程 说明1.wait(), notify(), notifyAll() 三个方法必须使用在同步代码块或者同步方法中2.三者的调用者必须是同步代码块或同步方法中的同步监视器，否则会报异常，不加调用者默认是this.3.三者是定义在java.lang.Object类中的 上述例题也可以使用公平锁来实现（存在一个等待队列，先进先出）,注意要使用finally来保证unlock的执行 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r=new Count(); Thread t1=new Thread(r); Thread t2=new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; ReentrantLock lock = new ReentrantLock(true);/*fair lock*/ @Override public void run() { while(true){ try{ lock.lock(); if(num&gt;0) System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num--); else break; } finally { lock.unlock(); } } }} 生产者消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Main { public static void main(String[] args) { Clerk clerk = new Clerk(); new Thread(new Consumer(clerk)).start(); new Thread(new Consumer(clerk)).start(); new Thread(new Producer(clerk)).start(); }}class Clerk { private int products = 0; public synchronized void produce() { //notity(); 也可以写这里 if (products &lt; 20) { System.out.println(&quot;生产者生产第&quot; + (++products) + &quot;个商品&quot;); this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void consume() { if (products &gt; 0) { System.out.println(&quot;消费者消费第&quot; + products-- + &quot;个商品&quot;); if (products &lt; 20) this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produce(); } }}class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consume(); } }} 这里有个疑问：如果把sleep写在两个同步方法中，while中只有调用，则会出现每次生产者生产满20个消费者才去消费，每次消费者消费完了生产者才开始生产。即每轮while循环结束同步方法都不释放锁。（在while中随意加入一个语句如print，则此现象消失，正常交替执行） 1.10 JDK5.0新增线程创建方式新增方式一：实现Callable接口与Runnable相比，Callable功能更强大1.相比run()方法，可以有返回值2.方法可以抛出异常（重写Runnable中的run不能抛出异常，因为Runnable接口中的run没有抛 ）3.支持泛型的返回值4.需要借助FutureTask类，比如获取返回值 123456789101112131415161718192021222324252627282930import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask futureTask = new FutureTask(count); new Thread(futureTask).start(); Object ans = null; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 使用泛型 12345678910111213141516171819202122232425public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(count); new Thread(futureTask).start(); int ans = 0; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable&lt;Integer&gt; { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 新增方式二：使用线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中的线程，不需要每次都创建）3.便于线程管理：corePoolSize核心池的大小maximumPoolSize最大线程数keepAliveTime 线程没有任务时最多保持多长时间后会终止 线程池相关API1.JDK5.0起提供了线程池相关API：ExecutorService和Executors2.ExecutorService 真正的线程池接口.常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令,没有返回值,一般用来执行Runnable &lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):执行任务,有返回值,一般用来执行Callable void shutdown():关闭连接池 3.Executors:工具类、线程池的工厂类,用于创建并返回不同类型的线程池 Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n):创建一个线程池,它可以安排在给定延迟后运行命令或者定期地执行 1234567891011121314151617181920212223242526272829303132333435363738public class Main { public static void main(String[] args) { /*Executors是线程池的工厂类*/ ExecutorService server= Executors.newFixedThreadPool(10); server.execute(new Count()); server.submit(new Calculate()); /*或者使用FutureTask包装Calculate()以获取线程返回值*/ FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Calculate()); server.submit(task); try { System.out.println(task.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }}class Count implements Runnable{ @Override public void run() { int i=0; while(i++&lt;100) System.out.print(i+&quot; &quot;); }}class Calculate implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;100;i++) sum+=i; return sum; }} 练习题 谈谈你对程序、进程、线程的理解 程序：一段静态代码进程：关于进程我想谈两点，一个是为什么需要进程这个概念，另一个是进程的作用。首先，现代操作系统的一大特点就是多道程序设计，那么在此之前是单道程序设计，一个程序运行时占有所有的资源，那么就无需资源的分配和调度，也就无需进程这个概念。到了多道程序设计中，多个程序并发执行，这就涉及到了系统资源的分配和调度，诸如CPU资源、存储资源、IO资源、文件资源，那么进程这个概念就应运而生。因此进程的作用有两大点，第一，它是资源分配和调度的基本单位。第二，它是程序独立运行的载体，保障程序正常执行。线程：线程是CPU调度的基本单位，多个线程之间共享进程的资源；线程包含在进程之中，是进程中实际运行工作的单位。 操作系统四大特性：虚拟、异步、共享、并发。2. 对比两种线程的创建方式3. sleep和wait方法的异同？相同点：都能使当前线程阻塞不同点：1.sleep声明在Thread类中，wait声明在Object类中 2.sleep()可以在任何地方使用，wait()需要在同步方法或者同步代码块中调用 3.如果都使用在同步代码块或者同步方法中，sleep方法不会释放锁，wait会释放锁 2.常用类2.1 字符串相关的类String类String特性1.String类:代表字符串.Java程序中,所有字符串的字面值(如”abc”)都是String类的实例2.String是一个final类,不可以继承3.字符串是常量,值在创建之后不可改变,字符内容是存储在一个字符数组value[]中的4.通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中5.字符串常量池(位于方法区中,后来改叫meta space)中是不会存储相同内容的字符串的String对象的创建1.字面量的方式,String str=&quot;abc&quot;;2.String s=new String()3.String s=new String(String s2)4.String s=new String(char[] arr)5.String s=new String(char[] arr,int startIndex, int count) 字符串常量池存储在字符串常量池,目的是共享; 字符串非常量的对象存储在堆中 面试题1:下面的p1.name==p2.name? 123456789101112131415public class Main { public static void main(String[] args) { Person p1 = new Person(&quot;yfx&quot;); Person p2 = new Person(&quot;yfx&quot;); System.out.println(p1.name == p2.name); //true 地址相同 }}class Person { String name; Person(String name) { this.name = name; }} 面试题2:String s=new String(&quot;abc&quot;); 在内存中创建了几个对象? 答:如果常量池中没有abc,则创建了两个,有的话则创建一个(现在常量池创建”abc”,然后在堆中创建一个String对象,内容fianl char[]value指向常量池的”abc”) 面试题3:下面几种字符串连接后,在内存中实际是怎么样的? 123456789101112131415161718192021public static void main(String[] args) { String s1 = &quot;java&quot;, s2 = &quot;docker&quot;; String s3=&quot;javadocker&quot;; String s4=&quot;java&quot;+&quot;docker&quot;; //编译阶段会直接合成&quot;javadocker&quot; String s5=s1+&quot;docker&quot;; String s6=&quot;java&quot;+s2; System.out.println(s3==s4); //true System.out.println(s3==s5); //false System.out.println(s3==s6); //false System.out.println(s5==s6); //false String s7=s5.intern(); //intern():如果常量池中没有s5的字符串值,那么就在常量池中创建该字符串常量,并返回其引用;如果常量池中已经有,则直接返回引用 System.out.println(s3==s7); //true final String s8=&quot;java&quot;; //final修饰的变成常量 String s9=s8+&quot;docker&quot;; System.out.println(s3==s9); //true} 涉及到对象的连接,则都在堆中产生新的String对象; 面试题4:java的值传递 123456789101112131415161718public class Main { String str = new String(&quot;good&quot;); char[] ch = {'t', 'e', 's', 't'}; public void change(String str, char ch[]) { str = &quot;test ok&quot;; //将常量池中&quot;test ok&quot;的地址赋值给str ch[0] = 'b'; } @Test public void test() { Main obj = new Main(); obj.change(obj.str, obj.ch); System.out.println(obj.str); //good System.out.println(obj.ch); //best }} String类常用方法1.int length()2.char charAt(int index)3.boolean isEmpty()4.String toLowerCase()5.String toUpperCase()6.String trim():返回字符串的副本,忽略前导空白和尾部空白7.boolean equalsIgnoreCase(String s)8.String concat(String str):将指定字符串连接到此字符串的结尾,等价于+9.int compareTo(String s):比较两个字符串字典序10.String substring(int beginIndex):11.String substring(int beginIndex, int endIndex):按照下标截取字符串,左闭右开12.boolean endsWith(String suffix):是否以指定的后缀结束13.boolean startsWith(String prefix):是否以指定的前缀开始14.boolean startsWith(String prefix,int offset):测试此字符串从指定索引开始的子串是否以指定前缀开始 15.boolean contains(CharSequence s):当且仅当此字符串包含指定的char值序列时,返回true16.int indexOf(String str):返回子串第一次出现的索引,未找到返回-117.int indexOf(String s,int fromIndex):返回子串从偏移下标开始首次出现的索引18.int lastIndexOf(String s):反向搜索19.int lastIndexOf(String s,int fromIndex),从指定偏移量开始反向搜索 20.String replace(char oldChar,char newChar):替换所有指定字符21.String replace(CharSequence target, CharSequence replacement):替换所有指定子串22.String replaceAll(String regex, String replacement):使用给定的子串替换所有匹配正则表达式的子串23.String replaceFirst(String regex, String replacement): 24.boolean matches(String regex):告知此字符串是否匹配给定的正则表达式 25.String[] split(String regex):根据给定正则表达式的匹配拆分此字符串26.String[] split(String regex, int limit):根据给定正则表达式来拆分此字符串,最多不超过limit个,如果超过了,剩下的全部放到最后一个元素中 String与基本数据类型转换1.String转基本数据类型、包装类: 调用包装类的静态方法:parseXXX(str)2.基本数据类型、包装类转Stirng:String.valueOf(xxx)3.String转char[]:str.toCharArray()4.char[]转String:new String(char[] arr)5.String转byte[]:str.getBytes()6.byte[]转String:new String(bytes[] arr) 重载函数new String(bytes[]arr,字符集) 123456789101112131415161718public class Main { public static void main(String[] args) throws UnsupportedEncodingException { String s=&quot;abc123中国&quot;; byte[] bytes = s.getBytes();//使用默认的字符集 System.out.println(Arrays.toString(bytes)); //[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67] utf-8编码一个汉字3个字节 byte[] gbks = s.getBytes(&quot;gbk&quot;); System.out.println(Arrays.toString(gbks)); //[97, 98, 99, 49, 50, 51, -42, -48, -71, -6] gbk编码一个汉字2个字节 System.out.println(new String(bytes)); //abc123中国 System.out.println(new String(gbks)); //abc123�й� 字符集指定错误,出现乱码 System.out.println(new String(gbks,&quot;gbk&quot;)); //abc123中国 }} StringBuffer,StringBuilderString:1.不可变字符序列 StringBuffer:1.可变字符序列2.线程安全,效率低 (除了构造方法,所有方法都加了synchronized) StringBuilder:1.可变字符序列2.线程不安全,效率高 三者底层都是用char[]存储 StringBuffer和StringBuilder的扩容默认情况下,扩容为原来的2倍+2,同时将原有数组中的元素复制到新的数组中指导意义: 如果需要对字符串进行频繁的添加, 建议使用此构造器StringBuffer(int capacity) 或 StringBuilder(int capacity),提前指定容量,以免频繁扩容,降低效率 三者效率对比 123456789101112131415161718192021@Testpublic void testTimeConsume() { String s = &quot;&quot;; StringBuffer buffer = new StringBuffer(); StringBuilder builder = new StringBuilder(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) { buffer.append(i); } System.out.println(&quot;StringBuffer use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { builder.append(i); } System.out.println(&quot;StringBuilder use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { s += i; } System.out.println(&quot;String use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;);} 2.2 JDK8之前的时间APISystem静态方法System.currentTimeMillis(): 返回1970年1月1日0点到现在经历了多少毫秒,返回值是long类型 Date类有两个Date类java.util.Date和java.sql.Date(继承前边的类) java.util.Date1.构造器一:Date() 创建了一个对应当前时间的Date对象 2.构造器二Date(long time) 创建指定毫秒数的Date类 java.sql.Date对应着数据库中的日期 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Date date=new Date(); System.out.println(date); //Wed Aug 25 10:49:42 CST 2021 System.out.println(date.getTime()); //1629859782884 Date date2=new Date(1629859782884L); System.out.println(date2); //Wed Aug 25 10:49:42 CST 2021 Date date3=new java.sql.Date(2131243242334L); System.out.println(date3); //2037-07-15 /*java.util.Date转换为java.sql.Date*/ //情形一 多态,对象本身就是sql下的Date Date date4=new java.sql.Date(2315432424345L); java.sql.Date date5= (java.sql.Date) date4; //情形二 对象本身就是util下的Date,无法直接强制转换.但是他们拥有一个共同的东西,就是毫秒数 Date date6=new Date(); java.sql.Date date7=new java.sql.Date(date6.getTime()); }} Calendar类Calendar是一个抽象基类,主要用于完成日期字段之间相互操作的功能 获取Calendar实例的方法1.使用Calendar.getInstance()方法 (抽象类无法实例化,这里返回的是子类GregorianCalendar的对象,多态,用Calendar接收)2.调用它的子类GregorianCalendar的构造器 一个Canlendar的实例是系统时间的抽象表示,通过get(int field)方法来取得想要的时间信息.比如YEAR, MONTH, DAY_OF_WEEK, HOUR_OF_DAY,MINUTE, SECOND1.public void set(int field, int value)2.public void add(int field, int amount)3.public final Date getTime()4.public final void setTime(Date date) 注意1.获取月份时:一月是0, 二月是1, 以此类推, 12月是112.获取星期时,周日是1,周二是2,…,周六是7 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); //多态 System.out.println(calendar.getClass()); //java.util.GregorianCalendar //get() System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //add() calendar.add(Calendar.DAY_OF_MONTH, -10); //往前倒10个月 //getTime() Date date=calendar.getTime(); //setTime() calendar.setTime(date); //用date来设置calendar calendar.setTimeInMillis(23214325798L); //用毫秒数设置calendar }} SimpleDateFormat类用于对Date类的格式化和解析 Date类的API不易于国际化,大部分都被废弃了,java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化: 日期-&gt;文本, 解析: 文本-&gt;日期 1.格式化SimpleDateFormat(): 默认的模式和语言环境创建对象public SimpleDateFormat(String pattern) 该构造方法可以用参数pattern指定的格式创建一个对象,该对象调用public String format(Date date): 方法格式化时间对象date 2.解析public Date parse(String source): 从给定字符串的开始解析文本,以生成一个日期 1234567891011public class Main { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); /*格式化:date转String*/ String format = sdf.format(new Date()); System.out.println(format); //2021-08-25 04:00:54 /*解析*:String转Date*/ Date date = sdf.parse(&quot;2021-08-25 16:30:20&quot;); System.out.println(date); //Wed Aug 25 16:30:20 CST 2021 }} 如果用SimpleDateFormat类解析字符串成java.sql.Date,就先解析为java.util.Date,在用毫秒数转换为java.util.Date 例题1990-01-01开始,三天打鱼两天晒网,请问给定日期在做什么事情?答:用SimpleDateFomart类解析两个日期,算出毫秒值之差,然后向上整除1000*3600*24(这里用向上除法$(m+n-1)/n$), 然后结果+1(代表一共有多少天), 然后对5取模. 0~2在打渔,3~4在晒网 2.3 JDK8中新日期的APIJDK1.0包含了一个java.util.Date类,但是它的大多数方法已经在JDK1.1引入Calendar类后被弃用了.而Calendar类并不比Date号多少.它们面临的问题是:1.可变性:像日期和事件这样的类,应该是不可变得2.偏移性:Date中的年份是从1900开始的,而月份是从0开始的3.格式化:格式化只对Date有用,Calendar则不行此外,它们也不是线程安全的; 不能处理润秒等 总结:对日期和时间的操作一直是Java程序员最痛苦的地方之一 第三次引入的API是成功的,并且Java8中引入的java.timeAPI已经纠正了过去的缺陷,将在很长一段时间内它都会为我们服务 LocalDate,LocalTime,LocalDateTime其中LocalDateTime最常用 1.now(): 当前的日期、时间2.of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便3.getXxx(): 获取某项时间信息4.with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象5.plus()/minus(): 增减日期 1234567891011121314151617181920212223242526272829303132333435public void test(){ /*now(): 当前的日期、时间*/ LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); //LocalDateTime用的最频繁 System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); /*of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便*/ LocalDateTime time1 = LocalDateTime.of(2021, 8, 25, 20, 34); System.out.println(time1); /*getXxx()*/ System.out.println(localDateTime.getYear()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getDayOfYear()); System.out.println(localDateTime.getMinute()); /*with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象*/ LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(1); //不修改原来的日期,重新返回一个修改后的日期 System.out.println(localDateTime1); System.out.println(localDateTime1); LocalDateTime localDateTime2 = localDateTime1.withHour(4); System.out.println(localDateTime2); /*plus()/minus(): 增减日期*/ LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusYears(2); System.out.println(localDateTime4);} Instant类似于java.util.Date类 方法 描述 now() 静态方法,返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳 1234567891011121314151617public void test2(){ /*now(): 获取本初子午线对应的时间标准*/ Instant time1 = Instant.now();//默认是 本初子午线 的时区 /*atOffset()结合即时的偏移来创建一个OffsetDateTime量*/ OffsetDateTime time2 = time1.atOffset(ZoneOffset.ofHours(8));//改成东八区 System.out.println(time1); System.out.println(time2); /*toEpochSecond():返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳*/ long l = time2.toEpochSecond(); System.out.println(l); /*ofEpochMilli()静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象*/ Instant instant = Instant.ofEpochMilli(1532324124325L); System.out.println(instant);} DateTimeFormatter1.方式一:预定义的标准格式2.本地化相关的格式 3.自定义的格式(一般都用这个) 12345678910public void test3(){ //自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format = formatter.format(LocalDateTime.now()); System.out.println(format); //解析 TemporalAccessor parse = formatter.parse(&quot;2021-08-25 09:34:46&quot;); //LocalDateTime,LocalDate,LocalTime都实现了TemporalAccessor接口 System.out.println(parse);} 其他类 2.4 Java比较器Comparable接口Comparator接口2.5 System类2.6 Math类2.7 BigInteger和BigDecimal类3.枚举类 &amp; 注解4.Java集合5.泛型6.IO流7.网络编程8.反射9.Java8新特性10.Java9 &amp; 10 &amp; 11 新特性","link":"/2020/07/30/Java/java%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}