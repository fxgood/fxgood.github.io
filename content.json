{"pages":[],"posts":[{"title":"","text":"","link":"/2022/04/28/%E7%AE%97%E6%B3%95-leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-2/"},{"title":"java编程中遇到的问题","text":"字符串相关 使用String[]arr=str.split(“,”)，如果两个分隔符相邻，则会分割出空字符串 数字加字符串转为字符串的原理 123456这里的加号是属于运算符重载。Java在语法层面不允许用户自行重载运算符，但是内置了两个重载操作符，即字符串操作过程中的+和+=。字符串的加号与数字类型加号相比有一定区别，只满足结合律，不满足交换律。编译器在处理+时，如果发现加号两侧都是字符串字面量或常量（常量会被编译器直接转换为字面量），则会直接将两个字面量拼接，用拼接后的字符串替换原来的表达式。如果发现加号两侧不都是字符串字面量常量，但是至少有一侧是字符串类型，则会将+号转换为StringBuilder的append方法，对不是字符串类型的数值调用String.valueOf方法，然后在运行时再进行求值。如果在循环中处理加号，则会产生多个StringBuilder对象，因此不要在循环中使用加号进行字符串拼接，而是应该自己手动在循环外创建StringBuilder对象。作者：程序员吉森链接：https://www.zhihu.com/question/456036161/answer/1849811948来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 数组相关 Arrays.copyOf(arr,[len])可以复制数组，可以指定长度 Arrays.copyOfRange(T[] arr,int from,int to)，复制数组，可以指定范围，左闭右开 比较数组是否相等不能直接用equals,得用Arrays.equals 生成数组对象的hash用Arrays.hashCode(T[]) int数组反向排序 ```javaint[]arr={1,2,3,4,5,6,7,7,1,0,-2,0,0,13};List collect = Arrays.stream(arr).boxed().sorted(Comparator.reverseOrder()).collect(Collectors.toList());System.out.println(collect);//Arrays.stream(arr).boxed().sorted(Comparator.comparingInt(a-&gt;-a)).forEach(System.out::println);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 集合相关- int数组转ArrayList\\&lt;Integer&gt; - `List&lt;Integer&gt;list=Arrays.stream(pushed).boxed().collect(Collectors.toList());` - boxed表示进行装箱- ArrayList\\&lt;Integer&gt;转int数组，目前来看只能手动for循环，因为ArrayList的toArray函数只能用于对象数组。- ArrayDeque线性双端队列的性能非常好，底层使用数组实现的循环队列，没有固定的开头和结尾。因为无论是双端队列还是栈，都推荐使用它。- PriorityQueue默认是小根堆，如果要建大根堆，可以传入lambda表达式 - `PriorityQueue&lt;Integer&gt; que=new PriorityQueue&lt;&gt;((x,y)-&gt;(y-x)); //大根堆`## Deque双端队列是在可以在头尾进行删除插入操作的数据结构实现类有ArrayDeque,LinkedList所谓的头和尾,就是普通队列的取数据的位置(头)和插入数据的位置(尾)## Map- 如果遍历map.keySet(),然后对Map自身进行修改,会报错 - 原因在于,keySet()的内容和Map自身是绑定的,修改一个另一个也会动 - 而java迭代器过程中不能修改数据,否则会触发`fail-fast`- 如果想将两个数或者更多作为key,**可以采用拼接字符串作为键**# Stream API## 案例### 案例1[leetcode179 最大数](https://leetcode.cn/problems/largest-number/)注意基本数据类型必须装箱后才能使用Comparator```javaclass Solution { public String largestNumber(int[] nums) { String res = Arrays.stream(nums) .boxed() .sorted((a, b) -&gt; -(&quot;&quot; + a + b).compareTo(&quot;&quot; + b + a)) .map(Object::toString) .collect(Collectors.joining(&quot;&quot;)); if(res.charAt(0)=='0') return &quot;0&quot;; return res; }} 案例2leetcode136 只出现一次的数字 12345class Solution { public int singleNumber(int[] nums) { return Arrays.stream(nums).reduce((a,b)-&gt;a^b).getAsInt(); }} 输入输出相关 控制小数点的方式和C++差不多int ans=3;System.out.printf(&quot;%.1f&quot;,(double)ans/2); 不知道输入数据的数量时,如何进行输入while(sc.hasNext()) next和nextLine nextInt,或者next,会先先跳过无效的内容(空格 注意next也是,回车),直到有效内容出现. 然后有效输入结束后的东西均会留在缓冲区(比如空格,或回车) 注意,如果读取的是连续的回车,那么next会全部跳过,直到出现有效内容 **nextLine()**会读取缓冲区中的所有内容,直到出现回车(如果只有回车,那么读取的是空字符串) 然后会消耗掉回车(否则下一个nextLine岂不是读不到东西了?) 因此读入数字或字符串,若以回车结尾的话,紧接着再nextLine,就会读出空字符串 结论是,如果nextLine前边有数字+回车,那么需要用一个额外的nextLine吸收回车! 正则表达式相关 分割字符串如果开头和结尾有分隔符,那么不会分割出空字符串! 连续两个分隔符放在一起,会切割出空字符串 其他问题 要想给一组一对数(x,y)排序,可以用二维int数组 用一维int数组不行,因为元素是基本数据类型,lamda表达式用不了 重写hashCode方法可以直接用Objects.hash(x,y) Java和C++的自定义排序的思想有所不同 C++的cmp，满足return条件的（true），就排前边 Java的compare(o1,o2)函数：定义比大小的规则 1234bool cmp(int a,int b){ return a&lt;b; //从小到大排序 return a&gt;b; //从大到小排序} ​ javap -c xxx.class可以进行反编译，查看虚拟机到底做了什么 看到一个知乎的回答讲jvm、jre、jdk，讲的很好，将其主要观点记录下来，来自知乎用户圆胖肿： 现在java现在已经不再强调jvm概念了 以前，jvm是跨平台所需要部分的最小子集，也就是主要用来封装OS差异用的，每一种操作系统，都弄一个jvm，这样提供给上层的接口就统一了。 在jvm的基础上，再加上一些常见的类库，工具，就做成了jre，也就是java的运行时runtime 然后再在jre的基础之上，添加一些编译器等工具，这就是java的sdk（软件开发工具包）了，简称jdk。因此jdk是jre的超集，jre是jvm的超集，反过来，jvm是jre的子集，jre是jdk的子集。 以前java提供jre和jdk两个下载，如果只是运行java的字节码，jar那些的话，只下载安装jre就行，无需安装jdk，只有开发者才需要jdk。 java在9的jsgsaw之后，就不再使用jvm的概念，因为jre可以被定制了，jvm和jre被拆成了一个又一个模块，可以根据需要，删减或者加入自己编写的模块。","link":"/2022/04/09/Java-java%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Java知识点复习","text":"Java基础基本概念 JDK,JRE和JVM JDK&gt;JRE&gt;JVM jdk包括jre,编译器javac,工具(如javadoc)等,能够创建和编译程序 jre包括jvm,标准类库等,是java运行时环境 jvm是java运行字节码的虚拟 现在最常用的JVM规范的实现是:HotSpot VM 什么是字节码?采用字节码的好处是什么? 字节码是面向JVM的代码,既JVM可以理解的代码 采用字节码的好处是: 跨平台行,一次编译,随处运行 由于解释器逐行解释速度比较慢,后面引进了JIT编译器(just-in-time即时编译器),JIT在运行时编译.对于重复的字节码,jit可以将上次编译好的机器码直接拿过来用,加快了运行效率. Java是编译型语言,还是解释型语言? Java是编译和解释并存的语言. .java文件通过javac编译成.class文件,是编译过程 .class文件加载到jvm中会解释执行(解释成可以直接执行的机器码),这是解释过程 Java和C++的区别 C++是编译型语言,Java是编译和解释并存的语言 Java有垃圾回收机制GC Java没有指针 Java的类是单继承,但是可以通过接口实现多继承 java不支持运算符重载 权限修饰符? public ,任何类中都能访问;修饰类的话,java源文件必须与public类名相同 protected,同一包和不同包的子类可以访问 default,无需修饰符,同一包下可以访问 private,只能在当前类中被访问 final, finally,finalize区别 final 用在类上:不能继承 用在方法上,不能初始化 用在变量上:常量,不能修改,必须赋初值(直接赋值,构造函数,静态代码块,ps:这些都是在类的加载机制的初始化阶段对其进行赋值) 基本数据类型:值不能改变 引用数据类型:地址不能修改 finally: try-catch-finally,里边的代码无论发生什么都一定会执行 finalize: 是Object中的方法,也就意味着每个对象中都可以调用. 通知垃圾回收器回收此对象.但是不能保证会被回收. 面向对象和面向过程? 面向过程性能比较高,因为没有实例化等过程 面向对象能实现高内聚,低耦合的代码设计,使得程序易维护,易扩展 面向对象的三大特征? 封装: 将数据和方法封装到类中,实现高内聚低耦合的设计 继承:子类继承父类的成员变量和方法,并在此基础上进行拓展,提高了代码的复用性. 多态:父类引用指向子类对象. 多态又叫延迟方法,指的是子类对象的类型在编译时无法确定,只有在运行时才能确定. 基本语法 标识符和关键字的区别? 标识符是类,变量,方法等的名字 关键字是被赋予特殊含义的标识符 java语言的关键字有哪些 访问控制: public private protected 数据类型: byte short int long float double boolean char 类,方法和变量修饰符: class interface enum abstract extends implements 错误处理: try catch finally throw throws 静态方法为什么不能调用非静态成员? 静态方法属于类,在类加载的时候就会分配内存 非静态方法属于实例对象,只有对象实例化之后才会存在 因此不能在内存中不存在非静态成员的时候调用它. 重载和重写的区别? 重载: 同名方法,参数列表不同 重写:覆盖父类的相同方法 方法重写要遵循”两同两小一大”原则: 即名称,参数列表相同; 返回值类型和异常类型应该比父类小或相同;访问权限应该比父类大或相同 可变长参数? 只能放在参数列表最右边 编译后实际会被转换为一个数组 在方法重载时不会被优先匹配 基本类型和包装类型的区别? 基本数据类型有默认值,而包装类型是对象类型,不赋值的话是null 基本数据类型不能作为泛型 包装类型在堆上分配内存,而基本数据类型的局部变量存放在java虚拟机栈的局部变量表中.(非静态成员变量如果用基本数据类型,那么会存放在堆中) 包装类型的缓存机制了解吗? Java的方法参数只有值传递,也是就方法得到的是所有参数值的一个副本 String特点 不可变 原因是底层byte[]value数组用final和private修饰了,既不能改变指向,也不能访问而修改 好处在于易于共享、可以避免多线程并发同时更新带来的麻烦(因为不可变,因此可以放心地让多个线程共享) 字面量都放在方法区的字符串常量池中(线程共享),同样的字符串只会保留一份 因为实际开发中字符串使用的太频繁了,为了提高执行效率,所以都放在字符串常量池中 要点 “abc”+”def” 执行这句会在字符串常量池中创建三个字符串 String s1=new String(&quot;abc&quot;); String s2=new String(&quot;abc&quot;); 内存中一共有三个对象. 堆中有两个String类型对象,都指向方法区字符串常量池的字面量”abc”. String、StringBuilder、StringBuffer的区别 String底层字节数组不可变，另外两个可变 StringBuilder线程不安全，执行速度快 StringBuffer线程安全，执行速度慢，内部方法加了synchronized 为什么jdk9将底层的char[]改成了byte[] 因为更加节省空间 纯英文的字符串可以用Latin-1编码,一个字符占一个字节,如String name=”jack”,占4个字节 带有中文的字符串 String name=”人山人海”,采用utf-16,就要占2*4=8个字节 (String源码中用coder来区分编码方式) synchronized关键字对象析构与finalize方法 java有垃圾回收机制,不需要人工回收内存 java不支持析构器 finalize可以通知gc进行垃圾进行,但是不能保证立即被清理 C++类的大小这篇文章写的很详细,不过最后一个案例感觉有点问题 空类1字节(编译器会用char占一个字节,C++中char是一个字节的,java是两个字节,utf-16编码) 32位系统指针大小为4字节,64位指针大小为8字节(CPU通用寄存器的大小,64位寻址空间为2^64字节) 存在虚指针时,要添加指向虚表的地址,因此多一个指针的大小(32位4字节,64位8字节),并且一定在类的最前边,因此继承的时候也要放在内存位置最前边 多个虚指针,也只会占用一个指针大小的内存,因为只需要一个指向虚表的指针 内存对齐 1234567891011121314151617181920212223class T{ } //占用一个字节 编译器会用char占一个字节 继承的时候会抹掉class A{ int i, j;}; //8字节 i i i i j j j j class B{ char ch; int i;};//8字节 ch _ _ _ i i i i class C{ char ch1, ch2; int i;};//8字节 ch1 ch2 _ _ i i i i class D{ char ch1; int i; char ch2;};//12字节 ch1 _ _ _ i i i i ch2 _ _ _ //注意,这里i不能再往前了,int变量的起始位置必须是4的倍数 有vptr的类, 会在最前端存放一个指向虚表的指针(不论内部有多少个虚函数,都只有一个这样的指针) 12345678910111213141516171819202122232425class A{ virtual void fun() {} int i, j;}; // 16字节class B{ virtual void fun() {} char ch; int i; }; // 16字节class C{ virtual void fun() {} char ch1, ch2; int i;}; // 16字节class D{ virtual void fun() {} char ch1; int i; char ch2;}; // 24字节 带有继承的类 12345678910111213class A {}; //1字节class B : A {}; // 1字节class A{ char i;};class B : A{ char ch; int i;}; // 8字节 A.i ch _ _ i i i i 有虚指针的基类 1234567891011121314151617class A{ virtual void fun() {} virtual void f2(){} char i;}; // 16字节class B : A{ char ch; int i;}; // 16字节 vptr vptr vptr vptr vptr vptr vptr vptr i ch _ _ i i i i class C : A{ int i; char ch;}; // 24字节 1234567891011class A{ virtual void f(); virtual void f3(); virtual void f5(); virtual void f6();};//8字节class B:A{ virtual void f2(); virtual void f4(); virtual void f3();};//8字节 有虚指针的子类 123456789101112class A{ virtual void fun() {} char i;}; // 16字节class B : A{ virtual void fun() {} char ch; int i;}; // 24字节 集合ArrayList底层结构: 底层是Object数组 如果不指定初始化长度,则先创建一个长度为0的数组,在第一次add的时候创建一个长度为10的Object数组(在源码grow方法中可以看到) 如果容量不够,会扩大1.5倍,底层用的是Arrays.copyOf(xx,xx)复制数组; 特点: 由于是顺序结构,所以具有顺序结构所有的优缺点 优点: 支持随机访问 查询效率高 缺点: 扩容的话,涉及到数组的复制,效率非常低 增删效率低 线程不安全 如何变成线程安全的? 答:使用Collections.synchronizedList(List list)方法返回一个线程安全的List LinkedList底层结构: 双向链表 特点: 实现了List和Deque双端队列接口 由于底层是双向链表,所以具有链表结构的所有优缺点 优点 增删效率高 不需要连续的存储空间 缺点: 查询效率低,每次需要从头节点开始遍历找到目标节点 线程不安全 如何变成线程安全的? 答:使用Collections.synchronizedList(List list)方法返回一个线程安全的List Vector底层: 数组 特点: 与ArrayList最大区别就是线程同步(线程安全,其方法都是带有synchronized关键字) 每次扩容是原来的两倍 SetHashSet内部存了一个HashMap TreeSet内部存了一个TreeMap HashMap 数据结构中哈希有哪些方法 除留余数法 % 直接定址法 $H(key)=key$或$H(key)=a*key+b$ 不会产生冲突 适合关键字分布基本连续的情况 数字分析法 如手机号码作为关键字设计散列函数,那么前面几位基本上都是138,139.所以可以用后面4位作为三列地址 要取分布比较均匀的几位数字 缺点是需要知道关键字集合的特点,如果更换了关键字集合则必须重新设计散列函数 平方取中法: 取关键字平方值的中间几位作为三列地址 优点: 与各位数字都相关,因此散列地址比较均匀 适用于关键字的每一位取值都不均匀的情况 什么是装填因子 装填因子=表中记录数/散列表长度 HashMap中使0.75 会直接影响查找效率 有哪些解决hash冲突的方法 开放定址法(用空位来解决冲突) $H_i=(H(key)+d_i)%m$,其中di增量有不同的取法 线性探测法: 越早遇到空位置,就可以越早确定查找失败 平方探测法 伪随机序列法 拉链法(还可以用红黑树) 再散列法,准备多个散列函数 get方法原理 先计算key的hash值(调用key的hashCode方法),然后和底层数组长度-1相与计算出下标 在该下标上用equals方法搜索是否有相同元素,如果有返回value,没有返回null 注意没有该key和key的值是null都会返回null,需要用containsKey来区别 线程不安全 put方法原理 先调用key的hashCode方法计算出hash,然后和数组长度-1进行相与,计算出实际下标 然后和该下标对应的链表或红黑树进行一个一个元素比对(equals),如果有相同的,则更新value 如果没有则接在末尾 jdk8的数据结构变化 链表元素超过8个转为红黑树 红黑树元素少于6个转为链表 放进HashMap的元素需要同时重写hashCode和equals方法 hashCode方法原则: hash值不同的元素一定不同(hash值相同的元素,不一定相同) hashCode散列应该比较均匀 可以存null key可以为null,只能有一个 value可以为null,但是去的时候注意要调用containsKey来区分是不存在key还是value是null 问题: 为什么hashmap允许key和value为null(但只能有一个),但是hashtable均不允许? 源码阅读 扩容过程 单链表和红黑树的转换过程 数据结构(红黑树节点继承Node,保持原来的顺序) Hashtable线程安全,不可以存null Properties键值对都是String类型 常用方法 String getProperties(String key) Object setProperties(String key,String value) TreeMap特点 无序(插入和读取顺序不能保证相同) 可以排序 key不能重复 底层数据结构是: 红黑树(自平衡二叉查找树) key必须提供排序规则 自身实现Comparable接口,重写compareTo方法 为TreeMap构造器提供一个比较器,重写compare方法 面向对象基础 构造函数,不写默认有一个空的;写的话默认的就没有了 子类构造器 super(…) 调用父类构造器 必须在子类构造器的第一行;如果不写,会默认调用父类空构造函数; 如果父类没有空构造函数,子类也不明确指定父类有参构造器,则会报错 运行时确定方法和实例对象,称为动态绑定 java不支持多继承,但是可以通过接口来实现 接口可以多继承! final关键字 修饰类:不可继承 修饰方法:不可重写 修饰变量:值不能被重新覆盖 基本数据类型:值不可变 引用数据类型:指向不可变 修饰类或方法的原因: 确保他们在子类中不会改变语义 类型转换 向上转型: 自动类型转换 向下转型:强制类型转换 无论向上还是向下类型转换,类之间本身必须要有继承关系,否则编译器会报错ClassCastException,即只能在继承层次内进行类型转换 抽象类 abstract修饰类 这个类是抽象类 包含&gt;=0个抽象方法 不能实例化 包含抽象方法的类一定是抽象类;但抽象类不一定包含抽象方法 如果子类没有实现抽象父类的全部方法,那么仍然是抽象类 abstract修饰方法 这个方法是抽象方法,没有方法体 使用预定义类LocalDate类 三种静态工厂方法来创建一个LocalDate类型对象(构造器私有,无法直接通过new来构造) 123LocalDate.of(2020,4,20);LocalDate.now();LocalDate.parse(&quot;2021-04-20&quot;); 浅拷贝与深拷贝Java内存模型JMM123我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。 进程/线程通信的的方法有 共享变量(Java采用) 消息通信 这个回头再看,感觉面试不怎么问吧! 对象的内存布局对象实例包括三部分 对象头 对象运行时元数据: hash值,gc分代年龄,各种锁的状态(锁状态标志,线程持有的锁,偏向进程id,偏向时间戳) 类型指针:指向方法区中的类型数据 如果是数组类型,还包括数组的长度 实例数据 真正存储有效信息的部分,包括程序中定义的各种字段,也包括从父类,Object类中定义的各种字段 对齐填充 虚拟机要求对象的起始地址必须是8字节的整数倍(对象头刚好是8字节) 因此不够8字节的话,要填充至8字节 对象的访问定位堆中的对象是通过元数据指针找到方法区中的元数据信息的,那么栈帧中的对象引用又是如何找到对应的对象呢? 两种方法: 方法1:通过句柄 堆区中开辟了⼀块空间⽤于存储句柄，该空间称为句柄池。句柄池分别存储着两个句柄，分别是到对象实例数据的指针和到对象类型数据的指针。前者指向对象实例数据，后者指向对象类型数据 方法2:直接访问(HotSpot虚拟机中的访问方式) 锁对象先了解有哪些锁,有哪些特征即可,具体实现先不了解 Java运行时数据区(内存布局) Java的集合体系略 看了一遍,感觉没什么好记录的 接口接口基础知识 Java的接口可以多继承,类也可以实现多个接口 所有成员都是自带public的,可以省略 方法的public abstract省略 成员变量的public static final 可以省略(接口不能有实例字段,即不加static的字段) java8接口中可以有静态方法 必须有方法体 子类不用实现它 java8接口中可以有默认方法 相当于给原来的接口方法加了一个默认实现,其他所有东西都不变 提供默认方法的原因是: java8之前,如果想给一个接口添加一个抽象方法,那么所有的实现类必须要实现这个方法,即使用不到也得写一个空实现,需要修改所有实现类,很麻烦; 加了默认方法之后就解决了这个问题. java9接口中可以有私有方法 给其他方法打辅助的,给接口中其他方法调用的 可以用instance of来判断某个对象是否实现了某接口 常用接口相关知识 实现Comparable接口时,重写compareTo方法,其实现要与equals逻辑上兼容. Cloneable接口 它是一个标识接口,内部没有具体成员;如果调用一个对象的clone方法,而它没有implements Cloneable接口,则会抛出异常 Lambda表达式 如果可以推导出类型,则不用写类型 如果只有一个参数,那么可以省略小括号 如果只有一句return,那么可以省略中括号和return 12Integer[]arr3=null;Arrays.sort(arr3,(a,b)-&gt;a-b); Lambda表达式中只能是引用数据类型,所以对int[]不能直接实现反向排序 函数式接口 只有一个抽象方法的接口,称之为函数式接口,可以提供一个lambda表达式来实现它. lambda表达式就是函数是接口的一个实例 @FunctionalInterface用来标记函数式接口（标记注解，没有实际内容），即只有一个抽象方法（可以有其他多个静态方法，默认方法） 四种基本的函数式接口 predicate：泛型单入参返回布尔值出参 function：泛型单入参返回泛型出参 supplier：无入参返回泛型出参 consumer：泛型单入参无出参 均可以用lamba表达式来创建对应类型的实例 方法引用方法引用就是用你提供的方法来代替函数式接口中的抽象方法 不能独立存在，总是转换为函数式接口的实例 下面的案例中有三种写法 匿名内部类实现断定型函数式接口的test方阿飞 lambda表达式实现test方法 提供一个方法引用来替换test方法（形式一致） 123456789101112131415161718192021222324252627282930public class Tesy { public static void main(String[] args) { new Tesy().f(); } void f(){ List&lt;String&gt;s=Arrays.asList(&quot;abc&quot;,&quot;def&quot;,&quot;g&quot;,&quot;k&quot;,&quot;iLoveYou&quot;); List&lt;String&gt; filter = filter(s, new Predicate&lt;String&gt;() { @Override public boolean test(String s) { return s!=null &amp;&amp; s.length()&gt;2; } });// List&lt;String&gt; filter = filter(s, e -&gt; e != null &amp;&amp; e.length() &gt; 2); //List&lt;String&gt; filter = filter(s, Tesy::strategy); System.out.println(filter); } static boolean strategy(String s){ return s!=null &amp;&amp; s.length()&gt;2; } //根据给定策略过滤字符串 List&lt;String&gt; filter(List&lt;String&gt;list, Predicate&lt;String&gt;predicate){ List&lt;String&gt;ans=new ArrayList&lt;&gt;(); for(String s:list) if(predicate.test(s)) ans.add(s); return ans; }} 构造器引用与数组引用12345678Supplier&lt;Stu&gt;supplier=()-&gt;new Stu();Supplier&lt;Stu&gt;supplier2=Stu::new;Supplier&lt;Stu&gt;supplier3=new Supplier&lt;Stu&gt;() { @Override public Stu get() { return new Stu(); }}; 12345678910class Stu { int id; Stu(){} Stu(int id){this.id=id;}}Function&lt;Integer,Stu&gt;function=id-&gt;new Stu(id);//Function&lt;Integer,Stu&gt;function= Stu::new;Stu stu = function.apply(10); 类加载机制类加载机制类加载分为三个阶段 加载: 将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存上创建一个java.lang.Class对象用来封装类在方法区内的数据结构作为这个类的各种数据的访问入口。 连接 验证: 验证.class文件是否符合jvm规范 准备: 为静态变量赋零值,对具有final修饰符的直接赋值(在方法区中分配内存) 解析: 将符号引用替换为直接引用(这一步可能发生在初始化之前或之后) 初始化: 为类变量赋值,执行静态代码块(不执行构造函数,构造函数只有new的时候才执行,是对象范畴的) 类的生命周期加载 链接 验证 准备 解析 初始化 使用 卸载 双亲委派模型什么叫双亲委派模型 如果一个类加载器收到类加载的请求，那么它会先尝试让父类加载器来加载，每一层都是如此，直到启动类加载器；只有当父类加载器无法完成请求时，才会委派子加载器去加载。 为什么需要双亲委派模型 如果一个类被不同加载器加载，那么就会被jvm认定为不同的类；这样的话，Java体系最基础的行为业务从保证（比如不同类加载器加载String类，则认为是不同类），应用程序会变得混乱； 所以有了双亲委派模型来保证类的唯一性。 首先,双亲委派模型不是强制要求的,是可以打破的 其次,它有以下几个优点 保证类的唯一性，避免类的重复加载。当父加载器已经加载该类时（有缓存），子加载器就没必要再加载了。 考虑到安全因素，java核心api中定义类型不会被随意替换。 假设通过网络传递过来一个名为java.lang.Integer的类,通过双亲委派模型则不会加载该类,而是直接返回已经加载过的Integer.class,这样可以防止核心API库被随意修改 破坏双亲委派模型 由于加载范围的限制,顶层的ClassLoader无法访问底层的ClassLoader所加载的类.所以此时需要破坏双亲委派模型. 如果A通过类加载器CA来加载,那么在A类中要加载其他类也会通过CA来加载;因此如果通过启动类加载器加载的类中如果想加载启动了加载不了的类,那么此时就需要打破双亲委派机制 实现方式:使用上下文类加载器 类加载器 在类加载的第一个阶段”加载”,通过类的全限定名来获取描述该类的二进制字节流,实现这一功能的代码叫做类加载器 Java中的任意一个类,都必须由加载这个类的类加载器和这个类自身来共同确立其在jvm中的唯一性; 每一个类加载器,都有其独立的类名称空间(不同类加载器的同名类,是不同的);这样同一个jvm上运行的不同应用程序就不会造成混乱. 判断两个类是否相等,必须在这两个类是被同一个加载器加载的前提下才有意义;否则即使Class文件相同,被同一个虚拟机加载,但是使用了不同的类加载器,那么这两个类也是不同的 双亲委派模型一共分了四层的加载器.除了顶层的启动类加载器,其他类加载器都有父类加载器。子类使用“组合”的方式复用父类的代码。（parent变量指向父类加载器），而非继承 启动类加载器打印出来是null，因为它是用C++写的，其余的都是用Java写的 用户自定义类加载器的parent一定是AppClassLoader 只为什么需要多个类加载器,只用一个类加载器不行吗?不就不需要双亲委派模型 jvm同时运行不同的应用程序,需要用不同的类加载器来区分同名的类 类名相同,如果类加载器不同则两个类不同 jvm需要有不同的类加载器来对不同的类库进行运行时增强(自定义):比如动态代理 1思考以下情景：首先，是为了区分同名的类：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候jvm该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？当然是不同的应用都拥有自己独立的类加载器了。其次，是为了更方便的加强类的能力：类加载器可以在loadclass时对class进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及debug等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？一个比较方便的模式就是每个类库都可以使用独立的类加载器小结：jvm需要有不同的类加载器，因为它一方面允许你在一个jvm里运行不同的应用程序，另一方面方便你独立的对不同类库进行运行时增强。 如果A通过类加载器CA来加载,那么在A类中要加载其他类也会通过CA来加载 重要概念浅拷贝与深拷贝 引用拷贝就是两个变量指向同一个对象; 对象拷贝是复制一个对象,地址不同;对象拷贝又分为浅拷贝和深拷贝 浅拷贝:对所有成员变量进行简单复制值,对基本数据类型来说没问题,但是对引用数据类型来说,仍然是只复制了引用对象的地址. 深拷贝:对引用数据类型也进行克隆. java Cloneable接口 是标记接口,内部是空的; clone方法是从Object中继承的,访问权限是protected,也就意味着如果子类不重写成public的,那么在类的外部无法被访问.(protected权限:同一个类中,包内,(含包外)子类中) 如果不实现它的话,调用对象的clone方法,会报异常 所有数组类型都会有一个public的clone方法,可以用这个方法简历一个新的数组,包含原数组的所有副本(浅拷贝)","link":"/2022/07/11/Java-java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"title":"Java简单聊天程序","text":"设计思想： 服务器端： 监听指定端口（如12345），一旦接收到Socket请求，就立马创建两个永远执行的线程（while(true)实现）。一个用于给客户端发送消息，一个用于接收从客户端来的消息。 客户端： 根据服务器的IP和端口号，生成Socket，启动两个永远执行的线程，一个用于向服务器端发送消息，一个用于从服务器端接收消息。 注意：需要先启动服务器端，然后启动客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package MyChat;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.Scanner;public class ChatClient { private static final String ip = &quot;219.230.70.7&quot;; //从路由器管理界面抄下来的，此IP地址由ISP动态分配，可能会发生改变 private static final int port=12345; public static void main(String[] args) { Socket serverSocket = null; try { serverSocket = new Socket(ip, port); new Thread(new MessageToServer(serverSocket)).start(); new Thread(new MessageFromServer(serverSocket)).start(); } catch (IOException e) { e.printStackTrace(); } }}class MessageToServer implements Runnable { private DataOutputStream dataOutputStream = null; private Scanner sc = new Scanner(System.in); public MessageToServer(Socket s) { try { dataOutputStream = new DataOutputStream(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message = null; while (true) { message=sc.nextLine(); try { dataOutputStream.writeUTF(message); } catch (IOException e) { e.printStackTrace(); } } }}class MessageFromServer implements Runnable { private DataInputStream dataInputStream = null; public MessageFromServer(Socket s) { try { dataInputStream = new DataInputStream(s.getInputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String info=null; while(true){ try { info=dataInputStream.readUTF(); System.out.println(&quot;收到服务端消息：&quot;+info); } catch (IOException e) { e.printStackTrace(); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package MyChat;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class ChatServer { public static void main(String[] args) { ServerSocket serverSocket = null; //服务端socket Socket clientSocket = null; //客户端socket final int port = 12345; try { serverSocket = new ServerSocket(port); while (true) { //监听端口，一旦收到新的scoket，则建立两个线程用于接收和发送消息 clientSocket = serverSocket.accept(); new Thread(new SendMessageToClient(clientSocket)).start(); new Thread(new ReceiveClientMessage(clientSocket)).start(); } } catch (IOException e) { e.printStackTrace(); } finally { if(clientSocket!=null) { try { clientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!=null) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } }}class SendMessageToClient implements Runnable { DataOutputStream dataOutputStream=null; private Scanner sc=new Scanner(System.in); public SendMessageToClient(Socket s) { try { dataOutputStream=new DataOutputStream(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message=null; try{ while(true){ message=sc.nextLine(); dataOutputStream.writeUTF(message); } }catch (IOException e){ e.printStackTrace(); } }}class ReceiveClientMessage implements Runnable { private DataInputStream dataInputStream = null; public ReceiveClientMessage(Socket s) { try { dataInputStream = new DataInputStream(s.getInputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message=null; try{ while(true){ //一直运行，一旦接收到消息，就打印 message=dataInputStream.readUTF(); System.out.println(&quot;收到客户端消息：&quot;+message); } }catch (IOException e){ e.printStackTrace(); } }}","link":"/2022/01/06/Java-%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/"},{"title":"军用电子手册项目","text":"项目介绍军方有一款火炮车需要做一个电子手册app，要求在鸿蒙系统的平板上运行。 电子手册结构如下： 装备认知 装备认知下主要是展示战车的3D模型，对战车整体以及其火力系统、火控系统、底盘系统、直属附件的视频、文字介绍。 操作使用 包括人员选择、任务选择等等 考核评估 使用前后端交互，每次从题库中抽取若干题目。 资料查询 将战车所有资料，图片、文档等分类展示。 硬件设备 设备品牌 屏幕尺寸 屏幕分辨率 运行内存 鸿蒙系统版本号 HUAWEI MatePad Pro 10.8英寸 2560 x 1600 8GB及以上 2.0.0及以上 技术 Unity C#常用语法(Rider开发、调试) SpringBoot 团队分工主要由四名开发人员：军方一位人员提供素材，设计院一位同学进行界面的设计，我和一位博士大师兄进行开发。 技术选型和前期整体框架的搭建主要由我的大师兄进行，我负责在他搭建的框架上，根据他现有的代码，边学习Unity和C#的基本语法，边进行开发。 （参考了一个Unity实现坦克大战的案例） 我的工作项目难点 没有素材的情况下进行开发。因此采用json文件的方式加载内容，可随时替换素材 遇到的困难以及解决方案 Untiy需要的安装环境，在涉密的Windows7电脑上，无法安装，因为点NET无法安装；最后发现是缺少某项更新，更新后安装了Unity破解版，发现安卓编译环境无法安装，需要联网在Unity内部进行下载。然后想的办法是，在自己电脑用Unity下载安卓编译环境，然后带过去，发现行不通。 解决方案：使用虚拟机，将所有环境配置好，然后统一带过去。中间还遇到坑就是Win7只能安装老版本的VM。 在操作使用-维修保养下，需要展示大量格式不同的表格，使用json读入表格数据，然后再使用代码生成表格，非常困难。 解决方案：将word表格制作成pdf，然后通过ps将表格抠出来，转为PNG，最后导入面板中。","link":"/2021/09/29/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE-%E5%86%9B%E7%94%A8%E7%94%B5%E5%AD%90%E6%89%8B%E5%86%8C%E9%A1%B9%E7%9B%AE/"},{"title":"仿B站项目","text":"坑点记录 xml文件里别写注释，会报错 视频里说type字段跟mysql关键字冲突，在xml文件中写sql要加引号，但是实际测试来看，加了引号会报错，不加没事 视频里这个地方讲错了，应该是我这样。 它写的是两个followingId 前端调试相关 ngrok使用需要开vpn，因为他给的公网地址是外网的，点开ngrok.exe（而非控制台打开）,输入命令ngrok http [后端服务端口号] ngrok启动之后如果前端调试，发现请求全部因为跨域被拒绝，稍微等会就好，应该是公网映射还没有生效（ngrok控制台里边都没有收到前端发的请求） 他给的前端测试里边，添加关注的post请求/user-followings内容是空的，无效 rocketmq需要把环境变量里的java_home改成jdk1.8, 启动rocketmq Name Server 方法一，在rocketmq的bin目录下控制台输入mqnamesrv 方法二，在rocketmq的bin目录下双击mqnamesrv.exe 启动rocketmq 代理 控制台切换到rocketmq的bin目录下，输入命令mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=true rocketmq的可视化管理应用，用idea打开 如果pom报红，点File -&gt; Invalidate Caches / Restart… -&gt; Invalidate and Restart就能解决了。这相当于把IDEA清除缓存重启了。","link":"/2022/05/12/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE-%E5%BC%B9%E5%B9%95%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"},{"title":"微服务优惠券项目","text":"项目简介微服务架构与传统架构的区别 传统架构（单体服务） 优点 所有功能集中在一起，结构简单 缺点 编写代码时，各种功能可能会发生冲突 需要修改某一功能时，需要重新编译整个项目 当某一功能发生故障时，可能会拖垮整个项目业务系统 微服务 微服务即将原本大系统中的各个功能点拆分为独立的小系统，并独立部署。致力于解决单体服务的各种弊端 优点 客户端不直接与微服务进行交互，而是通过网关做路由请求的分发 功能之间的方法调用，变成了微服务之间的服务调用 让开发、部署过程变得简单易维护 某个微服务出现问题，不会影响其他的微服务，对业务系统的高可用提供了保障项目架构 涉及的技术 Java Maven SpringCloud MySQL、Redis、Kafka MavenMaven是一种项目构建工具 相关特性 传递依赖与排除依赖 如果项目引用了一个jar包，而该jar包又引用了其他jar包。那么，默认情况下，项目编译时，Maven会把直接引用和间接引用的jar包都下载到本地（~/.m2/repository) 排除依赖：如果我们指向下载直接引用的jar包，那么需要在pom.xml中做如下配置（给出需要排除的坐标） 依赖冲突 说明：如果项目中多个jar同时引用了相同的jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的。 短路优先 本项目-&gt;A.jar-&gt;B.jar-&gt;X.jar 本项目-&gt;C.jar-&gt;X.jar 声明优先 若引用路径长度相同时，在pom.xml中，谁先被声明，就是用谁 多模块项目/聚合 为什么需要多个模块构成一个项目？ 项目很大的情况下，编译时间很长，只是改动某处的代码却需要编译整个项目 pom文件可以用来继承和重用，如果另一个项目需要用到这个项目中的某个模块，在不分模块的情况下（只有一个jar包或者war包），就只能依赖于一个很大的包，将整个项目都依赖进去。项目很大的情况下，维护困难，可重用性低。 dependencyManagement和dependencies标签的区别 dependencies子模块默认集成父项目的依赖项，全部继承 dependencyManagement只在父模块中声明依赖而不引入，子模块如果引入需要显示声明 父模块与子模块的关系 父模块管理所有jar包，子模块引用父模块即可，无需重复定义 父模块没有代码，只有pom文件管理所有的依赖，以及共同的配置 父模块packaging类型必须是pom（默认是jar）Redis支持的数据类型 String List 双向链表实现 Hash Set SortedSet 每个元素关联一个浮点型的权重值 Redis特性 Redis的所有操作都是原子的 一个操作要不全部完成，要不就不做 源自Redis的单线程 Redis可以对key设置过期时间（后面两种是Redis对key的删除方式） 定时删除 惰性删除 定期删除 Redis支持两种持久化方式 RDB（快照，默认）：一次性将redis数据全部写入磁盘文件中，在线上操作中几乎不被采用 AOF(append only file)：将用户的每一个写指令（添加、修改、删除），都备份到文件中，还原数据的时候，执行具体的写指令 Redis速度快的原因 完全基于内存 数据结构简单 单线程，没有切换 多路IO复用模型 select epoll 缓存穿透和缓存雪崩的问题 缓存穿透：指查询一个不存在的数据，但是由于Cache不命中，又需要去DB中查询，造成性能下降 解决方案：给没有命中的key设定“没有意义的空值”(防止对该key反复访问数据库） 缓存雪崩：指Cache设置了相同的过期时间，导致Cache在同一时间失效，请求全部转发到DB，DB的瞬间压力过大，造成雪崩 解决方案：给key设定不同的（随机的）过期时间 Redis的IO模型BIO BIO：Blocking I/O 阻塞模型 阻塞模型的特点 当read/write对某一文件描述符(FD)进行读写时，如果当前的FD不可读或者不可写，则服务阻塞 I/O多路复用在客户端/服务器的模型下：多个客户端（应用）向服务器（内核）请求数据（请求完后可以去做别的事情），服务器中有一个selector监听各个客户端请求的数据是否准备好，如果准备好了则发送消息通知客户端。 多路复用模型的特点： 同时监控(select/epoll)多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，就会返回可读以及可写的文件描述符（个数）Redis的Reactor设计模式MySQL版本 目前企业级开发中最常用的版本 MySQL5.5（又叫MySQL5） MySQL5.6（又叫MySQL6） MySQL5.7（又叫MySQL7） MySQL官方主推的版本 MySQL8.0 MySQL 8 Up to 2X Faster Than MySQL5.7 MySQL8.0配置 pom.xml的配置 jdbc驱动类的配置driver-class-name:com.mysql.cj.jdbc.Driver 数据库时区的配置(如果未设置时区，可能会报Time Zone错误）set GLOBAL time_zone=’+8:00’;InnoDB索引原理B树和B+树B树是一种多路平衡查找树，B是Balance，m阶（m&gt;=2）的B树有以下特性： 树中的每个子节点最多有m个子节点 除了根节点和叶子节点以外，其他每个节点至少有m/2个子节点 所有的叶子节点都在同一层 节点中关键字的顺序按照升序排列B+树是B树的一种变体，同样是多路平衡查找树，它与B树主要的不同是 非叶子节点不存储数据，只存储索引 叶子节点包含了全部的关键字信息，且叶子节点按照关键字顺序相互连接 Mysql索引主要使用的是B+树 聚簇索引聚簇索引的含义每个InnoDB的表都有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。聚簇索引的创建规则辅助索引辅助索引的含义除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于，辅助索引的叶子节点中存放的是主键的键值辅助索引的两次查找行记录常见索引类型 索引本质是一张表，保存的是主键与索引的字段，并且指向实体表的记录 Spring Data Jpa 什么是JPA即Java Persistence API，用于对象持久化的API，它是ORM规范(不是具体实现，只是定义了接口)，使得应用程序以统一的方式访问持久层。 ORM规范ORM 是 Object Relational Mapping 的缩写，译为 “对象关系映射” 框架。所谓的 ORM 框架就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述 Java 对象与数据库表之间的映射关系，自动将 Java 应用程序中的对象持久化到关系型数据库的表中。ORM 框架是一种数据持久化技术，即在对象模型和关系型数据库之间建立起对应关系，并且提供一种机制，可通JavaBean 对象操作数据库表中的数据。 JPA和Hibernate的关系 JPA是Hibernate的一个抽象 JPA是ORM规范，不是ORM框架 Hibernate是JPA的一种实现 JPA是Hibernate的一个功能子集 Hibernate 在查询不复杂、并发量小的情况下比较合适，查询复杂、并发量高的情况下用Mybatis，只要适合应用场景的就是好的技术。 JPA的优势 标准化 简单易用 面向对象 JPA包含的技术 ORM映射元数据 描述对象和表中数据的映射关系 提供了查询API 查询语句（JPQL）通过面向对象而非面向数据库的查询语言去查询数据，避免程序和具体的SQL耦合在一起 Spring Data项目 Spring Data是Spring的一个子项目，用于简化数据库访问 Spring Data JPA是Spring Data的一个子项目 Spring Data JPA致力于减少数据访问层（DAO）的开发量 数据库连接池 数据库连接池能够做什么 连接复用：通过简历一个数据库连接池以及一套连接使用管理策略，使得一个数据库可以得到高效、安全的复用，避免了数据库链接频繁简历、关闭的开销。 数据库连接池的基本原理 数据库连接池的基本原理是在内部对象池中维护一定数量的数据库链接，并对外暴露数据库连接获取和返回方法 getConnection releaseConnection 使用数据库连接池的优势 资源重用 更快的系统响应 优化的资源分配 统一的连接管理 SpringBoot2默认的数据库连接池Kafka消息系统 点对点消息系统 发布订阅消息系统 ## Kafka术语 ![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/202107101112313.png) 当需要保持消息的顺序时，可以设置partition数量为1（默认是1） kafka Brokers有自动负载均衡的功能 Kafka的使用 Kafka Producer消息分区 使用key指定分区，在实际开发中并不常用 Kafka Consumer消费组 Kafka保证，一个tipic中的每个信息，只被消费者组中的一个成员消费 消费者总是属于一个消费者组，即使不指定消费者组，kafka也会默认地将其放入一个消费者组中（只有它一个） SpringBootSpringBoot应用启动入口 应用启动的三种方式 SpringAppliction静态方法run 通过Api调整应用行为 SpringApplicationBuilder的Fluent Api，实现链式调用 自动配置原理（starter）配置文件 统一目录下的application和bootstrap bootstrap优先级高于application，优先被加载 bootstrap用于应用程序上下文的引导阶段，由父ApplicationContext加载 bootstrap是系统级别的配置（不变的参数），application是应用级别的配置 不同位置的配置文件加载顺序（优先级） 配置注入的方式即数据绑定的方式，有两种 通过配置直接注入 通过类注入定时和异步任务 单元测试开机启动Actuator监控遇到的问题及解决方案 在resources中自定义配置，编辑application.yml文件时，报错解决方法：书写键值的时候要加空格，如port: 8000，否则就会报错","link":"/2021/06/01/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"title":"短视频项目","text":"开发日志做完项目之后把这里边的问题回答一下 2022-7-11今日工作 完成了互粉朋友列表的功能 问题: 查询互粉的朋友视频列表中用到了三表联合查询 vlog和users,用inner join联合查询,然后id in(fans中我粉的也粉我的用户的id) 多端登录和退出的问题,如何解决? 2022-7-7 完成了关注列表视频的功能 ps:发生了redis和数据库不一致的情况,数据库里边我关注了很多人,redis里却没有; 2022-7-6 完成视频点赞数的统计(两处,一处是刷新,另一处是在获取首页视频列表时) 完成展示我的点赞列表功能 2022-7-5今日工作: 完成视频点赞和取消相关工作 其中首页视频是否被我赞过,是在getIndexVlogList中写的 问题: REDIS和数据库的一致性问题! 是否点赞 是否关注 视频获赞数,用户获赞数,关注数这些东西,redis和数据库的一致性如何保持 出现过的问题,我在项目完成的过程中,写入点赞信息的时候往redis和数据库中都写了,但是后来关闭vm之后,重新打开redis,这时候redis中数据不在.所以首页的视频显示视频没有点赞(读取redis),然后我再点点赞按钮,控制台显示数据库报错,com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException Duplicate entry xxxx违反数据库完成性约束的异常. 因为已经有该条目数据(某用户喜欢某视频,两个字段) 雪花算法是如何生成id的?有什么优点和缺点,有没有别的方法 2022-6-24今日工作 完成取消关注功能从查询数据库改成查询redis! 实现查询关注列表功能(多表查询,因为要查Fans表还要查User表,需要编写mapper) 实现查询粉丝列表功能 实现互粉关系的查询(reids,如果在数据库中查询的话高并发下影响数据库性能) 知识点: Pagehelper实现分页的原理: 其实现了Mybatis的拦截器方法,重新拼接sql实现的. 自定义mybatis xml文件,写sql记得不要加; 否则会报错(分页Pagedhelper会在sql后边添加 limit) 问题: 如何做到redis和内存数据一致性的(我的项目里就出现这样的错误) 2022-6-23今日工作 完成粉丝关注添加功能 实现了关注和取关功能(redis参与) 重点 粉丝计数和”我和博主的关联关系”,要放入 redis,不要放入数据库,避免db性能瓶颈(网红可能有几千万粉丝,那么所有这样的人每次都进入db查询,会造成数据库崩溃) 2022-6-22今日工作: 开发了视频转私密和公开功能 开发了查询自己的公开和私密视频列表功能 重点: 查询自己的公开和私密视频,这边需要分页,分页这块可以再重点看看 2022-6-9今日工作 使用unicloud的cdn实现了视频上传功能 uicloud地址:https://unicloud.dcloud.net.cn/cloud-storage?platform=aliyun 问题: 登录逻辑中,不能多端登录,会覆盖掉之前的设备登录的token,如何解决? 查询视频,分页那块,没咋整明白,回头再看一下 2022-6-8今日工作 开发了退出登陆功能 实现了用户信息查询功能 部署了minio,注意如果不注释掉okhttp,测试minio文件上传的时候会报错(注意,注释掉以后,要刷新maven) 收获 粉丝,关注,获赞等信息直接从数据库获取的话,数据库压力很大,因此单独采用redis来做 我的@Confugiration的理解: 配置类,把原来的xml形式对bean的配置转换为注解+yml配置文件形式.基本内部都是通过@Value读取配置文件中的属性,然后生成对应的Bean交给Spring进行管理 问题: 我对枚举类型不是很熟悉,需要去学一下 为什么需要用到分布式存储MinIO?项目中根本没有体现分布式,能否自己实现一下? xx 坑: 要存emoji表情,必须修改mariadb的字符集为utf8mb4,在安装目录下data\\my.ini中修改即可 minio不能运行,用sudo ./minio server xxx 即可(minio在 /usr/local/bin下) 注意,虚拟机要开启桥接模式而非NAT NAT模式下:虚拟机和主机处于同一个局域网,但是虚拟机不和其他设备如连到同一个wifi的手机,在一个局域网.如果使用NAT模式,则手机上无法访问minio存储的文件 桥接模式下:虚拟机,主机,其他所有连到同一个wifi的设备,都处于同一个无线网下 注意:启动minio要设置--console-address 0.0.0.0:9111,这样所有设备都能访问控制台 端口:http://192.168.1.106:9000 重点与难点: 视频上传这块,使用传统的上传方式和CDN上传的区别 2022-6-7今日工作: 完成了腾讯云短信功能的认证 完成验证码相关功能,集成腾讯云短信sdk,成功调用api发送验证码到手机上. 今日收获与感悟: 接触了Knife4j的用法 接触了lombok的用法 接触了Slf4j的用法 接触了Hibernate验证框架校验数据的用法 接触了RDM的使用 使用ubuntu安装了redis,然后在windows中用SecureCRT连接到虚拟机中的reids,用RDM连接到虚拟机中的redis.练习了一些linux命令的使用 前后端分离的好处: 静态资源(前端页面)与动态资源分离,可以将静态资源放入缓存,大大提升访问效率. 开发职责分离,让专业的人做专业的事情 前后端的开发互相透明,只需要约定接口即可.前后端可以独立测试,发布. 数据库实体,pojo,xml文件等,都是通过逆向工具生成的,surprise! 很棒 问题 为什么前后端分离不能使用session? 全局唯一ID如何实现的? 雪花算法? 美团和百度如何解决雪花算法的缺陷的? 异常的封装和全局统一拦截具体怎么做的? 枚举类的用法? @bean和@Autowired有什么区别? 数据层的访问怎么实现的?那一堆example,mapper啥的,怎么实现的?mybatis的接口+xml,提供自动代理是怎么实现的? 重点: 对数据的校验,比如手机号码长度,验证码是否为空等.交给hibernate 验证框架来解决,发生错误抛出异常,再由统一异常拦截处理,将错误信息返回给前端 原来是在每个单独处理,非常麻烦,这样改造之后条理清晰. redis的使用 存储定时60s的用户ip,保证一个用户60s内只能请求一次验证码 存储用户验证码,用于登录校验 软件安装 用HbuilderX连接iphone的时候,要先打开itunes idea调整vm参数在菜单help-edit custom vm options 12-Xmx6096m-Xms4096m SecureCRT许可证 1234567运行程序，选择菜单“帮助 &gt; 输入许可数据”启动“许可向导”。将以下数据复制并粘贴到“许可向导”的相应字段中即可。名字：Windows公司：IC序列号：03-50-008187许可密钥：ACDDHB JQ2D9S 7ZAA5G CVNX41 ADAQB9 6ZVPYK PQ4EF1 84V5JM发布日期：26-07-2006 minio的安装 1234下载服务端wget https://dl.min.io/server/minio/release/linux-amd64/minio -O /usr/local/bin/minio &amp;&amp; chmod +x /usr/local/bin/minio下载客户端wget https://dl.min.io/client/mc/release/linux-amd64/mc -O /usr/local/bin/mc &amp;&amp; chmod +x /usr/local/bin/mc 腾讯云的配置 一个是在common-src-main-java-resources-tencentcloud.properties 一个是在SMSUtils中 cmd方式进入mariadb客户端 环境变量 进入mariadb的bin下输入mysql -u root -p 密码123456 linux使用 secureCRT连接linux 虚拟机网络调成桥接模式,设置固定ip(在系统设置-network-wired-右下角options-ipv4 settings) 网关和dns服务器是192.168.1.1 进入linux, ifconfig查看ip地址 在secureCRT中连接 账号root 密码一个空格 启动redis 启动redis服务端 redis-server [配置文件] [&amp;后台启动] 启动redis客户端 redis-cli 启动minio 切换到minio的目录下(minio在 /usr/local/bin下) sudo ./minio server --console-address 0.0.0.0:9111 data --console-address 0.0.0.0:9111,这样所有设备都能访问控制台 data那个是表示数据存储在 data/下 控制台 http://192.168.1.xxxx:9111 账号密码都是minioadmin","link":"/2022/06/07/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE-%E7%9F%AD%E8%A7%86%E9%A2%91%E9%A1%B9%E7%9B%AE/"},{"title":"Filter&amp;Listener","text":"Filter基本概念 JavaWeb三大组件：Servlet、listener、filter 当访问服务器资源时，过滤器可以将请求拦截下来，完成一些特殊功能 过滤器的作用 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…. 快速入门 步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解配置 代码 123456789101112131415161718192021@WebFilter(&quot;/*&quot;) //拦截所有资源public class FilterDemo01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;I am excuted&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { }} 过滤器细节 web.xml配置 12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;com.hhu.web.filter.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--拦截所有资源--&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器生命周期方法 服务器启动后，会创建Filter对象，然后调用init方法，只调用一次。用于加载资源 服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。用于释放资源 doFilter方法每次请求被拦截资源时，会执行。执行多次 过滤器配置详解 拦截路径配置： 具体资源路径：/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录：/user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截：*.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源: /* 拦截方式配置：资源被访问的方式 注解配置（**注意配置了拦截方式后，原来的拦截路径配置就不能省略value=**） 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请i去资源 FORWARD：转发访问资源 （了解）INCLUDE：包含访问资源 （了解）ERROR：错误跳转资源 （了解）ASYNC：异步访问资源 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链（配置多个过滤器） 执行顺序：如果有两个过滤器：1和2 1 2 资源执行 2 1 过滤器先后顺序问题 注解配置：按照类名的字符串比较规则，值小的先执行 web.xml配置：谁定义在上边，谁先执行 案例：登录验证 需求 对访问用户信息列表展示此案例的资源。验证其是否登录 如果登录了，则直接放行 如果没有，则跳转到登录也没面，提示“您尚未登录，请先登录“ 图示 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CBRlZe4g-1589287434701)(Fliter&amp;Listener.assets/image-20200510122521814.png)] 代码 1234567891011121314151617181920212223242526272829303132333435363738/** 完成登录验证的过滤器*/@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { //判断是否是登录相关的资源 //0.强制转换 HttpServletRequest request=(HttpServletRequest)req; //1.获取资源的请求路径 String URI = request.getRequestURI(); //2.判断是否包含登录相关资源路径,要注意排除掉css/js/图片/验证码资源 if(URI.contains(&quot;/login.jsp&quot;)||URI.contains(&quot;/loginServlet&quot;) ||URI.contains(&quot;/css/&quot;)||URI.contains(&quot;/fonts&quot;) ||URI.contains(&quot;/js&quot;)||URI.contains(&quot;/checkCodeServlet&quot;)){ //放行 chain.doFilter(req, resp); } else{ //不包含，验证用户是否登录 //3.从session里获取user Object user = request.getSession().getAttribute(&quot;user&quot;); if(user!=null) chain.doFilter(req, resp); else{ request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,resp); } } } public void init(FilterConfig config) throws ServletException { }} Listener 监听器 概念：web的三大组件 事件监听机制 事件：如点击按钮 事件源：事件发生的地方。如按钮 监听器：一个对象 注册监听：将事件、事件源、监听器绑定在一起 当事件源发生某个事件后，执行监听器代码 Listener用的少 ServletContextListener 接口：监听ServletContext对象的创建和销毁 方法 void contextDestroyed(ServletContextEvent sce) ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ServletContext对象创建后会调用该方法","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-Filter-Listener/"},{"title":"","text":"案例 打开ODBC（mysql自带的，直接在windows搜索框搜索打开），添加本机mysql数据源 添加数据库的类 编写数据库类头文件 编写数据库类cpp 测试连接 数据库连接成功 创建登录界面","link":"/2022/04/02/%E6%8A%80%E6%9C%AF-QT%E4%B8%8EMysql/"},{"title":"git使用学习","text":"版本控制主流的版本控制器 Git SVN(Subversion) CVS VSS TFS Visual Studio Online 分类 单机版本控制 集中式版本控制：如SVN 版本库是集中放在中央服务器上的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器获得最新的版本，然后工作。完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络贷款要求比较高。 分布式版本控制：如Git 没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己的电脑上； 协同的方法：比如自己在电脑上修改了文件a，其他人在电脑上修改了文件a，这时，只需要把各自的修改推送给对方，就可以互相看到对方的修改了。 Git是目前世界上最先进的分布式版本控制系统。 每个人都有完整代码，有一定的安全隐患，故有些公司会用SVN 常用Linux命令 cd cd.. pwd：当前工作目录 ls 或 ll：列出当前目录下所有文件ll更详细 touch：新建文件 rm：删除文件 mkdir：新建目录（文件夹） rm -r：删除一个文件夹 mv：移动文件 reset：重新初始化终端，清屏 clear：清屏(windows下cls) history：查看命令历史 help：帮助 exit：退出 #：注释 常用git命令 git init git status 查看文件夹状态 git add . 当前文件夹所有untracked文件添加到暂存区 git commit -m &quot;xxxx&quot; 将暂存区的内容提交到本地仓库 Git配置 git config -l git配置，-l表示清单 git config --local -l local只对某个仓库有效 git config --global -l global对登录用户所有仓库有效（查看当前用户的配置） git config --system system对系统所有登录的用户有效，基本不用 注：优先级 local &gt; global &gt; system，也就是说当对一个仓库同时设置了 global 和 local 那么采用local配置的信息。所有配置文件都保存在本地。 git相关的配置文件 Git\\mingw64\\etc\\gitconfig：Git安装目录下的gitconfig –system系统级 C:\\Users\\Administrator\\.gitconf 只适用于当前登录用户的配置 –global全局 两个重要配置命令，用户标识，必要！ git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx.qq.com&quot; 这里加了global，对本用户，所有的项目都是用这个用户标识 git基本理论（核心） Git本地有三个工作区域 工作目录 Working Directory ：就是平常存放项目代码的地方 暂存区 Stage/Index：用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息 本地仓库 Repository或Git Directory：安全存放数据的位置，这里面有你提交的所有版本的数据。其中HEAD指向最新放入仓库的版本 远程 Remote Directory： 远程仓库，托管代码的服务器，可以简单认为是项目组中的一台电脑用于远程数据交换 git的一般工作流程 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区 将暂存区的文件提交到git仓库 因此，git管理的文件有三种状态： 已修改(modified) 已暂存(Staged) 已提交(Committed) git项目搭建工作目录(Workspace)一般就是你希望git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。日常使用下面六个命令即可。 本地仓库搭建创建本地仓库的方法有两种 1.创建全新的仓库 12# 在当前目录新建一个git代码库$ git init 2.克隆远程仓库 12# 克隆一个项目和它的整个代码历史（版本信息）$ git clone [url] git文件操作文件的四种状态 Untracked 未跟踪，此文件在文件夹中，但是并没有添加到git库，不参与版本控制 通过git add状态变为staged Unmodify 文件已入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。 如果它被修改，会变成modified 如果使用git rm移出版本库，则成为untracked文件 Modified 文件已修改，仅仅是修改，并没有进行其他的操作 通过git add可进入暂存staged状态 使用git checkout则丢弃修改过，返回到unmodify状态。即从库中取出文件，覆盖当前修改 Staged 暂存状态，执行git commit则将修改同步到库中，文件变为Unmodify 执行git resert HEAD filename取消暂存，文件变为Modified 忽略文件 有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等。 在主目录下建立.gitignore文件，此文件有如下规则： 忽略文件中的空行以#开始的行会被忽略 可以使用Linux通配符。例如，*,?,[abc],{string1,string2...} 如果名称前面有个!则表示例外规则，将不被忽略。 /tmp 忽略 tmp文件夹及其所有内容 tmp/忽略tmp文件夹下的所有内容（tmp文件夹自身会被版本管理） 123456#为注释*.txt #忽略所有以.txt结尾的文件!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件，但不包括其他目录tmpbuild/ #忽略build/目录下的所有文件doc/*.txt #忽略 doc/notes.txt 但不包括 doc/server/arch.txt 注意：如果你创建.gitignore文件之前就push了某一文件，那么即使你在.gitignore文件中写入过滤该文件的规则，该规则也不会起作用，git仍然会对该文件进行版本管理。 使用码云 注册码云 设置本机绑定SSH公钥，实现免密码登录 123# 进入C:\\Users\\Administrator\\.ssh 目录ssh-keygen # 生成公钥 在~/.ssh/id_rsa.pub 将公钥信息public key添加到码云账户中即可 使用码云创建一个自己的仓库 idea集成git 创建项目 把远程项目直接clone到项目文件夹下（或者从别的文件夹下复制过来） 启用自动add，然后写完以后git commit -m “xxx”, git push 即可 说明：git分支 git分支中常用指令： 123456789101112131415161718192021# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但是依然停留在当前分支git branch [branch-name]# 新建分支并且切换过去git checkout -b [branch]# 将指定分支合并到当前分支git merge [branch]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 如果同一个文件在合并分支的时候被修改了则会引起冲突：（协商选择到底要谁的代码） 解决的办法是我们可以修改冲突文件后重新提交 master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下载新建的dev分支上工作，工作完成后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上来。","link":"/2022/04/17/%E6%8A%80%E6%9C%AF-git/"},{"title":"Redis","text":"NoSQL数据库概述NoSQL数据库，指的是非关系型的数据库。不依赖业务逻辑的方式存储，而是以简单的key-value模式存储。因此大大增加了数据库的扩展能力。 不遵循SQL标准 不支持ACID 原子性：事务的一组操作，要么都执行， 要么都不执行 一致性：满足数据完整性和一致性 隔离性：多个事务之间互不影响 事务隔离分为不同级别：读未提交、读提交、可重复读、串行化 持久性：一旦事务提交，即使数据库故障也不会丢失信息 远超SQL的性能NoSQL适用场景 对数据进行高并发的读写 海量数据的读写 对数据高可扩展性 NoSQL数据的存在意义就是从关系型数据库以业务逻辑为依据的存储模式，变为以性能为最优先考虑的存储方式，目的就是为了提高性能。 NoSQL不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，即需要即席查询常见NoSQL Memcache 支持的数据类型比较单一 不支持持久化操作 多线程+锁 Redis 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等 一般作为缓存数据库辅助持久化的数据库 单线程+多路IO复用 实现了多线程的效果，比memcache效率更高 MongoDB 高性能、开源、模式自由的文档型数据库 数据都在内存中 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据和大型对象 可以根据数据的特点替代RDBMS，成为独立的数据库。或者配合RDBMS，存储特定的数据。Redis安装 安装gcc redis官网找下载链接，用wget 下载安装包并解压 解压目录下编译make然后安装make install 安装后，将配置文件redis.conf复制到/etc下，并修改启动模式为后台启动，即修改redis.conf中daemonize no为yes 启动redis redis-server /etc/redis.conf 以该配置启动（后台启动） 打开客户端redis-cli 查看进程ps -ef | grep redis 测试验证：ping 得到pong回复，则说明运行正常 关闭redis redis cli shutdown 或者查看进程号 kill -9 xxx Redis常用五大数据类型库命令 默认16个数据库，下标从0开始，默认使用0号库 使用select &lt;dbid&gt;来切换数据库，如select 1 统一密码管理，所有库同样密码 dbsize查看当前数据库的key的数量 flushdb 清空当前库 flushall 通杀所有库 五大数据类型键的基本操作 keys* 查看当前库所有key （匹配 keys *1） exists key 判断某个key是否存在 type key 查看你的key是什么类型 del key 删除执行的key数据 unlink key 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作 expire key 10 10秒种：为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 字符串String简介 String是Redis最基本的数据类型，它是二进制安全的（意味着redis的String可以包含任何数据，比如jpg图片或者序列化的对象） 一个Redis种字符串value最多可以是512M常用命令 set &lt;key&gt;&lt;value&gt; 添加键值对 *NX 当数据库种key不存在时，可以将key-value添加进数据库 *XX 当数据库种key存在时，可以将key-value添加进数据库，与NX参数互斥 *EX key的超时秒数 *PX key的超时毫秒数，与EX互斥 get &lt;key&gt; 查询对应键值 append &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt;追加到原值的末尾 strlen &lt;key&gt; 获得值的长度 setnx &lt;key&gt;&lt;value&gt; 只有在key不存在时，设置key的值 incr 数字加一 decr 数字减一 incrby/decrby &lt;value&gt; &lt;步长&gt; 数字增减自定义长度 增减操作具有原子性，即原子操作不会被线程调度机制打断。Redis单命令的原子性主要得益于Redis的单线程（单线程+IO多路复用） Java种的i++不是原子操作 mset &lt;key1&gt;&lt;value1&gt; &lt;key2&gt;&lt;value2&gt;... 同时设置多个key-value mget &lt;key1&gt;&lt;key2&gt;... 同时获取多个value msetnx &lt;key1&gt;&lt;value1&gt; &lt;key2&gt;&lt;value2&gt;... 同时设置多个key-value，当且仅当所有给定key都不存在 以上三个操作具有原子性，有一个失败则都失败 getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt; 获得某范围内的值（左右都是闭区间） setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt; 用value覆盖从起始位置开始的值（索引从0开始） setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt; 设置键值的同时，设置过期时间，单位秒 getset&lt;key&gt;&lt;value&gt; 以旧换新，设置新值同时获得旧值数据结构String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS）。是可以修改的字符串，内部结构类似Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于1M时，扩容时加倍现有的空间，超过1M，扩容时只会多扩1M的空间。字符串的最大长度是512M。列表list 简介Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际上是双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能比较差。 常用命令 lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt;... 从左边/右边插入值 lpop/rpop &lt;key&gt; 从左边/右边吐出一个值。 rpoplpush &lt;key1&gt;&lt;key2&gt; 从key1列表右边吐出一个值，插入到key2列表左边 lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; 按照索引下标获得元素（从左到右） lrange &lt;key&gt; 0 -1 获取所有元素 index &lt;key&gt;&lt;index&gt; 按照索引下标获得元素（从左到右） llen &lt;key&gt; 获得列表长度 linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt; 在&lt;value&gt;的前边或后边插入值 lrem &lt;key&gt; &lt;n&gt; &lt;value&gt; 从左边删除n各value lset &lt;key&gt; &lt;index&gt; &lt;value&gt; 将列表key下标为index的值替换为value数据结构List的数据结构为快速链表quickList。首先在列表元素较少的情况下会使用一块连续的内存空间， 这个结构是ziplist，即压缩列表。它将所有的元素紧挨着一块存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。Redis将链表和ziplist结合起来组成quicklist。也就是将多个ziplist使用双向指针串起来。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。集合set简介与list类似，但是具有去重功能。Redis的Set是string类型的无序集合。它底层是一个value为null的哈希表，所以添加、删除、查找的复杂度都是O（1）常用命令 sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt;... 将一个或多个member元素加入集合key种，已经存在的member元素被忽略 smembers &lt;key&gt;取出该集合的所有值 sismember &lt;key&gt; &lt;value&gt; 判断集合key是否含有value值 scard&lt;key&gt; 返回该集合的元素个数 srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt;... 删除集合中的某个元素 spop &lt;key&gt; 随机从该集合种吐出一个值 srandmember &lt;key&gt; &lt;n&gt; 随机从该集合种取出n个值。不会删除成员。 smove &lt;source&gt; &lt;des&gt; value 把集合中一个值移动到另一个集合 sinter &lt;key1&gt; &lt;key2&gt; 返回两个集合的交集元素 sunion &lt;key1&gt;&lt;key2&gt; 返回两个集合的并集元素 sdiff &lt;key1&gt;&lt;key2&gt; 返回两个集合的差集元素（在key1中，不在key2中） 数据结构Set数据结构是dict字典，字典是用哈希表实现的。哈希Hash简介Redis Hash是一个键值对集合，是一个stirng类型的field和value的映射表，hash特别适合用于存储对象，类似Java中的Map&lt;String,Object&gt;。 #### 常用命令 hset &lt;key&gt;&lt;field&gt;&lt;value&gt;给key集合中field键赋值 hget &lt;key&gt;&lt;field&gt; 从集合key中的field中取值value hmset &lt;key&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... 批量设置hash的值 hexists&lt;key1&gt;&lt;field&gt; 查看哈希表key中，给定域field是否存在 hkeys &lt;key&gt; 列出该hash集合的所有field hvals &lt;key&gt; 列出该hash集合的所有value hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt; 为哈希表key中的域field的值加上增量1 -1 hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt; 将哈希表key中的域field的值设置为value，当且仅当域不存在 数据结构Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，是用ziplist，否则是用hashtable有序集合Zset (sorted set)常用命令 zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;... 将一个或多个member元素及其score值（用于排序）添加到有序集合key中 zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores] 返回有序集合key中，下标在start和stop之间的元素(0 -1展示全部），带withscores，可以让分数一起和值返回到结果集中。 zrangebyscore key minmax [withscores] [limit offset count] 返回有序集合key中，所有score值介于min和max之间（闭区间）的成员。有序集成员按score值递增次序排列 zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列 zincryby &lt;key&gt;&lt;increment&gt;&lt;value&gt; 为元素的score加上增量 zrem &lt;key&gt;&lt;value&gt; 删除该集合下，指定值的元素 zcount &lt;key&gt; &lt;min&gt; &lt;max&gt; 统计集合，分数区间内的元素个数 zrank &lt;key&gt; &lt;value&gt; 返回该值在集合中的排名，从0开始 案例：如何利用zset实现文章访问量的排行榜 数据结构SortedSet(Zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String,Double&gt;，可以给每个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表zset底层使用了两个数据结构 hash，hash的作用就是关联value和权重score，保障元素value的唯一性，通过元素value可以找到相应的score值 跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表Redis6的发布和订阅什么是发布和订阅Redis发布订阅(pub / sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。Redis客户端可以订阅任意数量的频道。Redis6新数据类型BitmapsHyperLogLogGeospatial Jedis操作Redis6","link":"/2021/06/10/%E6%8A%80%E6%9C%AF-Redis/"},{"title":"servlet","text":"概念运行在服务器端的小程序 Servlet就是一个接口，定义了java类被浏览器访问（tomcat识别）的规则 将来我们自定义一个类，实现Servlet接口，复写方法[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6JtH1J5q-1589287306416)(servlet.assets/image-20200504214004662.png)] 快速入门 创建一个javaEE项目 定义一个类，实现Servlet接口 实现接口中的五个抽象方法 配置Servlet 在web.xml中配置 ```html &lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.hhu.web.servlet.servletDemo01&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--配置servlet和url的映射--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041# Servlet执行原理1. 当服务器接收到客户端浏览器的请求之后，会解析请求url，获取访问的Servlet的资源路径。2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容3. 如果有，则会找到对应的&lt;servlet-class&gt;全类名4. tomcat会将字节码文件加载进内存，并且创建其对象5. 调用其方法# Servlet中的生命周期（方法） 1. init方法| * 初始化方法 * 在Servlet被创建时执行。只会执行一次 2. getServletConfig方法 * 获取ServletConfig对象 3. service方法 * 提供服务方法 * 每次Servlet被访问时，执行。执行多次3. getServletInfo方法 * 获取Servlet的一些信息：版本，作者等4. destroy方法 * 销毁方法 * 在服务器正常关闭的时候执行，执行一次* Servlet的生命周期： * 被创建：执行inti方法，执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以在servlet标签下配置执行Servlet的创建时机 ```html &lt;!--配置servlet创建时机 负数：第一次被调用时创建 自然数：服务器启动时创建--&gt; &lt;load-on-startup&gt;5&lt;/load-on-startup&gt; Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题 解决： 尽量不要在Servlet中定义成员变量，即使定义了也不要对其修改值 提供服务：执行service方法，执行多次 被销毁：执行destroy方法，只执行一次 destroy方法在servlet被销毁之前执行，一般用于释放资源 Servlet3.0 好处： 支持注解配置。可以不需要web.xml 步骤 创建javaEE项目，选择Servlet版本3.0以上，可以不创建web.xml 定义一个类实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(&quot;/资源路径（自定义）&quot;) IDEA与Tomcat的相关配置 IDEA会为每个tomcat部署的项目单独建立一份配置文件 工作空间项目 和 tomcat部署的web项目 tomcat真正访问的是”tomcat部署的项目”，其对应着”工作空间项目”的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问 不要直接把资源放到WEB-INF下，浏览器无法访问 断点调试：使用”小虫子“debug启动 Servlet体系结构爷父孙三者 Servlet接口 GenericServlet 抽象类 HttpServlet 抽象类 GenericServlet：将Servlet接口中其他方法做了默认空实现，只将service（）方法作为抽象 将来自定义类时，可以继承GenericServlet类，实现service（）方法。其他方法有需要也可以复写 ( 推荐使用)HttpServlet ：对于http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 （HttpServlet已经对service方法进行了复写，在service内部对post和get方法做了判断，各自调用doPost和doGet方法，故只需对doGet/doPost方法做实现即可） Servlet 相关配置 urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径@WebServlet({&quot;/demo03&quot;,&quot;/03&quot;}) 路径定义规则： /xxx /xxx/xxx：多层路径，目录结构 *.自定义拓展名 注意前面不要加杠 （*通配符）","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-servlet/"},{"title":"SSH和RSA非对称加密算法","text":"SSH工作原理基本原理SSH的安全性比较好，其对数据进行加密的方式主要有两种：对称加密和非对称加密（公钥加密）。 对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是，Client数量庞大，很难保证密钥不泄漏。如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。为了解决对称加密的漏洞，于是就产生了非对称加密。非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。 SSH的加密原理中，使用了RSA非对称加密算法。整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 在通信过程中，使用的是对称加密算法。 Host Key 分为 Public 和 Private 两种。服务端拥有 Public Key 和 Private Key，并将 Public Key 发送给客户端。客户端用 Public Host Key 验证这台服务器确实是自己要连接的服务器后，双方使用 Diffie-Hellman 算法生成一致的 SessionKey。 Host Key 由 SSH 自行生成，不需要用户做什么。如果客户端通过 Host Key 发现从来没有连接过这台服务器，会询问用户是否要继续连接，用户回答 yes 之后会在本地的 known_hosts 文件记录这台服务器，下次连接时客户端就不会再次询问。由于仅靠服务端下发 Host Key 的方法无法防范中间人攻击，后来又出现了 Public Key Certificates，由一个可靠的第三方机构给服务端签发证书，从而确保了安全性。 Session Key 用于之后通讯时对消息进行加密解密。这个 Session Key 的机制被称作对称加密（Symmetric Encryption），也就是两端使用的相同的 Key 来加密和解密信息。可以看出 SSH 信息的加密解密时并不是用大家自己生成的 Public/ Private Key，而是用双方都一致的 Session Key。 生成 Session Key 的步骤大致如下： 客户端和服务端使用沟通时的信息，协商加密算法以及一个双方都知道的数字。 双方各自生成只有自己才知道的 private 密码（一个密码而不是公钥私钥），并使用上一步中的数字进行加密，再次生成密码。 双方交换再次加密后的密码。 双方在对方发来的密码基础上，加上第二步自己的 private 密码再次加密。本次加密之后得到的结果就是在双方处都相同的 Session Key。 简单来说就是，我生成一个密码使用双方都知道的数字加密，然后将结果互相交换，再用自己的密码进行加密，这样我们俩手头的密码就是一样的了（对称加密） 中间人攻击SSH之所以能够保证安全，原因在于它采用了公钥加密，这个过程本身是安全的，但是实际用的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，是自己签发的。 如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就不存在了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。那么SSH协议是怎样应对的呢？ 如何应对中间人攻击如果是第一次登录远程机，会出现以下提示： 1234$ ssh user@hostThe authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 因为公钥长度较长（采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。如98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，这样比对就容易多了。 经过比对后，如果用户接受这个远程主机的公钥，系统会出现一句提示语： 1Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts. 表示host主机已得到认可，然后再输入登录密码就可以登录了。 当远程主机的公钥被接受以后，它就会被保存在文件~/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，一般是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 公钥登录使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： $ ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在~/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是公钥，后者是私钥。 这时再输入下面的命令，将公钥传送到远程主机host上面： 1$ ssh-copy-id user@host 远程主机将用户的公钥，保存在登录后的用户主目录的~/.ssh/authorized_keys文件中。这样，以后就登录远程主机不需要输入密码了。 RSA原理简介RSA 算法的加密原理是什么？ - AngelYJ的回答 - 知乎 https://www.zhihu.com/question/25038691/answer/81565068 RSA 算法的加密原理是什么？ - 童凌的回答 - 知乎 https://www.zhihu.com/question/25038691/answer/388573650","link":"/2021/12/04/%E6%8A%80%E6%9C%AF-ssh%E4%B8%8ERAS%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"title":"vue入门","text":"vue简介 JavaScript框架 简化Dom操作 响应式数据驱动 页面是由数据来生成的，数据改变，页面跟着改变 第一个Vue程序123456789101112131415161718&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; { {message} } &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=new Vue({ el:'#app', //#是id选择器 data:{ message:&quot;你好!&quot; } }) &lt;/script&gt;&lt;/body&gt; el:挂载点建议使用id选择器 只用用于双标签，但&lt;html&gt;和&lt;body&gt;除外，建议用于&lt;div&gt; data:数据对象1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;h2&gt;{ {person.name} }&lt;/h2&gt; &lt;h2&gt;{ {person.age} }&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;{ {subjects[0]} }&lt;/li&gt; &lt;li&gt;{ {subjects[1]} }&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', //#是id选择器 data:{ person:{ name:'余丰旭', age:22, }, subjects:['English','Math'] } }) &lt;/script&gt;&lt;/body&gt; 本地应用vue指令v-text v-text指令的作用是：设置标签的内容（textContent） 默认写法会替换全部内容，使用**差值表达式{ {} }**可以替换指定内容 内部支持写表达式 12345678910111213141516171819202122&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;h2 v-text=&quot;'message'+'!'&quot;&gt;大哥大&lt;/h2&gt; &lt;h2&gt;{ {info+'!'} }大哥大&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ message:'what', info:'how' } }) &lt;/script&gt;&lt;/body&gt; v-html 设置标签的innerHTML 123456789101112131415161718&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;p v-html='content'&gt;&lt;/p&gt; &lt;p v-text='content'&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ content:&quot;&lt;a href='https://www.baidu.com'&gt;百度官网&lt;/a&gt;&quot; } }) &lt;/script&gt;&lt;/body&gt; v-on 作用：为元素绑定事件 事件名不需要写on 指令可以简写为@ 绑定的方法定义在methods属性中 方法内部通过this关键字就可以访问定义在data中的数据 案例：计算器 知识点 创建Vue实例时：el（挂载点）,data（数据）,methods（方法） v-on指令的作用是绑定事件，简写为@ 方法中通过this，关键字获取data中的数据 v-text指令的作用是：设置元素的文本值，简写为{ {} } v-html指令的作用是：设置元素的innerHTML v-on补充 事件绑定的方法写成函数调用的形式，可以传入自定义参数 定义方法时需要定义形参来接收传入的实参 事件的后面跟上.修饰符可以对事件进行限制，如 @keyup.enter 回车按键松开 @keyup.left 左键松开 @keyup.right 右键松开 @keyup.up 上键松开 @keyup.down 下键松开 @keyup.delete 删除键松开 .enter可以限制触发的按键为回车 事件修饰符有多种 v-show 根据表达式的真假，让元素显示或者隐藏 v-if 和v-show基本相同 v-blind 修改属性 可以缩写为:属性= v-for 根据数据生成列表结构（响应式） 数组经常和v-for一起使用 语法是(item,index) in 数据 item和index可以结合其他指令一起使用 数组长度的更新会同步到页面上，是响应式的 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in arr&quot;&gt; 第{ {index} }个数:{ {item} } &lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;ol&gt; &lt;li v-for=&quot;(item,index) in objArr&quot;&gt; 第{ {index+1} }个人的名字是:{ {item.name} } &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ arr:[1,2,3,4,5], objArr:[ {name:'余丰旭'}, {name:'陈香玉'} ] } }) &lt;/script&gt;&lt;/body&gt; v-model 获取和设置表单元素的值（双向数据绑定） v-model指令的作用是便捷地设置和获取表单元素的值 绑定的数据会和表单元素值相关联 绑定的数据&lt;——&gt;表单元素的值 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;div id='app'&gt; &lt;input type=&quot;text&quot; v-model=&quot;textContent&quot; @keyup.enter='showMessage'&gt; &lt;br&gt; &lt;h2&gt;{ {textContent} }&lt;/h2&gt; &lt;br&gt; &lt;h2 v-text='textContent'&gt;&lt;/h2&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:&quot;#app&quot;, data:{ textContent:'你好鸭读研人~' }, methods:{ showMessage:function(){ alert(this.textContent) } } }) &lt;/script&gt;&lt;/body&gt; 案例：网页记事本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .item{ border:solid 1px black; width: 200px; } #calculator{ padding-left: 30%; border: 1px solid blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='calculator'&gt; &lt;h2 style=&quot;padding-left: 10%;&quot;&gt;在线记事本&lt;/h2&gt; &lt;input style=&quot;margin-left: 7%;&quot; type=&quot;text&quot; v-model=&quot;currentInput&quot; @keyup.enter=&quot;addItem(currentInput)&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in content&quot; class=&quot;item&quot;&gt; { {item} } &lt;button @click=&quot;deleteItem(index)&quot;&gt;x&lt;/button&gt; &lt;/li&gt; &lt;li style=&quot;font-size: small;&quot;&gt; 一共{ {content.length} }个项目 &lt;button @click=&quot;clearAll&quot;&gt;清空&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var calculator=new Vue({ el:'#calculator', data:{ content:[ '吃饭', '洗脸' ], currentInput:'请输入任务' }, methods:{ deleteItem:function(index){ // delete this.content.shift() this.content.splice(index,1) }, addItem:function(input){ this.content.push(input) }, clearAll:function(){ this.content=[] } } }) &lt;/script&gt;&lt;/body&gt; 网络应用 Vue结合网络数据开发应用 axios网络请求库 axios+vue axios基本使用 功能强大的网络请求库 axios必须先导入才能使用 使用get和post方法即可发送对应的请求 then方法中的回调函数会在请求成功或者失败时触发 通过回调函数的形参可以获取响应内容，或者错误信息 用法 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; axios.get(地址?查询字符串).then(function(response){},function(err){}) axios.post(地址,{key:value,key2:value2}).then(function(response){},function(err){}) 123456789101112131415161718192021222324252627&lt;head&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;get请求&quot; class='get'&gt; &lt;input type=&quot;button&quot; value=&quot;post请求&quot; class='post'&gt; &lt;script&gt; document.querySelector(&quot;.get&quot;).onclick=function(){ axios.get(&quot;https://autumnfish.cn/api/joke/list?num=6&quot;) .then(function(response){ console.log(response); },function(err){ console.log(err) }) } document.querySelector(&quot;.post&quot;).onclick=function(){ axios.post(&quot;https://autumnfish.cn/api/user/reg&quot;, {username:'jackandhisfriends'}) .then(function(response){ console.log(response) },function(err){ console.log(err) }) } &lt;/script&gt;&lt;/body&gt; axios+vue 网络应用的核心是：data中的一部分数据是从网络中获取的 保证编码在导入两个地址之后 坑 axios回调函数中的this已经改变，无法访问到data中的数据‘ 解决方法：把this保存起来，回调函数中直接使用保存的this即可 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='jokes'&gt; &lt;button @click=&quot;getJokes&quot;&gt;获取笑话&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in jokes&quot;&gt; { {item} } &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var jokes=new Vue({ el:'#jokes', data:{ jokes:[] }, methods:{ getJokes:function(){ var that=this; axios.get(&quot;https://autumnfish.cn/api/joke/list?num=3&quot;) .then(function(response){ that.jokes=response.data.jokes }) }, } }) &lt;/script&gt;&lt;/body&gt;","link":"/2020/03/10/%E6%8A%80%E6%9C%AF-vue%E5%85%A5%E9%97%A8/"},{"title":"O(1)时间插入、删除和获取随机元素的数据结构","text":"今天做到了这一题O(1) 时间插入、删除和获取随机元素，其利用了哈希的O(1)查找，和数组O(1)的随机访问特点来实现题目所要求的数据结构。 并且，做这道题目，纠正了我一个很大的误区，数组的删除，只有在要求顺序不变的情况下，其最坏时间复杂度才是O(N)，否则可以通过交换当前数和数组尾部的数字，然后pop_back()，来实现O(1)时间复杂度的删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*利用哈希的O(1)查找和数组的随机访问*/class RandomizedSet {private: map&lt;int,int&gt;mp; vector&lt;int&gt;nums; //O(1)时间复杂度删除一个数字 void deleteNum(int n){ int index=mp[n]; nums[index]=nums[nums.size()-1]; mp[nums[index]]=index; //删除 mp.erase(n); nums.pop_back(); }public: /** Initialize your data structure here. */ RandomizedSet() { srand((unsigned)time(NULL)); } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(mp.find(val)==mp.end()){ mp[val]=nums.size(); nums.emplace_back(val); return true; } return false; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(mp.find(val)!=mp.end()){ deleteNum(val); return true; } return false; } /** Get a random element from the set. */ int getRandom() { return nums[rand()%nums.size()]; }};/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"使用优先级队列合并K个升序链表","text":"在做23合并K个升序链表这题时，发现使用优先级队列（堆）能够高效地解决此问题。 思路：直接无脑地将所有节点扔进优先级队列中（小根堆），然后依次取出所有节点，按照头插法构建结果链即可。 注意：这里C++优先级队列对于自定义数据类型的比大小的实现，是通过一个结构体内实现()运算符重载来实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */struct cmp{ bool operator()(ListNode*&amp;p1,ListNode*&amp;p2){ return p1-&gt;val&lt;p2-&gt;val; }};class Solution {private: priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;que; //传入自定义比较器cmppublic: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { //将所有节点指针，放入大根堆中 for(int i=0;i&lt;lists.size();i++){ ListNode*p=lists[i]; while(p){ que.push(p); p=p-&gt;next; } } ListNode*res=new ListNode(0); while(!que.empty()){ //头插法 ListNode*t=que.top(); que.pop(); t-&gt;next=res-&gt;next; res-&gt;next=t; } return res-&gt;next; }};","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"利用双堆找中位数","text":"今天做了一题堆相关的题目295数据流的中位数，题解巧妙地用一个大根堆和一个小根堆来快速计算中位数。 其中添加新数字的写法十分精妙：如果一个数字要添加到小根堆，就先添加到大根堆，再将大根堆堆顶的元素转移至小根堆；反之亦然，以此能够保证小根堆中的元素永远大于大根堆中的元素。 其中，C++优先级队列底层默认是一个大根堆（使用了less&lt;xxx&gt;，更换成greater&lt;xxx&gt;，即变为小根堆）。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(que1.size()&gt;=que2.size()){ que1.push(num); que2.push(que1.top()); que1.pop(); }else{ que2.push(num); que1.push(que2.top()); que2.pop(); } } double findMedian() { if(que1.size()&gt;que2.size()) return que1.top(); if(que1.size()==que2.size()) return (double)(que1.top()+que2.top())/2; return que2.top(); }private: priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;que1; //大根堆 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;que2; //小根堆};/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%A9%E7%94%A8%E5%8F%8C%E5%A0%86%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"双栈模拟队列","text":"使用第一个栈存储push的元素，只有当需要pop时，才将第二个栈中的元素全部倒入到第二个栈中。n次操作总复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyQueue {private: stack&lt;int&gt; st1,st2; int popSt2(){ int ans=st2.top(); st2.pop(); return ans; } void transfer(){ while(!st1.empty()){ st2.push(st1.top()); st1.pop(); } }public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { st1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if(!st2.empty()){ return popSt2(); } transfer(); return popSt2(); } /** Get the front element. */ int peek() { if(!st2.empty()){ return st2.top(); } transfer(); return st2.top(); } /** Returns whether the queue is empty. */ bool empty() { return st1.empty() &amp;&amp; st2.empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"title":"单调栈的应用案例","text":"单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序。 单调栈模板单调栈一般用来解决一类问题：Next Greater Number。比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。即找到每个元素之后，第一个大于它的元素，如果没有则设置为-1。 解决方式：使用一个栈st，然后逆序来看nums数组，先将所有栈中比当前元素小的全部弹出（比当前元素矮的元素都是后续无法利用的无效信息,如图，矮个子会被高个子挡住，因此丢弃），然后如果此时栈空，则结果是-1；如果不为空，为结果是栈顶元素。最后将当前元素入栈；循环执行，最后得出结果数组。 例题1496下一个更大元素I 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int,int&gt;mp; stack&lt;int&gt;st; for(int i=nums2.size()-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; st.top()&lt;nums2[i]){ st.pop(); } if(st.empty()){ mp[nums2[i]]=-1; }else{ mp[nums2[i]]=st.top(); } st.push(nums2[i]); } vector&lt;int&gt;ans; for(auto&amp;n:nums1){ ans.push_back(mp[n]); } return ans; }}; 例题2739每日温度 12345678910111213141516171819class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt;st; vector&lt;int&gt;ans(temperatures.size()); //如果不预先申请长度，则会因为频繁扩容和复制数组，导致超时 for(int i=temperatures.size()-1;i&gt;=0;i--){ int n=temperatures[i]; while(!st.empty() &amp;&amp; n&gt;=temperatures[st.top()]){ st.pop(); } if(st.empty()) ans[i]=0; else ans[i]=st.top()-i; st.push(i); } return ans; }}; 例题3503下一个更大元素II 解决循环数组问题的常用解决方法就是数组翻倍。这里并没有直接构建一个双倍数组，而是通过下标小技巧实现的，形成逻辑上的二倍数组。 1234567891011121314151617class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int len=nums.size(); vector&lt;int&gt;ans(len,-1); stack&lt;int&gt;st; for(int i=2*len-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; nums[i%len]&gt;=st.top()) st.pop(); if(i&lt;len &amp;&amp; !st.empty()){ ans[i]=st.top(); } st.push(nums[i%len]); } return ans; }};","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"堆与堆排序","text":"堆其实就是一种数组形式的完全二叉树，具体分为大根堆和小根堆 大根堆：父节点的值大于等于子节点的值 小根堆：父节点的值小于等于子节点的值 堆排序利用堆的特点，根节点大于等于所有节点的值（大根堆），那么每次建堆后将根节点与末尾节点交换位置，然后再对末尾节点以外的所有节点重新建堆（注意，这里不需要调用build_heap函数，只需要调用heapify函数即可，因为根节点的做右子树已经是堆，正因为如此，堆排序才有nlogn的时间复杂度），这样不断重复即可完成排序。 技巧：逆序下第一个有子节点的节点的下标，无论什么情形，固定为$len/2-1$ 原因：任意一个节点的父节点下标为(i-1)/2; 那么逆序第一个有子节点的节点，即为完全二叉树最后一个节点的父节点。故为(n-1-1)/2=n/2-1; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;void swap(int tree[], int c1, int c2) { int t = tree[c1]; tree[c1] = tree[c2]; tree[c2] = t;}/** * n个节点的完全二叉树 * 在第i个节点处建堆 * 前提：左右子树已经是堆 * @param tree * @param n 完全二叉树节点个数 * @param i 进行heapify的根节点 */void heapify(int tree[], int n, int i) { int p = i; while (p &lt; n) { int max = p; int l = 2 * p + 1, r = 2 * p + 2; if (l &lt; n &amp;&amp; tree[l] &gt; tree[max]) { max = l; } if (r &lt; n &amp;&amp; tree[r] &gt; tree[max]) { max = r; } if (max == p) break; swap(tree, p, max); p = max; }}/** * 对节点数为n的完全二叉树建堆 * @param tree * @param n 完全二叉树节点个数 */void build_heap(int tree[], int n) { int p = n / 2 - 1; while (p &gt;= 0) { heapify(tree, n, p); p--; }}/*堆排序*/void heap_sort(int tree[], int n) { build_heap(tree, n); for (int i = n - 1; i &gt; 0; i--) { swap(tree, 0, i); heapify(tree, i, 0); }} 知识点: 堆排序中,建堆(buildHeap)的时间复杂度是O(N),具体计算方法是计算每个节点的计算次数,然后用等比数列求和公式,最后得到. 问:为什么堆排序不用小根堆? 答:小根堆无法向下调整堆,向上调整堆的时间复杂度是O(N),整体时间复杂度是N2","link":"/2020/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"单调队列解决滑动窗口最大值问题","text":"今天遇到一道滑动窗口最大值问题239滑动窗口最大值，发现单调队列是解决这类问题的高效方法，遂加以记录。 单调队列：即保持单调有序的队列。底层数据结构使用双端队列比较好，C++需要添加&lt;deque&gt;头文件。 滑动窗口最大值问题中，我们关心的是滑动窗口内的最大值，当滑动窗口向右移动一位时，需要删除一个元素和添加一个元素。对于添加元素来说比较好办，如果添加的元素大于当前最大值则替换其为最大值。而删除元素，如果删除的是最大值，则需要重新遍历滑动窗口内容，造成效率的低下。 研究此问题发现，如下图，当添加的元素是4,时，前面的所有小于4的元素均变成无效数据（如果删除5，则4是最大值，轮不到123当最大值；如果删除了5又删除了4，因为123在4之前进入滑动窗口，所以删除4之前123已经被删除，所以也轮不到123当最大值）。 因此滑动窗口右移，一：删除窗口左端元素，如果和队首元素相同，则队首元素出队，否则什么也不做；二：添加窗口右边元素，新元素入队时，都将前面所有比自己小的元素删除再入队 1234567891011121314151617181920212223242526272829303132333435//单调队列struct MonotonicQue{ deque&lt;int&gt;que; void push(int n){ while(!que.empty() &amp;&amp; que.back()&lt;n){ que.pop_back(); } que.push_back(n); } void pop(int n){ if(n==que.front()) que.pop_front(); } int top(){ return que.front(); }};class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MonotonicQue monQue; //添加前k个元素到单调队列 for(int i=0;i&lt;k;i++) monQue.push(nums[i]); vector&lt;int&gt;ans; ans.push_back(monQue.top()); for(int i=k;i&lt;nums.size();i++){ monQue.pop(nums[i-k]); monQue.push(nums[i]); ans.push_back(monQue.top()); } return ans; }};","link":"/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"},{"title":"实现一个LRU缓存结构","text":"LRU：最近最少使用算法。LRU缓存算法，由哈希表和双向链表构成，能以O(1)时间复杂度获取缓存的键值，也能以O(1)的时间复杂度存储键值。 Java中有内置类型LinkedHashMap，可以直接用于LRUCache的实现。C++没有，需要手动实现，这里我手动实现一个。 leetcode有一题LRU题目LRU缓存机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//双向链表+哈希表struct Node{ int key,val; Node*pre,*next; Node(int k,int v):key(k),val(v),pre(NULL),next(NULL){}};class DoubleList{ public: DoubleList(){ size=0; head=new Node(0,0); tail=new Node(0,0); head-&gt;next=tail; tail-&gt;pre=head; } //在链表尾部添加节点 void addTail(Node*x){ x-&gt;next=tail; x-&gt;pre=tail-&gt;pre; tail-&gt;pre-&gt;next=x; tail-&gt;pre=x; size++; } //删除某个节点(根据地址) void deleteNode(Node*x){ x-&gt;pre-&gt;next=x-&gt;next; x-&gt;next-&gt;pre=x-&gt;pre; size--; //return x; } //删除首节点，并返回其键值，用于反向删除map中的键 int deleteFirst(){ int key=head-&gt;next-&gt;key; deleteNode(head-&gt;next); return key; } int getSize(){ return size; } private: int size; Node*head,*tail; //tail处是最近访问的};class LRUCache {public: LRUCache(int capacity) { this-&gt;capacity=capacity; } int get(int key) { if(node_map.find(key)==node_map.end()) return -1; Node*p=node_map[key]; makeRecent(p); return p-&gt;val; } void put(int key, int value) { //如果已经存在，则更新值 if(node_map.find(key)!=node_map.end()){ Node*p=node_map[key]; makeRecent(p); p-&gt;val=value; return; } //不存在的情况下： //如果满了 if(capacity==cache.getSize()){ removeLRU(); } Node*p=new Node(key,value); cache.addTail(p); //放入哈希表 node_map[key]=p; } //将某个节点提升到recent void makeRecent(Node*x){ cache.deleteNode(x); cache.addTail(x); } //删除LRU节点缓存 void removeLRU(){ int key=cache.deleteFirst(); node_map.erase(key); }private: int capacity; DoubleList cache; unordered_map&lt;int,Node*&gt;node_map;}; 123456789101112131415161718192021222324252627282930313233343536373839404142class LRUCache { int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() &gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); }}","link":"/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/"},{"title":"最大频率栈","text":"今天写到一到数据结构的题目，觉得很有意思，遂记录下leetcode895最大频率栈。这题既需要记录每个数字的频率，又需要记录每种频率拥有的数字，故采用两个map来实现。 执行过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FreqStack {public: FreqStack() { maxFreq=0; } void push(int val) { /*查询是否已存在*/ if(numFreq.find(val)==numFreq.end()){ numFreq[val]=1; freqNums[1].push(val); if(maxFreq==0) maxFreq=1; }else{ numFreq[val]++; freqNums[numFreq[val]].push(val); if(numFreq[val]&gt;maxFreq) maxFreq++; } } int pop() { int ans=freqNums[maxFreq].top(); freqNums[maxFreq].pop(); if(freqNums[maxFreq].empty()) maxFreq--; if(numFreq[ans]==1){ numFreq.erase(ans); }else{ numFreq[ans]--; } return ans; }private: map&lt;int,int&gt;numFreq; //每个数字的频率 map&lt;int,stack&lt;int&gt;&gt;freqNums; //每种频率含有的数字 int maxFreq; //最大频率};/** * Your FreqStack object will be instantiated and called as such: * FreqStack* obj = new FreqStack(); * obj-&gt;push(val); * int param_2 = obj-&gt;pop(); */","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"},{"title":"实现一个优先级队列(堆)","text":"手动实现一个优先级队列，拥有插入、弹出、判空功能。核心代码是对维护堆结构的代码：从完全二叉树逆序第一个有子节点的节点开始调整。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//手动实现一个二叉堆（优先级队列）#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class PriorityQueue{public: //插入 void push(int n){ arr.push_back(n); makeHeap(); } //弹出队首元素 int pop(){ int ans=arr[0]; swap(arr[0],arr[arr.size()-1]); arr.pop_back(); makeHeap(); return ans; } //判断队空 bool empty(){ return arr.size()==0; }private: //底层数组 vector&lt;int&gt;arr; //调整堆结构 void makeHeap(){ int len=arr.size(); int first=len/2-1; //固定是此位置 for(int i=first;i&gt;=0;i--){ //如果存在右子节点 if(2*i+2&lt;len){ if(arr[2*i+2]&lt;arr[2*i+1] &amp;&amp; arr[2*i+2]&lt;arr[i]) swap(arr[2*i+2],arr[i]); else if(arr[2*i+1]&lt;arr[2*i+2] &amp;&amp; arr[2*i+1]&lt;arr[i]) swap(arr[2*i+1],arr[i]); } //只有左子节点 else{ if(arr[2*i+1]&lt;arr[i]){ swap(arr[2*i+1],arr[i]); } } } }};int main(){ PriorityQueue que; que.push(1); que.push(1); que.push(4); que.push(3); que.push(2); while(!que.empty()){ cout&lt;&lt;que.pop()&lt;&lt;&quot; &quot;; }}","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8F%89%E5%A0%86%EF%BC%89/"},{"title":"Floyd判圈法","text":"Floyd判圈法用于判断一个链表中是否有环并找到环首位置，其算法分为两个部分。 第一部分：判断是否有环141环形链表其算法应用龟兔赛跑的思想，使用一个slow和fast指针初始都指向链表第一个节点，slow每次向前走一步，fast向前走两步。如果链表无环，那么fast会先走到NULL节点。如果有环，那么当slow和fast都进入环的时候，由于fast比slow走的快，fast总会追上slow。C++代码如下： 12345678910111213class Solution {public: bool hasCycle(ListNode *head) { ListNode*slow=head,*fast=head; while(slow &amp;&amp; fast &amp;&amp; fast-&gt;next){ slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) return true; } return false; }}; 第二部分：找到环开始的节点142环形链表II当fast和slow相遇的时候，将fast调到链表开头节点，每次fast和slow各向前走一步，直到相遇。相遇时指向的节点即是环开始的节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { //floyd判圈法 public ListNode detectCycle(ListNode head) { if(head==null) return null; ListNode slow=head,fast=head; do{ if(fast.next!=null &amp;&amp; fast.next.next!=null) fast=fast.next.next; else return null; slow=slow.next; }while(slow!=fast); slow=head; while(slow!=fast){ slow=slow.next; fast=fast.next; } return slow; }} 原理如下：","link":"/2021/03/18/%E7%AE%97%E6%B3%95-Floyd%E5%88%A4%E5%9C%88%E6%B3%95/"},{"title":"LRU缓存","text":"leetcode146LRU缓存，这题可以直接用Java的LinkedHashMap来写，或者自己实现hash+双向链表。 首先分析问题，题目有两个需求，一个是O(1)时间找到key-value；一个是根据LRU替换规则，需要在各key-value之间保持某种顺序 O(1)时间访问–&gt;哈希表 保持一定顺序–&gt;双向链表维护顺序 在Java中LinkedHashMap底层是hash表+双向链表，因此可以直接继承LinkedHashMap，或者自己手动写一个也可以。 方法一：使用Java的LinkedHashMap详解见leetcode 题解 123456789101112131415161718192021class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;{ private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } //可不写 public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) { return size() &gt; capacity; }} 主要就是重写removeEldestEntry函数，实现自定义的删除最老元素回调函数的时机。 方法二：手动实现LRU注意：删除节点时要同时在hash表和双向链表中删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.HashMap;import java.util.LinkedList;import java.util.Map;/*首先分析有哪些动作* 1. get：如果没有返回-1，如果有返回value，并且将数据在链表中的位置放到开头* 2. put，如果有，更新值并将节点放到链表开头；* 如果没有，则放到链表开头（若空间不足不需要先删除链表尾部元素，* 并在hash表中删除）*/public class LRUCache { //成员内部类 class Node{ int key,value; Node pre,next; Node(int value){ this.value=value; pre=null; next=null; } Node(int key,int value){ this.key=key; this.value=value; } Node(int key,int value,Node pre,Node next){ this.key=key; this.value=value; this.pre=pre; this.next=next; } } //双向链表 Node head; Node tail; //哈希表 Map&lt;Integer,Node&gt; hash=new HashMap&lt;&gt;(); private int capacity; private int count=0; public LRUCache(int capacity){ this.capacity=capacity; head=new Node(-1); tail=new Node(-1); head.next=tail; tail.pre=head; } public int get(int key){ if(!hash.containsKey(key)) return -1; Node t=hash.get(key); int val=t.value; deleteNode(t); moveToHead(t); return val; } public void put(int key,int value){ if(hash.containsKey(key)){ Node t=hash.get(key); t.value=value; deleteNode(t); moveToHead(t); }else{ if(count&lt;capacity){ count++; }else{ hash.remove(tail.pre.key); deleteNode(tail.pre); } Node t=new Node(key,value); hash.put(key,t); moveToHead(t); } } //将某个节点移动到双向链表的开头 private void moveToHead(Node t){ t.next=head.next; head.next=t; t.next.pre=t; t.pre=head; } //将某个节点剥离双向链表 private void deleteNode(Node t){ t.next.pre=t.pre; t.pre.next=t.next; }}","link":"/2022/04/07/%E7%AE%97%E6%B3%95-LRU%E7%AE%97%E6%B3%95/"},{"title":"搜索旋转排序数组II","text":"刷到leetcode81题搜索旋转排序数组觉得有点意思，遂记录下解题思路和过程。要求实现O(logn)的时间复杂度。 要抓住二分查找的核心，其在于每次排除掉一边的区间，故不在乎整个数组是否是完全递增的，只要每次能排除掉一边的区间，选择另一个区间继续进行二分查找即可。 对于这一题，数组的大小顺序形如下图：我们以右端点为参照对象进行分类，当中间值==target时返回true，否则： 如果mid值小于右端点时：如果中间值&lt;target&lt;=右端点，则下一步对mid右侧进行二分查找，否则对mid左侧进行二分查找 如果mid值大于右端点时：如果左端点&lt;=target&lt;=中间值，则下一步对mid左侧进行二分查找，否则对mid右侧进行二分查找 如果mid值等于右端点时： 直接让右端点向左挪一个单位。（因为target不等于mid值，mid值又等于右端点的值，因此右端点可以被抛弃） 代码如下： 123456789101112131415161718192021222324252627bool search(vector&lt;int&gt;&amp; nums, int target) { int left=0,right=nums.size()-1; while(left&lt;=right){ int mid=(left+right)/2; //命中则返回true if(nums[mid]==target) return true; //以右端点为参照进行分类 if(nums[mid]&lt;nums[right]){ //就两种情况，要不在左半边，要不在右半边 if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left=mid+1; else right=mid-1; }else if(nums[mid]&gt;nums[right]){ //就两种情况，要不在左半边，要不在右半边 if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right=mid-1; else left=mid+1; }else{ //抛弃右端点 right--; } } return false;} 这里再看一道旋转数组的变形，同样要求时间复杂度O（logn）：这里同样应用刚才说的二分查找的核心思路，每次排除掉一边，对另一边继续进行二分查找。代码如下： 123456789101112131415161718192021class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { if(nums.size()==1) return nums[0]; int left=0,right=nums.size()-1; while(left&lt;right-1){ //缩小到最小区间 int mid=(left+right)/2; if(nums[mid]&lt;nums[right]){ //最小值只有可能在左侧 right=mid; }else if(nums[mid]&gt;nums[right]){ //最小值只可能在右边 left=mid; }else //右端点此时不可能是最小值，排除 right--; } return min(nums[left],nums[right]); //返回最后两个候选人中较小的 }};","link":"/2021/03/21/%E7%AE%97%E6%B3%95-leetcode-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"},{"title":"K个一组反转链表","text":"leetcode 递归方法，其中结合了一般反转链表的非递归写法 123456789101112131415161718192021222324252627public class Solution { public ListNode reverseKGroup(ListNode head, int k) { //如果长度不足k那么直接返回 int cnt=k; ListNode p=head; while(p!=null &amp;&amp; cnt&gt;0){ cnt--; p=p.next; } if(cnt&gt;0) return head; //否则递归调用 ListNode tail=reverseKGroup(p,k); ListNode pre=tail; p=head; while(k&gt;0){ k--; ListNode t=p.next; p.next=pre; pre=p; p=t; } return pre; }}","link":"/2022/04/17/%E7%AE%97%E6%B3%95-leetcode-K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"K站中转内最便宜的航班","text":"leetcode 787 K站中转内最便宜的航班 方法一：改进的BFS，使用优先级队列(超时）一般遇到最短路径（最少步骤、最近距离）的题目，要下意识地想到用BFS。 这一题是带权的，直接bfs不好写，可以借助于优先级队列，这一题中需要用到小根堆，每次选择距离src最近的进行处理 1234567891011121314151617181920212223242526272829303132333435363738class Node{public: int N; //号 int K; //与src之间有多少个中转节点 int D; //与src之间的距离 Node(int n,int k,int d):N(n),K(k),D(d){} bool operator&lt;(const Node &amp;node)const{ return D&gt;node.D; //小根堆 }};class Solution {public: int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) { vector&lt;vector&lt;int&gt;&gt;edges(n,vector&lt;int&gt;(n,-1)); for(auto&amp;a:flights){ edges[a[0]][a[1]]=a[2]; } priority_queue&lt;Node&gt;que; que.push(Node(src,-1,0)); while(!que.empty()){ Node first=que.top(); que.pop(); if(first.N==dst &amp;&amp; first.K&lt;=k){ return first.D; } if(first.K&gt;=k) continue; //将后续放入 for(int i=0;i&lt;n;i++){ if(edges[first.N][i]!=-1){ que.push(Node(i,first.K+1,first.D+edges[first.N][i])); } } } return -1; }}; 注意：在这一题中，某些用例下会超时。 方法二：dfs+回溯+剪枝（超时）1234567891011121314151617181920212223242526272829303132333435class Solution {public: int des,n; vector&lt;vector&lt;int&gt;&gt;edge; int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) { //邻接矩阵 edge=vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(n,0x3f3f3f3f)); for(auto&amp;a:flights){ edge[a[0]][a[1]]=a[2]; } des=dst; this-&gt;n=n; int ans=help(src,k); return ans!=0x3f3f3f3f?ans:-1; } //src节点，在k个中转限制下到达终点，所需的最小费用（如果不能则返回0x3f3f3f3f) int help(int src,int k){ //k不可能满足了 if(k&lt;-1) return 0x3f3f3f3f; //走到终点 if(src==des){ return k&gt;=-1?0:0x3f3f3f3f; } int ans=0x3f3f3f3f; //寻找下一个节点 for(int i=0;i&lt;n;i++){ if(edge[src][i]!=0x3f3f3f3f &amp;&amp; edge[src][i]&lt;ans){ ans=min(ans,edge[src][i]+help(i,k-1)); } } path.erase(src); return ans; }}; 方法四：Bellman-Ford 算法","link":"/2021/08/13/%E7%AE%97%E6%B3%95-leetcode-K%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/"},{"title":"leetcode N皇后问题","text":"解决完N皇后问题后，将思路加以记录首先我整体的方法使用的是DFS+回溯，每次递归对第k行，在哪一列放置Queen进行处理。函数主要有：辅助函数assist，冲突位置记录函数choose，冲突位置回溯函数backTrace，其中辅助函数完成主要任务。 对于辅助函数，终止条件是递归到第n行（只有0~n-1行，递归到第n行说明0~n-1行都成功放置了皇后） 辅助函数的递归+回溯的逻辑是 在当前行一个无冲突位置放置皇后（记录当前行放置的皇后的位置，同时在mark数组种记录因此而产生的冲突） 递归下一行 回溯（撤销当前行放置的皇后，撤掉在mark数组记录的冲突） 其中记录冲突有多种方法，我使用的是mark矩阵来记录（切记斜方向上有做对角线和右对角线两种）。 网上还有一种不错的方法，是使用vector&lt;bool&gt;column(n,false)，vector&lt;bool&gt;ldiag(2*n-1,false)，vector&lt;bool&gt;rdiag(2*n-1,false)来记录矩阵的每一列，每个左对角线和右对角线是否已被占用，左右对角线的个数都为2*n-1，这是显而易见的。 C++代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Solution{public: bool mark[9][9]; //记录放置位置，需要回溯 vector&lt;vector&lt;string&gt; &gt;ans; vector&lt;int&gt;queenPos; //0~n行皇后放置的位置 //将放置在该位置产生的冲突记录下来 void choose(int x,int y,vector&lt;pair&lt;int,int&gt; &gt;&amp;record,int n) { mark[x][y]=false; record.push_back(make_pair(x,y)); //竖直方向 for(int i=0-n; i&lt;=n; i++) { if(i+x&gt;=0 &amp;&amp; i+x&lt;n) { if(mark[i+x][y]) { mark[i+x][y]=false; record.push_back(make_pair(x+i,y)); } } } //斜方向（主对角线和副对角线） for(int i=0-n; i&lt;=n; i++) { if(i+x&gt;=0 &amp;&amp; i+x&lt;n &amp;&amp; i+y&gt;=0 &amp;&amp; i+y&lt;n ) { if(mark[i+x][i+y]) { mark[i+x][i+y]=false; record.push_back(make_pair(x+i,y+i)); } } } for(int i=0-n; i&lt;=n; i++) { if(i+x&gt;=0 &amp;&amp; i+x&lt;n &amp;&amp; y-i&gt;=0 &amp;&amp; y-i&lt;n ) { if(mark[i+x][y-i]) { mark[i+x][y-i]=false; record.push_back(make_pair(x+i,y-i)); } } } } void backTrace(vector&lt;pair&lt;int,int&gt; &gt;&amp;record) { for(int i=0; i&lt;record.size(); i++) { int x=record[i].first; int y=record[i].second; mark[x][y]=true; } } //辅助函数，对第k行进行处理 void assist(int k,int n) { //递归终止条件，采用下一轮判断法 if(k==n) { vector&lt;string&gt;temp; for(int i=0;i&lt;queenPos.size();i++){ string t=&quot;&quot;; for(int j=0;j&lt;n;j++){ if(j!=queenPos[i]) t+='.'; else t+='Q'; } temp.push_back(t); } ans.push_back(temp); return; } //递归+回溯 for(int i=0; i&lt;n; i++) //放置在第k行可以放置的位置上 { if(mark[k][i]) { queenPos.push_back(i); //记录第k行选择了第i列放置皇后 vector&lt;pair&lt;int,int&gt; &gt;record; choose(k,i,record,n); //选中该位置以后，标记产生的冲突位置 assist(k+1,n); queenPos.pop_back(); //撤掉第k行在第i列放置的皇后 backTrace(record); //回溯刚才记录的冲突 } } } vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) { for(int i=0; i&lt;9; i++) fill(mark[i],mark[i]+9,true); assist(0,n); //从第0行开始 return ans; }}; 网上根据列、左右对角线占用记录来求解的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int n; vector&lt;vector&lt;string&gt; &gt;ans; vector&lt;string&gt;chess; void assist(int k,vector&lt;bool&gt;&amp;column,vector&lt;bool&gt;&amp;ldiag,vector&lt;bool&gt;&amp;rdiag){ //递归终止条件 if(k==n){ ans.push_back(chess); return; } //递归+回溯 for(int i=0;i&lt;n;i++){ //对第k层的第i列进行判断，是否能够放置Queen //计算该位置是第列，第几条左对角线，第几条右对角线 int cur_col=i,cur_ldiag=(i-k)+n-1,cur_rdiag=i+k; if(!column[cur_col] || !ldiag[cur_ldiag] || !rdiag[cur_rdiag]) continue; //选中该位置 column[cur_col]=false; ldiag[cur_ldiag]=false; rdiag[cur_rdiag]=false; string temp=&quot;&quot;; for(int j=0;j&lt;n;j++) if(j==i) temp+='Q'; else temp+='.'; chess.push_back(temp); //递归 assist(k+1,column,ldiag,rdiag); //回溯 column[cur_col]=true; ldiag[cur_ldiag]=true; rdiag[cur_rdiag]=true; chess.pop_back(); } } vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) { this-&gt;n=n; vector&lt;bool&gt;column(n,true); vector&lt;bool&gt;ldiag(2*n-1,true); vector&lt;bool&gt;rdiag(2*n-1,true); assist(0,column,ldiag,rdiag); return ans; }};","link":"/2021/03/29/%E7%AE%97%E6%B3%95-leetcode-N%E7%9A%87%E5%90%8E/"},{"title":"两道二叉树的公共祖先","text":"leetcode 二叉搜索树的最近公共祖先 牢牢把握一件事：pq在root异侧则说明root是pq的最近公共祖先 小技巧：先用一个递归保证p.val小于q.val，后续处理就很方便了，很棒！ 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //二叉搜索树的特点：左子树都小于root，右子树都大于root public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { int v=root.val; int pv=p.val; int qv=q.val; if(pv&gt;qv) //保证p的值小于q return lowestCommonAncestor(root,q,p); if(pv&gt;v) return lowestCommonAncestor(root.right,p,q); else if(qv&lt;v) return lowestCommonAncestor(root.left,p,q); return root; }} 二叉树的最近公共祖先 方法一：最好的方法 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { //若t是ab的最近公共祖先，则ab在t的异侧 //返回pq的最近公共祖先或者p或者q或者null //抽象的来说，就是把pq在树中，往上拎 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root==null) return null; if(root==p || root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left!=null &amp;&amp; right!=null) //说明root是最近公共祖先 return root; if(left!=null) return left; if(right!=null) return right; return null; } } 方法二： 递归+位运算。如果以某一节点为根的树包含了p和q，那么该节点是p和q的祖先；后续遍历，找到最早出现的祖先即可。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { TreeNode ans; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { find(root,p,q); return ans; } int find(TreeNode t,TreeNode p,TreeNode q){ if(ans!=null || t==null) //说明已经找到了 return 0; int l=find(t.left,p,q); if(ans!=null) //剪枝 return 0; int r=find(t.right,p,q); if(ans!=null) //剪枝 return 0; int s=0; if(t==p) s|=1; if(t==q) s|=2; s|=l; s|=r; if(s==3 &amp;&amp; ans==null){ ans=t; } return s; }}","link":"/2022/04/17/%E7%AE%97%E6%B3%95-leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"leetcode 优势洗牌","text":"今天遇到一道算法题870优势洗牌，发现这个问题类似著名的田忌赛马问题。 使用贪心算法可以有效解决这个问题，其思想核心是：比得过就比，比不过就找个最菜的垫背。 下面的C++代码也值得品味，使用了Lambda表达式。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; advantageCount(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { int len = nums1.size(); vector&lt;int&gt; ans(len); //结果集 /*记录nums2的数字和下标*/ vector&lt;pair&lt;int, int&gt;&gt; nums3; nums3.reserve(len); //预留vector空间 for (int i = 0; i &lt; len; i++) nums3.emplace_back(nums2[i], i); /*对nums1和nums3进行由大到小排序*/ sort(nums3.begin(),nums3.end(),[](pair&lt;int,int&gt;&amp;a,pair&lt;int,int&gt;&amp;b){ return a.first&gt;b.first; }); sort(nums1.rbegin(),nums1.rend()); //逆序排列 /*双指针进行比较*/ int left=0,right=len-1; for(auto &amp;item:nums3){ if(item.first&lt;nums1[left]){ ans[item.second]=nums1[left]; left++; }else{ ans[item.second]=nums1[right]; right--; } } return ans; }}; 注意：这里的vector.reserve（储备），是在已知长度的情况下，为vector预留空间，这样后序添加的时候，就无需频繁扩容（含有数组的赋值），提高效率。","link":"/2021/07/30/%E7%AE%97%E6%B3%95-leetcode-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/"},{"title":"leetcode 分割数组的最大值","text":"410分割数组的最大值 遇到诸如 “xx最大值的最小”，这类问题，一般都可以采用二分来解决。 这一题正向思维不好解决，需要逆向思维，直接对分组和的最大值进行二分搜索，其下限是数组中最大元素，上限是所有元素的和。枚举分组和的最大值后，逆向判断在此情况下，能否使得数组分为m个分组（贪心解决）。 1234567891011121314151617181920212223242526272829303132333435class Solution {public: bool check(vector&lt;int&gt;&amp; nums, int x, int m) { long long sum = 0; int cnt = 1; for (int i = 0; i &lt; nums.size(); i++) { if (sum + nums[i] &gt; x) { cnt++; sum = nums[i]; } else { sum += nums[i]; } } return cnt &lt;= m; } int splitArray(vector&lt;int&gt;&amp; nums, int m) { long long left = 0, right = 0; for (int i = 0; i &lt; nums.size(); i++) { right += nums[i]; if (left &lt; nums[i]) { left = nums[i]; } } while (left &lt; right) { long long mid = (left + right) &gt;&gt; 1; if (check(nums, mid, m)) { right = mid; } else { left = mid + 1; } } return left; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95-leetcode-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"leetcode-划分k个相等的子集","text":"leetcode 698 划分为k个相等的子集 解题之前先将题目等效为更容易求解的问题，这一题可以转换为一组数放入若干个桶中，使每个桶中数字的和均为target。 这一题有两种解题视角：1.从数字角度出发，每个数字选择一个桶放入2.从桶角度出发，每个桶选择若干数字放入自身 解法1：该解法中，事先对数组进行由大到小的排序，可以大幅提升效率，原因在于：如果本轮的一系列选择最终会导致溢出，那么应该让溢出早点发生，不浪费算力，因此大的放前边可以使迟早会溢出的一组数早点溢出，提高效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private int target; private int[] basket; //把数放到四个篮子里 private int ans = 0; int[] nums; int k; public boolean canPartitionKSubsets(int[] nums, int k) { this.k = k; this.nums = nums; int len = nums.length; if (k &gt; len) return false; basket = new int[k]; Arrays.fill(basket, 0); int sum = Arrays.stream(nums).sum(); if (sum % k != 0) return false; target = sum / k; //写一个冒泡排序，时间复杂度O(N^2) for(int i=0;i&lt;nums.length-1;i++){ for(int j=0;j&lt;nums.length-1-i;j++){ if(nums[j]&lt;nums[j+1]){ int t=nums[j]; nums[j]=nums[j+1]; nums[j+1]=t; } } } dfs(0); return ans == 1; } private void dfs(int t) { //if ans is already true, then stop recursion if (ans == 1) return; if (t == nums.length) { boolean flag = true; //check k baskets for (int n : basket) { if (n != target) { flag = false; break; } } if (flag) ans = 1; return; } //choose the basket for (int i = 0; i &lt; basket.length; i++) { if (nums[t] + basket[i] &lt;= target) { basket[i] += nums[t]; dfs(t + 1); basket[i] -= nums[t]; } } }} 解法2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { private int n,target,k; private int[] bucket,nums; private int tag=0; //tag for which bucket to use private boolean []canBeChose; public boolean canPartitionKSubsets(int[] nums, int k) { n=nums.length; this.nums=nums; this.k=k; if(k&gt;n) return false; int sum=Arrays.stream(nums).sum(); if(sum%k!=0) return false; target=sum/k; bucket=new int[k]; Arrays.fill(bucket,0);/*initialize zero for every bucket*/ canBeChose=new boolean[n]; Arrays.fill(canBeChose,true); return dfs(0,0); } private boolean dfs(int bucketNum,int index){ /*k个桶都选完了*/ if(bucketNum==k){ for(int i:bucket) System.out.print(i+&quot; &quot;); System.out.println(); return true; } //某个桶已经选完了，看下一个桶 if(index==n){ if(bucket[bucketNum]!=target) return false; return dfs(bucketNum+1,0); } //当前桶已经选满了 if(bucket[bucketNum]==target){ return dfs(bucketNum+1,0); } //如果该元素已经被选中了 if(!canBeChose[index]) return dfs(bucketNum,index+1); if(bucket[bucketNum]+nums[index]&lt;=target){ bucket[bucketNum]+=nums[index]; canBeChose[index]=false; if (dfs(bucketNum,index+1)) { return true; } canBeChose[index]=true; bucket[bucketNum]-=nums[index]; } if (dfs(bucketNum,index+1)) { return true; } return false; }}","link":"/2021/08/19/%E7%AE%97%E6%B3%95-leetcode-%E5%88%92%E5%88%86k%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/"},{"title":"leetcode-地下城游戏","text":"这一题让我学到了两个教训： 动态规划先写状态转移方程 写动态规划应该思维灵活，有时需要逆向思维 12345678910111213141516171819202122232425262728//先写状态转移方程，无论是递归还是动态规划/*dp[i][j]=max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);*/class Solution {public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) { int m=dungeon.size(),n=dungeon[0].size(); vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0x3f3f3f3f)); for(int i=m-1;i&gt;=0;i--){ for(int j=n-1;j&gt;=0;j--){ if(i==m-1 &amp;&amp; j==n-1){ dp[i][j]=max(1,1-dungeon[i][j]); continue; } int a=0x3f3f3f3f,b=0x3f3f3f3f; //想加相乘都小于int范围 if(i+1&lt;m){ a=dp[i+1][j]; } if(j+1&lt;n){ b=dp[i][j+1]; } dp[i][j]=max(1,min(a,b)-dungeon[i][j]); } } return dp[0][0]; }};","link":"/2021/08/11/%E7%AE%97%E6%B3%95-leetcode-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"},{"title":"leetcode-数据流的中位数","text":"leetcode 精髓是用两个堆来保存大的一半和小的一半的数字。 凡是遇到奇怪的数据结构的题目，首先要想到堆、hash这些。。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder { PriorityQueue&lt;Integer&gt;que1=new PriorityQueue&lt;&gt;((x,y)-&gt;(y-x)); //大根堆 PriorityQueue&lt;Integer&gt;que2=new PriorityQueue&lt;&gt;(); //小根堆 int n1=0,n2=0; /** initialize your data structure here. */ public MedianFinder() { } public void addNum(int num) { /*这样的方式存入，可以保证que1中的元素全部小于等于que2中的元素*/ if(n1==n2){ que2.offer(num); que1.offer(que2.poll()); n1++; }else{ que1.offer(num); que2.offer(que1.poll()); n2++; } } public double findMedian() { if(n1==n2) return (que1.peek()+que2.peek())/2.0; return que1.peek(); }}/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */","link":"/2022/04/12/%E7%AE%97%E6%B3%95-leetcode-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"leetcode-数组中数字出现的次数","text":"leetcode 精髓在于：分组异或操作。将所有数字异或之后，以二进制某一位为1的位置来作为分组的依据（任取全部异或后结果为1的位置即可）。 凡是在这一位置上为0的分到一组，其余分到另一组。这样能够保证相同数字肯定分到一组（相同数字每一位上的1/0都相同），同时两个出现一次的数字肯定不在一组。 其中，lowbit操作可以找到一个数字为1的一位。 123456789101112131415161718192021class Solution { int lowbit(int x){ return x&amp;(-x); } //贪心 dp 二分 排序 搜索 位运算 public int[] singleNumbers(int[] nums) { int res=0; for(int i:nums) res^=i; int r1=0,r2=0; int t=lowbit(res); for(int i:nums){ if((t&amp;i)==0) r1^=i; else r2^=i; } return new int[]{r1,r2}; }}","link":"/2022/04/14/%E7%AE%97%E6%B3%95-leetcode-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"},{"title":"leetcode-数组中出现次数超过一半的数字","text":"leetcode 方法1：先排序，然后取最中间的数字 方法2：摩尔投票。其思路是：每次去掉两个不同的数字，直到不能删除为止，剩下的就是众数。（如果删掉的两个数字都不是众数，那么对结果没有影响；如果删掉的其中一个是众数，那么对结果也没有影响） 123456789101112131415161718class Solution { public int majorityElement(int[] nums) { int candidate=0; int cnt=0; for(int i=0;i&lt;nums.length;i++){ if(cnt==0){ cnt=1; candidate=nums[i]; }else{ if(nums[i]==candidate) cnt++; else cnt--; } } return candidate; }}","link":"/2022/04/12/%E7%AE%97%E6%B3%95-leetcode-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"数组中的逆序对","text":"leetcode 核心思想：归并排序与逆序对有着天然的练习。两个有序数组num1和num2进行merge时，使用双指针p1,p2; 如果num1[p1]&gt;num2[p2]时，那么num2[p2]与num1[p1]，num1[p1+1]…num1[num1.size()-1]，即p1所指元素后的所有元素都会形成逆序对。 那么在归并排序的过程中统计这个数量即可。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public int reversePairs(int[] nums) { mergeSort(nums,0,nums.length-1); return cnt; } void mergeSort(int[]nums,int l,int r){ if(l&gt;=r) return; int mid=l+(r-l)/2; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); merge(nums,l,mid,r); } int cnt=0; void merge(int[]nums,int l,int mid,int r){ int p1=l,p2=mid+1; int n=r-l+1; int[]tmp=new int[n]; int t=0; while(p1&lt;=mid &amp;&amp; p2&lt;=r){ if(nums[p2]&lt;nums[p1]){ //统计逆序对个数 cnt+=mid-p1+1; tmp[t++]=nums[p2++]; } else{ tmp[t++]=nums[p1++]; } } while(p1&lt;=mid) tmp[t++]=nums[p1++]; while(p2&lt;=r) tmp[t++]=nums[p2++]; for(int i=0;i&lt;n;i++) nums[l+i]=tmp[i]; }}","link":"/2022/04/13/%E7%AE%97%E6%B3%95-leetcode-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"title":"最长递增子序列的长度","text":"300最长递增子序列 这一题如果使用动态规划来写，那么会到达$O(N^2)$的时间复杂度。由于不需要求出具体的最长递增子序列，只需要求出最长的长度，那么可以使用贪心+二分，将时间复杂度降低到$O(N*logN)$ 思路：维护一个升序队列，在遍历nums的过程中，不断优化升序队列的结构（使每个元素尽可能小），这样给后序元素的添加提供了更大的数字空间。 123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) {//维护一个升序队列，在遍历nums的过程中，不断优化升序队列的结构（使每个元素尽可能小），这样给后序元素的添加提供了更大的数字空间。 vector&lt;int&gt;arr; for(auto&amp;n:nums){ auto it=lower_bound(arr.begin(),arr.end(),n); //所有元素都小于n（或为空） if(it==arr.end()){ arr.push_back(n); continue; } //替换第一个大于等于它的元素，以优化结构（瘦身），使得后序元素有更大的数字空间来进栈 *it=n; } return arr.size(); }}; 注意这里使用了lower_bound()，底层是对顺序表的二分查找，时间复杂度是O(logN)","link":"/2021/08/13/%E7%AE%97%E6%B3%95-leetcode-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"title":"leetcode 求1+2+…+n","text":"leetcode 前置知识：快速乘(俄罗斯农民乘法）（ 前提：a和b是正整数 12345678910int quickMuilti(int a,int b){ int ans=0; while(b&gt;0){ if((b&amp;1)&gt;0) ans+=a; a&lt;&lt;=1; b&gt;&gt;=1; } return ans;} 原理： A*B=A*(2^0+2^3+2^10+..)=((A&lt;&lt;1)+(A&lt;&lt;3)+(A&lt;&lt;10)+…) 回到本题，其中if不能用，则可以用逻辑运算的短路效应代替，for循环不能用，则n的最大值是10000，因此手动写14次循环即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { //sum=n*(1+n)/2 //A*B=A*(2^0+2^3+2^10+..)=((A&lt;&lt;1)+(A&lt;&lt;3)+(A&lt;&lt;10)+...) //与2的幂相乘，等价于左移 public int sumNums(int n) { int ans=0; int a=n; int b=(n+1); boolean s; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; a&lt;&lt;=1; b&gt;&gt;=1; s=(b&amp;1)&gt;0 &amp;&amp; (ans+=a)&gt;0; ans&gt;&gt;=1; return ans; }}","link":"/2022/04/18/%E7%AE%97%E6%B3%95-leetcode-%E6%B1%821-2-n/"},{"title":"leetcode-正则表达式匹配","text":"leetcode 10 正则表达式匹配这一题的关键在于第一，处理好dp的初始状况（i==0, j==0的情况）第二，对复杂问题进行分类讨论。思考清楚当前匹配字符为*时的情况，*可以匹配0个，或者多个前一位的字符，抓住这个特点即可写出状态转移方程 *匹配0次：如果dp[i][j-2]==true，则dp[i][j]=true*匹配多次：需要两个条件，第一：dp[i-1][j]==true，第二s当前字符必须和p中*的前一个字符匹配。（思考一下，这是一种有趣的递归写法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: bool isMatch(string s, string p) { int len1=s.size(),len2=p.size(); //dp[i][j],s长度为i，p长度为j时，二者能否匹配 vector&lt;vector&lt;int&gt;&gt;dp(len1+1,vector&lt;int&gt;(len2+1,false)); for(int i=0;i&lt;=len1;i++){ for(int j=0;j&lt;=len2;j++){ if(i==0 &amp;&amp; j==0){ dp[0][0]=true; continue; } if(j==0){ dp[i][j]=false; continue; } if(i==0){ if(j&gt;=2 &amp;&amp; p[j-1]=='*' &amp;&amp; dp[0][j-2]) dp[i][j]=true; else dp[i][j]=false; continue; } if(p[j-1]=='.') dp[i][j]=dp[i-1][j-1]; else if(p[j-1]!='*'){ /*必须前边匹配上了，本位置也匹配上了才行*/ dp[i][j]=dp[i-1][j-1] &amp;&amp; s[i-1]==p[j-1]; }else{ //*匹配0次，有*代表p至少长度为2 if(dp[i][j-2]) { dp[i][j]=true; continue; } //*匹配多次 if(dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.') ){ dp[i][j]=true; continue; } dp[i][j]=false; } } } return dp[len1][len2]; }};","link":"/2021/08/18/%E7%AE%97%E6%B3%95-leetcode-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"leetcode-监控二叉树","text":"leetcode监控二叉树 这是一题树形dp题目，可以像一般的dp题目一样分解子问题，把该题目想象成自下而上构建一颗完整的二叉树。只不过dp[i-1]只有一条路，而树形dp[i-1]有两条路。通过后序遍历，一个节点获取两个子节点的信息后，如何最优化自己在不同状态下的结果，这是需要考虑的。 思路： 首先，递归中我们只考虑自己，那么就有两种状态： 当前节点放摄像头 当前节点不放摄像头 对于状态1来说，当前节点的左右子树可以是以下状态 放摄像头 不放摄像头，但是子树有摄像头覆盖了自己 不放摄像头，且子树没有覆盖自己 对于状态2来说，当前节点的左右子树可以是以下状态 其中一颗子树放摄像头，另一颗子树放摄像头或不放摄像头，但是子树有摄像头覆盖了自己 综上所述，对于一个节点，我们一共需要三种状态 放摄像头 不放摄像头，但是被子树覆盖 不放摄像头，且没有被子树覆盖 注意： 对于空节点来说，等价于没有摄像头，且被子树覆盖（假设被覆盖意味着不需要父亲的摄像头） 更明确地说是，若有情况如下，ans[2]=left[1]+right[1];如果把空节点设为没有被子树覆盖，那么这里会出错。 主函数中，最后返回的是min(ans[0],ans[1])而不是三者最小，因为ans[3]下root没有被覆盖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int minCameraCover(TreeNode root) { int[]ans=dp(root); return min(ans[0],ans[1]); } int min(int...arr){ int ans=0x3fffffff; for(int a:arr) ans=Math.min(ans,a); return ans; } //ans[0]:当前节点放摄像头 //ans[1]:当前节点不放摄像头，但是被子树至少之一覆盖 //ans[2]:当前节点不放摄像头，且没有被子树覆盖 int[] dp(TreeNode t){ int[]ans=new int[3]; if(t==null){ ans[0]=0x3fffffff; ans[1]=0; ans[2]=0x3fffffff; return ans; } int[]left=dp(t.left); int[]right=dp(t.right); ans[0]=1+min(left)+min(right); ans[1]=min(left[0]+min(right[0],right[1]),right[0]+min(left[0],left[1])); ans[2]=left[1]+right[1]; return ans; }}","link":"/2022/04/21/%E7%AE%97%E6%B3%95-leetcode-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"leetcode 黑名单中的随机数","text":"leetcode 710 黑名单中的随机数 涉及到等概率的问题，一般都得使用数组（用随机数作下标等概率随机返回一个数）来解决，数组即为一种顺序存储的结构，因此逻辑上顺序，也能够满足要求。 下面的图片用√表示有效数字，X表示在黑名单中的数字。其中，虚线是，最终将所有有效数字挪到左侧以后，和右侧黑名单数字的分界线（用总数量减去黑名单数量，即可得到最终有效数字的数量） 如图，根据虚线划分位置的数学原因，左侧X的数量和右侧√数量相同，因此只要将左侧的X映射到右侧每个√，即可完成任务。后序在虚线左侧随机返回一个下标值，就达到了题目的要求。在代码实现上：1.先将所有黑名单数字放入map中，last指向数组末尾元素2.遍历黑名单数字，如果在虚线右侧，则什么都不做；如果在虚线左侧，那么将last左移至第一个为√的位置，然后在map中添加映射，最后last-- 12345678910111213141516171819202122232425262728293031class Solution {private: int split; //有效数字的总数量 map&lt;int,int&gt;mp;public: Solution(int n, vector&lt;int&gt;&amp; blacklist) { split=n-blacklist.size(); int last=n-1; //先将所有黑名单数字记录，因为last需要向左找到第一个不在黑名单中的数字 for(auto&amp;i:blacklist) mp[i]=-1; //只有黑名单数字，才需要映射 for(auto&amp;i:blacklist){ if(i&lt;split){ while(mp.find(last)!=mp.end()) last--; mp[i]=last; last--; } } srand((unsigned)time(NULL)); } int pick() { int ans=rand()%split; //如果是黑名单数字，则需要映射 if(mp.find(ans)!=mp.end()) return mp[ans]; return ans; }};","link":"/2021/08/04/%E7%AE%97%E6%B3%95-leetcode-%E9%BB%91%E5%90%8D%E5%8D%95%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"leetcode148-排序链表","text":"leetcode148 这题充分说明了，凡是涉及到链表的排序，归并是效率最高的，可以将问题转化为两个有序链表的合并问题。 此外，自底向上的方法可以避免递归带来的空间复杂度的提升。 自顶向下：时间复杂度O(nlogn)，空间复杂度即递归栈的深度O(logn) 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode sortList(ListNode head) { if(head==null || head.next==null) return head; //找到中点 ListNode slow=head,fast=head; while(fast.next!=null &amp;&amp; fast.next.next!=null){ //找到中间偏左的节点 fast=fast.next.next; slow=slow.next; } ListNode t=slow.next; slow.next=null; ListNode l=sortList(head); //要断开链表！！！ ListNode r=sortList(t); //合并链表 return mergeList(l,r); } ListNode mergeList(ListNode a,ListNode b){ if(a==null) return b; if(b==null) return a; if(a.val&lt;b.val){ a.next=mergeList(a.next,b); return a; }else{ b.next=mergeList(a,b.next); return b; } }} 自底向上:时间复杂度(nlogn)，空间复杂度O(1) 1","link":"/2022/05/11/%E7%AE%97%E6%B3%95-leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"leetcode215-数组中的第K个最大元素","text":"可以基于快速排序或者堆排序来写。 方法一：基于快速排序快速排序中，每一轮能够确定一个元素的最终位置。其本质是分治算法。 这里划分时随机选取pivot有个小技巧，就是随机选下标后跟第一个元素进行交换，这样后续就能符合常见的快速排序的写法了。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution { private void swap(int[]arr,int a,int b){ int tmp=arr[a]; arr[a]=arr[b]; arr[b]=tmp; } public int findKthLargest(int[] nums, int k) { //目标元素下标应该是排好序后的target位置 int target=nums.length-k; int left=0,right=nums.length-1; while(true){ //将所有小于nums[t]的放左边，所有大于nums[t]的放右边 int l=left,r=right; //随机选基准元素 int pivot=new Random().nextInt(r-l+1)+l; swap(nums,l,pivot); int value=nums[l]; while(l&lt;r){ //从右边找小于value的 while(l&lt;r &amp;&amp; nums[r]&gt;=value) r--; swap(nums,l,r); //从左边找大于value的 while(l&lt;r &amp;&amp; nums[l]&lt;=value) l++; swap(nums,l,r); } nums[l]=value; if(l==target) return value; else if(l&lt;target){ left=l+1; } else{ right=l-1; } } }} 方法二：基于堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution2 { int []nums; int len; private void swap(int[]arr,int a,int b){ int t=arr[a]; arr[a]=arr[b]; arr[b]=t; } //在i的左右子树已经是堆的情况下，通过元素的下降来建堆 private void heapify(int i,int n){ //i~n进行下降 while(i&lt;n){ int lchild=2*i+1,rchild=2*i+2; int p=i; //p指向的节点在三者之中最大 if(lchild&lt;n &amp;&amp; nums[lchild]&gt;nums[p]){ p=lchild; } if(rchild&lt;n &amp;&amp; nums[rchild]&gt;nums[p]){ p=rchild; } if(i==p){ //说明建堆已经提前完成 break; } swap(nums,i,p); i=p; } } private void buildHeap(int n){ //对0~n进行堆排序 for(int i=n/2-1;i&gt;=0;i--){ heapify(i,n); } } public int findKthLargest(int[] nums, int k) { this.nums=nums; this.len=nums.length; buildHeap(len); for(int i=0;i&lt;k;i++){ swap(nums,0,len-1-i); heapify(0,len-1-i); } return nums[len-k]; }}","link":"/2022/04/07/%E7%AE%97%E6%B3%95-leetcode215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"三数之和","text":"leetcode15 三数之和 这一题的难点有两个 三数求和 元组不能重复 对于第一个点,务必务必要想到两数之和的最快速求法: 双指针两头往中间缩,这是O(N)的算法. 对于第二个点,只要在每一重循环中,每次枚举的元素不重复即可 12345678910111213141516171819202122232425262728class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt;ans=new ArrayList&lt;&gt;(); int n=nums.length; for(int i=0;i&lt;n;){ int l=i+1,r=nums.length-1; while(l&lt;r){ if(nums[l]+nums[r]==-nums[i]){ ans.add(Arrays.stream(new int[]{nums[i],nums[l],nums[r]}).boxed().collect(Collectors.toList())); l++; while(l&lt;r &amp;&amp; nums[l]==nums[l-1])l++; r--; while(l&lt;r &amp;&amp; nums[r]==nums[r+1])r--; }else if(nums[l]+nums[r]&lt;-nums[i]){ l++; while(l&lt;r &amp;&amp; nums[l]==nums[l-1])l++; }else{ r--; while(l&lt;r &amp;&amp; nums[r]==nums[r+1])r--; } } i++; while(i&lt;n &amp;&amp; nums[i]==nums[i-1]) i++; } return ans; }}","link":"/2022/06/15/%E7%AE%97%E6%B3%95-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"两数之和","text":"leetcode1 两数之和 首先不能用排序!! 因为会扰乱下标! 其次,使用哈希表,不能一次性把所有元素放进去,必须一个一个放,并且每一轮必须先检查再放元素进去 1234567891011class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer,Integer&gt;mp=new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++){ if(mp.containsKey(target-nums[i])) return new int[]{mp.get(target-nums[i]),i}; mp.put(nums[i],i); } return null; }}","link":"/2022/06/15/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"两种经典的最小生成树算法","text":"B站一个Up主的动画演示非常生动形象：https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=9719056953147312216 最小生成树最小生成树要求 无环图 联通图（任意两点之间必须有通路） N个顶点，N-1条边 所有生成树之中权值和最小的那棵（MST不唯一） Kruskal算法 基于贪婪算法思想，每次选择权值最小的边 算法过程 1. 将所有边按照权值从小到大排序 2. 每次选择最小的边试图加入结果集 3. 如果加入后会形成环则遗弃该边（用并查集判环） 4. 重复步骤2和3直到选择了N-1条边（N为顶点数） 需要用到并查集和优先级队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct UFNode { UFNode *parent; UFNode() : parent(NULL) {}};UFNode *find(UFNode *p) { set&lt;UFNode *&gt; path; while (p-&gt;parent != NULL) { path.insert(p); p = p-&gt;parent; } for (set&lt;UFNode *&gt;::iterator it = path.begin(); it != path.end(); it++) { (*it)-&gt;parent = p; } return p;}bool isSame(UFNode *p1, UFNode *p2) { return find(p1) == find(p2);}void merge(UFNode *p1, UFNode *p2) { if (isSame(p1, p2)) return; find(p1)-&gt;parent = find(p2);}struct Node { int src, des; int len; Node(int s, int d, int l) : src(s), des(d), len(l) {} bool operator&lt;(const Node &amp;node)const{ return len&gt;node.len; }};//kruskal算法：void kruskal() { vector&lt;UFNode&gt; NodeArr(N); vector&lt;Node&gt; ans; int MSTLen = 0; int s, d, l; priority_queue&lt;Node&gt; pri_que; for (int i = 0; i &lt; M; i++) { cin &gt;&gt; s &gt;&gt; d &gt;&gt; l; pri_que.push(Node(s, d, l)); } while (!pri_que.empty()) { Node first = pri_que.top(); pri_que.pop(); //如果两个点已经在一个集合中，那么加入这条边会造成环 if (isSame(&amp;NodeArr[first.src], &amp;NodeArr[first.des])) { continue; } merge(&amp;NodeArr[first.src], &amp;NodeArr[first.des]); MSTLen += first.len; ans.push_back(first); } cout &lt;&lt; &quot;MST total len is &quot; &lt;&lt; MSTLen &lt;&lt; &quot;\\nthe path is :\\n&quot;; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i].src &lt;&lt; &quot;-&quot; &lt;&lt; ans[i].des &lt;&lt; endl; }} Prim算法 基于贪婪算法思想，每次选择已选定顶点集合到未选顶点集合权值最小的边 通过三个数组的不断更新来完成算法注意，minDist记录的是该顶点与已选顶点集中距自己最近的顶点的距离、 算法过程： 1. 建立三个数组，selected,minDIst,parent，大小为N 2. 选定0号节点为初始节点，更新其相邻节点距离信息 3. 在剩下节点中选择距离已选顶点集最近的节点，加入已选顶点集 4. 更新距离信息 5. 重复步骤3和4，直到所有顶点都被选中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#define N 9 //9个顶点using namespace std;struct Node { int key; int len; //边长度 Node *next; Node(int k, int l) : key(k), len(l), next(NULL) {};};//顶点struct Vertex { int key; Node *next=NULL;};//邻接表struct Graph { Vertex arr[N]; //存储顶点};//将一个边接上去void addArc(Graph &amp;G, int a, int b, int len) { //顶点a添加ab边 if (G.arr[a].next == NULL) { G.arr[a].next = new Node(b, len); } else { //找尾巴在哪 Node *p = G.arr[a].next; while (p-&gt;next != NULL) p = p-&gt;next; p-&gt;next = new Node(b, len); } //顶点b添加ab边 if (G.arr[b].next == NULL) { G.arr[b].next = new Node(a, len); } else { //找尾巴在哪 Node *p = G.arr[b].next; while (p-&gt;next != NULL) p = p-&gt;next; p-&gt;next = new Node(a, len); }}//初始化void init(Graph &amp;G) { for (int i = 0; i &lt; N; i++) { G.arr[i].key = i; } addArc(G, 0, 1, 4); addArc(G, 0, 7, 8); addArc(G, 1, 2, 8); addArc(G, 1, 7, 11); addArc(G, 7, 8, 7); addArc(G, 7, 6, 1); addArc(G, 2, 8, 2); addArc(G, 6, 8, 6); addArc(G, 2, 3, 7); addArc(G, 2, 5, 4); addArc(G, 6, 5, 2); addArc(G, 3, 5, 14); addArc(G, 3, 4, 9); addArc(G, 4, 5, 10);}bool selected[N];int minDist[N]; //距离已选顶点集的最短距离int parent[N];int main() { Graph G; init(G); //初始化三个数组 for (int i = 0; i &lt; N; i++) { selected[i] = false; minDist[i] = 999999; parent[i] = -1; } selected[0] = true; int count = 1; //已选顶点数量 int now=0; //新增顶点 //开始进行Prim算法，每次将距离已选定点集最近的顶点加入已选顶点 while (count &lt; N) { //更新当前能到达的(未选）节点的minDist信息 Node*p=G.arr[now].next; while(p!=NULL){ if(!selected[p-&gt;key] &amp;&amp; p-&gt;len&lt;minDist[p-&gt;key]){ parent[p-&gt;key]=now; minDist[p-&gt;key]=p-&gt;len; } p=p-&gt;next; } //选出距离已选顶点集最近的顶点加入 int d=999999; int t=-1; for(int i=0;i&lt;N;i++){ if(!selected[i] &amp;&amp; minDist[i]&lt;d){ d=minDist[i]; t=i; } } now=t; selected[t]=true; count++; } //计算一下权值和即可（注意不能用dist加，dist表示的是到已选顶点集的最短距离）} 这是对视频中的最小生成树进行计算，注意：最小生成树不唯一。","link":"/2021/05/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E7%A7%8D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/"},{"title":"两种经典的最短路径算法","text":"dijkstra算法：计算单源最短路径（固定起点，计算出起点到其他所有顶点的最短路径） 用贪心思想，每次找出距离起点最近的节点，直到找出所有节点 动态规划：每次在已有结果的基础上自下而上进行拓展 缺陷：无法计算存在负权值的情况。 floyd算法：计算任意两点之间的最短路径 基于动态规划思想 三重循环遍历所有顶点，如果a到c再到b的距离，小于a到b的距离，那么将a到b原来的路径更换为a到c再到b 其中路径信息parent矩阵，parent[i][j]代表的是，从i到j，i走过以后，下一步应该走哪个节点，如果parent[i][j]==j说明i、j相邻。 p4779 这一题中使用了链式前向星存储图，使用了堆优化（减少未访问顶点集中搜寻最小dist[i]的时间，其中使用了惰性删除）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*dijkstra算法，链式前向星与堆优化版*/#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 100010;const int M = 500010; //边的数量const int MAX = 0x7fffffff;struct Arc { //两点之间的一条弧 int to, next, d; //next是兄弟边的下标，若为0说明没有};/*链式前向星*/Arc edge[M]; //存放所有边int head[N]; //head[i]表示i节点的第一条边是edge[head[i]]int cnt = 0; //现有边的数量int n, m, s;struct Node { int key, dist; bool operator&lt;(const Node &amp;node) const { return dist &gt; node.dist; //顺序存储中优先级高的在前边，堆中优先级中的在堆顶 }};int dist[N];bool visit[N];int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= n; i++) dist[i] = MAX; for (int i = 0; i &lt; m; i++) { int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; cnt++; edge[cnt].to = b; edge[cnt].d = d; edge[cnt].next = head[a]; //next指向兄弟节点 head[a] = cnt; } priority_queue&lt;Node&gt; que; //que维护一个按照所有节点dist排列的优先级队列，其中可能存在冗余无效数据 /*因为更新dist后不方便删除que中原有的点，因此从que中取点，遇到已经访问过的，则直接删除（越短越先被访问，后访问的肯定是过时的数据）*/ dist[s] = 0; que.push({s, dist[s]}); while (!que.empty()) { Node first = que.top(); que.pop(); int u = first.key; if (visit[u]) //说明是过期数据 continue; visit[u] = true; int t = head[u]; //u节点指向的第一条边 while (t) { int v = edge[t].to; int d = edge[t].d; if (!visit[v] &amp;&amp; d + dist[u] &lt; dist[v]) { dist[v] = dist[u] + d; que.push({v, dist[v]}); } t = edge[t].next; //兄弟边 } } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;; return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*dijkstra算法，邻接矩阵标准版*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int N=5;const int src=0;const int des=N-1;int edge[N][N];void init(){ //初始化邻接矩阵 memset(edge,-1,sizeof(edge)); edge[0][1]=10; edge[0][2]=1; edge[0][3]=3; edge[2][1]=1; edge[1][4]=20;}int main(){ init(); bool visit[N]; int parent[N]; int dist[N]; memset(visit,false,sizeof(visit)); memset(parent,-1,sizeof(parent)); memset(dist,0x3f,sizeof(dist)); int now=src; visit[src]=true; dist[src]=0; while(!visit[des]){ //更新当前能到达的节点的dist信息 for(int i=0;i&lt;N;i++){ if(!visit[i] &amp;&amp; edge[now][i]!=-1 &amp;&amp; dist[now]+edge[now][i]&lt;dist[i]){ parent[i]=now; dist[i]=dist[now]+edge[now][i]; } } //在未选顶点中，选出距离远点最近的顶点，确定它的最短路径 int minDist=0x3f3f3f3f; for(int i=0;i&lt;N;i++){ if(!visit[i] &amp;&amp; dist[i]&lt;minDist){ minDist=dist[i]; now=i; } } visit[now]=true; } //给出最短路径 stack&lt;int&gt;path; int t=des; while(t!=-1){ path.push(t); t=parent[t]; } while(!path.empty()){ cout&lt;&lt;path.top()&lt;&lt;&quot; &quot;; path.pop(); } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*floyd算法*/#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100;const int MAX = 0x3fffffff;int dist[N][N]; //i经过path[i][j]到j的路径长度int link[N][N]; //link[i][j]表示i第一步从link[i][j]走int n, m;/*Floyd算法适用于点比较少的图，因为其时间复杂度是O(n^3)*/int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dist[i][j] = MAX; link[i][j] = j; } } for (int i = 0; i &lt; m; i++) { int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; dist[a][b] = d; dist[b][a] = d; } for (int k = 1; k &lt;= n; k++) //注意：k必须在最外层，因为它是dp的阶段 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) { if (dist[i][k] + dist[k][j] &lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; link[i][j] = link[i][k]; } } while (1) { int src, des; cin &gt;&gt; src &gt;&gt; des; int res = dist[src][des]; if (res == MAX) { cout &lt;&lt; -1 &lt;&lt; endl; continue; } cout &lt;&lt; dist[src][des] &lt;&lt; endl; /*打印路径*/ int t = src; //t 表示第一步// cout&lt;&lt;src&lt;&lt;&quot; &quot;; while (t != des) { cout &lt;&lt; t &lt;&lt; &quot; &quot;; t = link[t][des]; } cout &lt;&lt; des &lt;&lt; endl; } return 0;} 这个视频讲解非常生动清晰：https://www.bilibili.com/video/BV1q4411M7r9","link":"/2021/05/25/%E7%AE%97%E6%B3%95-%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"},{"title":"乘积最大子数组","text":"leetcode 152 乘积最大数组 一个重要的事实 若a&gt;b,则同时乘上一个正数c,不论a和b的符号,那么ac&gt;bc 若a&gt;b,则同时乘上一个负数c,不论a和b的符号,ac&lt;bc 虽然上面的结论小学生都知道,但是用于思考这一题的状态方程的时候可以去伪存真,简化思考. 我们要求的以下标i为结尾的子数组的最大连续乘积,考虑两种情况: 不和前面相连 和前面相连(如何才能连接出最大值呢) 如果当前数字是正数,那么和与i-1结尾的最大连续乘积连接最优 如果当前数字是负数,那么和与i-1结尾的最小连续乘积连接最优 因此导出,我们需要的dp数组有两个,即以i结尾的连续数组的最大连续积和最小连续积 (不需要考虑正负) 12345678910111213141516171819202122class Solution { public int maxProduct(int[] nums) { int n=nums.length; int[]max=new int[n]; int[]min=new int[n]; max[0]=min[0]=nums[0]; int ans=nums[0]; for(int i=1;i&lt;n;i++){ if(nums[i]&gt;0){ max[i]=Math.max(nums[i],nums[i]*max[i-1]); min[i]=Math.min(nums[i],nums[i]*min[i-1]); }else if(nums[i]&lt;0){ max[i]=Math.max(nums[i],nums[i]*min[i-1]); min[i]=Math.min(nums[i],nums[i]*max[i-1]); }else{ max[i]=min[i]=0; } ans=Math.max(ans,max[i]); } return ans; }}","link":"/2022/06/17/%E7%AE%97%E6%B3%95-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"二分搜索的边界问题","text":"二分搜索可以在有序序列中，以logN的时间复杂度快速找到答案。常见的问题有三种，第一：找到目标值，第二：找到符合要求的最小值(搜索左边界)，第三：找到符合要求的最大值(搜索右边界)。对应的二分搜索也有三种形式。 注意：二分搜索也可以是逻辑上的 第一种：标准二分搜索，返回目标值下标，没找到返回-1 12345678910111213int binarySearch(vector&lt;int&gt;&amp;arr,int target){ int left=0,right=arr.size()-1; while(left&lt;=right){ int mid=left+(right-left)/2; if(arr[mid]==target) return mid; else if(arr[mid]&lt;target) left=mid+1; else right=mid-1; } return -1;} 第二种：搜索右边界，返回目标值下标，没找到返回-1 1234567891011121314151617int binarySearchRight(vector&lt;int&gt;&amp;arr,int target){ int left=0,right=arr.size()-1; int ans=-1; while(left&lt;=right){ int mid=left+(right-left)/2; if(arr[mid]==target){ ans=mid; l=mid+1; } else if(arr[mid]&lt;target) l=mid+1; //收缩左边界 else right=mid-1; //收缩右边界 } return ans;} 我们每次找到找到符合条件的数字时，就将其赋值给ans。直到搜索空间[l,r]缩减至空。 解释一下这里为什么l=mid+1而不是l=mid。我们的二分过程相当于在不断优化ans的值，当mid符合条件时，赋值给ans以优化其结果，然后需要将搜索空间移到mid右侧来搜寻是否有更优的结果。 注意：为什么搜索空间是闭区间[l,r]，是因为l=mid+1和r=mid-1，使得左边界和有边界一定会被mid访问到。","link":"/2021/07/31/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/"},{"title":"二叉树最大宽度","text":"leetcode 662二叉树最大宽度 这题的几个要点 一开始我想的是根结点左右的节点用正负来表示,后来发现很麻烦,全都当作坐标轴正数方向的节点不就好! bfs中,层序遍历是从上到下,从左到右的,因此第一次碰到新的高度的节点,肯定是下一层的第一个节点.后续同层的每一个节点的pos都可以覆盖r 数据范围! 这一题中如果用int,虽然会溢出,但是由于我们需要的是r-l+1,溢出在一定范围内也是可以得到正确答案的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int widthOfBinaryTree(TreeNode root) { if(root==null) return 0; Queue&lt;Node&gt;que=new ArrayDeque&lt;&gt;(); que.offer(new Node(root,0,0)); int height=0; long l=0,r=0; long ans=0; while(!que.isEmpty()){ Node f=que.poll(); if(f.h==height){ //l=Math.min(l,f.pos); r=Math.max(r,f.pos); //r=f.pos; }else{ ans=Math.max(ans,r-l+1); height++; //height=f.h; //更换高度 l=f.pos; r=f.pos; } if(f.t.left!=null) que.offer(new Node(f.t.left,2*f.pos,f.h+1)); if(f.t.right!=null) que.offer(new Node(f.t.right,2*f.pos+1,f.h+1)); } ans=Math.max(ans,r-l+1); return (int)ans; }}class Node{ TreeNode t; long pos; int h; Node(){} Node(TreeNode t,long pos,int h){ this.t=t; this.pos=pos; this.h=h; }}","link":"/2022/06/20/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/"},{"title":"互不侵犯","text":"洛谷 p1896 互不侵犯 这一题给我带来的感悟: dp,状态压缩dp或者其他各种形式的dp**,不一定dp的最后一个值就是答案,也可能需要再进一步处理得到**.比如这一题里边,最后需要把$sum=\\sum_{st=0}^{(1&lt;&lt;n)-1} dp[n-1][st][k]$求出来才能得到最终答案 对于dp的问题,要始终采用把问题分解为一个小问题和剩下所有问题来解决.对于本题来说,就是将n行分解为前面n-1行外加最后一行. 对于多个方向的问题(如存在上下两个方向),如果从上到下构建问题,则只需要考虑一个方向.比如这一题上下两个方向上不能冲突,但是我一行一行从上向下构建,那么每次只需要考虑当前行和上一行的冲突. 以前做的树相关问题,要求上下不能冲突,我们是通过自下而上构建整棵树来使双向问题考虑变成单向问题考虑. 对于位置相关问题,用位运算进行计算是想当好的! 计算一个数字中1的个数,可以采用lowbit操作进行加速. 注:洛谷中写java,主函数需要名字写成Main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class Main { static int lowbit(int x) {// return ~(x-1)&amp;x; //补码中-1再取反等于取相反数 return x &amp; -x; //&amp;优先级低 } //计算二进制位中1的数量 static int count(int x) { int ans = 0; while (x != 0) { ans++; x -= lowbit(x); } return ans; } public static void main(String[] args) { int n, k; Scanner sc = new Scanner(System.in); n = sc.nextInt(); k = sc.nextInt(); //dp[i][state][j] 0~i行一共有j个国王 第i行的状态是state情况下,有多少种方案 long[][][] dp = new long[n][1 &lt;&lt; n][n * n]; //初始化第一行状态 for (int s = 0; s &lt; (1 &lt;&lt; n); s++) { if ((s &amp; (s &lt;&lt; 1)) == 0) //说明左右方向上互不侵犯 dp[0][s][count(s)] = 1; } //开始dp for (int i = 1; i &lt; n; i++) { //0~i行的情况 for (int s1 = 0; s1 &lt; (1 &lt;&lt; n); s1++) { //枚举第i行的所有状态 if ((s1 &amp; s1 &lt;&lt; 1) != 0) continue; //排除非法状态 int thisRowK = count(s1); //枚举0~i-1行 国王数量为k-thisRowK个下的所有状态 for (int s2 = 0; s2 &lt; (1 &lt;&lt; n); s2++) { if ((s2 &amp; s2 &lt;&lt; 1) != 0 || (s1 &amp; s2) != 0 || (s1 &lt;&lt; 1 &amp; s2) != 0 || (s1 &gt;&gt; 1 &amp; s2) != 0) continue; int lastRowK = count(s2); for (int ks = lastRowK; ks &lt;= k - thisRowK; ks++) { dp[i][s1][ks + thisRowK] += dp[i - 1][s2][ks]; } } } } //最后核算 long ans = 0; for (int s = 0; s &lt; (1 &lt;&lt; n); s++) ans += dp[n - 1][s][k]; System.out.println(ans); }}","link":"/2022/06/20/%E7%AE%97%E6%B3%95-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"},{"title":"出栈问题之卡特兰数","text":"经典的出栈序列问题，可以用动态规划来解决，其中的递推思路非常精妙。 栈 思路：建立dp数组，dp[i]表示i个数的全部可能性。 dp[0]=dp[1]=1，作为边界条件。 设x是当前序列最后出栈的数字，则x将该序列分为两部分（1x-1, x, x+1n) 如图，假如x=3是最后出栈的，则前面的1和2是独立进出栈的，其可能的方案数是dp[2];后边的4,5,6也是独立入栈出栈的，其可能的方案数是dp[3];故最后的方案数是dp[2]*dp[3]； 因此数字个数为6时，dp[6]=dp[0]*dp[5]+dp[1]*dp[4]+dp[2]*dp[3]+dp[3]*d[2]+dp[4]*dp[1]+dp[5]*dp[0]; 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; vector&lt;int&gt;dp(n+1,0); //dp[i]表示序列若为1~i，则最终方案有dp[i]个 dp[0]=dp[1]=1; for(int i=2;i&lt;=n;i++){ //选取1~i中的数字x作为最后出栈的，则1~x-1自由出栈，x+1~i自由出栈 for(int j=0;j&lt;i;j++){ dp[i]+=dp[j]*dp[i-j-1]; } } cout&lt;&lt;dp[n]; return 0;}","link":"/2022/02/18/%E7%AE%97%E6%B3%95-%E5%87%BA%E6%A0%88%E9%97%AE%E9%A2%98%E4%B9%8B%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"title":"分组01背包题目","text":"分组01背包，其实本质还是01背包，只不过01背包是每样物品最多只能选一次，分组01背包是每组中的元素只能选一个。 一般01背包是把物品序号作为dp的一个维度，这样保证了选中物品的唯一性； 分组01背包是把组号作为dp的一个维度，这样保证了每一组只选一个。 题目 123456789101112131415161718192021222324252627测试用例：2121 12 61 14 102 22 32 3 383 24 13 3 153 11 234 13 25 19 105 17 115 16 26 20 2111 14 161 17 32 6 323 3 244 12 34 13 05 22 55 21 46 3 376 14 66 23 0 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int t,n;int p,c,d;int main(){ cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; vector&lt;vector&lt;int&gt;&gt;dp(6,vector&lt;int&gt;(25*6+1,-1)); //dp[i][j]表示 第i组物品，剩余暴击为j的情况下，能达到的最大暴击伤害 vector&lt;vector&lt;int&gt;&gt;chance(6,vector&lt;int&gt;()); vector&lt;vector&lt;int&gt;&gt;damage(6,vector&lt;int&gt;()); for(int i=0;i&lt;n;i++){ cin&gt;&gt;p&gt;&gt;c&gt;&gt;d; chance[p-1].push_back(c); damage[p-1].push_back(d); } for(int k=0;k&lt;chance[0].size();k++){ dp[0][chance[0][k]]=max(dp[0][chance[0][k]],damage[0][k]); } for(int i=1;i&lt;6;i++){ for(int j=1;j&lt;=25*6;j++) //剩余可用暴击率为k for(int k=0;k&lt;chance[i].size();k++){ int ch=chance[i][k]; int da=damage[i][k]; if(ch&lt;=j &amp;&amp; dp[i-1][j-ch]!=-1){ dp[i][j]=max(dp[i][j],dp[i-1][j-ch]+da); } } } int res=-1; for(int i=100;i&lt;=25*6;i++){ res=max(res,dp[5][i]); } if(res==-1) cout&lt;&lt;&quot;TAT&quot;&lt;&lt;endl; else cout&lt;&lt;res&lt;&lt;endl; } return 0;}","link":"/2022/04/17/%E7%AE%97%E6%B3%95-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%A2%98%E7%9B%AE/"},{"title":"算法题之戳气球","text":"leetcode312 戳气球 这一题可以用动态规划来解决,但是dp含义的设置和状态转移方程的设计很有意思。 首先,一维dp难以实现的，应该考虑二维dp，尤其在一个数组中，要考虑到双指针移动来解决复杂问题。 如果将dp[i][j]的含义设置为戳爆下标[i,j]之间所有的气球能获得的最大钱币,会发现由于涉及到与i左边和j右边数字相乘,难以书写状态转移方程。 将dp[i][j]的含义设置为:戳爆下标i和j之间（开区间）的所有气球能获得的最大钱币。此时，如果将状态转移方程写为$dp[i][j]=max(先戳气球k,再戳剩下所有气球,获得的最大钱币) i&lt;k&lt;j$,会造成子问题之间相互牵连,不具有独立性,也就无法完成动态规划的设计。 因此将状态转移方程方程写成dp[i][j]=max(先戳剩下所有气球,再戳气球k,获得的最大钱币) i&lt;k&lt;j,这样每次左右两边的计算互不干扰,即可完成动态规划的设计。 （本质是由于，如果先戳爆气球k，则气球k-1右侧的气球改变，气球k+1左侧的气球也改变，造成钱币获取公式的改变,而最后戳爆气球k,则不会出现这个问题,即固定了dp[i][j]中i和j这两个气球) 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt;nums; int stab(int t){ if(t==0 || t==nums.size()+1) return 1; return nums[t-1]; } //一维dp不行,就整二维 int maxCoins(vector&lt;int&gt;&amp; nums) { this-&gt;nums=nums; int n=nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n+2,vector&lt;int&gt;(n+2,-1)); for(int i=0;i&lt;=n+1;i++) for(int j=i;j&gt;=0;j--){ if(i==j || i==j+1){ dp[j][i]=0; } else{ int m=0; //最后戳爆气球k for(int k=j+1;k&lt;i;k++){ m=max(m,dp[j][k]+dp[k][i]+stab(i)*stab(k)*stab(j)); } dp[j][i]=m; } } return dp[0][n+1]; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%88%B3%E6%B0%94%E7%90%83/"},{"title":"动态规划总结与思考","text":"动态规划本质剖析动态规划其实是运筹学的一种最优化方法，其核心思想是穷举/暴力搜索，只不过因为存在大量重叠子问题，所以需要避免重复计算。其本质就是带备忘录的穷举。 备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。 值得一提的是，递归是一种自顶向下的算法思想，不断分解成子问题来解决；而动态规划是自底向上的算法思想，从最小的子问题算起，不断向上累积，最后求出最终问题的解。 动态规划三要素 重复子问题存在大量重复计算的子问题 最优子结构要符合「最优子结构」，子问题间必须互相独立。公众号labuladong作者对这个问题作如下解读：1234567比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。 123也可以将其理解为**无后效性**，有两层含义。第一层含义是，在推导后面阶段状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。 状态转移方程 几个问题动态规划用于解决什么问题 求最值（最优解） 判断某某命题是否成立 没思路时如何思考 如果没有思路，应该先想暴力法，看看暴力法中哪里存在大量的重复子问题，然后再思考怎么用动态规划（或者备忘录）来记录这些重复子问题。 应该将问题分解成子问题，然后思考第i项与第i-1项，或者第i项与0~i-1项之间的关系 动态规划与递归的区别 递归采用自顶向下分解问题的方法（当前问题的子问题没有被解决） 动态规划采用自底向上求解问题（当前问题的子问题已经被解决）","link":"/2021/08/06/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"},{"title":"原地删除序列中某些元素的两类方法","text":"遇到删除序列中所有不符合条件的元素时，均可以使用以下两种算法，原地修改序列，时间复杂度O(N),空间复杂度O(1)。 其核心思想是把数组分割为两个部分：左侧有效元素序列，右侧无效元素序列，每次找到有效元素就插入到有效元素序列末尾。 如：删除序列中大于等于s，小于等于t的所有元素。 k记录不用删除元素的个数 12345678void deleteTarget(vector&lt;int&gt;arr,int s,int t){ int k=0; /*记录不删除、需要保留下来的元素的个数*/ for(int i=0;i&lt;arr.size();i++){ if(arr[i]&lt;s || arr[i]&gt;t) arr[k++]=arr[i]; } arr.resize(k);} k记录需要删除元素的个数 123456789void deleteTarget2(vector&lt;int&gt;arr,int s,int t){ int k=0; /*记录需要删除的元素的个数*/ for(int i=0;i&lt;arr.size();i++) if(arr[i]&gt;=s &amp;&amp; arr[i]&lt;=t) k++; else arr[i-k]=arr[i]; /*前面有k个无效元素，故往前挪k个位置*/}","link":"/2021/08/01/%E7%AE%97%E6%B3%95-%E5%8E%9F%E5%9C%B0%E5%88%A0%E9%99%A4%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%A4%E7%B1%BB%E6%96%B9%E6%B3%95/"},{"title":"双指针之滑动窗口","text":"滑动窗口是双指针一个比较经典的应用，分为固定窗口和变动窗口， 对于变动窗口，其执行过程可以概括为：1.初始left=0;right=02.向右移动right，扩大窗口，寻找可行解3.找到可行解后，向右移动left，收缩窗口，优化可行解4.循环执行第2步和第3步，直到right到达边界 注意，如果逻辑比较复杂， 每次获得可行解，需要立马与临时记录的最优解进行比较 变化滑动窗口：76最小覆盖子串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public://滑动窗口思想：每轮先找到可行解，然后优化可行解 string minWindow(string s, string t) { //结果 int len=s.size()+1,start=0; //统计t中的字符 map&lt;char,int&gt;mp; for(auto&amp;c:t) if(mp.find(c)==mp.end()) mp[c]=1; else mp[c]++; //滑动窗口[left,right] int left=0,right=0; while(right&lt;s.size()){ char c=s[right]; //处理当前字符 if(mp.find(c)!=mp.end()){ mp[c]--; } //如果当前是可行解，那么优化可行解 while(check(mp)){ //记录可行解 if(right-left+1&lt;len){ len=right-left+1; start=left; } char c2=s[left]; //优化可行解 if(mp.find(c2)!=mp.end()){ mp[c2]++; } left++; } right++; } return len&lt;=s.size()?s.substr(start,len):&quot;&quot;; } bool check(map&lt;char,int&gt;&amp;mp){ for(auto&amp;item:mp) if(item.second&gt;0) return false; return true; }}; 固定滑动窗口：567字符串的排列此题利用长度为26的vector，来存放字符信息，非常巧妙。因为可以直接利用==符号，判断两个vecoter内容是否相同。注意：本题不宜使用两个map，然后用==判断内容是否相同。因为map2[xx]=0时，仍然存留在map2中，此时如果map1中没有xx，则==结果为false。 123456789101112131415161718192021222324class Solution {public: //固定大小的滑动窗口 bool checkInclusion(string s1, string s2) { if(s2.size()&lt;s1.size()) return false; vector&lt;int&gt;cs1(26,0); vector&lt;int&gt;cs2(26,0); int len=s1.size(); for(int i=0;i&lt;len;i++){ cs1[s1[i]-'a']++; cs2[s2[i]-'a']++; } if(cs1==cs2) return true; for(int i=0;i+len&lt;s2.size();i++){ cs2[s2[i+len]-'a']++; cs2[s2[i]-'a']--; if(cs1==cs2) return true; } return false; }}; 固定滑动窗口：438找到字符串中所有字母异位词 123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; findAnagrams(string s, string p) { if(s.size()&lt;p.size()) return {}; vector&lt;int&gt;ans; //记录字符 vector&lt;int&gt;char_s(26,0); vector&lt;int&gt;char_p(26,0); //初始化 for(auto&amp;c:p) char_p[c-'a']++; int len=p.size(); for(int i=0;i&lt;len;i++) char_s[s[i]-'a']++; if(char_p==char_s) ans.emplace_back(0); //滑动窗口 for(int i=len;i&lt;s.size();i++){ char_s[s[i-len]-'a']--; char_s[s[i]-'a']++; if(char_s==char_p) ans.emplace_back(i-len+1); } return ans; }}; 固定滑动窗口：最长不含重复字符的子字符串 12345678910111213141516171819202122class Solution { public int lengthOfLongestSubstring(String s) { //记录每个字符上次出现的位置 Map&lt;Character, Integer&gt; pos = new HashMap&lt;&gt;(); int n = s.length(); int l = 0, r = 0; int ans = 0; while (r &lt; n) { char cur = s.charAt(r); if (pos.containsKey(cur)) { int lastPos = pos.get(cur); while (l &lt;= lastPos) //恢复至可行解 l++; //注意，如果lastPos在滑动窗口l左侧，则while不执行 } ans = Math.max(ans, r - l + 1); pos.put(cur, r); r++; } return ans; }}","link":"/2021/08/02/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"基本计算器Ⅱ","text":"leetcode227 基本计算器Ⅱ 遇到算式一类问题,可以优先考虑用栈 思路: 先计算乘除的结果,再计算加减的结果 进一步优化: 将负号融入数字,将乘除的结果看成一个数字,这样整个字符串最后就变成了多个数字相加 过程: 如果当前数字的前导符号是+,则将其入栈 如果当前数字的前导符号是-,则将其相反数入栈 如果当前数字的前导符号是*,则将栈顶元素取出与当前数字相乘,然后入栈 如果当前数字的前导符号是/,则将栈顶元素取出与当前数字相除,然后入栈 最后将栈中所有数字相加即是结果 注:第一个数字的前导符号视为加号 1234567891011121314151617181920212223242526272829303132333435class Solution { public int calculate(String s) { Stack&lt;Integer&gt;st=new Stack&lt;&gt;(); char[]chs=s.toCharArray(); int t=0; //临时存储数字 char preOps='+'; for(int i=0;i&lt;s.length();i++){ if(Character.isDigit(chs[i])){ t*=10; t+=chs[i]-'0'; } if(!Character.isDigit(chs[i]) &amp;&amp; chs[i]!=' ' || i==s.length()-1) { if(preOps=='+') st.push(t); else if(preOps=='-') st.push(-t); else if(preOps=='*'){ st.push(st.pop()*t); }else st.push(st.pop()/t); preOps=chs[i]; t=0; //刷新数字 } } int ans=0; while(!st.isEmpty()){ ans+=st.pop(); } return ans; }}","link":"/2022/06/20/%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E2%85%A1/"},{"title":"复制带随机指针的链表","text":"方法一:双哈希表 一个哈希表把节点映射到相对位置 另一个哈希表把相对位置映射到节点 然后拷贝+从哈希表中读数据即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; }}*/class Solution { public Node copyRandomList(Node head) { Map&lt;Node,Integer&gt;origin=new HashMap&lt;&gt;(); Node p=head; int index=0; while(p!=null){ origin.put(p,index++); p=p.next; } Node pre=new Node(-1); p=head; Node q=pre; Map&lt;Integer,Node&gt;latter=new HashMap&lt;&gt;(); index=0; while(p!=null){ q.next=new Node(p.val); q=q.next; latter.put(index++,q); p=p.next; } p=head; q=pre.next; while(p!=null){ q.random=latter.get(origin.get(p.random)); p=p.next; q=q.next; } return pre.next; }} 方法二: 在原链表上间隔复制节点 先在原链表上一个挨着一个复制节点,然后再给每个节点赋值random即可. 关于拆分链表的递归算法,我写的过程中忘记h.next已经修改过方向,结果直接返回导致报错.要注意一下. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*// Definition for a Node.class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; }}*/class Solution { //寄生大法,太妙了 public Node copyRandomList(Node head) { if(head==null) return null; Node p=head; while(p!=null){ Node t=new Node(p.val); t.next=p.next; p.next=t; p=p.next.next; } p=head; while(p!=null){ Node t=p.next; if(p.random!=null) t.random=p.random.next; p=p.next.next; } return splitList(head)[1]; } //拆分链表 Node[]splitList(Node h){ if(h==null) return new Node[]{null,null}; Node[]twoHead=splitList(h.next.next); h.next.next=twoHead[1]; Node t=h.next; h.next=twoHead[0]; return new Node[]{h,t}; }}","link":"/2022/06/20/%E7%AE%97%E6%B3%95-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"复杂动态规划之状态机解法","text":"刷到leetcode309 最佳买卖股票时机含冷冻期时，学习了一种状态机的解法，觉得很好用，遂记录一下。 对于这类复杂的状态转移问题，可以通过建立多个状态以及他们之间的转移方程来解决。对于该题，则定义四种状态，买入，卖出，持有，和不持有，其值代表当前状态下最大的利润。 状态机及之间的转换如下： 1234567891011121314151617181920212223242526272829#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n=prices.size(); if(n==0) return 0; //定义四种状态，买入，卖出，持有，和不持有，其值代表当前状态下最大的利润 vector&lt;int&gt; buy(n), sell(n), hold(n), not_hold(n); //初始化 hold[0]=buy[0]=-prices[0]; //意思是上来就买入/持有股票，的最大收益 sell[0]=not_hold[0]=0; //意思是上来就卖出/不持有股票，的最大收益 for(int i=1;i&lt;n;i++){ //只能在冻结期后进行买入 buy[i]=not_hold[i-1]-prices[i]; //可以在买入后和已经持有的情况下，继续持有 hold[i]=max(buy[i-1],hold[i-1]); //只能在买入后和已经持有的情况下，卖出 sell[i]=max(buy[i-1],hold[i-1])+prices[i]; //只能在卖出后或者不持有后，保持不持有 not_hold[i]=max(not_hold[i-1],sell[i-1]); } //只有卖出和非持有状态，才可能有最高的利润 return max(sell[n-1],not_hold[n-1]); }};","link":"/2021/04/11/%E7%AE%97%E6%B3%95-%E5%A4%8D%E6%9D%82%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E6%B3%95/"},{"title":"多数元素","text":"leetcode169 多数元素 方法1: 排序+取中间元素 方法2: 摩尔投票, 每次去掉两个不同的数,最后剩下的数就是众数 原理:若去掉的数中有一个是众数,另一个则不是众数.因此不影响最终结果;若去掉的两个数字都不是众数,那么肯定也不影响结果. 123456789101112131415161718class Solution { //每次去掉一个众数和其他数字,不影响最后的众数数字 public int majorityElement(int[] nums) { int ans=-1,cnt=0; for(int a:nums){ if(cnt==0){ cnt=1; ans=a; }else if(ans==a) cnt++; else { cnt--; } } return ans; }}","link":"/2022/06/14/%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"},{"title":"字符串解码","text":"leetcode394 字符串解码 特别注意:做题的时候一定要看数据范围,这一题虽然用例数字都是1位的,但实际上可以是多位! 方法一: 递归用递归解决问题就要把多层/多个问题,分解为一个子问题+其他所有. 我们的目标就是通过解决这一个子问题来递归解决整个问题. 对于本题来说,由于存在多个嵌套括号,那么我们应当将问题分解为解决一层括号+解决剩下内层所括号.可以采用后序的方法,先调用递归函数解决内层所有,然后再解决最外面一层. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { //审题! boolean isNum(char c){ return c&lt;='9' &amp;&amp; c&gt;='0'; } public String decodeString(String s) { //找第一个数字 int index=-1; for(int i=0;i&lt;s.length();i++){ if(s.charAt(i)&lt;='9' &amp;&amp; s.charAt(i)&gt;='0') { index=i; break; } } if(index==-1) return s; int r=index; while(s.charAt(r)!='[')r++; int leftBracketIndex=r; int leftBracetCount=1; //左括号 int rightBracketIndex=leftBracketIndex; while(leftBracetCount&gt;0){ rightBracketIndex++; if(s.charAt(rightBracketIndex)=='[') leftBracetCount++; else if(s.charAt(rightBracketIndex)==']') leftBracetCount--; } String ans=s.substring(0,index); int num=Integer.parseInt(s.substring(index,r)); for(int i=0;i&lt;num;i++) ans+=decodeString(s.substring(leftBracketIndex+1,rightBracketIndex)); ans+=decodeString(s.substring(rightBracketIndex+1)); return ans; }} 方法二: 栈用栈来解决括号相关问题是一个经典的方法 关于本题,凡遇到右括号再进行总结!否则直接入栈. 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { //括号问题用栈绝对是一个好方法 public String decodeString(String s) { Stack&lt;Character&gt;st=new Stack&lt;&gt;(); for(char c:s.toCharArray()){ if(c!=']') st.push(c); else{ Stack&lt;Character&gt;tmp=new Stack&lt;&gt;(); while(st.peek()!='[') //获取有效字符串 tmp.push(st.pop()); StringBuilder ss=new StringBuilder(); while(!tmp.isEmpty()) ss.append(tmp.pop()); String cur=ss.toString(); st.pop(); //抛出左括号 while(!st.isEmpty() &amp;&amp; isNum(st.peek())) tmp.push(st.pop()); int n=0; while(!tmp.isEmpty()){ n*=10; n+=tmp.pop()-'0'; } while(n&gt;0){ n--; for(char cc:cur.toCharArray()){ st.push(cc); } } } } StringBuilder ans=new StringBuilder(); while(!st.isEmpty()){ ans.append(st.pop()); } return ans.reverse().toString(); } boolean isNum(Character c){ return c&lt;='9' &amp;&amp; c&gt;='0'; }}","link":"/2022/06/17/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"title":"常用的排序算法","text":"堆排序12345678910111213141516171819202122232425262728293031323334353637class Solution { void swap(int[]nums,int l,int r){ int t=nums[l]; nums[l]=nums[r]; nums[r]=t; } //前提是i的左右子树都已经是堆 void heapify(int[]nums,int i,int n){ //在长度为n的堆，对下标为i的元素进行下降 while(i&lt;n){ int p=i; int l=2*i+1; int r=2*i+2; if(l&lt;n &amp;&amp; nums[l]&gt;nums[p]) p=l; if(r&lt;n &amp;&amp; nums[r]&gt;nums[p]) p=r; if(i==p) return; swap(nums,i,p); i=p; } } //建立大根堆 void buildHeap(int[]nums,int n){ for(int i=n/2-1;i&gt;=0;i--) heapify(nums,i,n); } //堆排序 public int[] sortArray(int[] nums) { int n=nums.length; buildHeap(nums,n); for(int i=n-1;i&gt;=0;i--){ swap(nums,0,i); heapify(nums,0,i); //重新调整成堆 } return nums; }} 拓扑排序核心思想：每次将入度为0的节点加入结果集末尾，然后将其子节点入度减一注意有环情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { vector&lt;int&gt;ans; queue&lt;int&gt;que; vector&lt;int&gt;inDegree(numCourses,0); //记录入度 vector&lt;bool&gt;visit(numCourses,false); //记录是否已经访问过 vector&lt;vector&lt;int&gt; &gt;postNode(numCourses); //记录子节点 for(int i=0;i&lt;prerequisites.size();i++){ int from=prerequisites[i][1]; int to=prerequisites[i][0]; inDegree[to]++; postNode[from].push_back(to); } //初始化，将所有入度为0的节点入队 for(int i=0;i&lt;numCourses;i++){ if(!inDegree[i]){ que.push(i); visit[i]=true; } } //进行主体逻辑 while(!que.empty()){ //取出来，归结果集 int node=que.front(); que.pop(); ans.push_back(node); //子节点入度-1， for(int j=0;j&lt;postNode[node].size();j++){ int child=postNode[node][j]; inDegree[child]--; } //将所有入度为0的节点入队 for(int i=0;i&lt;numCourses;i++){ if(visit[i]) continue; if(!inDegree[i]){ que.push(i);A visit[i]=true; } } } if(ans.size()==numCourses) return ans; vector&lt;int&gt;empty; return empty; }}; 快速排序写法一：三指针123456789101112131415161718192021222324/** * 快速排序：每次选取一个基准，小的放左边，大的放右边 * @param arr */void quickSort(int arr[],int left,int right){ if(left&gt;=right) return; int pivot=arr[left]; //可以增加随机选基准int pivot=arr[left~right]; int p=left,l=left,r=right; //p表示马上要处理的元素，l左边都小于基准，r右边都大于基准 while(p&lt;=r){ if(arr[p]&lt;pivot){ swap(arr[p],arr[l]); p++; l++; }else if(arr[p]&gt;pivot){ swap(arr[p],arr[r]); r--; }else p++; } quickSort(arr,left,l-1); quickSort(arr,r+1,right);} 写法二12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[] sortArray(int[] nums) { quickSort(nums,0,nums.length-1); return nums; } void quickSort(int[]nums,int l,int r){ if(l&lt;r){ int p=partition(nums,l,r); quickSort(nums,l,p-1); quickSort(nums,p+1,r); } } void swap(int[]nums,int l,int r){ int t=nums[r]; nums[r]=nums[l]; nums[l]=t; } int partition(int[]nums,int l,int r){ //随机选择基准元素 int p=new Random().nextInt(r-l+1)+l; swap(nums,p,l); int pivot=nums[l]; while(l&lt;r){ //从右边找一个比pivot小的 while(l&lt;r &amp;&amp; nums[r]&gt;=pivot)r--; swap(nums,l,r); //注意这里一定要有swap，因为要利用nums[l]这个位置 //从左边找一个比pivot大的 while(l&lt;r &amp;&amp; nums[l]&lt;=pivot)l++; swap(nums,l,r); } nums[l]=pivot; return l; }} 二路归并排序这种写法下不用写三个while,非常牛! 12345678910111213141516171819void mergeSort(int[]arr,int left,int right){ if(left&gt;=right) return; int mid=(left+right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); int n=right-left+1; int[]tmp=new int[n]; int t=0; int l=left,r=mid+1; while(l&lt;=mid || r&lt;=right){ if(r&gt;right || l&lt;=mid &amp;&amp; arr[l]&lt;arr[r]) tmp[t++]=arr[l++]; else tmp[t++]=arr[r++]; } for(int i=0;i&lt;n;i++) arr[left+i]=tmp[i];} 1234567891011121314151617181920212223242526272829303132/** * 二路归并排序：递归实现，每次将两边排序好的序列合并成一个新的顺序序列 * @param arr * @param left * @param right */void mergeSort(int arr[],int left,int right){ //递归终止条件，当分组只有一个元素的时候就是终态 if(left==right) return; int mid=(left+right)/2; //递归，分别对左右半边进行二路归并排序 mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); //将两个已经排序好的序列合并 int l=left,r=mid+1; int temp[right-left+1]; int i=0; while(l&lt;=mid &amp;&amp; r&lt;=right){ if(arr[l]&lt;arr[r]) temp[i++]=arr[l++]; else temp[i++]=arr[r++]; } while(l&lt;=mid) temp[i++]=arr[l++]; while(r&lt;=right) temp[i++]=arr[r++]; i=0; for(int j=left;j&lt;=right;j++) arr[j]=temp[i++];} 插入排序1234567891011121314/** * 插入排序，每次将一个元素插入到已排序好的序列中 * 这里使用的插入方法类似于冒泡法 * 当前元素从右往左比较，如果左边的比我小，那么就交换 * 直到左边的元素&gt;=我，那么就停止，即找到最终位置 * @param arr * @param len */void insertSort(int arr[],int len){ for(int i=0;i&lt;len;i++) for(int j=i;j&gt;0 &amp;&amp; arr[j-1]&gt;=arr[j];j--){ //j&gt;0是因为每次要和前面一个比，所以只能到第二个 swap(arr[j],arr[j-1]); }} 冒泡排序12345678910111213141516171819/** * 冒泡排序：第i轮（0开始），确定len-1-i位置的元素 * @param arr * @param len */void bubbleSort(int arr[],int len){ //一共len-1轮，每次把最大的元素挪到最右边 for(int i=0;i&lt;len-1;i++){ bool flag=true; for(int j=0;j&lt;len-1-i;j++){ if(arr[j]&gt;arr[j+1]){ flag=false; swap(arr[j],arr[j+1]); } } if(flag) return; }} 选择排序12345678910111213141516/** * 选择排序，每次选择i后边所有元素中的最小元素与i的交换 * @param arr * @param len */void selectSort(int arr[],int len){ for(int i=0;i&lt;len;i++){ //在i到len-1中，把最小的选择出来放在i位置 int min_index=i; for(int j=i+1;j&lt;len;j++){ if(arr[j]&lt;arr[min_index]) min_index=j; } swap(arr[i],arr[min_index]); }} 计数排序（说白了就算记录每个数有多少个，然后按照数轴顺序输出对应个数的数字） 用于所给数据范围不大的情况下 做法： 找到最小和最大元素 申请(max-min+1)这么大的空间，下标0代表数字min，下标1代表数字min+1… 遍历数组，统计每个数字出现的次数 遍历申请的额外空间，对应数字有多少个，就输出多少次。 桶排序需要每个桶内的数量均匀，如果都集中到一个桶，则退化到普通排序 做法 根据数据范围分为多个桶 桶内排序 合并","link":"/2021/03/22/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"并查集","text":"记录并查集的实现方式，及其应用 并查集可以用链表形式实现，也可以用数组实现，数组实现更简单； 并查集可以进行两种优化 路径压缩：即在查询根结点的时候优化树的结构 秩优化：在两个节点合并到同一个集合的时候，根据秩（即树高的上限）来决定连接方式 该例题使用克鲁斯卡尔算法求最小生成树的权值和。 Kruskal算法步骤： 将所有边从小到大排序 从小到大考虑每条边，如果一条边的加入不会在图中生成环，则加入该边，否则舍弃； 当所有边考虑完成时，已选边就是最小生成树 其中，判断一条边的加入是否会生成环，可以使用并查集来实现：如果两点已经联通，再加入一条以这两点为端点的边，则会产生环； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1000;int parent[N]; //记录每个节点的直接父节点,初始值为自身int Rank[N]; //以i节点为祖宗的树的高度(的上限)，初始为1/*为什么说是上限，因为路径压缩之后，其并不是准确的树高 * 但其仍然有意义，因为不会出现a比b树高，但是rank[a]&lt;Rank[b]的情况*//*找到祖宗节点,并进行路径压缩*/int findParent(int k) { if (parent[k] == k) return k; parent[k] = findParent(parent[k]); return parent[k];}/*将两个节点合并到一个集合中，并优化*/void merge(int a, int b) { int pa = findParent(a); //根结点 int pb = findParent(b); //根结点 if (pa == pb) return; /*按照树高决定连接方式，可以优化搜索路径*/ if (Rank[pa] &gt; Rank[pb]) { parent[pb] = pa; } else { parent[pa] = pb; if (Rank[pa] == Rank[pb]) Rank[pb]++; }}/*判断两个节点是否属于同一个集合*/bool check(int a, int b) { return findParent(a) == findParent(b);}int n, m;struct edge { int a, b, len; edge(int a_, int b_, int l) { a = a_, b = b_, len = l; } bool operator&lt;(const edge &amp;e) const { return len &lt; e.len; }};vector&lt;edge&gt; edges;int ans = 0;int main() { for (int i = 0; i &lt; N; i++) { parent[i] = i; Rank[i] = 1; } cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; edges.push_back({a, b, d}); } sort(edges.begin(), edges.end()); for (int i = 0; i &lt; edges.size(); i++) { /*判断是否能够加入已选边*/ int u = edges[i].a; int v = edges[i].b; int d = edges[i].len; if (check(u, v)) { //此时加入边会导致成圈 continue; } merge(u, v); ans += d; } cout &lt;&lt; ans;} 简化版并查集 1234567891011121314int parent[N]; //初始值parent[i]=i;//查询根结点,并进行路径压缩int find(int k){ if(k==parent[k]) return k; parent[k]=find(parent[k]); return parent[k];}//合并void merger(int a,int b){ parent[find(a)]=find(b);}","link":"/2022/03/04/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"二叉树的序列化与反序列化","text":"leetcode 297 二叉树的序列化与反序列化 思路: 序列化: 先序遍历+#表示空 反序列化: 充分利用先序遍历中左子树均在右子树左侧的特点,即意味着左子树利用完了剩下的都是右子树(故用used变量记录已经使用了的数字/#) 注意事项: 拼接字符串用StringBuilder效率更高 比较字符串”#”用equals 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { if(root==null) return &quot;#&quot;; StringBuilder res=new StringBuilder(); res.append(root.val); res.append(','); res.append(serialize(root.left)); res.append(','); res.append(serialize(root.right)); return res.toString(); } int used=-1; //&lt;=used下标已经被使用过 String[]strs; // Decodes your encoded data to tree. public TreeNode deserialize(String data) { strs=data.split(&quot;,&quot;); return de(); } TreeNode de(){ used++; if(strs[used].equals(&quot;#&quot;)) return null; TreeNode t=new TreeNode(Integer.parseInt(strs[used])); t.left=de(); t.right=de(); return t; }}// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root));","link":"/2022/04/12/%E7%AE%97%E6%B3%95-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"异或交换的坑","text":"用异或来交换数据是很爽的 123a=a^b;b=a^b;a=a^b; 原理: 相同数字异或结果为0 初始值 a b a=a^b; a^b b b=a^b; a^b a^b^b=a a=a^b; a^b^a=b a 但是,有个大坑:如果a和b是同一个变量(可以是相同值,但不能是同一个变量) 因为第一步中会同时把两个变量中的值变成0!","link":"/2022/06/15/%E7%AE%97%E6%B3%95-%E5%BC%82%E6%88%96%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%9D%91/"},{"title":"拓展欧几里得算法","text":"欧几里得算法又叫辗转相除法 123int gcd(int a,int b){ return !b?a:gcd(b,a);} ax+by=gcd(a,b)求解使用拓展欧几里得算法 1234567891011int extgcd(int a,int b,int &amp;x,int &amp;y){ int temp=a; if(!b){ x=1,y=0; } else{ temp=extgcd(b,a%b,y,x); y-=(a/b)*x; } return temp;} 然后通过以下式子获得所有解： 1234x' = x + ( b/gcd) * Ky' = y - (a/gcd) * K其中K是任意整数 即x和y的所有解分别以b/gcd和a/gcd为周期其中x的最小非负整数解是(x % b/gcd +b/gcd )% (b/gcd)，注意b要先取绝对值，推导见算法笔记，但是算法笔记有个错误，就是b也要取绝对值，否则如果b为负数，最小非负x求出来可能为负数 这里实际求x最小非负整数解的时候不用这么麻烦，用一个while循环不断试探，如果x大于0，每轮减去T=|b/gcd|，如果x&lt;0，每轮加上T就行。 当gcd==1时，全部解化简为以下公式 12x' = x + b * Ky' = y - a * K x的最小非负整数解也可以化简为(x%b+b)%b，注意b要先取绝对值 补充：贝祖定理：给定两个整数a、b，必定存在整数x、y使得 ax + by = gcd(a, b)，且存在x &lt; b, y &lt; a满足等式。 后边黑体字很重要，给出了有解的范围。","link":"/2021/05/18/%E7%AE%97%E6%B3%95-%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"},{"title":"排列数与组合数的递归实现","text":"排列数排列数：从N个目标中选出M个进行排列（即使元素相同，其顺序不同，排列也不同）leetcode46 全排列 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt;ans; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { dfs(nums,0); return ans; } //处理下标为k的数 void dfs(vector&lt;int&gt;&amp; nums,int k){ if(k==nums.size()){ ans.push_back(nums); return; } for(int i=k;i&lt;nums.size();i++){ swap(nums[i],nums[k]); dfs(nums,k+1); swap(nums[i],nums[k]); } }}; 若存在重复元素 123456789101112131415161718void permutation(vector&lt;int&gt;&amp;nums,int k){ //在下一轮进行判断 if(k==nums.size()){ ans.push_back(nums); return; } set&lt;int&gt;record; //选择第k个位置的数字，不能重复选择相同的数字 for(int i=k;i&lt;nums.size();i++){ int target=nums[i]; if(record.find(target)!=record.end()){ continue; } record.insert(target); swap(nums[i],nums[k]); permutation(nums,k+1); swap(nums[i],nums[k]); } 组合数组合数：从N个目标中选出M个进行组合（顺序不影响结果）leetcode77 组合 1234567891011121314151617181920212223242526272829class Solution { private List&lt;List&lt;Integer&gt;&gt;ans=new ArrayList&lt;&gt;(); private List&lt;Integer&gt;tmp=new ArrayList&lt;&gt;(); private int n,k; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { this.n=n; this.k=k; dfs(1); return ans; } //从下标t~n中选一个数 void dfs(int t){ if(tmp.size()==k){ ans.add(new ArrayList&lt;Integer&gt;(tmp)); return; } if(t==n+1){ return; } for(int i=t;i&lt;=n;i++){ tmp.add(i); dfs(i+1); tmp.remove(tmp.size()-1); } }}","link":"/2021/08/19/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%88%97%E6%95%B0%E4%B8%8E%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"},{"title":"排序算法稳定性","text":"什么叫稳定和不稳定排序？ 答：相同元素前后顺序不发生改变的叫稳定排序；会发生改变的叫不稳定排序 稳定的排序算法：直接插入排序、冒泡排序、归并排序、基数排序 不稳定的排序算法：希尔排序、快速排序、简单选择排序、堆排序 为什么直接插入排序稳定？ 因为新元素向左找位置的时候，遇到相等的就停止了，因此相同元素的前后顺序不会发生改变 为什么冒泡排序稳定？ 冒泡排序每一轮通过两两比较和交换的方式，将最大值移动到末尾。遇到两个比较元素相同的时候，当然不会闲着没事进行交换。因此稳定。 为什么归并排序稳定？ 归并是把问题划分为多个小规模问题，将小规模问题解决完之后，再做合并操作。比如将两个已经排好序的子序列做合并操作，此时如果有相同的值分别存在于两个子序列中，我们可以先将左边数组中的数插入到临时数组中，再将右边数组的数插入到临时数组中。这样一来就可以确保相同值相对顺序不变。因此是稳定的。 为什么基数排序稳定？ 基数排序是一种桶排序，每次在入桶的时候，遇到相同元素，将左侧元素放上边即可保证稳定。 第一轮 第二轮 第三轮 第四轮 34 49 66 100 137 1002 1234 为什么简单选择排序不稳定？ 比如对于数组[5,5,5,3,7,1]来说，3比5小，我们把二者交换位置之后，第一个5就跑到了3的位置，这样一来，第一个5就跑到了第二、三个5的后面了，相对顺序变了，因此不稳定。 为什么堆排序不稳定？ 比如对于[3，4，4，5]这样的一棵树来说，在构建大顶堆的过程中，会将5这个节点与它的父节点交换位置，变成[3，5，4，4]，这样一来，第一个4就跑到了第二个4的后面，相对顺序变了，因此不稳定。","link":"/2021/10/16/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/"},{"title":"旋转图像","text":"leetcode48 旋转图像 12345678910111213141516171819202122232425262728293031class Solution { int[][] matrix; public void rotate(int[][] matrix) { this.matrix=matrix; flipByMainDiagonal(); flipRight(); } void swap(int x1,int y1,int x2,int y2){ int t=matrix[x1][y1]; matrix[x1][y1]=matrix[x2][y2]; matrix[x2][y2]=t; } public void flipRight(){ int n=matrix.length; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n/2;j++){ swap(i,j,i,n-1-j); } } public void flipByMainDiagonal(){ int n=matrix.length; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;i;j++){ swap(i,j,j,i); } }}","link":"/2022/06/15/%E7%AE%97%E6%B3%95-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"title":"最长回文子序列","text":"刷算法题时遇到这道求最长回文子序列长度的题，因为其子序列不要求连续，跟普通求回文子序列不同，因此加以记录 最长回文子序列 题目描述：给定一仅由大小写字母组成的字符串，求其回文子序列的最大长度，回文子序列指正反读都一样的子序列，如madam。本题中大小写不敏感，即a和A相同。 输入描述：输入包含一行字符串，长度不超过300 输出描述：输出该字符串最长回文子序列的长度 输入样例：ABCdca 输出样例：5 提示：子序列不要求连续 方法一：二维动态规划 123456789101112131415161718192021222324class Solution {public: int dp[1010][1010]; int longestPalindromeSubseq(string s) { int n=s.size(); for(int j=0;j&lt;n;j++){ //注意动态规划必须先解决子问题，因此i和j的遍历顺序必须是这样的（i左边界，j右边界） for(int i=j;i&gt;=0;i--){ if(i==j) dp[i][j]=1; else if(j==i+1) dp[i][j]=(s[i]==s[j])?2:1; else{ int t=0; if(s[i]==s[j]) t=2; dp[i][j]=max(dp[i+1][j-1]+t,max(dp[i+1][j],dp[i][j-1])); } } } return dp[0][n-1]; }}; 方法二：递归 12345678910111213141516171819202122232425262728293031public class Question6_递归解法 { public static void main(String[] args) { String s=new Scanner(System.in).nextLine().toLowerCase(); System.out.println(subStrLen(s)); } //递归计算最长回文子序列的长度 public static int subStrLen(String s){ if(s.length()==1) return 1; if(s.length()==2){ if(s.charAt(0)==s.charAt(1)) return 2; else return 0; } int maxSubStrLen=1; for(int dist=1;dist&lt;=s.length()-3;dist++){ for(int i=1;i&lt;s.length()-1;i++){ for(int j=i+dist;j&lt;s.length()-1;j++){ int record=subStrLen(s.substring(i,j+1)); if(record&gt;maxSubStrLen) maxSubStrLen=record; } } } if(s.charAt(0)==s.charAt(s.length()-1)) return 2+maxSubStrLen; else return maxSubStrLen; }}","link":"/2020/04/25/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"最长连续序列","text":"首先,第一个能想到的方法就是排序.但是它的时间复杂度是O(NlogN) 123456789101112131415161718192021222324class Solution { public int longestConsecutive(int[] nums) { if(nums.length==0) return 0; Arrays.sort(nums); int ans=1; int t=1; for(int i=1;i&lt;nums.length;i++){ if(nums[i]==nums[i-1]+1) t++; else if(nums[i]==nums[i-1]) continue; else{ ans=Math.max(ans,t); t=1; } } ans=Math.max(ans,t); return ans; }} 如果要减少时间复杂度的话,我们通常的思路有: 二分 dp (避免重复计算) 空间换时间 对于此题,显然使用哈希表能够大大降低时间复杂度. 此外,如果想提升运行效率的话,我们应该考虑在程序运行中,是否有 冗余操作或不必要的操作. 这一题中,如果我们去看每个数字的上下的连续数字的话,显然是浪费的,我们只需要看每一条连续数字的最下面那个数字,看它的上方是否有连续数字即可. 因此,我们通过哈希表判断是否有比当前数字小一个的,如果有的话,则说明当前数字不是连续数字序列的最小数字,因此可以直接跳过. 12345678910111213141516171819202122232425class Solution { //对于ON时间复杂度的算法,务必要想到哈希表 空间换时间! public int longestConsecutive(int[] nums) { if(nums.length==0) return 0; Set&lt;Integer&gt;set=new HashSet&lt;&gt;(); for(int a:nums){ set.add(a); } int ans=1; for(int a:set){ if(!set.contains(a-1)){ int i=1; while(set.contains(a+i))i++; ans=Math.max(ans,i); } } return ans; }}","link":"/2022/06/16/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"},{"title":"最长递增子序列","text":"这篇文章讲的很细：https://blog.csdn.net/lxt_Lucia/article/details/81206439 方法一：动态规划 时间复杂度$n\\log{n}$ dp[i]：以第i个元素为结尾的子序列的最大长度 状态转移方程：$dp[i]=max( dp[j]+1), 其中arr[i]&gt;arr[j], i&gt;j$ 方法二：动态规划+二分注意，此方法只能用于求LIS的长度，如果需要求LIS，需要记录路径信息 $dp[i]$，表示长度为i的LIS结尾元素的最小值 算法思想：维护一个递增序列，让其每个位置的元素尽可能保持最小，这样就给后续添加递增元素让出了最大空间，其维护的最终结果不一定是LIS，但长度和LIS相同。 维护一个路径信息，可以推出所有LIS中字典序最小的一个。 原理: 一个数字a在序列中,如果用一个比他小的数字b替换他,那么不影响比a大的数字在后边和它组成递增序列的最大长度. 后面比前面大的,可以增加维护序列的长度;而后面&lt;=前面的,只能优化维护的队列,而不能增加长度; 换言之,在我右边还比我小的数字,是不能影响含有我的最终序列的最长长度的. 例如 1,3,2 1-&gt;1,3,-&gt;2,3 3根本不用担心2跑到前边会影响自己的长度,因为2是替换1,而不是插入一个2. 我担心会出现2,3,100这样的序列,2跑到3前边去了然后跟后边的数字组成序列 !不用担心,因为你这里的2,3,100和1,3,100是等价的,最大长度不会有区别 例如: 4,5,6,7 -&gt; 0,5,6,7 添加数字1 4,5,6,7 -&gt; 0,5,6,7 -&gt;0,1,6,7 发现添加比7小的数字,并不影响原来的4,5,6,7的长度. 继续添加2,3,4 4,5,6,7 -&gt; 0,5,6,7 -&gt;0,1,6,7-&gt;**0,1,2,**7 -&gt;0,1,2,3 -&gt; 0,1,2,3,4 只有当0为首的递增序列长度大于原来的4,5,6,7的时候,才会替换掉 最长递增子序列 123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { //遍历的过程中，不断优化队列的结构（使每个元素尽可能小），这样给后序元素的添加提供了遍历 vector&lt;int&gt;arr; for(auto&amp;n:nums){ auto it=lower_bound(arr.begin(),arr.end(),n); //所有元素都小于n（或为空） if(it==arr.end()){ arr.push_back(n); continue; } //替换第一个大于等于它的元素，以优化结构（瘦身），使得后序元素有更大的数字空间来进栈 *it=n; } return arr.size(); }}; 方法三：树状数组 或 线段树","link":"/2021/05/30/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"树状数组","text":"引入问题给出一个长度为n的数组，完成以下两种操作 将第x个数加上k 输出区间[x,y]内每个数的和 使用暴力算法 单点修改：O(1) 区间查询：O(n) 对于大数据来说，这样的复杂度是不能接受的 树状数组处理： 单点修改：O(logn) 区间查询：O(logn) 可以应对非常大规模的数据 前置知识——lowbit()操作lowbit()操作：非负整数n在二进制表示下最低为1及其后面的0构成的数值例如：lowbit(44) = lowbit( (101100)2) =(100)2 =4 求101100的lowbit值过程 按位取反010011 然后加一010100 然后与原来的数相与：000100 由于二进制在计算机中是用补码存储的，因此（非负整数）N按位取反加一就是-N，故lowbit(N) = N&amp;(~N+1) = N&amp;(-N); 树状数组——思想及实现区间查询 ——&gt; 前缀和 ——&gt; 树结构维护（logn) 因为求得是区间和，所以很容易想到用前缀和相减的方法，如果使用树结构来维护，那么就可以将复杂度降低到logn该树状数组特性 每个节点t[x]保存以x为根的子树中的叶节点（即原数组的每个元素）值的和 t[x]节点覆盖的长度就是lowbit(x) t[x]节点的父节点为t[x+lowbit(x)] 整棵树的深度为log2n+1 add(x,k)操作，即将a[x]加上k - 需要处理每一层的一个树状数组的数据 - 最坏时间复杂度log2nask(x)操作，即查询a[1]~x[7]的和，即前缀和 最坏时间复杂度log2n 向左上找上一个节点，只需要将下标-=lowbit(index)即可 如果需要求区间和，则计算出两个前缀和，然后相减即可 示例可以通过前缀和来初始化树状数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//树状数组#include &lt;iostream&gt;using namespace std;const int N=10;int arr[11]={0,1,4,2,5,10,3,4,0,1,0}; //0号位置舍弃不用int treeArr[11]; //0号位置舍弃不用int prefix[11]; //记录前缀和，用于树状数组初始化int lowbit(int x){ return x&amp;(-x);}void init(){ prefix[1]=arr[1]; for(int i=2;i&lt;=N;i++){ prefix[i]=arr[i]+prefix[i-1]; } for(int i=1;i&lt;=N;i++){ //treeArr[i]是以i为根的树的所有叶节点的和 treeArr[i]=prefix[i]-prefix[i-lowbit(i)]; }}//对a[i]增加xvoid add(int i,int x){ while(i&lt;=N){ treeArr[i]+=x; i+=lowbit(i); }}//查询1到x之间的区间和即前缀和int ask(int x){ if(x==0) return 0; int sum=0; while(x&gt;0){ //注意这里一定要是&gt;0 sum+=treeArr[x]; x-=lowbit(x); } return sum;}//计算坐标a到b之间的区间和int interval(int a,int b){ return ask(b)-ask(a-1);}int main(){ init(); while(1){ cout&lt;&lt;&quot;0:add 1:interval&quot;&lt;&lt;endl; int opt; cin&gt;&gt;opt; switch(opt){ case 0: cout&lt;&lt;&quot;enter index and addValue:&quot;&lt;&lt;endl; int index,value; cin&gt;&gt;index&gt;&gt;value; add(index,value); break; case 1: cout&lt;&lt;&quot;enter left and right boundary:&quot;&lt;&lt;endl; int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;interval(l,r)&lt;&lt;endl; break; default: return 0; } } return 0;} 总结树状数组是动态维护前缀和的工具，最基本的用途是进行区间和查询和单点修改（均是logn的时间复杂度），此外还可以进行区间修改、单点查询；区间修改、区间查询等。 本文根据该视频的讲解总结而来，地址如下https://www.bilibili.com/video/BV1pE41197Qj?from=search&amp;seid=13604527415584361816","link":"/2021/05/15/%E7%AE%97%E6%B3%95-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"欧拉筛质数（线性筛）","text":"适用场景：求2~N范围内的素数 优点：线性筛，复杂度为O(n)。与埃氏筛相比，不会对已经被标记过的合数再进行重复标记，故效率更高。欧拉筛将合数分解为 (最小质因数 * 一个自然数) 的形式，通过最小质因数来判断当前合数是否已经被标记过。 筛数原理：我们知道当一个数为素数的时候，它的倍数肯定不是素数。所以我们可以从2开始通过乘积筛掉所有的合数。 算数基本定理：一个合数可以唯一分解为多个素数的乘积。 例如：i循环到77，这是要筛掉77的倍数，2*77,3*77,4*77…这些都为合数，那么筛到什么时候为止呢？ 77=7*11 筛掉2*77=2*7*11 筛掉3*77=3*7*11 筛掉5*77=5*7*11 筛掉7*77=7*7*11 停止筛数 此时如果继续筛下去，就要筛掉11*77=11*7*11=847，那么这个数也会被121筛，因为7*121=7*11*11=847,产生重复筛出 避免重复筛除原理：把一个合数分解为，一个质因子乘以另一个自然数X，欧拉筛就是保证所有合数，只被这个X筛。这样就保证了这个数不会被重复筛出。 847=7*11*11，保证847只被11*11，即121在它的回合内筛除(筛2*121,3*121,5*121..)就行了 实现方法就是，每个数i只筛到最小质因子乘以自身就停止。 代码12345678910111213141516171819202122232425class Solution {public: int countPrimes(int n) { vector&lt;int&gt;prime(n); //记录已发现的素数 int num=0; //已发现素数数量 //记录0~n-1是否是质数 vector&lt;bool&gt;digit(n,true); //下标即对应数字 for(int i=2;i&lt;n;i++){ //遇到素数存起来 if(digit[i]){ prime[num++]=i; } //筛除合数 for(int j=0;j&lt;num;j++){ if(i*prime[j]&gt;=n) break; digit[i*prime[j]]=false; //第一个能整除i的，即i的最小质因数(因为prime中的质数是从小到达排列的） if(i%prime[j]==0) break; } } return num; }}; 算法思想：保证构建合数的路径唯一 方法：用一个基数向后筛数的时候，将基数分解为从小到大的质因数相乘 如果是素数，则为X1 如果是合数，则质因数分解为X1 * X2 * …* Xn 规定一种构建合数的方法：即在上面的序列左侧再乘上一个数 使用基数向后筛数的过程，即找基数的倍数的过程，即在质因数相乘的序列左侧再乘以一个数的过程，等同在构建合数 那么每次构建合数的时候，只允许在左侧乘以一个小于等于X1的素数，那么就保证了构建合数的路径唯一，也就意味着一个合数只会被一个特定的基数筛出，也就不会出现重复筛数的情况。","link":"/2021/03/15/%E7%AE%97%E6%B3%95-%E6%AC%A7%E6%8B%89%E7%AD%9B%E8%B4%A8%E6%95%B0%EF%BC%88%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%89/"},{"title":"汉诺塔问题","text":"递归方法，每次将上面的n-1个盘子看成一个整体 1234567891011121314151617public class Question6汉诺塔问题 { public static void main(String[] args) { int n=new Scanner(System.in).nextInt(); move(n,'A','B','C'); } //借助B把A上的盘子，移动到C上 public static void move(int n, char a, char b, char c){ if(n==1) { System.out.println(a + &quot;移动到&quot; + c + &quot;上&quot;); return; } move(n-1,a,c,b); System.out.println(a+&quot;移动到&quot;+c+&quot;上&quot;); move(n-1,b,a,c); }}","link":"/2020/04/23/%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"},{"title":"求平方根的两种方法","text":"二分二分法求平方根其实是将问题转化为求$x^{2}{\\leq}target$中x的最大整数值 12345678910111213int sqrt(int x){ int l=0,r=x; int ans; while(l&lt;=r){ int mid=l+(r-l)/2; if((long long)mid*mid&lt;=x){ ans=mid; l=mid+1; }else r=mid-1; } return ans;} 牛顿迭代法1234567891011121314int Newton(int x){ if(x==0) return 0; double C=x,x0=x; while(1){ double x1=0.5*(x0+C/x0); if(fabs(x1-x0)&lt;1e-7){ break; } x0=x1; } return int(x0);}","link":"/2021/08/08/%E7%AE%97%E6%B3%95-%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"leetcode滑动窗口的最大值","text":"leetcode 方法一：单调队列 运用到单调队列和单调栈的题目，不要生硬地套用这两种数据结构，单调队列和单调栈其根本目的是保留有用数据，将无用数据丢弃，留下的数据有序且有用。 小技巧：单调队列里不是直接存数据，而是存下标，这样可以根据下标判断是否在滑动窗口内。 1234567891011121314151617181920212223242526class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; k; ++i) { while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) { deque.pollLast(); } deque.offerLast(i); } int[] ans = new int[n - k + 1]; ans[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; n; ++i) { while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) { deque.pollLast(); } deque.offerLast(i); while (deque.peekFirst() &lt;= i - k) { deque.pollFirst(); } ans[i - k + 1] = nums[deque.peekFirst()]; } return ans; }} 方法二：堆 凡是求最小值、最大值的题目，要能想到用堆。 小技巧：因为堆中的元素不方便直接删除，所以我们采用延迟删除，当访问到的堆顶元素不在滑动窗口范围内（堆中存放下标，用下标判断），那么直接舍弃。 这里我用的是哈希表判断是否在堆中（用下标更优） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(k==0) return new int[0]; PriorityQueue&lt;Integer&gt; que=new PriorityQueue&lt;&gt;((x,y)-&gt;(y-x)); //大根堆 Map&lt;Integer,Integer&gt; mp=new HashMap&lt;&gt;(); List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); int r=0; while(r&lt;k){ que.offer(nums[r]); if(mp.containsKey(nums[r])) mp.put(nums[r],mp.get(nums[r])+1); else mp.put(nums[r],1); r++; } r--; while(r&lt;nums.length){ /*求当前的最大值*/ int l=r-k+1; while(mp.get(que.peek())==0){ //延迟删除 que.poll(); } res.add(que.peek()); /*删除左边*/ mp.put(nums[l],mp.get(nums[l])-1); //在hash表中删除左侧元素 /*增加右边*/ r++; if(r&lt;nums.length){ que.offer(nums[r]); if(mp.containsKey(nums[r])) mp.put(nums[r],mp.get(nums[r])+1); else mp.put(nums[r],1); } } int[]resArr=new int[res.size()]; for(int i=0;i&lt;res.size();i++){ resArr[i]=res.get(i); } return resArr; }}","link":"/2022/04/15/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"状态压缩dp","text":"理解 当出现NPC问题，但是题目给出的N在20左右时，一般用状态压缩dp来解决 状态压缩dp本质还是动态规划，只不过是将一些不方便表示的状态用二进制数的形式来表示。 例题例题1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;int N, K;ll dp[9][(1 &lt;&lt; 9)][82] = {0}; //dp[i][st][j] 表示0~i行共j个国王，第i行状态为st，此时的方案数//所求结果=sum(dp[.][.][K])//状态转移方程：dp[i][st][j]=sum( dp[i-1][st2][K-count(st)] )int countOne(int n) { int count = 0; while (n) { count += (n &amp; 1); n &gt;&gt;= 1; } return count;}ll f() { //初始化第一行，所有合法状态的方案数都是1 for (int s = 0; s &lt; (1 &lt;&lt; N); s++) { if (s &amp; (s &lt;&lt; 1)) continue; dp[0][s][countOne(s)] = 1; } //枚举行 for (int i = 1; i &lt; N; i++) //枚举当前行状态 for (int s = 0; s &lt; (1 &lt;&lt; N); s++) { if (s &amp; (s &lt;&lt; 1)) continue; for (int j = countOne(s); j &lt;= K; j++) { //0~i行的king数量 for (int s2 = 0; s2 &lt; (1 &lt;&lt; N); s2++) { if (s2 &amp; (s2 &lt;&lt; 1)) continue; if (s &amp; s2) continue; if ((s &lt;&lt; 1) &amp; s2) continue; if (s &amp; (s2 &lt;&lt; 1)) continue; dp[i][s][j] += dp[i - 1][s2][j - countOne(s)]; } } } long long ans = 0; for (int i = 0; i &lt; (1 &lt;&lt; N); i++) ans += dp[N - 1][i][K]; return ans;}int main() { scanf(&quot;%d%d&quot;, &amp;N, &amp;K); cout &lt;&lt; f(); return 0;} 例题2 http://acm.hdu.edu.cn/showproblem.php?pid=5418 杭电OJ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 1e9 + 7;int T, n, m;int dp[(1 &lt;&lt; 16)][16]; //dp[i][j]表示，路径为i，终点为j时，最少的油耗int oilCost[16][16]; //油耗int f() { //处理特殊情况 if (n == 1) return 0; //规定从0节点出发 dp[1][0] = 0; //开始dp for (int st = 1; st &lt; (1 &lt;&lt; n); st++) //枚举不同访问状态 for (int i = 0; i &lt; n; i++) if ((1 &lt;&lt; i) &amp; st) //枚举已访问节点 //枚举未访问节点 for (int j = 0; j &lt; n; j++) if (!((1 &lt;&lt; j) &amp; st)) { dp[st | (1 &lt;&lt; j)][j] = min(dp[st | (1 &lt;&lt; j)][j], dp[st][i] + oilCost[i][j]); } //整理结果 int ans = INF; for (int i = 1; i &lt; n; i++) { ans = min(ans, dp[(1 &lt;&lt; n) - 1][i] + oilCost[0][i]); } return ans;}void init() { //初始为INF for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (i == j) oilCost[i][j] = 0; else oilCost[i][j] = INF; while (m--) { int a, b, cost; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;cost); if(oilCost[a-1][b-1]&lt;=cost) //这一步不知道为什么，但是不加就不通过oj continue; oilCost[a - 1][b - 1] = cost; oilCost[b - 1][a - 1] = cost; } //floyd计算任意两点之间的最少油耗 for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) for (int k = 0; k &lt; n; k++) if (oilCost[i][k] + oilCost[k][j] &lt; oilCost[i][j]) { oilCost[j][i] = oilCost[i][k] + oilCost[k][j]; oilCost[i][j] = oilCost[i][k] + oilCost[k][j]; } //打印floyd结果// for (int i = 0; i &lt; n; i++) {// for (int j = 0; j &lt; n; j++)// cout &lt;&lt; oilCost[i][j] &lt;&lt; &quot; &quot;;// cout &lt;&lt; endl;// } //重置dp for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) dp[i][j] = INF;}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); cout &lt;&lt; f()&lt;&lt;endl; } return 0;} 例题3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int count = 0;const int Mod = 1e9;int M, N;int fieldState[12] = {0};int dp[12][(1 &lt;&lt; 12)]; //dp[i][st]表示第i行状态为st时，0~i行的方案数void init() { cin &gt;&gt; M &gt;&gt; N; int t; for (int i = 0; i &lt; M; i++) { for (int j = 0; j &lt; N; j++) { scanf(&quot;%d&quot;, &amp;t); fieldState[i] &lt;&lt;= 1; fieldState[i] += t; } }}bool checkLine(int st, int landLimit) { return !(st &amp; (st &lt;&lt; 1)) &amp;&amp; (landLimit | st) == landLimit;}bool checkTwoLines(int st1, int st2) { return !(st1 &amp; st2);}int f() { //初始化dp第一行 for (int st = 0; st &lt; (1 &lt;&lt; N); st++) if (checkLine(st, fieldState[0])) dp[0][st] = 1; //开始dp for (int i = 1; i &lt; M; i++) for (int st1 = 0; st1 &lt; (1 &lt;&lt; N); st1++) if (checkLine(st1, fieldState[i])) for (int st2 = 0; st2 &lt; (1 &lt;&lt; N); st2++) if (checkLine(st2, fieldState[i - 1]) &amp;&amp; checkTwoLines(st1, st2)) { dp[i][st1] = (dp[i][st1] + dp[i - 1][st2]) % Mod; } //统计结果 int ans = 0; for (int st = 0; st &lt; (1 &lt;&lt; N); st++) { ans = (ans + dp[M - 1][st]) % Mod; } return ans;}int main() { init(); cout &lt;&lt; f(); return 0;} 例题4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;/*写题目之前先关注：数据大小，所用方法复杂度，边界情况*///@Todo 为什么记两行，因为枚举当前行的状态时，要与前两行进行比较int N, M;int battle[100]; //记录每一行的战场情况int goodSt[1000]; //记录在一行中合法的状态int goodN = 0; //一行中合法状态的数量int dp[100][(1 &lt;&lt; 10)][1 &lt;&lt; 10] = {0}; //dp[i][st1][st2]表示，第i行情形为st1，i-1行情形为st2，此状态下0~i行最多能摆放的炮兵数量//状态转移方程：dp[i][st1][st2]=max(自身,dp[i-1][st2][st3]+count(st1) ) if( checkLine(st1,st2,st3) )void init() { cin &gt;&gt; N &gt;&gt; M;// scanf(&quot;%d%d&quot;,&amp;N,&amp;M); //预处理，将一行中的合法状态存入goodSt中 for (int st = 0; st &lt; (1 &lt;&lt; M); st++) { if (!(st &amp; (st &lt;&lt; 1)) &amp;&amp; !(st &amp; (st &lt;&lt; 2))) goodSt[goodN++] = st; } //输入战场情况,1表示平原可摆放 char c; for (int i = 0; i &lt; N; i++) { int battle_st = 0;// getchar(); for (int j = 0; j &lt; M; j++) { cin&gt;&gt;c;// scanf(&quot;%c&quot;, &amp;c); battle_st &lt;&lt;= 1; battle_st += (c == 'P'); } battle[i] = battle_st; }}//检查是否与当前行匹配bool checkLine(int st, int line) { return (line | st) == line;}//检查两行之间是否匹配bool check(int st1, int st2) { return !(st1 &amp; st2);}//计算一种摆放状态下的部队数int count(int st) { int num = 0; while (st) { num += (st &amp; 1); st &gt;&gt;= 1; } return num;}//处理dpvoid f() { if (N == 0) return; //处理第一行 for (int i = 0; i &lt; goodN; i++) { int st = goodSt[i]; if (checkLine(st, battle[0])) { for (int st2 = 0; st2 &lt; (1 &lt;&lt; M); st2++) //枚举-1行状态，其实并不存在，只是配合dp而用 dp[0][st][st2] = count(st); } } if (N == 1) return; //处理第二行 for (int i = 0; i &lt; goodN; i++) { int st1 = goodSt[i]; for (int j = 0; j &lt; goodN; j++) { int st2 = goodSt[j]; if (!check(st1, st2)) continue; dp[1][st1][st2] = count(st1) + count(st2); } } //开始动态规划 for (int row = 2; row &lt; N; row++) { for (int i = 0; i &lt; goodN; i++) { //枚举当前行摆放方式 int st1 = goodSt[i]; if (!checkLine(st1, battle[row])) continue; for (int j = 0; j &lt; goodN; j++) { //枚举上一行摆放方式 int st2 = goodSt[j]; if (!checkLine(st2, battle[row - 1])) continue; for (int k = 0; k &lt; goodN; k++) { //枚举上上行摆放方式 int st3 = goodSt[k]; if (!checkLine(st3, battle[row - 2])) continue; if (!check(st1, st2) || !check(st1, st3) || !check(st2, st3)) continue; dp[row][st1][st2] = max(dp[row][st1][st2], dp[row - 1][st2][st3] + count(st1)); } } } }}//计算结果int getRes() { f(); //统计结果 int ans = 0; for (int i = 0; i &lt; goodN; i++) for (int j = 0; j &lt; goodN; j++) ans = max(ans, dp[N - 1][goodSt[i]][goodSt[j]]); return ans;}int main() { init(); cout &lt;&lt; getRes(); return 0;}","link":"/2021/05/10/%E7%AE%97%E6%B3%95-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/"},{"title":"理解KMP算法","text":"","link":"/2021/03/15/%E7%AE%97%E6%B3%95-%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/"},{"title":"用Rand7()实现Rand10()","text":"leetcode470 这里做法非常巧妙,先奇偶性凑出1/2概率,然后用等概率的15凑出等概率的110 12345678910111213/** * The rand7() API is already defined in the parent class SolBase. * public int rand7(); * @return a random integer in the range 1 to 7 */class Solution extends SolBase { public int rand10() { int t1,t2; while((t1=rand7())==7); while((t2=rand7())&gt;5); return (t1&amp;1)==0?t2+5:t2; }}","link":"/2022/06/14/%E7%AE%97%E6%B3%95-%E7%94%A8Rand7-%E5%AE%9E%E7%8E%B0Rand10/"},{"title":"移动零","text":"leetcode 283 移动零 这种方法快速排序,选择排序,插入排序中均用到. 思路:一个指针的左侧全是最终的有效元素,一个指针用来遍历数组 12345678910111213141516171819202122class Solution { void swap(int[]arr,int a,int b){ int t=arr[a]; arr[a]=arr[b]; arr[b]=t; } public void moveZeroes(int[] nums) { int n=nums.length; int l=0; //l左边是有效元素 for(int i=0;i&lt;n;i++){ if(nums[i]!=0){ swap(nums,i,l); l++; } } while(l&lt;n){ nums[l]=0; l++; } }}","link":"/2022/06/21/%E7%AE%97%E6%B3%95-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"},{"title":"抓捕孔连顺","text":"牛客-字节-抓捕孔连顺 降低时间复杂度的三种经典方法: 空间换时间(一般用hash,或者优先级队列) 二分搜索 动态规划(减少冗余计算) 这一题的内层显然可以用二分进行优化. 此外,做题的时候先用经典和常规的方法去思考,如果行不通再用刁钻的奇思妙想. 注意: len要用long,否则相乘的时候会溢出. 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main{ public static void main(String[]args){ int mod=99997867; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int d=sc.nextInt(); int[]pos=new int[n]; for(int i=0;i&lt;n;i++){ pos[i]=sc.nextInt(); } if(n&lt;3){ System.out.println(0); return; } int ans=0; for(int i=2;i&lt;n;i++){ //二分搜索左边界 int l=0,r=i-1; int tar=-1; while(l&lt;=r){ int m=l+(r-l)/2; if(pos[i]-pos[m]&lt;=d){ tar=m; r=m-1; }else{ l=m+1; } } if(tar!=-1 &amp;&amp; i-tar&gt;=2){ long len=i-tar; ans+=(int)((len*(len-1)/2)%mod); ans%=mod; } } System.out.println(ans); }}","link":"/2022/06/28/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E5%AD%97%E8%8A%82-%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/"},{"title":"毕业旅行问题","text":"牛客网 字节-毕业旅行问题 两种dp的方法dp[st][i] 一种是st中包含i,i是最后一个点;一种是不包含; 我的建议是: 包含,因为这样最后结算的时候方便. 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[][]dis=new int[n][n]; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ dis[i][j]=sc.nextInt(); //改变量名的时候记得一致性 } } int[][]dp=new int[1&lt;&lt;19][20]; //二进制第0为是城市1 //dp[st][i] 表示已经走过的城市是st,最后一步是i,此情况下的最小花费 for(int st=1;st&lt;(1&lt;&lt;(n-1));st++){ for(int i=0;i&lt;n-1;i++){ if((st&amp;(1&lt;&lt;i))==0) continue; int last=st^(1&lt;&lt;i); if(last==0){ dp[st][i]=dis[0][i+1]; continue; } for(int j=0;j&lt;n-1;j++){ int t=last&amp;(1&lt;&lt;j); if(t!=0){ if(dp[st][i]==0) dp[st][i]=dp[last][j]+dis[i+1][j+1]; else dp[st][i]=Math.min(dp[last][j]+dis[i+1][j+1],dp[st][i]); } } } } int ans=0x3fffffff; for(int i=0;i&lt;n-1;i++){ ans=Math.min(ans,dp[(1&lt;&lt;(n-1))-1][i]+dis[i+1][0]); } System.out.println(ans); }}","link":"/2022/06/22/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E5%AD%97%E8%8A%82-%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"},{"title":"雀魂启动","text":"感悟: 卡牌类的题目,用数组来处理是最好的(直接用数组作为哈希表) 仔细审题! 这一题里边说了每张卡牌最多4张,就因为这个问题没看到,导致我找了半个小时的bug 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Main{ public static void main(String[]args){ new Main().solve(); for(Integer a:ans) System.out.print(a+&quot; &quot;); if(ans.size()==0) System.out.print(0); } int[]card=new int[10]; static List&lt;Integer&gt;ans=new ArrayList&lt;&gt;(); void solve(){ Scanner sc=new Scanner(System.in); while(sc.hasNext()){ card[sc.nextInt()]++; } for(int k=1;k&lt;=9;k++){ if(card[k]==4) continue; card[k]++; for(int i=1;i&lt;=9;i++){ if(card[i]&gt;=2){ card[i]-=2; boolean flag=check(0); card[i]+=2; if(flag){ ans.add(k); break; } } } card[k]--; } } //对于每个数字来说,不是刻子就是顺子 boolean check(int k){ if(k==10) //说明1~9都是0 return true; if(card[k]==0) return check(k+1); //当成顺子 boolean res=false; if(k&lt;=7 &amp;&amp; card[k+1]&gt;0 &amp;&amp; card[k+2]&gt;0){ card[k]--; card[k+1]--; card[k+2]--; res=check(k); card[k]++; card[k+1]++; card[k+2]++; } if(res) return true; //当成刻子 if(card[k]&gt;=3){ card[k]-=3; res=check(k); card[k]+=3; } return res; }}","link":"/2022/06/22/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E5%AD%97%E8%8A%82-%E9%9B%80%E9%AD%82%E5%90%AF%E5%8A%A8/"},{"title":"公司食堂","text":"美团笔试-公司食堂 由于最左边的1的位置是会时刻变化的,因此要采用优先级队列 而0的最左端坐标只会增加,所以可以采用栈,效率更高. 这一题最后两个用例死活超时,最后看了题解才发现大坑: 输出语句非常耗时,需要将多个输出先拼接,最后一起输出. (小坑: 注意拼接字符串的时候,不能直接用 k +'\\n',字符型和int型会直接相加) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.*;public class Main{ public static void main(String[]args){ int t,n,m;/* FileInputStream fis=null; try { fis=new FileInputStream(&quot;E:\\\\test.txt&quot;); } catch (FileNotFoundException e) { throw new RuntimeException(e); } Scanner sc=new Scanner(fis);*/ Scanner sc=new Scanner(System.in); t=sc.nextInt(); while(t&gt;0){ t--; n=sc.nextInt(); //Queue&lt;Integer&gt;zero=new PriorityQueue(n); Stack&lt;Integer&gt;zero=new Stack&lt;&gt;(); PriorityQueue&lt;Integer&gt;one=new PriorityQueue&lt;&gt;(); String seats=sc.next(); for(int i=n;i&gt;=1;i--){ if(seats.charAt(i-1)=='1'){ one.offer(i); }else if(seats.charAt(i-1)=='0'){ zero.push(i); } } m=sc.nextInt(); String people=sc.next(); StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;m;i++){ if(people.charAt(i)=='M'){ if(one.isEmpty()){ int k=zero.pop(); sb.append(k).append('\\n'); one.offer(k); }else{ sb.append(one.poll()).append('\\n'); } }else{ if(zero.isEmpty()){ int k=one.poll(); sb.append(k).append('\\n'); }else{ int k=zero.pop(); one.offer(k); sb.append(k).append('\\n'); } } } System.out.print(sb); } }}","link":"/2022/06/24/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BE%8E%E5%9B%A2-%E5%85%AC%E5%8F%B8%E9%A3%9F%E5%A0%82/"},{"title":"最优二叉树Ⅱ","text":"这一题我采用记忆化搜索来解决(也有人称之为树形dp,其实就是自下而上的记忆化搜索) 一开始我用的bestTree函数中,第三个参数root根结点下标,我采用的思路是,从[l,r]之间来选, 最后发现只能通过70%; 看了一下题解,他的第三个参数root是[l,r]范围形成的树的共同根结点,最后测试全部通过 我思考了一下,为什么他的更优.我的猜想是: 如果我要计算[0,n-1]范围内的最优二叉树 使用我自己的方法,要先挑选根结点,然后在左右范围内再挑选根结点,然后形成连接.涉及两次挑选,只考虑本层的时间的话,复杂度是$O(N^2)$ 使用题解的思路的话,由于根结点已定,那么只需要挑选一轮根结点即可形成连接,只考虑本层的时间的话,复杂度是$O(N)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.FileInputStream;import java.io.*;import java.util.*;public class Main { int n; int[] nums; int[][][]dp; public static void main(String[] args){ new Main().solve(); } void solve(){ Scanner sc=new Scanner(new BufferedInputStream(System.in)); n = sc.nextInt(); nums = new int[n]; dp=new int[n][n][n+1]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n+1;k++) dp[i][j][k]=-1; for (int i = 0; i &lt; n; i++) nums[i] = sc.nextInt(); System.out.println(bestTree(0,n-1,n)); } final int MAX = 0x3fffffff; int bestTree(int l, int r, int root) { if(l&gt;r) return 0; if(dp[l][r][root]!=-1) return dp[l][r][root]; int rootVal=root!=n?nums[root]:0; if (l == r){ dp[l][r][root]=rootVal*nums[l]; return dp[l][r][root]; } int ans=0x3fffffff; for(int i=l;i&lt;=r;i++){ //选当前的root int left=bestTree(l,i-1,i); int right=bestTree(i+1,r,i); ans=Math.min(ans,left+right+nums[i]*rootVal); } dp[l][r][root]=ans; return ans; }}","link":"/2022/06/25/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BE%8E%E5%9B%A2-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/"},{"title":"二叉树","text":"注意需要用long,因为虽然有mod,但是两个数相乘的时候会超int,结果已经错了,有mod也没用. 思考问题还是要返璞归真,不要想无头苍蝇一样乱想. 首先计算树类的题目,如果利用递归思想的话,就是把整棵树分为根结点,左子树和右子树. 这题显然$f(root)=\\sum(f(left)*f(right))$ 123456789101112131415161718192021import java.util.*;public class Main{ static int mod=(int)1e9+7; public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int m=sc.nextInt(); long[][]dp=new long[n+1][m+1]; Arrays.fill(dp[0],1); //没有节点视为1种 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ for(int k=0;k&lt;=i-1;k++){ //左侧节点数量 dp[i][j]+=(dp[k][j-1]*dp[i-k-1][j-1])%mod; dp[i][j]%=mod; } } System.out.println(dp[n][m]); }}","link":"/2022/06/25/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"第K小子串","text":"牛客-腾讯-第K小子串 我的思路是 双层for循环分割子串 用大根堆来装最多k个串,用set来处理堆中的重复问题(只去重堆内的元素,否则会空间复杂度过高) 我本以为我的方法已经足够巧妙,但是时间还是超了,最后看题解: 一条重要结论: 第k小子串的长度一定是小于等于K的! 借助这个结论可以大大优化双层for循环的时间 1234567891011121314151617181920212223import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); String s=sc.next(); int m=sc.nextInt(); int n=s.length(); PriorityQueue&lt;String&gt;que=new PriorityQueue&lt;&gt;((a,b)-&gt;-a.compareTo(b)); Set&lt;String&gt;set=new HashSet&lt;&gt;(); for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n &amp;&amp; j-i+1&lt;=m;j++){ String t=s.substring(i,j+1); if(!set.contains(t)){ set.add(t); que.offer(t); if(que.size()&gt;m){ set.remove(que.poll()); } } } System.out.println(que.poll()); }}","link":"/2022/06/30/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E8%85%BE%E8%AE%AF-%E7%AC%ACK%E5%B0%8F%E5%AD%90%E4%B8%B2/"},{"title":"合法连续子段","text":"滑动窗口的过程可以理解为 寻找可行解(扩大右边界) 优化可行解(缩小左边界) 这一题我想过滑动窗口,但是为什么没采用主要是 我既没有意识到滑动过程中是l-&gt;xxxAxxxA&lt;-r形式,我当时认为的是l-&gt;AxxxxA&lt;-r形式,前边一种形式中,正好可以缩小左边界. 也没有按照滑动窗口的过程去想问题(先扩大右边界,然后再缩小左边界) 我所采用的办法是大量hash表组成的数组来模拟前缀和,然后固定左边界,右边界进行二分,最后结果是内存超了 数组长度是4e5,如果弄个hash表数组,那么大概需要$4\\times{10^{5}\\times{10^5}}$字节,大概是40个G! 滑动窗口中的一个棘手问题就是开始怎么挪动,r是取0还是-1. 这道题中用-1做的,还可以. 总之,滑动窗口是解决区间问题的大杀器! 牛客-阿里-合法连续子段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int m=sc.nextInt(); int[]nums=new int[n]; for(int i=0;i&lt;n;i++){ nums[i]=sc.nextInt(); } Map&lt;Integer,Integer&gt;mp=new HashMap&lt;&gt;(); int l=0,r=-1; long ans=0; while(r&lt;n){ //寻找可行解 boolean flag=false; while(r&lt;n){ r++; if(r&gt;=n) break; int k=nums[r]; if(mp.containsKey(k)) mp.put(k,mp.get(k)+1); else mp.put(k,1); if(mp.get(k)&gt;=m){ flag=true; break; } } if(!flag) break; while(l&lt;=r &amp;&amp; nums[l]!=nums[r]){ mp.put(nums[l],mp.get(nums[l])-1); ans+=n-r; l++; } if(l&lt;=r){ mp.put(nums[l],mp.get(nums[l])-1); ans+=n-r; l++; } } System.out.println(ans); }}","link":"/2022/06/29/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%90%88%E6%B3%95%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5/"},{"title":"对称飞行器","text":"牛客-阿里-对称飞行器 BFS里,务必务必放入node之前要先修改visit,否则会造成大量冗余!! 这题虽然通过了全部10个用例,但是我认为还是存在问题的,因为同样到达一个位置,后到达的,如果路径更长的话,不一定就不可以 可能我路径比你长,但是我用的飞行器比你少,最后你没有足够飞行器到达不了终点,而我最后能到达! 一开始求对称坐标m写成了n,导致看了半天没看出来问题,写题的时候一定要严谨! x和y,m和n区分清楚.. 给定的矩阵如果没有强调是n阶的心里要默认长和宽不同! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.*;public class Main { int n, m; public static void main(String[] args) { new Main().solve(); } char[][] land; boolean[][] visit; void solve() { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); land = new char[n][m]; visit = new boolean[n][m]; int[] start = new int[2]; int[] end = new int[2]; sc.nextLine(); for (int i = 0; i &lt; n; i++) { String line = sc.nextLine(); for (int j = 0; j &lt; m; j++) { land[i][j] = line.charAt(j); if (land[i][j] == 'S') { start[0] = i; start[1] = j; } else if (land[i][j] == 'E') { end[0] = i; end[1] = j; } } } Queue&lt;Node&gt; que = new LinkedList&lt;&gt;(); que.offer(new Node(start[0], start[1], 0, 5)); visit[start[0]][start[1]]=true; int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; while (!que.isEmpty()) { Node f = que.poll(); if (f.x == end[0] &amp;&amp; f.y == end[1]) { System.out.println(f.len); return; } //用飞行器 x+x'=n-1; int flyX = n - 1 - f.x; int flyY = m - 1 - f.y; if (f.fly &gt; 0 &amp;&amp; check(flyX, flyY) ) { visit[flyX][flyY]=true; que.offer(new Node(flyX, flyY, f.len + 1, f.fly - 1)); } //不用飞行器 for (int i = 0; i &lt; 4; i++) { int nx = f.x + dir[i][0]; int ny = f.y + dir[i][1]; if (check(nx, ny)){ visit[nx][ny]=true; que.offer(new Node(nx, ny, f.len + 1, f.fly)); } } } System.out.println(-1); } boolean check(int x, int y) { return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !visit[x][y] &amp;&amp; land[x][y] != '#'; } private class Node { int x, y; int len; int fly; Node() { } Node(int x, int y, int len, int fly) { this.x = x; this.y = y; this.len = len; this.fly = fly; } }}","link":"/2022/06/28/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%AF%B9%E7%A7%B0%E9%A3%9E%E8%A1%8C%E5%99%A8/"},{"title":"笔试题-阿里-小强爱数学","text":"牛客-阿里-小强爱数学 这题学到了几个东西 dp比记忆化搜索效率更高(没有hash表的存取),以后能dp尽量dp 在取MOD过程中,如果出现a-b的情况(或a+b可能为负数),要先加上mod ,(a-b+mod)%mod这样才合理 long!!! 123456789101112131415161718192021222324252627282930import java.util.*;public class Main{ static final int MOD=(int)(7+1e9); static long a,b; static int n; public static void main(String[]args){ Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t&gt;0){ t--; a=sc.nextLong(); b=sc.nextLong(); n=sc.nextInt(); if(n==1) System.out.println(a); else if(n==2) System.out.println(((a*a)%MOD-(2*b)%MOD+MOD)%MOD); else{ long[]dp=new long[n+1]; dp[1]=a; dp[2]=((a*a)%MOD-(2*b)%MOD+MOD)%MOD; for(int i=3;i&lt;=n;i++){ dp[i]=((dp[i-1]*a)%MOD-(b*dp[i-2])%MOD+MOD)%MOD; } System.out.println(dp[n]); } } }} 这题我感觉题目是有点问题的,测试用例的第二组中x,y其实是无解的. x+y=2; x*y=3; 这个式子x和y是没有实数解的.(不过题目也没有说x和y是实数!)","link":"/2022/06/25/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%B0%8F%E5%BC%BA%E7%88%B1%E6%95%B0%E5%AD%A6/"},{"title":"方案数量","text":"牛客-阿里-方案数量 对那些题意比较模糊的题目,一定要结合用例读题,这一题虽然不难,但是我写了好久,就是因为题意读错了. 此外,思考问题要返璞归真,先采用常规的思路进行思考,再天马行空. 1234567891011121314151617181920212223242526272829303132import java.util.*;public class Main{ static final int mod=(int)1e4; public static void main(String[]args){ Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t&gt;0){ t--; int n=sc.nextInt(); int m=sc.nextInt(); int[][]matrix=new int[n][m]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) matrix[i][j]=sc.nextInt(); int[][]dp=new int[n][m]; dp[0][0]=1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++){ int v=matrix[i][j]; for(int x=0;x&lt;=v;x++){ for(int y=0;y&lt;=v;y++){ if(x==0 &amp;&amp; y==0 || x+y&gt;v || i+x&gt;=n || j+y&gt;=m) continue; dp[i+x][j+y]=(dp[i+x][j+y]+dp[i][j])%mod; } } } System.out.println(dp[n-1][m-1]); } }}","link":"/2022/06/29/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E6%96%B9%E6%A1%88%E6%95%B0%E9%87%8F/"},{"title":"笔试题-阿里-树上最短链","text":"牛客网-阿里-树上最短链 关键的问题是: 题意给的是极小连通子图(生成树) 也就意味着 图中任意两点之间有且只有一条通路 图中没有环(结论一可以推出) 所以这题可以直接用bfs bfs可以求路径长度为1的最短路径问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//极小连通子图=生成树 任意两点之间有且只有一条路径 因为没有环import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[]grade=new int[n+1]; for(int i=0;i&lt;n;i++) grade[i+1]=sc.nextInt(); //链式前向星存储图 空间复杂度是ON int[][]edge=new int[2*n-2][2]; //边表,从0开始 int[]head=new int[n+1]; //指向所连接的第一条边,从1开始 Arrays.fill(head,-1); int cnt=0; //边的数量 for(int i=0;i&lt;n-1;i++){ int a=sc.nextInt(); int b=sc.nextInt(); //添加两条边 edge[cnt][0]=b; edge[cnt][1]=head[a]; head[a]=cnt++; edge[cnt][0]=a; edge[cnt][1]=head[b]; head[b]=cnt++; } int ans=0x3fffffff; for(int i=1;i&lt;=n;i++){ //计算i到其他所有节点的最短距离 boolean[]visit=new boolean[n+1]; Queue&lt;int[]&gt;que=new LinkedList&lt;&gt;(); que.offer(new int[]{i,0}); //能放进去的都是合法的 visit[i]=true; while(!que.isEmpty()){ int[]f=que.poll(); //遍历所有f[0]能到达的节点 int k=f[0]; int h=f[1]; if(k!=i &amp;&amp; grade[k]==grade[i]){ ans=Math.min(ans,h); } int t=head[k]; while(t!=-1){ int e=edge[t][0]; if(!visit[e]){ visit[e]=true; que.offer(new int[]{e,h+1}); } t=edge[t][1]; } } } if(ans!=0x3fffffff) System.out.println(ans); else System.out.println(-1); }}","link":"/2022/06/28/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E6%A0%91%E4%B8%8A%E6%9C%80%E7%9F%AD%E9%93%BE/"},{"title":"牛牛们吃糖果","text":"牛客-阿里-牛牛们吃糖果 经典的01背包问题,唯一的区别在于,有些物品是绑定在一起的,那么就把他们当成一个物品来处理就好啦! 倒序更新dp可以减少一维的空间复杂度. 注意dp[j]=Math.max(dp[j],dp[j-candy[i]]+1);这里要有max!!之前有一次写的时候就忘记了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int m=sc.nextInt(); //糖果数 int[]candy=new int[n+1]; boolean[]visit=new boolean[n+1]; //01背包中是否已经吃过糖果了 for(int i=0;i&lt;n;i++){ candy[i+1]=sc.nextInt(); } Map&lt;Integer,Integer&gt;hash=new HashMap&lt;&gt;(); int k=sc.nextInt(); while(k&gt;0){ k--; int a=sc.nextInt(); int b=sc.nextInt(); hash.put(a,b); hash.put(b,a); } int[]dp=new int[m+1]; //i个糖果最多有dp[i]个小朋友来吃 for(int i=1;i&lt;=n;i++){ if(visit[i]) continue; if(!hash.containsKey(i)){ visit[i]=true; for(int j=m;j&gt;=0;j--){ if(j-candy[i]&gt;=0) dp[j]=Math.max(dp[j],dp[j-candy[i]]+1); } }else{ int friend=hash.get(i); visit[i]=true; visit[friend]=true; int t=candy[i]+candy[friend]; for(int j=m;j&gt;=0;j--){ if(j-t&gt;=0) dp[j]=Math.max(dp[j],dp[j-t]+2); } } } System.out.println(dp[m]); }}","link":"/2022/06/28/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E7%89%9B%E7%89%9B%E4%BB%AC%E5%90%83%E7%B3%96%E6%9E%9C/"},{"title":"算法中常用的数学知识","text":"算数基本定理（唯一分解定理） 对于一个大于1的整数n，n可以分解质因数为： $\\prod_{i=1}^kp_i^{a_i}={p_1^{a_1}}\\cdot{p_2^{a_2}}\\cdots{p_k^{a_k}}$ 其中$p_i$表示n的第i个质因子 例：18 = $2^1$ × $3^2$ 约数定理：一个正整数n的正约数的个数 $d(n)=\\prod_{i=1}^k(a_i+1)=(a_1+1)(a_2+1)\\cdots(a_k+1)$ 这里的$a_i$就是n的各个质因数的幂 曼哈顿距离：$|x_1-x_2|+|y_1-y_2|$ 三角形（或者平行四边形）面积公式，使用向量外积 $S_\\Delta=|\\frac 1 2\\cdot \\vec{a}\\times\\vec{b}|=\\frac 1 2|(x_1\\cdot{y_2}-x_2\\cdot{y_1})|$ 在二维空间中，向量外积的一个几何意义就是：|a×b|在数值上等于由向量a和向量b构成的平行四边形的面积 线性筛-欧拉函数算法，可以快速求1~n范围内与n互质的数的个数12345678910111213141516171819202122232425262728293031323334const ll MAX_N = 1e7 + 5;const ll ANS_MOD = 1e9 + 7;ll phi[MAX_N], cnt_d[MAX_N], cnt, vis[MAX_N], prim[MAX_N];/** * 欧拉线性筛模板 */void init() { phi[1] = 1; // φ(1) = 1 for (int i = 2; i &lt;= MAX_N; i++) { if (!vis[i]) { phi[i] = i - 1; // 如果𝑖是素数，那么𝜑(𝑖)=𝑖−1 prim[++cnt] = i; // 素数表 } // 迭代素数表，更新 i*prim[j] (是合数)的φ值 for (int j = 1; j &lt;= cnt; j++) { int tp = prim[j]; if (i * tp &gt; MAX_N) break; vis[i * tp] = true; if (i % tp == 0) { // 如果𝑖%𝑝𝑟𝑖𝑚[𝑗]==0， phi[i * tp] = phi[i] * tp;// 则𝜑(𝑖∗𝑝𝑟𝑖𝑚[𝑗])=𝜑(𝑖)∗𝑝𝑟𝑖𝑚[𝑗]（ break; } else // 如果𝑖%𝑝𝑟𝑖𝑚[𝑗]!=0 ,那么(𝑖,𝑝𝑟𝑖𝑚[𝑗])==1, 则有 phi[i * tp] = phi[i] * phi[tp]; //𝜑(𝑖∗𝑝𝑟𝑖𝑚[𝑗])=𝜑(𝑖)∗𝜑(𝑝𝑟𝑖𝑚[𝑗]) } } cnt_d[1] = phi[1]; for (int i = 2; i &lt; MAX_N; i++) cnt_d[i] = cnt_d[i - 1] + 2 * phi[i];}","link":"/2021/05/29/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"title":"知识竞赛","text":"牛客-阿里-知识竞赛 按照a-b的绝对值进行排序确实没法想到,但是排序之后的分类讨论和前缀和减少时间复杂度是做题的常用方法! 减少时间复杂度的常用方法 空间换时间 hash 二分(或者每次排除一部分数据) dp(前缀和也属于dp) 123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[][]cap=new int[n][2]; for(int i=0;i&lt;n;i++){ cap[i][0]=sc.nextInt(); cap[i][1]=sc.nextInt(); } Arrays.sort(cap,Comparator.comparingInt(a-&gt;Math.abs(a[0]-a[1]))); int[]maxa=new int[n]; int[]maxb=new int[n]; maxa[n-1]=cap[n-1][0]; maxb[n-1]=cap[n-1][1]; for(int i=n-2;i&gt;=0;i--){ if(cap[i][0]&gt;cap[i+1][0]) maxa[i]=cap[i][0]; else maxa[i]=maxa[i+1]; if(cap[i][1]&gt;cap[i+1][1]) maxb[i]=cap[i][1]; else maxb[i]=maxb[i+1]; } int ans=0; for(int i=1;i&lt;n;i++){ //选第二个数 if(cap[i][0]&gt;cap[i][1]){ //用b ans=Math.max(ans,maxb[i]+cap[i-1][1]); }else ans=Math.max(ans,maxa[i]+cap[i-1][0]); } //除以二 System.out.println(ans/2.0); }}","link":"/2022/06/28/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9B/"},{"title":"蓝桥杯国赛准备","text":"位运算位运算规则 异或可以理解为不进位加法 &gt;&gt;右移运算符 对于无符号数，左边补0 对于有符号数，左边补符号位的数 任何数与00...00异或都等于自身 A^0=A 任何数与111..11异或等同按位取反。 任何数与自身异或都等于0 A^A=0 位运算作用 判断奇偶 x &amp; 1 结果是1则是奇数，为0则是偶数 获取二进制位是1还是0 用对应二进制位1，其余位0的数与之相与，再右移到最低位与1取余即可 交换两个整数变量的值 三次异或 a=a^b;b=a^b;a=a^b; 不用判断语句，求整数的绝对值 负数位运算求绝对值原理： 负数补码转原码：除符号位，各位取反，然后+1 负数原码取绝对值： 符号位取反 因此综合这两步，补码形式的负数要想得到绝对值，即对所有位取反，然后+1即可。 至于正数，由于正数的补码和原码相同，保持不变即是自身的绝对值。 这里举例子： a为正数 如果a=2，那么m=0； 因为任何数与0异或都等于自身，a=a^m，则a不变。 a=a-m继续保持不变。 a为负数 如果a=-2，那么m=111..11（有符号数右移左边补符号位）； 因为任何数和11.11异或等同按位取反，所以a=a^m，即所有位置按位取反 最后一步需要+1，因为m=111..11，是补码形式，值为-1。所以+1即-m;123456int myAbs(int a){ int m=a&gt;&gt;31; a=a^m; a=a-m; return a;} 第一题异或有去重的作用原理：A^A=0; B^0=B解题思路：将序列元素全部异或，然后再和1~1000进行异或，成对的数都变成了0，任何数与0异或又等于自身，所以结果就剩下了重复的数。 12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int main() { int arr[1001]; for (int i = 1; i &lt;= 1000; i++) { arr[i - 1] = i; } arr[1000] = 3; //重复元素是3 int res = 0; //和序列元素全部异或 for (int i = 0; i &lt; 1001; i++) res ^= arr[i]; //与1到1000异或 for (int n = 1; n &lt;= 1000; n++) res ^= n; printf(&quot;%d&quot;, res); return 0;} 注意初始res要设置为0 第二题方法同上，异或去重 第三题题意应该是正整数 方法一每次取最低位，如果是1，count++，然后右移一位 1234567891011121314151617#include &lt;cstdio&gt;using namespace std;int main() { int n; //假设输入的都是正整数 scanf(&quot;%d&quot;,&amp;n); int count=0; while(n){ if(n&amp;1){ count++; } n&gt;&gt;=1; } printf(&quot;Num of binary '1' : %d&quot;,count); return 0;} 方法二 ⭐使用**-1再与自身相与**的方法来消除尾1，计算一共消除多少次尾1即可 1234567891011121314#include &lt;cstdio&gt;using namespace std;int main() { int a; scanf(&quot;%d&quot;,&amp;a); int count=0; while(a){ a&amp;=(a-1); count++; } printf(&quot;%d&quot;,count); return 0;} 第四题同上，判断是否只出现一个1。 1234567891011121314151617#include &lt;cstdio&gt;bool isTwoMultiple(int n) { if (!n) return false; return !(n &amp; (n - 1));}int main() { int N; scanf(&quot;%d&quot;, &amp;N); if (isTwoMultiple(N)) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); return 0;} 第五题题目：将整数的奇偶位互换（题意是第一位和第二位换，第三位和第四位换…）思路：用101010..和010101..把奇数位和偶数位抠出来然后一个左移一位，一个右移一位，然后进行或运算 1234567891011121314151617#include &lt;cstdio&gt;using namespace std;void moveOddAndEven(int &amp;N){ int odd=0xaaaaaaaa;// int odd=0b10101010101010101010101010101010; int even=0x55555555;// int even=0b01010101010101010101010101010101; N=((N&amp;odd)&gt;&gt;1)^((N&amp;even)&lt;&lt;1);}int main() { int N; scanf(&quot;%d&quot;,&amp;N); moveOddAndEven(N); printf(&quot;%d&quot;,N); return 0;} 第六题 12345678910111213141516171819202122232425262728293031323334//// Created by 14259 on 2021/5/2.//#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void printBinaryForm(double N){ string res=&quot;0.&quot;; for(int i=0;i&lt;32;i++){ N*=2; if(N&gt;=1){ N-=1; res+='1'; } else{ res+='0'; } if(N==0){ cout&lt;&lt;res; return; } } printf(&quot;ERROR&quot;);}int main() { double N; scanf(&quot;%lf&quot;,&amp;N); printBinaryForm(N); return 0;} 第七题思路：将所有数转换为k进制，然后做不进位加法（只有二进制的不进位加法才是异或运算），最后结果转换为10进制即可。原理： 2个相同的2进制数做不进位加法（二进制不进位加法即异或），结果为0 10个相同的10进制数做不进位加法，结果为0 k个相同的k进制数做不进位加法，结果为0（因为每个位上k个数相加，一定是k的倍数，若是k进制，则每位一定为0） 注意定义结构体的时候，用字符串数组，或者vector&lt;string&gt;来记录一个数，不要直接用字符串，因为一个位上超过10，会产生歧义。 查找与排序递归我总结的递归三要素： 递归终止条件 如何向递归终止条件演进 搞清楚递归函数的含义（即递归函数做了一件什么事）递归数组求和1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int calSum(int *arr,int left,int right){ if(left==right) return arr[left]; return arr[left]+calSum(arr,left+1,right);}int main() { int arr[]={1,2,3,4,5}; cout&lt;&lt;calSum(arr,0,4); return 0;} 汉诺塔问题此问题的关在在于，搞清楚递归函数的含义12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;//辗转相除法求最大公因数int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);}/** * 递归的含义是：将src上的N个盘子，移动到des上，assist（辅助必须盘子为空）作为辅助 * @param N */void Hanoi(int N,char src,char des,char assist){ //边界条件 if(N==1){ printf(&quot;%c --&gt; %c\\n&quot;,src,des); return; } if(N==2){ printf(&quot;%c --&gt; %c\\n&quot;,src,assist); printf(&quot;%c --&gt; %c\\n&quot;,src,des); printf(&quot;%c --&gt; %c\\n&quot;,assist,des); return; } //递归演进 Hanoi(N-1,src,assist,des); Hanoi(1,src,des,assist); Hanoi(N-1,assist,des,src);}int main() { Hanoi(3,'a','b','c'); return 0;} 排序简单插入排序123456789void insertSort(int *arr,int len){ for(int i=1;i&lt;len;i++){ int j=i; while(j&gt;=1 &amp;&amp; arr[j]&lt;arr[j-1]){ swap(arr[j],arr[j-1]); j--; } }} 时间复杂度：O(N2）进一步优化：每一轮寻找当前元素的最终位置时，可以使用二分查找，时间复杂度降为O(nlogn)希尔排序希尔排序可以理解为分组插入排序，是插入排序的一种改进。因为插入排序要进行大量无效的比较（每一轮要将一个元素往前送，不停地比较），而希尔排序能够以较大的步伐将小元素往前送，大元素往后摆，这样大大减少了原来插入排序所需要比较的次数，从而提高了速度。（希尔排序的时间复杂度涉及到数学上尚未解决的难题）12345678910111213141516void shellSort(int *arr,int len){ for(int interval=len/2;interval&gt;=1;interval/=2){ //对每个分组进行插入排序 //i是每组的开头元素位置 for(int begin=0;begin&lt;interval;begin++){ //以interval作为间隔的一组数，进行插入排序 for(int i=begin+interval;i&lt;len;i+=interval){ int j=i; while(j-interval&gt;=0 &amp;&amp; arr[j]&lt;arr[j-interval]){ swap(arr[j],arr[j-interval]); j-=interval; } } } }} 评估算法性能 评估算法性能，主要评估问题的输入规模n与元素的访问次数f(n)之间的关系 大O符号，忽略非主体部分，如常数项、低阶项1s不同复杂度能处理的规模 n : 108 n2 : 104 n3 : 500以下 2n : 27以下 logn : 2^(108) ⭐各种复杂度的常见算法 O(n2) :冒泡排序，直接插入排序，选择排序 O(nlogn) ：归并排序，快速排序三种典型递归算法的性能分析 数组求和：递归解法 复杂度是O(n)，即O(1)*n，子问题规模下降层数为n，每个子问题的答案消耗的时间为O(1)。 斐波那契数列： f(n)=f(n-1)+f(n-2)，复杂度是O（2n） 因为递归形式是个二叉树(高度约为n，节点个数为2n左右），子问题答案求解消耗的时间O(1) 汉诺塔问题 和斐波那契数列类似，O(2n) 最大公约数时间复杂度O（logn） 排序算法稳定性稳定：两个相同的数，经过排序，前后相对位置（谁在前，谁在后）不会发生变化 几种不稳定的排序算法 希尔排序：不稳定 因为相同元素可能分到不同组中，不同组内调换顺序，可能导致不稳定 选择排序：不稳定 因为涉及到交换，会把当前数字换到后边 例如：3,3,1，此时最小元素是1，会将1与第一个3交换，导致不稳定 堆排序：不稳定 快速排序：不稳定 剩下的算法都稳定：插入排序、冒泡排序、归并排序、基数排序、计数排序、桶排序。 算法稳定的好处12345678比如这么一个场景：有一批订单，按日期降序排列，如果日期一样的，按订单金额降序。这个需要很好理解，实现起来，可能就没那么容易，按日期排好了，再把日期一样的按订单金额排一次。这个就不好实现，先把日期一样的分别取出来排下，再对应放回去，很麻烦。有了稳定性排序算法，就很容易实现。第一步，先按订单金额降序排列，第二步，再把第一步得到的结果，按日期降序重新排列一次，就可以实现需求了。————————————————此案例转载自CSDN博主「北枫凉」的一篇文章原文链接：https://blog.csdn.net/qq_34686440/article/details/105112263 例题1123456789101112131415/** * 递归函数含义：上n阶台阶有多少种走法 * @param n * @return */int upstairs(int n){ //边界条件 if(n&lt;0) return 0; if(n==0) return 1; //递归演进 return upstairs(n-1)+upstairs(n-2)+upstairs(n-3); //类似背包问题，假设已经装了部分，对剩下部分的处理，用递归来解决} 例题2注意体会high = pivot和low = pivot + 1还有high -= 1最终目的是使left==right的时候，刚好是最终答案。 1234567891011121314151617int minArray(vector&lt;int&gt;&amp; numbers) { int low = 0; int high = numbers.size() - 1; while (low &lt; high) { int pivot = low + (high - low) / 2; if (numbers[pivot] &lt; numbers[high]) { high = pivot; //nums[pivot]可能是答案 } else if (numbers[pivot] &gt; numbers[high]) { low = pivot + 1; //nums[pivot]不可能是答案 } else { high -= 1; } } return numbers[low];} 例题3写这一题的体会在于：处理特殊情况时，如果情况复杂，采用分类讨论。如果有类似两端都有情况时，选取一端作为分类的标准比较明智（多次遇到这种情况了） 12345678910111213141516171819202122232425262728293031323334353637383940//// Created by 14259 on 2021/5/4.//#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int findPos(string arr[], int len,string target) { int l = 0, r = len - 1; while (l &lt;= r) { int mid = l + (r - l) / 2; int t=mid; while (t &lt;= r &amp;&amp; arr[t]==&quot;&quot;){ t++; } if(t&gt;r){ r=mid-1; continue; } if(arr[t]==target){ return t; } if(target&lt;arr[t]){ r=mid-1; } else l=t+1; } return -1;}int main() { string arr[] = {&quot;a&quot;, &quot;&quot;, &quot;ac&quot;, &quot;ad&quot;, &quot;b&quot;, &quot;&quot;, &quot;ba&quot;}; int len = sizeof(arr) / sizeof(*arr); cout&lt;&lt;findPos(arr,len,&quot;abc&quot;); return 0;} 例题4写一个递归形式的直接插入排序 12345678910111213141516171819202122232425262728293031323334353637//// Created by 14259 on 2021/5/4.//#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;//首先要知道：插入排序的思想是将序列分为已经排序和未排序的部分/** * left及其左侧是已经排序好了的 * @param arr * @param left * @param right */void insertSort(int arr[],int left,int right){ //递归终止条件 if(left==right) return; //处理当前问题 int t=left+1; while(t&gt;0 &amp;&amp; arr[t]&lt;arr[t-1]){ swap(arr[t],arr[t-1]); t--; } //处理子问题 insertSort(arr,left+1,right);}int main(){ int arr[]={0,0,-1,-2,3,3,-1,4,55,9,0}; int len=sizeof(arr)/sizeof(*arr); insertSort(arr,0,len-1); for(int i=0;i&lt;len;i++){ printf(&quot;%d &quot;,arr[i]); } return 0;} 递归的关键在于：当前问题可以拆解为更小的类似的问题。 例题5快速幂 多维数组与矩阵字符串数学问题递归、DFS、剪枝、回溯贪心与动态规划","link":"/2021/05/01/%E7%AE%97%E6%B3%95-%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9B%E5%87%86%E5%A4%87/"},{"title":"背包问题研究","text":"背包问题分类图片来自leetcode用户代码随想录的题解中： 0-1背包问题 问题描述：有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每件物品都只有1件。 12345样例：5 8 // n==5, V==83 5 1 2 2 // w[i]4 5 2 1 3 // c[i]答案：10 使用暴力法时间复杂度为O(2n），可以使用二维DP解决该问题，时间复杂度为O(nV)。其中dp[i][j]表示：在前i个物品中挑选若干，使容量为j的背包，能装下的最大价值。 那么状态转移方程即为dp[i][j]=max(dp[i-1][j],value[i]+dp[i-1][j-weight[i]]); 其含义是：在背包容量为j的情况下，装第i个物品，和不装第i个物品，选择使背包中物品价值更大的方案。其中，dp[i-1][j]表示在前i-1个物品中挑选，使得容量为j的背包能够达到的最大价值。对于value[i]+dp[i-1][j-weight[i]]，value[i]表示选中了第i个物品；dp[i-1][j-weight[i]]表示去掉选中的第i个物品占有的重量，剩下的背包部分能装下的最大价值。 以下是上述样例的二维dp数组，注意dp[i][j]表示的是什么。动态规划的思路是：物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：选与不选C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int findLargestValue(vector&lt;int&gt; weight, vector&lt;int&gt; value, int N, int V) { vector&lt;vector&lt;int&gt; &gt; dp(N, vector&lt;int&gt;(V + 1, 0)); //初始化第一行 for (int weighti = 1; weighti &lt;= V; weighti++) { //这里的i是背包容量 if (weighti &gt;= weight[0]) { dp[0][weighti] = value[0]; } } //状态转移方程：dp[i][j]=max(dp[i-1][j],value[i]+dp[i-1][j-weight[i]]); 即选中和不选中两种方法 for (int i = 1; i &lt; N; i++) for (int j = 1; j &lt;= V; j++) { if (j - weight[i] &lt; 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], value[i] + dp[i - 1][j - weight[i]]); } return dp[N - 1][V];}int main() { int arr1[] = {3, 5, 1, 2, 2}; int arr2[] = {4, 5, 2, 1, 3}; vector&lt;int&gt; weight; for (int i = 0; i &lt; 5; i++) weight.push_back(arr1[i]); vector&lt;int&gt; value; for (int i = 0; i &lt; 5; i++) value.push_back(arr2[i]); cout &lt;&lt; findLargestValue(weight, value, 5, 8); return 0;} 很多类似问题可以转化为0-1背包问题，如leetcode416题 将分割为两个和相等子集的问题，转换为数字中挑数以组成固定和的问题，即01背包问题。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;class Solution {public: bool canPartition(vector&lt;int&gt; &amp;nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; int target = sum / 2; //dp[i][j]表示，在nums，0~i中挑选数字，能否组合成j vector&lt;vector&lt;bool&gt; &gt; dp(nums.size(), vector&lt;bool&gt;(target + 1, false)); //对第一行进行初始化 for (int i = 1; i &lt;= target; i++) { if (i == nums[0]) dp[0][i] = true; else dp[0][i] = false; } //对第一列进行初始化 for (int i = 0; i &lt; nums.size(); i++) { dp[i][0] = true; } //开始进行动态规划 for (int i = 1; i &lt; nums.size(); i++) for (int j = 1; j &lt;= target; j++) { if (dp[i - 1][j]) dp[i][j] = true; else { if (j - nums[i] &gt;= 0 &amp;&amp; dp[i - 1][j - nums[i]]) dp[i][j] = true; } } return dp[nums.size()-1][target]; }}; 进一步对空间进行压缩 123456789101112131415161718192021222324252627//多维费用问题class Solution {public: pair&lt;int,int&gt; count(const string&amp;s){ int count0=s.length(),count1=0; for(const char&amp;c:s){ if(c=='1'){ count1++; count0--; } } return make_pair(count0,count1); } int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { //dp[i][j]表示0有i个，1有j个地情况下，最多能容纳几个字符串 vector&lt;vector&lt;int&gt; &gt;dp(m+1,vector&lt;int&gt;(n+1,0)); for(const string&amp;str:strs){ auto [count0,count1]=count(str); //倒序 for(int i=m;i&gt;=count0;--i) for(int j=n;j&gt;=count1;--j){ dp[i][j]=max(dp[i][j],1+dp[i-count0][j-count1]); } } return dp[m][n]; }}; 如果想使用压缩dp数组来节省空间，那么原本的二维dp只需要一维，原本的三维dp只需要二维，但是注意，在下一轮利用上一轮的dp数据时，因为是原地修改，需要倒序遍历修改，否则会造成上一轮的临时数据被修改（顺序遍历会导致多次取用本轮的同一个物品，不符合01背包题意） 普通01背包和多维费用01背包问题，在进行动态规划时，解题形式相似，如下 普通01背包 普通01背包压缩空间 多维费用01背包 多维费用01背包压缩空间后","link":"/2021/04/10/%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6/"},{"title":"质因数分解及其幂次求解","text":"涉及到算术基本定理和约数定理的题目经常需要求质因数及其幂次，下面是一种高效的求法，和一种复杂度稍高但是简单实用的方法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int primePower[101];const int N = 100; int power[N + 1]; //power[i]是质因子i的幂次void findPrimeFactorPower() { int x = N; //x不断缩小，直至不再能分解 for (int j = 2; j * j &lt;= x; j++) { //若x&lt;j*j,说明连j^2都分解不出来了，更别谈j^3,(j+1)^2,(j+1)^3...所以此时退出循环，最多剩下一个质数（j或j+1或j+2..或j*j-1) while (x % j == 0) { x /= j; power[j]++; } } if (x &gt; 1) //此时如果仍然大于1，则剩下一个质因子 power[x]++;}void show(){ //展示所有质因数的幂次 cout &lt;&lt; N &lt;&lt; &quot;=&quot;; bool isFirst = true; for (int i = 1; i &lt;= N; i++) { if (power[i]) { if (isFirst) { isFirst = false; } else { cout &lt;&lt; &quot;+&quot;; } cout &lt;&lt; i &lt;&lt; &quot;^&quot; &lt;&lt; power[i]; } }} 问题：求一个正整数的约数个数(根据约数基本定理，等于各个质因数幂次+1的乘积）这里发现，并不需要判断质数，大大降低了复杂度，核心原因是合数可以分解为质数乘积，所以从i=2开始，每次对n把i除尽，也就意味着n后续不可能是2（或者别的质数）的倍数了，所以循环种所有i为合数的情况都被直接跳过了。例如$\\frac{12}{2^2}=3$，后续3不可能再是4的倍数了。 12345678910111213141516//计算一个数各个质因数幂+1的乘积int func(long long n){ int res=1; int i=2; while(n&gt;1){ int count=0; while(n%i==0){ n/=i; count++; } res*=(count+1); i++; } return res;}","link":"/2021/05/29/%E7%AE%97%E6%B3%95-%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%B9%82%E6%AC%A1%E6%B1%82%E8%A7%A3/"},{"title":"贪心算法","text":"求最值、求最优解的题目，一般可以用动态规划、贪心、二分来解决。贪心中常常先进行排序。 贪心的一大特点就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。 例题1452用最少数量的箭引爆气球考虑到每个气球都要被射中，所以射每个气球的时候，我们希望有尽量多的别的气球也被射到。迭代时，已经被射中的气球就跳过。 本题以左边界为标准进行排序，会导致如下的情况，射当前气球无法保证射爆所有与其有重叠的气球：但是以右边界为标准进行排序，只要我在当前气球的右边界射一箭，那么就能射爆所有和其有重叠的： 12345678910111213141516171819202122class Solution {public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if(points.size()==0) return 0; sort(points.begin(),points.end(),[](vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){return A[1]&lt;B[1];}); int count=0; int i=0; while(i&lt;points.size()){ //看后边有多少个和自己有重叠 int j=i+1; int t=0; while(j&lt;points.size() &amp;&amp; points[j][0]&lt;=points[i][1]){ t++; j++; } count++; i+=1+t; } return count; }}; 例题2435无重叠区间先以右边界进行排序（给剩下的区间留下最大的空间，以使得要删除的区间最少），删除所有与当前区间重叠的区间，留下当前区间（理由：因为当前区间的右边界最靠左，最能够给剩下区间留下最大空间） 123456789101112131415161718192021222324class Solution {public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { int len=intervals.size(); if(len&lt;=1) return 0; //对区间们进行从小到大排序，使用lambda表达式 sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt;a,vector&lt;int&gt;b){ return a[1]&lt;b[1]; }); int prev=intervals[0][1]; int chosen=1; for(int i=1;i&lt;len;i++){ //说明重叠了，抛弃 if(intervals[i][0]&lt;prev){ continue; }else{ chosen++; prev=intervals[i][1]; } } return len-chosen; }}; 例题31024视频拼接这一题的贪心策略应该是：先将所有区间按照左侧从小到大排序，左侧相同的，从大到小排序。初始覆盖范围是[0,r]，从左到右遍历区间，每次用所有left&lt;=r中right最大的区间来更新r（保证了每次挑出最有用的区间来更新r）。 注意：这一题中有很多细节（坑），比如新的一轮开始时，如果left&gt;r，则直接返回-1。此外，类似这种中间含有多个小周期的，用while更合适一些。 1234567891011121314151617181920212223242526272829303132class Solution {public: int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int time) { int len=clips.size(); if(len==0) return 0; sort(clips.begin(),clips.end(),[](vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){ return A[0]&lt;B[0] || A[0]==B[0] &amp;&amp; A[1]&gt;B[1]; //只写小于的条件，等于和大于都是false }); int r=0; int ans=0; int i=0; while(i&lt;len){ if(r&gt;=time) return ans; if(clips[i][0]&gt;r) return -1; int t=clips[i][1]; int j=i; for(;j&lt;len &amp;&amp; clips[j][0]&lt;=r;j++){ t=max(t,clips[j][1]); } //能够更新r范围的情况下，加入结果集 if(t&gt;r){ ans++; r=t; } i=j; } return r&gt;=time?ans:-1; }}; 例题455跳跃游戏贪心在这一题的体现：每一步都拓展当前能够到达的最远距离。 12345678910111213class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { //不断计算能到达的最远距离 int farthest=0; for(int i=0;i&lt;nums.size()-1;i++){ farthest=max(farthest,i+nums[i]); if(farthest&lt;=i) return false; } return true; }};","link":"/2021/08/09/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"递归删除不带头节点的链表中所有值为x的节点","text":"题目如标题所示，这一题有个很关键的问题，在于传参引用，然后修改传入指针的指向，只有这样才能完成递归操作。 值得一提的是，按我目前的java知识水平来理解，Java似乎无法完成这个算法，因为java只有值传递，因此无法完成这个算法。 12345678910111213//递归删除没有头节点的链表中所有值为x的节点void deleteX(Node *p, int x) { if (!p) return; if (p-&gt;val == x) { //Node*tmp=p; //释放节点 p = p-&gt;next; //修改传入指针的指向 //free(tmp); deleteX(p, x); /*注意这里传入的参数是p，不是p-&gt;next，否则会造成漏处理一个节点*/ } else { deleteX(p-&gt;next, x); }}","link":"/2021/08/02/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E6%97%A0%E5%A4%B4%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E4%B8%BAx%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"递归解压密码串","text":"遇到过好几次类似的解压字符串的题目，每次写起来都比较困难，今天看到一种不错的思路，加以记录。 外星密码 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;string decode() { int k; char ch; string s = &quot;&quot;, str = &quot;&quot;; //s是最终答案,str是被压缩的数字 while (cin &gt;&gt; ch) { if (ch == '[') { //找到了被压缩的字符串 cin &gt;&gt; k; str = decode(); //递归 while (k--) s += str; } else if (ch == ']') //如果找到了待压缩字符串的末尾 return s; else //如果没有被压缩 s += ch; //直接添上这个字符 }}int main() { cout &lt;&lt; decode(); return 0;} 知识点：虽然数字和英文字母连在一起，但是cin还是能够把它抠出来（scanf也能做到），惊，我以前竟然都不知道。","link":"/2022/02/19/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E8%A7%A3%E5%8E%8B%E5%AF%86%E7%A0%81/"},{"title":"高精度加法和乘法","text":"高精度的思想就在于用一个一个int型数组来逆序存储一个数字（数组低位存储数字低位） 高精度加法高精度加法有两种方式，一种是先边加边进位，一种是先加再进位（推荐使用这种，逻辑比较清晰） 蜜蜂路线 其中最重要的一步就是在for循环中不断检测dp[k][len]来判断是否增加len 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int dp[1000][1000]; //第二维低位存储数字低位int len = 1; //第一个dp必为1，因此长度是1void cal(int k) { //计算dp[k] /*先加再进位*/ for (int i = 0; i &lt; len; i++) dp[k][i] = dp[k - 1][i] + dp[k - 2][i]; for (int i = 0; i &lt; len; i++) { dp[k][i + 1] += dp[k][i] / 10; dp[k][i] %= 10; if (dp[k][len] != 0) /*为什么要写在for里边，因为len记得是之前数字的最长位数，后边有可能突然遇到一个特别长的，写在for里边可以边加边检测长度*/ len++; }}int main() { fill(*dp, *dp + 1000 * 1000, 0); dp[0][0] = dp[1][0] = 1; int m, n; cin &gt;&gt; m &gt;&gt; n; for (int i = 2; i &lt; n - m + 1; i++) { cal(i); } for (int i = len - 1; i &gt;= 0; i--) cout &lt;&lt; dp[n - m][i]; return 0;} 问题：为什么这题需要使用高精度加法？ 因为dp[i]=dp[i-1]+dp[i-2]最后结果大约是21000约等于10300左右，而long long最大值约为9*1018。 高精度乘法p1303 A*B problem 几个要点： len&lt;=(len1+len2) 因为两数相乘长度最长就是len1+len2，但是有可能一个乘数为0，因此需要去除前导0 采用先计算再进位/取余，其中计算的双层for循环中用的是+=而不是=`，这一点和高精度加法有所不同，因为其是模拟竖式乘法，n3[i]多层相加的结果的和组成 输入字符串存储到int数组中，注意需要倒序 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int n1[2000];int n2[2000];int n3[4000];int main() { string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; for(int i=0;i&lt;s1.size();i++) n1[s1.size()-1-i]=s1[i]-'0'; for(int i=0;i&lt;s2.size();i++) n2[s2.size()-1-i]=s2[i]-'0'; int len1=s1.size(),len2=s2.size(); int len=len1+len2; for(int i=0;i&lt;len1;i++) for(int j=0;j&lt;len2;j++){ n3[i+j]+=n1[i]*n2[j]; } for(int i=0;i&lt;len;i++){ n3[i+1]+=n3[i]/10; n3[i]%=10; } while(n3[len-1]==0 &amp;&amp; len&gt;1) len--; for(int i=len-1;i&gt;=0;i--) cout&lt;&lt;n3[i]; return 0;}","link":"/2022/02/19/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"title":"事务的隔离级别","text":"幻读 不可重复读 脏读 串行化 可重复读 √ 读已提交 √ √ 读未提交 √ √ √ 四种隔离级别 串行化：事务之间串行执行，不存在任何并发产生的问题 可重复读：同一个事务内，多次相同查询的结果相同（即使中途别人修改了数据库中实际的数据） 其实就是事物内部看不见别人（感知不到）别的事务的操作（不管别人提没提交） 因此别人对数据库进行了实际的操作（增删改），而我却不知道，于是在我增删改查的时候就会出现幻觉，例如 User表中用户名是唯一索引，事务A查询User老王，结果为空；然后B插入了User老王；接着A插入User老王，结果报错（事务A很懵，觉得自己发生了幻觉，明明我查询结果没有老王，为什么插入的时候会报错，产生唯一索引的冲突） 我的理解，在可重复读隔离级别的事务内部，只要进行了查询，那么则会保存一份这个查询的副本在本地，下次进行相同查询的时候，不去看数据库，而是看本地我存的副本。 Mysql默认的隔离级别 读已提交： 其实就是事务内部看不见别人还没有提交的操作 会产生不可重复读的问题，很好理解，在事务A的过程中，在两次查询同一数据的过程中，B修改了它，则会产生不可重复读的问题。 读未提交 其实就是事务内部可以看见别人没有提交的操作 产生脏读的原因很简单，我读了某一数据，别人又回滚了，那么我就读到了脏数据 12345678910/*** 1. 读未提交 存在 脏读,不可重复读,幻读的问题* 2. 读已提交 存在 不可重复读,幻读的问题* 3. 可重复读 存在 幻读* 4. 串行化** 脏读: 读了别人回滚的数据* 不可重复读: 两次读数据的中途,有人修改了数据(增删改)* 幻读: 为了保证可重复读,实际上看到的是隔离了数据库真实数据的视图,故读到的情况和数据库真实情况有出入,导致幻读* /","link":"/2022/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"title":"队列模拟栈","text":"栈模拟队列需要两个，而队列模拟栈最少只需要一个。即每次需要出栈时，把队尾元素返回即可（其他元素出队再入队）。 下面给出用双队列模拟栈的代码，其中now标记的使用，比较巧妙 12345678910111213141516171819202122232425262728293031323334353637class MyStack {private: queue&lt;int&gt; qArr[2]; int now=0;public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { qArr[1-now].push(x); while(!qArr[now].empty()){ qArr[1-now].push(qArr[now].front()); qArr[now].pop(); } now=1-now; } /** Removes the element on top of the stack and returns that element. */ int pop() { int ans=qArr[now].front(); qArr[now].pop(); return ans; } /** Get the top element. */ int top() { return qArr[now].front(); } /** Returns whether the stack is empty. */ bool empty() { return qArr[now].empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E6%A0%88/"},{"title":"非递归实现树的三种遍历","text":"三种非递归遍历都使用一种框架,代码如下 123456789101112131415void traversal(TreeNode* root) { TreeNode*p=root; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜入栈 while(p!=NULL){ st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } } 中序遍历其核心思想在于：每次把一棵树的根节点、根节点的左孩子、左孩子的左孩子…一直到最左下角，这一条斜线上的所有节点入栈。每次取出并打印栈顶节点的值，然后对其右子树进行上述入栈操作。 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt;st; while(root){ st.push(root); root=root-&gt;left; } vector&lt;int&gt;ans; while(!st.empty()){ //取出栈顶元素 TreeNode*t=st.top(); st.pop(); ans.emplace_back(t-&gt;val); //将栈顶元素右孩子一直到其最下角的左孩子全部入栈 TreeNode*p=t-&gt;right; while(p){ st.push(p); p=p-&gt;left; } } return ans; }}; 前序遍历1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { TreeNode*p=root; vector&lt;int&gt;ans; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜先打印，再入栈 while(p!=NULL){ //打印 ans.push_back(p-&gt;val); //cout&lt;&lt;st.top()-&gt;val //入栈 st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使它为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } return ans; }}; 后序遍历后序遍历非递归的关键在于，栈顶元素何时打印，何时不打印。 当栈顶元素右子树全部访问完了（pre==top()-&gt;right)或为空时，根据后序遍历的定义，此时可以打印栈顶元素；这里的pre指向上次打印的节点，由于后序遍历根最后打印，所以当pre==top()-&gt;right时，能够判断出栈顶元素的右子树所有节点已经访问完毕。 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt;st; TreeNode*pre=NULL; vector&lt;int&gt;ans; TreeNode*p=root; while(p || !st.empty()){ while(p){ st.push(p); p=p-&gt;left; } //如果栈顶元素的右子树为空 或者 右子树存在且已经全部访问过了，则直接打印 if(st.top()-&gt;right==NULL || st.top()-&gt;right==pre){ ans.push_back(st.top()-&gt;val); pre=st.top(); st.pop(); p=NULL; //让下一轮直接访问栈顶元素 }else p=st.top()-&gt;right; } return ans; }};","link":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"},{"title":"github使用指南","text":"常见前后缀 找某项技术的百科大全：awesome xxx 如 awesome vue，点击第一个官方出品的，会展示vue相关的各种资源，包括教程，项目，相关等等。 总之，找某项知名技术，先搜awesome就对了 找例子：xxx sample 找空项目架子 xx starter 或者 xxx boilerplate 已经配置好的项目 找教程 xxx tutorial https://github.com/trending 根据热度查看项目","link":"/2020/01/10/%E9%9A%8F%E7%AC%94-github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"MySQL","text":"对数据库基本原理和sql相关内容进行复习总结。 mysql登录方法： windows cmd打开 mysql -u root -p 输入密码123456 概述将MySQL的学习分为三个部分： 基础 SQL 函数 约束 多表查询 事务 进阶 存储引擎 索引 SQL优化 视图/存储过程/触发器 锁 InnoDB核心 MySQL管理 运维 日志 主从复制 分库分表 读写分离 SQL语法 分类 全程 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象（数据库，表，字段） DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 DDL数据库操作 查询 查询所有数据库 SHOW DATABASES; 查询当前数据库SELECT DATABASE(); 创建 CREATE DATABASE [IF NOT EXISTS] 数据库名 [default charset 字符集] [collate 排序规则] 删除 DROP DATABASE [IF EXISTS] 数据库名； 使用 USE 数据库名; 表操作 查询 查询当前数据库所有表 SHOW TABLES; 查询表结构 DESC 表名; 查询指定表的建表语句 SHOW CREATE TABLE 表名; 创建 MySQL数据类型 数值类型 描述只有一位小数的考试分数score double(4,1) 表示这个数字一共4位，其中小数占1位，整数3位。 字符串类型 日期时间类型 修改表 添加字段 alter table 表名 add 字段名 类型(长度) [COMMENT] [约束]; 修改数据类型 alter table 表名 modify 字段名 新数据类型(长度); 修改字段名和字段类型 alter table 表名 change 旧字段名 新字段名 类型(长度) [comment][约束]; 删除字段 alter table 表名 drop 字段名; 修改表名 alter table 表名 rename to 新表名; 删除表 drop table [if exists] 表名 删除指定表，并重新创建该表 truncate table 表名; DML添加数据 给指定字段添加数据 insert into 表名(字段名1，字段名2,...) values(值1,值2,值3...); 给全部字段添加数据 insert into 表名 values(值1，值2，...); 批量添加数据 insert into 表名(字段名1，字段名2,...) values(值1,值2,值3...),(值1，值2..),(值1，值2..); insert into 表名 values(值1，值2,...),(值1，值2,...),(值1，值2,...); 注：字符串和日期类型数据需要包含在引号中；插入的数据大小应该在字段的规定范围内。 修改数据update 表名 set 字段名1=值1, 字段名2=值2,...[where 条件]; 删除数据delete from 表名 [where 条件]; DQL正常业务系统中，查询的频率远高于增删改。 DQL语法： 1234567select 字段列表from 表名列表where 条件列表group by 分组字段列表having 分组后条件列表order by 排序字段列表limit 分页参数 基本查询 查询多个字段 select 字段1，字段2... from 表名; select*from 表名; 设置别名 select 字段1[as 别名1], 字段2[as 别名2]... from 表名; # as可以省略 去除重复记录 select distinct 字段列表 from 表名; 条件查询语法：select 字段列表 from 表名 where 条件列表; 条件： 聚合函数聚合函数：将一列数据作为整体进行纵向计算 注意：所有NULL值不参与聚合运算，比如不算在count内 count、max、min、avg、sum 分组查询 group bywhere和having区别 执行时机不同：where是分组前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤 判断条件不同：where不能对聚合函数进行判断，而having可以 注意： 执行顺序：where&gt;聚合函数&gt;having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询 order by语法：select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2……; (如果是多个字段排序，当第一个字段值相同时，才会根据第二个字段进行排序) 分页查询 limitselect 字段列表 from 表名 limit 起始索引,查询记录数； 注意： 起始索引从0开始，起始索引=(查询页码-1)*每页的记录数。 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是limit 如果查询的是第一页数据，起始索引可以省略，直接简写成limit 10； DQL语句执行顺序执行顺序非编写顺序！ DCLDCL英文全称Data Control Language 数据控制语言，用来管理数据库用户、控制数据库的访问权限。 用户管理 查询用户 use mysql; select*from user; 创建用户 create user ‘用户名‘@’主机名’ identified by ‘密码’; 修改用户密码 alter user ‘用户名‘@’主机名’ identified with mysql_native_password by ‘新密码’; 删除用户 drop user ‘用户名‘@主机名; 主机地址+用户名，才能唯一定位一个mysql用户，对应用户名只能在特定主机地址上访问mysql 权限控制常用权限如下 查询权限 show grants for ‘用户名‘@’主机名’; 授予权限 grant 权限列表 on 数据库名.表名 to ‘用户名‘@’主机名’; 撤销权限 revoke 权限列表 on 数据库名.表名 from ‘用户名‘@’主机名’; 函数约束概述 概念 约束是作用于表中字段上的规则，用于限制存储在表中的数据。 目的 保证表中数据的正确性、完整性、一致性 分类 约束 描述 关键字 非空约束 限制该字段数据不能为null NOT NULL 唯一约束 保证该字段所有数据唯一、不重复 UNIQUE 主键约束 主键是一行数据的唯一标识，非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的数据，则采用默认值 DEFAULT‘ 外键约束 用来在两张表的数据之间建立联系，保证数据的一致性和完整性 FOREIGN KEY 检查约束(8.0.16版本之后) 保证字段值满足某些条件 CHECK 完整性的定义：它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。 一致性：我的理解:如果a表的外键关联着b表，那么b表中的数据不能随意删除，否则会导致a表的外键引用出错 自动增长关键字：AUTO_INCREMENT 案例 外键约束概念：对两张表的数据进行联系，以保证数据的完整性、一致性。 增加外键的两种方式 1.创建表时添加 2.修改表 删除外键 alter table drop foreign key 外键名称; 外键约束中的行为删除/更新行为 行为 说明 not action 当在父表中更新/删除对应记录时，首先检查该记录是否有对应的外键，如果有则不允许删除/更新（与restrict一致） restrict 当在父表中更新/删除对应记录时，首先检查该记录是否有对应的外键，如果有则不允许删除/更新（与not actiont一致） cascade 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 set null 当在父表中删除对应记录时，首先应检查是否有对应外键，若有，则设置子表中该外键的值为null（这里要求该外键允许取null） set default 父表有变更时，子表将外键列设置为默认值（innodb不支持） alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名) on upadate cascade on delete cascade; 多表查询多表关系1.一对多关系 案例：部门与员工的关系 关系：一个部门对应多个员工，一个员工对应一个各部门 实现：在多的一方建立外键，指向一的一方的主键 多表查询概述直接查询两张表的数据，出来的是笛卡尔积 例如：select*from emp,dept; 笛卡尔积：笛卡尔乘积在数学中，两个集合A集合和B集合的所有组合情况。（在多表查询时，需要消除无用的笛卡尔积） 内连接内连接：相当于查询A、B交集的部分 隐式内连接 select 字段列表 表1，表2 where 条件 显式内连接 select 字段列表 from 表1 [inner] jion 表2 on连接接条件…; 外连接左外连接：查询左表所有数据，以及两张表交集部分的数据 右外连接：查询右表所有数据，以及两张表交集部分的数据 左外连接 select 字段列表 from 表1 left [outer] join 表2 on 条件…; 右外连接 select 字段列表 from 表1 right [outer] jion 表2 on 条件…； 可以通过左外连接写出右外连接的效果（交换两个表的位置即可） 自连接自连接：当前表与自身的连接查询，自连接必须使用表别名 语法“ select 字段列表 from 表a 别名a join 表a 别名b on 条件….; 自然连接查询，可以是内连接查询，也可以是外连接查询。 案例一： 查询员工及其所属领导的名字 select a.name ,b.name from emp a,emp b where a.manager =b.id; 案例二： 查询所有员工emp及其领导的名字，如果员工没有领导，也需要查询出来 select a.name, b.name from emp a left outer join emp b on a.managerid=b.id; 自然连接12select * from dept natural join emp;select * from dept natural left join emp; 联合查询对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。 123select 字段列表 from 表a ...uion [all]select 字段列表 from 表b.... 注意： 1.uoin all会将全部的数据直接合并在一起，union则会对合并后的数据去重 2.使用联合查询的条件：对于联合查询的多张表列数必须保持一致，字段的类型也需要保持一致 子查询概念：sql语句中嵌套select语句，称为嵌套查询，又称为子查询、 select * from t1 where col1=(select col1 from t2); 子查询的外部语句可以是insert/update/delete/select的任何一个 根据子查询的结果不同，分为： 标量子查询（子查询的结果为一个） 列子查询（子查询的结果为一列） 行子查询（子查询的结果为一行） 表子查询（子查询的结果为多行多列） 根据子查询的位置，分为where之后，from之后，select之后 标量子查询查询在“方东白”入职之后的员工信息 select * from emp where entrydate &gt; (select entrydate from emp where name = '方东白'); 列子查询子查询的结果为一列(可以是多行) 常用的操作符有：IN, NOT IN, ANY, SOME, ALL 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 行子查询行子查询返回的结果是一行（可以是多列），这种子查询称为行子查询 常用的操作符：=、&lt;&gt;、IN、NOT IN 表子查询子查询返回的结果是多行多列，这种子查询称为表子查询。 常用操作符：IN 多表查询案例略 事务 学习内容来自 https://www.bilibili.com/video/BV1Kr4y1i7ru?p=49&amp;spm_id_from=pageDriver","link":"/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93sql/"},{"title":"生成学习时间统计图","text":"给女朋友做的学习时间统计柱状图，代码加以记录，以后方便复用 123456789101112131415161718import matplotlib.pyplot as plt# 这两行代码解决 plt 中文显示的问题plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = Falsedays = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]study_hours = [0,7,6.5,8,8.5,5,8,7,6.5,4,8,8,7,8.5,9,3,10,5.5,8,4,0,7.5,7,7.5,8,0,7.5,7.5,7,4,7.5]plt.bar(days, study_hours)plt.title('宝宝七月份学习时间统计')plt.ylabel('学习时间/h')plt.xlabel('日期')plt.show()","link":"/2021/06/01/%E9%9A%8F%E7%AC%94-%E7%BB%99%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%81%9A%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%E5%9B%BE/"},{"title":"生成学习时间统计图表","text":"给女朋友做的学习时间统计柱状图，代码加以记录，以后方便复用 123456789101112131415import matplotlib.pyplot as plt# 这两行代码解决 plt 中文显示的问题plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = Falsedays = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]study_hours = [0,7,6.5,8,8.5,5,8,7,6.5,4,8,8,7,8.5,9,3,10,5.5,8,4,0,7.5,7,7.5,8,0,7.5,7.5,7,4,7.5]plt.bar(days, study_hours)plt.title('宝宝七月份学习时间统计')plt.ylabel('学习时间/h')plt.xlabel('日期')plt.show()","link":"/2021/06/02/%E9%9A%8F%E7%AC%94-%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8/"},{"title":"自建博客过程记录","text":"本博客采用hexo+gitee page+阿里云图床(阿里云对象存储oss)来建立的，主题选用的是基于hexo的icarus主题。一开始用的是hexo+githubpage，存在两个问题：1.博客部署在github部署和访问不稳定2.图片的使用和访问不方便。 建站过程 下载node.js、git等工具。进入在windows命令行 配置npm的国内源 12npm config set registry https://registry.npm.taobao.org #配置国内的镜像源npm info hexo # 测试查看hexo的安装信息，是否是taobao.org的源 安装hexo 12npm install -g hexo # 通过npm安装hexo# -g 指定全局安装，可以使用hexo命令 在自选的路径下，进行以下操作 123hexo init test # 初始化创建，会再桌面创建test文件夹cd test # 进入test目录npm install # 进一步安装hexo所需文件 hexo安装完成，启动hexo 123hexo clean # 清除所有记录hexo generate # 生成静态网页hexo server -p 80 # 在80端口启动服务，如果写-p xx 则在默认端口 浏览器访问localhost:端口号，可以查看博客当前的样子 主题配置：将下载的hexo主题（可以去github或者百度知乎上搜喜欢的）放在themes文件夹下，然后修改_config.yml配置文件 1theme: xxx # 这里与theme下主题文件夹的名称相同 在gitee中创建和用户名相同的仓库，然后修改_config.yml中的仓库url 123deploy: type: git repo: https://gitee.com/fxgood/fxgood # gitee的仓库地址 cd到博客根目录下，输入命令hexo generate &amp;&amp; hexo deploy 或者hexo g &amp;&amp;hexo d ，即可将博客部署到gitee page 阿里云购买域名，进行域名绑定 Typora绑定阿里云图床过程参考 https://zhuanlan.zhihu.com/p/138878534 注意事项 通过gitee page来建博客，仓库名一定要与gitee用户名一致，这样可以采用https://用户名.gitee.io/的方式来访问博客。 每次更新博客内容需要手动在gitee page上进行刷新（氪金会员据说可以自动刷新） hexo配置和主题配置，分别在_config.yml和_config.xxx主题名xx.yml中 写文章，就在source/_posts/下，可以再创建文件夹进行分类存放 生成文章摘要有两种方法 在文章中某一行添加&lt;-- more --&gt;，则该行以上的内容会作为摘要 在md文件开头添加属性excerpt:xxx内容填写摘要即可 添加代码实现文章首页顺序控制,修改node_modules/hexo-generator-index/lib/generator.js文件（没有top属性则比较日期，有则比较top大小，top越大文章在首页越靠前） 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';const pagination = require('hexo-pagination');const { sort } = require('timsort');module.exports = function(locals) { const config = this.config; const posts = locals.posts.sort(config.index_generator.order_by); //添加这一段 posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); //到此截止 sort(posts.data, (a, b) =&gt; (b.sticky || 0) - (a.sticky || 0)); const paginationDir = config.pagination_dir || 'page'; const path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 我在github和gitee都部署了我的博客，其中githubpage绑定了我阿里云买的域名fengxu.work。用git更新博客的时候，只需要修改_config.yml中的deploy下的repo地址。（因为github和gitee用户名和邮箱相同） hexo常用命令 注：首先要用cmd或者git来到本地博客根目录 hexo init初始化博客 hexo clean 刷新部署 hexo generate 更新博客内容后，需要重新生成 hexo deploy 部署到远程服务器上 hexo c &amp;&amp;hexo g &amp;&amp;hexo d 可以一键完成上述三个功能 遇到OpenSSL SSL_read: Connection was aborted, , errno 10053错误，原因是Git默认限制推送的大小，运行命令更改限制大小即可 git config --global http.postBuffer 10000000000 文章常用yaml front matter title: xxx标题 category: 分类 tag: 标签 1234# 多个标签下tag:- 二叉树- 递归 excerpt: 文章摘要 updated: 2020-04-01 00:00:00 更新时间，（注意在_config.icarus.yml中article中可以设置update_time以实现控制) date: 2020-1-1 00:00:00 创建时间 top: num 根据num的大小，决定在首页的排列顺序，num越大优先级越高 博客内容备份可以将整个MyBlog文件夹用git推送到github博客静态页面仓库的分支hexo中 在.git的config中添加 1234[remote &quot;origin&quot;] url = https://github.com/fxgood/fxgood.github.io'[branch &quot;master&quot;] remote = origin git add . git commit -m “xxx” git push origin hexo:hexo 如果没有添加config这里的origin要写成链接形式 常见问题解决方式 更新推不上去 vpn挂美国节点 Git报错connection was aborted,errno 10053 git安装目录下etc/gitconfig设置postbuffer=100m，报错的原因是postbuffer缓存不足","link":"/2020/01/10/%E9%9A%8F%E7%AC%94-%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/"},{"title":"JavaScript","text":"JavaScript简介 概念：一门客户端脚本语言 运行在客户端浏览器中，每个浏览器都有javascript地解析引擎 脚本语言：无需编译，直接就可以被浏览器解析执行 功能： 可以来增强用户和html页面的交互。可以控制html元素，可以实现页面的动态效果，增强用户体验 JavaScript发展史 三足鼎立，略 ECMA（欧洲计算机制造商协会），制定出客户端脚本语言的标准：ECMAScript，统一了所有客户端脚本语言的编码方式 JavaScript=ECMAScript+JavaScript的（BOM+DOM) ECMAScript：客户端脚本语言的标准 ECMAScript基本语法 与html结合方式 内部JS 定义，标签体内容就是js代码 定义,通过src属性引入外部的js文件 &lt;script&gt;标签可以写在任意位置，但是影响加载顺序，一般放后面，否则会获取不到html对象 外部JS 注释 单行注释 // 多行注释 /* */ 数据类型 原始数据类型（基本数据类型） number：数字。 正数/小数/NaN（not a number） string：字符串。 字符/字符串 “abc” “a” ‘abc’ 没有字符的概念，不区分单双引号 boolean：true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值则会被默认赋值为undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而Javascript是弱类型语言，即申请空间时不规定类型 语法： var 变量名 = 初始化值； 12345678910111213&lt;script&gt; var a=1; var b=&quot;我是一句话&quot;; var c=NaN; var d=true; var e=null; var f=undefined; document.write(a+&quot;&lt;br&gt;&quot;); document.write(b+&quot;&lt;br&gt;&quot;); document.write(c+&quot;&lt;br&gt;&quot;); document.write(d+&quot;&lt;br&gt;&quot;); document.write(e+&quot;&lt;br&gt;&quot;); document.write(f+&quot;&lt;br&gt;&quot;);&lt;/script&gt; typeof 运算符可以查看变量类型 实际开发中不需要了解具体的类型，javascript是弱类型语言。但面试会问 运算符 跟java基本相同 多了一个===全等于符号，比较时先判断类型，类型不同直接返回false（javaScript在其他类型的运算符比较时，如果类型不同会先转换类型再比较） 注意：再JS中，如果运算数不是运算符所要求的类型，js引擎会自动将运算数进行类型转换 string转number，按照字面值转。如果字面值不是数字，则转为NaN类型 boolean转number，true转1，false转0 流程控制语句 和java相同 JS中，switch语句可以接受任意的原始数据 特殊语法 语句以;结尾，一行只有一个语句，可以省略（不推荐） 变量可以不使用var 用：定义的是局部变量 不用：定义的是全局变量（不建议在方法中不加var定义全局变量） 基本对象 Function对象：函数对象 创建 ```html//形参前面的var可以省略function fun1(a,b){alert(a+b); }12345* ```html var fun2=function(a,b){ alert(a+b); } 属性 length：代表形参个数 特点 方法定义中，形参的类型不用写，返回值类型也不写 方式是一个对象，如果定义名称相同的方法会覆盖 在JS中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数 Array：数组对象 创建 var arr=new Array(元素列表); var arr=new Array(默认长度); var arr=[元素列表] 方法 join()：将数组中的元素，按照指定的分隔符，拼接为字符串(默认是逗号) push()：类似java中的add(),向数组尾部添加1个或更多元素 其他的查看文档 属性 length 特点 JS中，数组元素的类型是可变的 JS中，数组长度可变（数组不会访问越界），会自动扩容 Date对象 创建 var date=new Date(); 方法 toLocalString()：以当地的使用习惯返回时间 getTime()：获取毫秒值。和1970年1月1日之间的毫秒值差 Math对象 创建： 特点：Math对象不用创建，直接使用 方法 Math.PI ：返回Π值 Math.random()：返回[0,1)之间的一个随机数 Math.ceil()：对数进行向上取整 Math.floor()：对数进行向下取整 Math.round()：四舍五入 属性 Math.PI：返回圆周率 Number String RegExp：正则表达式对象 正则表达式：定义字符串的组成规则 单个字符：[]。 如[a-z]表示a到z之间的一个字符 如[ab]表示a或者b [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符 \\d表示单个数字字符 \\w单个单词字符[a-zA-Z0-9_] 量词符号 *：表示0次或多次 ?：表示出现0次或1次 +：表示出现1次或多次 如\\w*表示一个字符串，由单个字符构成，出现0次或多次 {m,n}表示最多 m&lt;=数量&lt;=n \\w{6,12}长度为6到12的仅由单词字符组成的字符串 {,n}：m缺省表示最多n次 {m,}：最少m次 开始结束符号 ^：开始 $：结束 只用^表示以该正则开头，只用$表示以该正则结尾，^xxx$表示字符串须严格匹配正则 正则对象 创建 var reg=new RegExp(“正则表达式”) var reg=/正则表达式/ （不要加双引号） 方法 test(参数)：验证字符串是否符合正则表达式 ```html &lt;script&gt; var reg1=new RegExp(&quot;\\\\w{2,4}&quot;); var reg2=/\\w{0,4}/; /*使用test方法*/ var username=&quot;ab&quot;; document.write(reg2.test(username)); &lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263648. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用 2. 方法 * encodeURL():url编码 * decodeURL()：url解码 * encodeURLComponent()：url编码 * decodeURLComponent()：url节码 * **后面的两种，编码出来的字符更多** * parseInt()：将字符串转数字 * 逐一判断每个字符是否是数字，直到不是数字位置，将前边的数字部分转为number * isNaN（）：判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的比较结果全部为false * eval()：将字符串转为javaScript代码来执行# BOM## 简单学习1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象2. 组成 * Window：窗口对象 * 特点：不需要创建对象， window.方法名() 或直接写方法名() 如alert（） * 方法 * 与弹出框有关的方法 * alert()：弹出警告框 * confirm()：弹出确认框 * 用户点击确定，返回true * 用户点击取消，返回false * prompt():显示一个用户输入框，**现在不常用** * 与打开关闭有关的方法 * open()：返回一个新的window对象 * close()：谁调用，关闭谁 * ```html &lt;body&gt; &lt;input id=&quot;button1&quot; type=&quot;button&quot; value=&quot;点击以打开一个新的标签页&quot;&gt; &lt;input id=&quot;button2&quot; type=&quot;button&quot; value=&quot;点击以关闭当前的页面&quot;&gt; &lt;script&gt; var button1=document.getElementById(&quot;button1&quot;); var button2=document.getElementById(&quot;button2&quot;); var newWindow; button1.onclick=function () { newWindow=open(&quot;http://www.baidu.com&quot;); } button2.onclick=function () { if(newWindow==null) close(); else newWindow.close(); } &lt;/script&gt; &lt;/body&gt; 与定时器相关的方法 setTimeout()：在指定毫秒值之后执行事件 第一个参数：js代码或方法对象 毫秒值 返回值：唯一标识，用于取消定时器 12345678910111213141516&lt;script&gt; //setTimeout(&quot;f();&quot;,1000); /* setTimeout(f,1000); function f() { alert(&quot;1秒中过去了&quot;) }*/ var id=setInterval(f1,1000); var i=1; function f1() { if(i&lt;=3) document.write(&quot;第&quot;+(i++)+&quot;秒...&lt;br&gt;&quot;); else clearInterval(id); }&lt;/script&gt; clearTimeout()：取消由setTimeout（）方法设置的timeout setInterval()：循环执行的定时器 clearInterval():取消之 属性 获取其他BOM对象 history location navigator screen 获取DOM对象 document Navigator：浏览器对象 不讲解 Screen：显示器屏幕对象 不讲解 History：当前页面历史记录对象 创建 window.history 或省略window 方法 back()：加载history列表中的前一个url forward（）：加载history列表中的下一个url go()：加载history列表中的某个具体页面 参数为正数，前进n个历史记录 参数为负数，后退n个历史记录 属性 length：返回当前窗口历史列表中的url数量 Location：地址栏对象 创建：window.location （可以省略window） 方法 reload()：刷新 属性 href 设置或返回完整的url（可以用来跳转网页） 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;倒计时跳转&lt;/title&gt; &lt;style&gt; p{ text-align: center; } span{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;span id=&quot;time&quot;&gt;5&lt;/span&gt;秒之后跳转 &lt;/p&gt;&lt;script&gt; var n=4; var time=document.getElementById(&quot;time&quot;); function f1() { if(n&gt;=1) time.innerHTML=n--; else location.href=&quot;http://www.baidu.com&quot;; } setInterval(f1,1000);&lt;/script&gt;&lt;/body&gt; DOM简单学习 DOM：Document Object Model 文档对象模型 将标记语言文档的各个组成部分封装为对象，对标记语言文档进行CRUD的动态操作 功能：控制html文档的内容 即增删改查 代码：获取页面的标签（元素）对象 Element document.getElementById(“id值”)：通过元素的id获取元素对象 记得加双引号 操作对象 设置其属性 明确获取的对象是哪一个 查看API文档，找其中有哪些属性可以设置 修改标签体内容 属性：innerHTML 事件的简单学习 功能：某些组件被执行了某些操作后，触发某些代码的执行 如何绑定事件 直接在html标签上，指定事件的属性（操作），属性就是js代码 事件：onclick：单击事件 通过js获取元素对象，指定事件属性，设置一个函数 ```htmlfunction f1() { alert(&quot;我被点了&quot;); } var img1=document.getElementById(&quot;img1&quot;); img1.onclick = f1; 123456789101112131415161718192021222324 * **注意调用函数的时候不加括号，因为他是一个对象*** 案例 ```html &lt;body&gt; &lt;img src=&quot;../img/future.jpg&quot; id=&quot;img1&quot;&gt; &lt;script&gt; var img1=document.getElementById(&quot;img1&quot;); var flag=true; img1.onclick=function () { if(flag){ img1.src=&quot;../img/验证码1.png&quot;; flag=false; } else{ img1.src=&quot;../img/future.jpg&quot;; flag=true; } } &lt;/script&gt; &lt;/body&gt; DOM对象W3C DOM 标准被分为3个不同的部分 核心DOM Node对象 是其他5个的父对象 所有的dom对象都可以认为是一个Node（节点） 方法： CRUD dom树 appendChild()：向节点的子节点列表的尾部添加新的子节点 removeChild()：删除（并返回）当前节点的指定子节点 replaceChild()：用新节点替换一个子节点 属性 parentNode：返回当前节点的父节点 Document：文档对象 创建：可以用window对象来获取 window.document 直接document 方法 获取Element对象 getElementById() getElementsByTagName()：根据元素名称获取元素对象们。返回的是数组 getElementsByClassName()：根据class属性值来获取元素对象们 getElementsByName()：根据name属性值来获取元素们 创建其他的DOM对象 createElement() createAttribute(name) （如table） 属性 Element：元素对象 通过document来获取和创建 方法 removeAttribute():删除属性 setAttribute()：设置属性 Attribute：属性对象 Text：文本对象 Comment：注释对象 XML DOM HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 第一种方式 div1.style.border=&quot;solid red 1px&quot;; 遇到类似font-size的则改写为fontSizediv1.style.fontSize=&quot;20px&quot;; 第二种方式：通过控制className在CSS中控制样式 动态删除添加表格 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table{ margin:auto; width: 500px; } div{ margin: 50px; text-align: center; } th,td{ text-align: center; border: 1px solid; border-radius: 5px; } .btn{ text-align: center; border: 1px solid; border-radius: 5px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;编号&quot;&gt; &lt;input id=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot;&gt; &lt;input id=&quot;input3&quot; type=&quot;text&quot; placeholder=&quot;性别&quot;&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;&gt;&lt;/div&gt;&lt;table id=&quot;table&quot;&gt; &lt;tr id=&quot;tr1&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; /*发生错误时，浏览器F12 console查找错误*/ //1.获取输入内容 document.getElementById(&quot;btn1&quot;).onclick=function () { var code=document.getElementById(&quot;input1&quot;).value; var name=document.getElementById(&quot;input2&quot;).value; var gender=document.getElementById(&quot;input3&quot;).value; //获取table var table=document.getElementById(&quot;table&quot;); //创建三个td var td_code=document.createElement(&quot;td&quot;); var textNode_code=document.createTextNode(code); td_code.appendChild(textNode_code); var td_name=document.createElement(&quot;td&quot;); var textNode_name=document.createTextNode(name); td_name.appendChild(textNode_name); var td_gender=document.createElement(&quot;td&quot;); var textNode_gender=document.createTextNode(gender); td_gender.appendChild(textNode_gender); //创建一个tr var tr=document.createElement(&quot;tr&quot;); tr.appendChild(td_code); tr.appendChild(td_name); tr.appendChild(td_gender); //创建一个删除按钮 var btn_delete=document.createElement(&quot;input&quot;); btn_delete.setAttribute(&quot;type&quot;,&quot;button&quot;); btn_delete.setAttribute(&quot;value&quot;,&quot;删除&quot;); btn_delete.setAttribute(&quot;class&quot;,&quot;btn&quot;); btn_delete.onclick=function () { //删除本行 tr table.removeChild(tr); } tr.appendChild(btn_delete); //将tr放入表格 table.appendChild(tr); } //2.添加到表中 //3.删除按钮&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例动态删除添加表格_innerHTML简化版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table{ margin:auto; width: 500px; } div{ margin: 50px; text-align: center; } th,td{ text-align: center; border: 1px solid; border-radius: 5px; } .btn{ text-align: center; border: 1px solid red; border-radius: 5px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;编号&quot;&gt; &lt;input id=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot;&gt; &lt;input id=&quot;input3&quot; type=&quot;text&quot; placeholder=&quot;性别&quot;&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;&gt;&lt;/div&gt;&lt;table id=&quot;table&quot;&gt; &lt;tr id=&quot;tr1&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; /*发生错误时，浏览器F12 console查找错误*/ //1.获取输入内容 function del(obj){ var table=obj.parentNode.parentNode.parentNode; var tr=obj.parentNode.parentNode; table.removeChild(tr); } document.getElementById(&quot;btn1&quot;).onclick=function () { var code=document.getElementById(&quot;input1&quot;).value; var name=document.getElementById(&quot;input2&quot;).value; var gender=document.getElementById(&quot;input3&quot;).value; var table=document.getElementById(&quot;table&quot;); table.innerHTML+=&quot;&lt;tr&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+code+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+name+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+gender+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&lt;a href='javascript:void(0);'onclick='del(this)' &gt;删除&lt;/td&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot; } //2.添加到表中 //3.删除按钮&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/03/02/%E6%8A%80%E6%9C%AF-Javascript/"},{"title":"cookie&amp;session&amp;jsp","text":"会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围的多次请求间内共享数据 方式 客户端会话技术:cookie 数据存在客户端 服务器端会话技术:session 数据存在服务器端 Cookie 概念：客户端会话技术，将数据保存到客户端 快速入门 使用步骤 创建（API）Cookie对象，绑定数据 new Cookie(String name,String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() Cookie实现原理基于响应头set-Cookie和请求头cookie实现 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AAhdofVS-1589287359257)(会话技术cookie&amp;session&amp;JSP.assets/image-20200505183236228.png)] Cookie的细节 一次可不可以发送多个Cookie？ 可以 可以创建多个cookie对象，使用response调用多次addCookie发送cookie即可 Cookie在浏览器中保存多长时间？ 默认情况下，浏览器关闭后，cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：持久化将Cookie数据写到硬盘的文件中。代表cookie存活时间 负数：默认情况 0：删除cookie信息 cookie能不能存中文？ 在tomcat8之前，cookie中不能直接存储中文数据 需要将中文数据转码，一般采用URL编码（如%E3） 在tomcat8及之后，cookie支持中文数据。特殊字符还是不支持（如空格），建议使用URL编码存储，URL解码 cookie获取的范围是多大？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中，cookie能不能共享？ 默认情况下，cookie不能共享 setPath(String path)：设置cookie的获取范围。默认情况下，设置当前的虚拟目录 设置setPath(“/“) 即可实现多个web项目之间的cookie共享 不同的tomcat服务器间cookie共享问题？ setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie之间可以共享 setDomain(“.baidu.com”)，那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 Cookie存储数据在客户端浏览器，不安全 浏览器对于单个cookie大小有限制，以及同一个域名下的总cookie数量有限制（20个以内） 作用 cookie一般用于存储少量不敏感数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问的时间 需求 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问 如果不是第一次访问，则提示：欢迎回来，您上一次访问时间为：显示时间字符串 分析： 可以用Cookie完成 在服务器的Servlet中判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：您好，欢迎回来，您上次访问的时间为：xxxx 写回cookie 没有：是第一次访问 响应数据：您好，欢迎首次访问 写回Cookie：lastTime=xxx 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445@WebServlet(&quot;/rememberLastTimeAccess&quot;)public class rememberLastTimeAccess extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //获取cookie Cookie[] cookies = request.getCookies(); boolean flag=true; if(cookies!=null&amp;&amp;cookies.length&gt;0){ for(Cookie c:cookies){ if(&quot;lastTime&quot;.equals(c.getName())){ flag=false; //有该cookie表示不是第一次访问 String value = c.getValue(); String decode = URLDecoder.decode(value,&quot;utf-8&quot;); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次的访问时间：&quot;+decode+&quot;&lt;/h1&gt;&quot;); //获取当前时间的字符串，重新设置cookie的值 Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年mm月dd日 HH:mm:ss&quot;).format(date); //string中有空格，cookie不支持，故进行URL编码 String encode = URLEncoder.encode(time, &quot;utf-8&quot;); c.setValue(encode); //设置cookie存活时间 c.setMaxAge(3600*24*30); //存储一个月 response.addCookie(c);//会覆盖原来的值 break; } } } if(cookies==null||cookies.length==0||flag) { response.getWriter().write(&quot;&lt;h1&gt;欢迎您，首次访问！&lt;/h1&gt;&quot;); Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); String encode = URLEncoder.encode(time, &quot;utf-8&quot;); Cookie cookie=new Cookie(&quot;lastTime&quot;,encode); cookie.setMaxAge(3600*24*30); response.addCookie(cookie); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中（HttpSession） 快速入门 HttpSession对象 获取session对象 request.getSession() 使用 getAttribute(String name) setAttribute(String name,Object value) removeAttribute() 原理 服务器如何确保在一次会话范围内，多次获取的session对象是同一个？ Session是依赖于Cookie的（相当于把数据存在服务器，把这份数据的id通过cookie存在客户端浏览器） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zzUpGT0d-1589287359260)(会话技术cookie&amp;session&amp;JSP.assets/image-20200506102119056.png)] 细节 当客户端关闭后，服务器不关闭，两次session是否为同一个？ 默认情况下：不是（请求头中没有cookie记录） 如果需要相同，则可以创建Cookie，键设置为JSESSIONID，值为获取到的session的id，设置最大存活时间，让cookie持久化保存 12Cookie cookie=new Cookie(&quot;JSESSIONID&quot;,session.getId());response.addCookie(cookie); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失（Tomcat已帮我们自动完成，必须用本地的tomcat服务器启动才能实现，idea中部署tomcat服务器无法完成） Session的钝化 在服务器正常关闭之前，将Session对象序列化到硬盘上 Session的活化 在服务器启动后将session文件转化为内存中的Session对象即可 Session的默认失效时间？ 服务器关闭 session对象调用invalidate（） session默认失效时间是30分钟 可以在tomcat/conf/web.xml的 &lt;session-config&gt;中设置 特点 session用于存储一次会话的多次请求间的数据，存储在服务器端 session可以存储任意类型，任意大小的数据 session与cookie的区别 session在服务器端存储数据，cookie存在客户端 session可以存储任意数据类型，没有数据大小限制，cookie只能存储字符串，有大小限制 session比较安全，cookie相对不安全 案例：验证码JSP入门学习 概念：Java Server Pages：java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写 原理[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7V2NgSrk-1589287359261)(会话技术cookie&amp;session&amp;JSP.assets/image-20200505214202822.png)] 本质：JSP本质是一个Servlet JSP的脚本：JSP定义Java代码的方式 &lt;%java代码%&gt;：定义的java代码在Service方法中。service方法中可以定义什么，该脚本中就可以定义什么 &lt;%! java代码%&gt;：定义成员（成员变量，成员方法） &lt;%=java代码%&gt;：会将内容输出到页面中 jsp的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象 常用的3个 request response out：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似 tomcat服务器真正给客户端做出响应之前，会先找到response缓冲区数据，再找out缓冲区数据 response.getWriter().write()数据输出永远在out.write()之前 案例：改造cookie案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page import=&quot;java.net.URLDecoder&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%@ page import=&quot;java.text.SimpleDateFormat&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //获取cookie Cookie[] cookies = request.getCookies(); boolean flag=true; if(cookies!=null&amp;&amp;cookies.length&gt;0){ for(Cookie c:cookies){ if(&quot;lastTime&quot;.equals(c.getName())){ flag=false; //有该cookie表示不是第一次访问 String value = c.getValue(); String decode = URLDecoder.decode(value,&quot;utf-8&quot;);%&gt; &lt;h1&gt;欢迎回来，您上次的访问时间：&lt;%=decode%&gt;&lt;/h1&gt; &lt;% //获取当前时间的字符串，重新设置cookie的值 Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); //string中有空格，cookie不支持，故进行URL编码 String encode = URLEncoder.encode(time, &quot;utf-8&quot;); c.setValue(encode); //设置cookie存活时间 c.setMaxAge(3600*24*30); //存储一个月 response.addCookie(c);//会覆盖原来的值 break; } } } if(cookies==null||cookies.length==0||flag) {%&gt; &lt;h1&gt;欢迎您，首次访问！&lt;/h1&gt; &lt;% Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); String encode = URLEncoder.encode(time, &quot;utf-8&quot;); Cookie cookie=new Cookie(&quot;lastTime&quot;,encode); cookie.setMaxAge(3600*24*30); response.addCookie(cookie); } %&gt; &lt;/body&gt;&lt;/html&gt; 指令 作用：用于配置JSP页面，导入资源文件 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ...%&gt; 分类 page：配置jsp页面 contentType：等同于response.setContentType() 设置响应体的mime类型和字符集 设置当前jsp页面的编码（只能是高级IDE才能生效，如果使用记事本开发则需要设置pageEncoing来设置当前页面的字符集编码） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：表示当前页面是否是错误也弥漫 true：可以使用内置对象exception false：默认值。不可以使用内置对象exception include：用不到。导入页面的资源文件 taglib：导入资源（一般用于导入标签库） ```java&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 * prefix：自定义的前缀## 注释1. html注释`&lt;!-- --&gt;`只能注释html代码片段2. （**推荐使用**）jsp注释：`&lt;%-- --%&gt;`可以注释所有## 内置对象* 在jsp页面中不需要创建，直接使用的对象* 一共有9个 * 四个域对象 * pageContext * 范围：当前页面共享数据 * 可以获取其他8个对象 * request * 一次请求内共享数据 * session * 一次会话的多个请求间共享数据 * application * 所有用户间共享数据 *** * response * 响应对象 * page * 当前页面（Servlet）的对象 this * out * 输出对象，可以把数据输出到页面上 * config * Servlet的配置对象 * exception * 异常对象# MVC：开发模式* jsp演变历史 1. 早期只有Servlet，只能使用response输出标签数据，非常麻烦 2. 后来有jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中既写大量的java代码，又写html标签，造成难以维护难以分工 3. 再后来，java的web开发借鉴了mvc开发模式使得程序的设计更加合理* MVC： * Model：模型 * 完成具体的业务操作，如：查询数据库，封装对象 * **使用JavaBean来充当** * View：视图 * 展示数据 * **使用JSP来充当** * Controller：控制器 * 获取用户的输入 * 调用模型 * 将模型返回的数据，交给视图进行展示 * **使用Servlet来充当** * 优点 * 耦合性低，方便维护，利于分工协作 * 重用性高 * 缺点 * 使得项目架构变得复杂，对开发人员要求高 * 不适合小型项目 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bkaXsHDs-1589287359265)(会话技术cookie&amp;session&amp;JSP.assets/image-20200506140632847.png)]# EL表达式1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：`${表达式}`4. 注意： * jsp默认支持el表达式 * `&lt;%@ page isELIgnored=&quot;true&quot;%&gt;` ：设置页面忽略EL表达式 * 加转义符`\\`反斜杠：忽略当前这个EL表达式5. 作用 1. 运算 * 运算符： 1. 算数运算符：+,-,*,/(div),%(mod) 2. 比较运算符 3. 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 4. 空运算符：empty * 功能：用于判断字符串，集合，数组对象是否为null并且长度是否为0 * `${empty list}` list为空或者长度为0，则该表达式返回true * `${not empty xxx}`：判断字符串、集合、数组对象是否不为null且长度&gt;0 2. 获取值 1. **el表达式只能从域对象中获取值** 2. 语法 1. `${域名称.键名}`：从指定域中获取指定键的值 * 域名称： 1. pageScope ——&gt; pageContext 2. requestScope ——&gt; request 3. sessionScope ——&gt; session 4. applicationScope ——&gt; application (ServletContext) * 举例：在request域中存储了name=张三 2. `${键名}`：表示**依次从最小的域**中查找是否有该键对应的值，直到找到为止 3. 获取对象，List集合，Map集合的值 1. 对象：${域名称.键名.属性名} * **本质上会去调用对象的get方法** ```java public class User { private String name; private int age; private Date date; //逻辑视图 public String getBirthday(){ if(date==null) return &quot;&quot;; return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(date); } 1234567891011&lt;% User user=new User(); user.setName(&quot;余丰旭&quot;); user.setAge(22); Date mydate = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1997-12-29&quot;); user.setDate(mydate); request.setAttribute(&quot;user1&quot;,user);%&gt;${user1.name}&lt;br&gt;${user1.age}&lt;br&gt;${user1.birthday}&lt;br&gt; //直接按照getBirthday()方法的返回值打印 2. List集合： * `${域名称.键名}` 域名可省略（**依次从最小的域**中查找是否有该键对应的值，直到找到为止） * ``${域名称.键名[索引]}` 如果索引越界，则什么都不显示 3. Map集合 * `${域名称.键名.key名称}` 域名可省略 * `${域名称.键名[&quot;key名称&quot;]}` 123456789&lt;%Map map=new HashMap();map.put(&quot;name&quot;,&quot;丰旭&quot;);map.put(&quot;user&quot;,user);request.setAttribute(&quot;map&quot;,map);%&gt;${map.name}&lt;br&gt;${map.user.name}&lt;br&gt;${map.user.birthday}&lt;br&gt; 隐式对象 作用：例如，如果想在jsp页面的html中的一个字符串中表示post或get方式提交过来的内容，则必须使用request.getParameter()方法，但是字符串中无法调用，只能用EL表达式先通过pageContext获取requst对象 el表达式中有11个隐式对象 pageContext: 获取jsp其他8个对象 如动态获取虚拟目录：${pageContext.request.contextPath} 用于路径的编写 JSTL标签 概念：JavaServer Pages Tag Libray JSP标准标签库 是由apache组织提供的开源的免费的jsp标签 作用：用于简化和替换jsp页面上的java代码 使用步骤 导入jar包 jsp页面引入标签库：&lt;%taglib prefix= url=%&gt; 使用标签 if 相当于java的if语句 属性： test 必须属性，接收boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示 一般情况下，test属性会综合el表达式一起使用 注意：c:if标签没有else情况，需要再定义if标签 1234&lt;h1&gt;判断数字是否为偶数&lt;/h1&gt;&lt;c:if test=&quot;${num%2==0}&quot;&gt; ${num}是偶数&lt;/c:if&gt; choose 相当于java的switch语句 12345678910111213&lt;% request.setAttribute(&quot;num&quot;,8);%&gt;&lt;c:choose &gt; &lt;c:when test=&quot;${num==1}&quot;&gt;星期一&lt;/c:when&gt; &lt;c:when test=&quot;${num==2}&quot;&gt;星期二&lt;/c:when&gt; &lt;c:when test=&quot;${num==3}&quot;&gt;星期三&lt;/c:when&gt; &lt;c:when test=&quot;${num==4}&quot;&gt;星期四&lt;/c:when&gt; &lt;c:when test=&quot;${num==5}&quot;&gt;星期五&lt;/c:when&gt; &lt;c:when test=&quot;${num==6}&quot;&gt;星期六&lt;/c:when&gt; &lt;c:when test=&quot;${num==7}&quot;&gt;星期日&lt;/c:when&gt; &lt;c:otherwise&gt;输入数字有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; foreach 相当于java的for语句 完成重复的操作 属性 begin：开始值 end：结束值（包含） var：临时变量 step：步长 varStatus：循环状态 123&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;1&quot; varStatus=&quot;status&quot;&gt; i的值：${i} 循环序号${status.index} 循环的总数${status.count} &lt;br&gt;&lt;/c:forEach&gt; 遍历容器 属性 items：容器对象 var：容器中元素的临时变量 123456789101112&lt;% List list=new ArrayList(); list.add(1); list.add(&quot;bb&quot;); list.add(&quot;ccc&quot;); request.setAttribute(&quot;list&quot;,list);%&gt;&lt;c:forEach items=&quot;${list}&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; ${s.index} ${s.count} ${str} &lt;br&gt;&lt;/c:forEach&gt; 练习 需求：再request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中。并实现table中奇数行和偶数行颜色不同 &lt;% List list=new ArrayList(); User user1=new User(); User user2=new User(); User user3=new User(); //User user3=new User(); user1.setName(&quot;余丰旭&quot;); user2.setName(&quot;陈香玉&quot;); user3.setName(&quot;小小余&quot;); user1.setAge(22); user2.setAge(24); user3.setAge(0); user1.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1997-12-29&quot;)); user2.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1995-11-25&quot;)); user3.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2026-1-1&quot;)); list.add(user1); list.add(user2); list.add(user3); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;table class=&quot;t1&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;c:if test=&quot;${not empty list}&quot;&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;u&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count%2==0}&quot;&gt; &lt;tr bgcolor=&quot;yellow&quot;&gt; &lt;td&gt;${u.name}&lt;/td&gt; &lt;td&gt;${u.age}&lt;/td&gt; &lt;td&gt;${u.birthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;c:if test=&quot;${status.count%2!=0}&quot;&gt; &lt;tr bgcolor=&quot;#ffc0cb&quot;&gt; &lt;td&gt;${u.name}&lt;/td&gt; &lt;td&gt;${u.age}&lt;/td&gt; &lt;td&gt;${u.birthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:if&gt; &lt;/table&gt; 三层架构：软件设计架构 界面层（表示层）：用户看到的界面，用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑（如登录，注册） 数据访问层：操作数据存储文件（如数据库、xml中） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gsBaNMGW-1589287359267)(会话技术cookie&amp;session&amp;JSP.assets/image-20200507120117672.png)] 案例：用户信息列表展示 需求：用户信息的增删改查 设计： 技术选型：Servlet+JSP+MySQL+JDBCTemplate+Druid+BeanUtils+tomcat 数据库设计： 开发 环境搭建 创建数据库环境 创建项目，导入需要的jar包 编码 测试 部署运维 综合练习 简单功能 列表查询 登录 添加 删除 修改 复杂功能 删除选中 分页查询 复杂的条件查询，带有分页效果 登录功能 调整页面，加入验证码功能","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-cookie-session-jsp/"},{"title":"Spring","text":"Spring概念 Spring是轻量级的开源的JavaEE框架 轻量级：引入Jar包少，体积小，可以独立进行使用 Spring出现的目的：解决企业应用开发的复杂性 Spring有两大核心特性： IOC：控制反转，把创建对象过程交给Spring进行管理 AOP：面相切面编程，在不改变源代码的情况下扩展功能（增强了可扩展性） Spring特点 方便解耦、简化开发 支持AOP编程 方便程序的测试（整合了Junit4） 方便和其他框架进行整合 方便进行事务操作 降低API开发难度（比如对JDBC进行了封装） Spring的源码，是Java学习的经典范例 Spring的组成部分 IOC容器什么是IOC 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 使用IOC目的：将对象创建和对象之间的调用，都统一交给Spring进行管理。简化了代码开发过程，降低了耦合度。如果以原始方式构建代码，效果如下： 两个类之间耦合度过高，如果UserDao发生改变（修改方法，增加方法等扩展行为），则会牵一发动全身，不利于程序的扩展性。 我们追求的是程序的高内聚、低耦合。 123SpringIOC的好处：全称是Inversion of Control 简称 IoC，控制反转。是指程序中对象的获取方式发生反转，由最初的new方式创建，转为由框架创建、注入，这样可以降低对象之间的耦合度。IoC（Inversion of Control，控制反转）也称为依赖注入（Dependency Injection），作为Spring的一个核心思想，是一种设计对象之间依赖关系的原则及其相关技术。先来看看字面上怎么来解释：当一个对象创建时，它所依赖的对象由外部传递给它，而非自己去创建所依赖的对象（比如通过new操作）。因此，也可以说在对象如何获取它的依赖对象这件事情上，控制权反转了。这便不难理解控制反转和依赖注入这两个名字的由来了。 IOC底层原理 xml解析 工厂模式 工厂模式出现的目的就是为了实现低耦合 并没有将耦合度降低到最低，工厂类和UserService仍然具有较强的耦合度 反射 反射：.java文件编译成.class字节码文件后，获取字节码文件，以实现对类的控制 IOC接口（BeanFactory） IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring提供IOC容器实现两种方式：（两个接口） BeanFactory：IOC容器基本实现，是Spring内部使用的接口，一般不提供给开发人员使用。 加载配置文件时，不会创建对象；在获取（使用）对象时，才会创建对象 ApplicationContext：BeanFactory接口的子接口，提供了更多更强大的功能，一般面向开发人员进行使用 加载配置文件时，就创建对象 将耗时耗资源的过程在服务器启动的时候就完成，执行过程中直接用就可以了 ApplicationContext实现类 IOC操作Bean管理 什么是Bean管理 Spring创建对象 Spring进行属性注入 两种实现方式 基于XML 基于注解 两种类型bean1.Spring有两种类型bean，一种是普通bean，一种是工厂bean（FactoryBean） 普通bean：在配置文件中定义的bean类型，就是返回类型 工厂bean：在配置文件中定义的bean类型可以和返回类型不同 创建类，让这个类作为工厂bean，实现FactoryBean接口 实现接口里的方法，让实现的方法中定义返回的bean类型 注意，context.getBean的第二个参数用的不是MyBean.class,而是Person.class bean作用域 在Spring中，设置创建bean实例是单实例还是多实例（如何验证：连续两次使用 new ClassPathXmlApplicationContext()返回对象，看地址值是否相同） bean中有个属性，有个scope属性，用于设置单实例还是多实例（默认是单实例） singleton：单实例，加载spring配置文件时(new ClassPathXmlApplicationContext())，就会创建单实例对象 prototype：多实例，在调用getBean方法时创建多实例对象 request：了解，每次创建对象会放入request中 session：了解，每次创建对象会放入session中 bean生命周期 生命周期：从对象创建到销毁的过程 通过构造器创建bean实例（无参构造） 为bean的属性设置值和对其他bean引用（调用set方法） 调用bean的初始化方法（bean标签init-method指定方法名） bean可以使用（对象获取到了） 当容器关闭的时候，调用bean的销毁方法（bean标签destroy-method指定方法名，使用ClassPathXmlApplicationContext接口的close方法会自动调用指定的方法） （注意，ClassPathXmlApplicationContext是ApplicationContext的子接口，其中close是子接口的特有方法） bean的后置处理器加上后置处理器以后，bean的生命周期由五步变成七步 通过构造器创建bean实例（无参构造） 为bean的属性设置值和对其他bean引用（调用set方法） 把bean实例传递到bean后置处理器方法postProcessBeforeInitialization 调用bean的初始化方法（bean标签init-method指定方法名）、 把bean实例传递给bean后置处理器的方法postProcessAfterInitialization bean可以使用（对象获取到了） 当容器关闭的时候，调用bean的销毁方法（bean标签destroy-method指定方法名，使用ClassPathXmlApplicationContext接口的close方法会自动调用指定的方法） 配置后置处理器后，同一个xml中所有bean都添加了后置处理器。（如下，orders对象就被自动配置了后置处理器） IOC操作Bean管理（基于xml）基于xml方式创建对象 在spring配置文件中，使用bean标签，标签里边添加对应属性，就可以实现对象创建 在bean标签中有很多属性 id属性：唯一标识 class属性：类全路径 创建对象时，默认执行无参构造函数完成对象创建 基于xml方式注入属性 DI：依赖注入，就是注入属性(需要先创建对象) IOC与 DI的区别，DI是IOC的一种实现方式 （1）基于setter的注入 （2）基于构造函数的注入 (3) p名称空间注入（了解） 可以简化基于xml配置方式。(但仍然是基于setter的注入) 在配置文件中添加p名称空间 进行属性注入，在bean标签里进行操作 （4）注入null或特殊符号 注入外部bean与级联赋值需要使用setter来进行注入 注入内部bean 级联赋值即使用外部bean注入属性（使用ref），外部的bean中也已经注入了属性 方式一： 方式二： 注意：在Employee类中必须为成员Department dpt设置Getter，注意是getter，否则dept.name会报错 注入集合属性1.数组 2.List 3.Map 4.Set 注：name随便取的，和类中成员的名字相同即可 5.注入集合的元素是对象 进阶：将集合注入部分抽取出来，用于复用 xml自动装配自动装配：根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入 实现方式：增加autowire属性，值可以选择byname or bytype 根据属性名称进行自动装配 xml中用于自动装配的bean的id需要和属性名相同 根据属性类型进行自动装配 相同类型的bean不能定义多个（会报错，因为会冲突） xml自动装配实际用的很少，一般都用注解方式进行实现 引入外部属性文件首先导入druid连接池jar包（在projectStructure里导入） IOC操作Bean管理（基于注解）使用注解的目的：简化xml配置 基于注解方式创建对象四个注解 @Component @Service @Controller @Repository 注：上面四个注解功能一样，都可以用来创建bean实例。 基于注解创建对象过程 引入依赖spring-aop-5.2.6.RELEASE.jar 开启组件扫描 需要在xml文件中添加xmlns:context=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 创建类，在类上添加创建对象注解 value属性值可以省略，默认值是类名称，首字母小写 其中扫描包的过滤器可以自定义，见下图 （use-default-filters=’false’ 表示不使用默认的filter，默认会扫描指定包下的所有类） 基于注解方式注入属性相关注解 @AutoWired：根据属性类型进行自动注入 注意不需要添加set方法哦 @Qualifier：根据属性名称进行自动注入 需要配合autowired一起使用 @Resource：根据属性类型/名称进行自动注入 它是javax.annotation扩展包下的，不是spring下的 @Value：注入普通数据类型（上面三种都是注入对象类型） 纯注解开发 创建配置类，替代xml的配置文件 测试时，有所不同 实际开发中，会使用SpringBoot来完成这些工作，SpringBoot本质就是Spring AOP概念 面相切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。 使用登录案例说明AOP： 底层原理原理：使用动态代理，在不改变原有代码基础上增强功能 有接口 使用JDK动态代理 public interface Animal { public void speak(); public int calculate(int a,int b); } public class Cat implements Animal{ @Override public void speak() { System.out.println(&quot;喵喵喵&quot;); } @Override public int calculate(int a, int b) { System.out.println(&quot;正在计算...&quot;); return a+b; } } public class Test { public static void main(String[] args) { Class[]interfaces={Animal.class}; Object cat=new Cat(); Animal animal=(Animal)Proxy.newProxyInstance(Test.class.getClassLoader(),interfaces,new AnimalProxy(cat)); animal.speak(); animal.calculate(1,2); } } class AnimalProxy implements InvocationHandler{ private Object obj; //将要代理的对象传入 public AnimalProxy(Object obj){ this.obj=obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //方法执行前 if(method.getName()==&quot;speak&quot;){ System.out.println(&quot;叫之前...&quot;); } //执行原有的方法 Object res = method.invoke(obj, args); //方法执行后 if(method.getName()==&quot;speak&quot;){ System.out.println(&quot;叫之后...&quot;); } else if(method.getName()==&quot;calculate&quot;){ System.out.println(&quot;计算结果是&quot;+res); } return res; } } 无接口 使用GCLIB动态代理 AOP术语连接点 类中可以被增强的方法，就被称为连接点 切入点 实际真正被增强的方法，成为切入点 通知（增强） 实际增强的逻辑部分成为通知（增强） 通知有多重类型 前置通知 后置通知 环绕通知：在被增强的方法的前后都有执行 异常通知：当被增强的方法出现异常时，执行 最终通知：类似finally 切面 把通知应用到切入点的过程，就称为切面（切面是一个动作） AOP操作 Spring框架一般都是基于AspectJ实现AOP操作 什么是AspectJ：它不是Spring的组成部分，是一个独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作 基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解实现（实际使用） 在项目工程里引入AOP相关依赖 导入lib后，需要在project struct中Add。 各种依赖在百度网盘-编程相关-各种软件包里有 切入点表达式 作用：知道对哪个类中的哪个方法进行增强 语法结构 基本流程 (1)创建类，定义方法 (2)创建增强类，编写增强逻辑 (3)在增强类上添加注解@Aspect (4)在spring配置文件中开启生成代理对象 (5)配置不同类型的通知 JdbcTemplate事务管理Spring5新特性","link":"/2020/05/06/%E6%8A%80%E6%9C%AF-Spring/"},{"title":"HTML与CSS学习笔记","text":"JavaWeb概述 JavaWeb 使用Java开发的基于互联网的项目 软件架构 B/S C/S B/S架构详解 静态资源：使用静态网页开发技术发布的资源 特点： 所有用户访问，得到的结果相同 如：文本、图片、视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，服务器会直接将静态资源发送给浏览器，浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源：使用动态网页技术即时发布的资源 特点： 所有用户访问，得到的结果可能不同 如：jsp/servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转化为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源 静态资源： HTML：用于搭建基础网页，用于展示页面内容 CSS：用于美化页面，布局页面 JavaScript（盲猜做业务流用不到）：控制页面元素，让页面有一些动态效果 HTMLHTML基础1.概念：是最基础的网页开发语言 超文本：用超链接的方法，把不同空间的文字信息组织在一起的网状文本 标记语言：由标签构成的语言 2.快速入门 语法： html文档后缀.html 或.htm 标签分为 围堵标签：如 自闭和标签：开始标签和结束标签在一起，如 标签可以嵌套 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来 html标签不区分大小写，建议小写 3.标签（在帮助文档里可以查到具体的） 文件标签：构成html最基本的标签 html：html文档的根标签 head： 头标签。用于指定html文档的一些属性。引入外部资源 title：标题标签 body：体标签 ：html5中定义该文档是html文档 文本标签：和文本有关的标签 &lt;!– –&gt; ：注释 &lt;h1&gt; to &lt;h6&gt; ：标题标签 &lt;p&gt;：段落标签 （paragraph段落） &lt;br&gt;：换行标签 &lt;hr/&gt;:显示一条水平线 （自闭和标签）（horizontal rule 水平分割线） &lt;hr color=’red’ width=’200’ size=’10’ align=”left”/&gt; 可以设置属性来改变样式，不过了解即可，html5不推荐使用，后面会用CSS &lt;b&gt;:字体加粗 &lt;i&gt;：字体斜体 &lt;font&gt;：字体标签 不推荐使用，已废弃 图片标签： &lt;img/&gt;：自闭和标签，展示图片 只需记得src给出图片路径即可 相对路径 ./代表当前路径 可以省略 ../表示上一级目录 &lt;img src=&quot;image/timg.jpg&quot; align=&quot;right&quot; alt=&quot;美丽的风景&quot;/&gt; alt代表图片加载失败时显示的文字 列表标签： 有序列表 ol:(order list) li: 1234567//type省略默认按123..排序//start决定从什么开始数&lt;ol type=&quot;a&quot; start='3'&gt; &lt;li&gt;起床&lt;/li&gt; &lt;li&gt;刷牙&lt;/li&gt; &lt;li&gt;吃饭&lt;/li&gt; &lt;/ol&gt; 无序列表 ul：可以修改type li 链接标签： a：定义一个超链接 1&lt;a href=&quot;http://www.baidu.com&quot;&gt;点我 &lt;/a&gt; href：指定URL（统一资源定位符） target：-self指在本页面打开 _blank指在一个新的页面打开 可以用&lt;a&gt;标签包裹图片 div和span标签（了解，将来和CSS结合） span：文本信息在一行展示，行内标签 div：每一个div占满一整行，会自动换行。块级标签 语义化标签：html5中为了提高程序的可读性，提供了一些标签，结合CSS一起使用 header footer 表格标签 table：定义表格 一下属性html5基本都已废弃，改用CSS控制 width： border： cellpadding：定义内容与单元格之间的距离 cellspacing：定义单元格之间的距离，0则会变为线 bgcolor：背景色 tr：定义行 bgcolor：背景色 align：内部文本对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 caption：定义表格标题 thead：表示表格的头部分 tbody：表示表格的体部分 tfoot：表示表格的脚部分 html表单标签表单：用于采集用户输入的数据的。用于和服务器进行交互 使用的标签：form 可以定义一个范围，范围代表采集用户数据的范围 属性 action：指定提交数据的URL method：指定提交方式 get： 请求参数会在地址栏中显示。会封装到请求行中 请求参数长度有限制 不安全 post： 请求参数不会在地址栏中显示，会封装在请求体中（http协议） 请求参数的大小没有限制 较为安全 表单中的数据要想被提交，必须指定其name属性 例： 12345&lt;form action=&quot;###&quot; method=&quot;get&quot;&gt; 用户名：&lt;input name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 表单项标签 input：可以通过type属性值，改变元素展示的样式 type属性 text placeholder：指定输入框提示信息 password radio：单选框 注意：要想使多个单选框实现单选，他们的name必须相同 一般会给每个radio提供value值，指定其被选中后提交的值 checked，可以指定默认值 checkbox：复选框 checked，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息 按钮 submit：提交 button: 配合javascript使用的按钮 image：图片提交按钮 （src指定图片路径） label：指定输入项的文字描述信息 注意：label的for属性一般和input的id属性值对应。对应后点击label区域，会让input输入框获取焦点 select：下拉列表 option：指定列表项 textarea：文本域 cols：指定列数，每一行有多少字符 rows：默认多少行 案例 1234567891011121314151617181920212223&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;get&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;game&quot;&gt; 打游戏 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;learning&quot; checked&gt; 学习 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sports&quot;&gt; 运动 &lt;br&gt; 取色器：&lt;input type=&quot;color&quot; name=&quot;color&quot;&gt;&lt;br&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt;&lt;br&gt; 籍贯：&lt;select name=&quot;homecity&quot;&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;南京&lt;/option&gt; &lt;/select&gt;&lt;br&gt; 自我介绍：&lt;br&gt;&lt;textarea name=&quot;selfIntroduction&quot; rows=&quot;3&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt; 案例2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;!--定义表单--&gt; &lt;form action=&quot;###&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;500&quot;&gt; &lt;!--第一行--&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第二行--&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第三行--&gt; &lt;tr&gt; &lt;td&gt;Email&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;邮件&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第四行--&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第五行--&gt; &lt;tr&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;phoneNum&quot; placeholder=&quot;手机号码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第六行--&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;!--第七行--&gt; &lt;tr&gt; &lt;td&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第八行--&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;vcode&quot; placeholder=&quot;验证码&quot;&gt; &lt;img src=&quot;../image/验证码.jpg&quot; align=&quot;right&quot; width=&quot;150&quot; height=&quot;50&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--注册按钮--&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt; CSS基本概念 概念 CSS：页面美化和布局控制 Cascading style sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 使用CSS的好处 功能强大 将内容展示和样式控制分离 降低耦合度，解耦 让分工协作更容易， 可以提高开发效率 CSS与html结合方式内联样式 标签内使用style属性指定css代码 如&lt;div style=&quot;color: crimson&quot;&gt;IloveYoubaby&lt;/div&gt; 未实现内容与样式的分离，不推荐使用 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 ```html Title div{ color: blue; } Legionwhat's up? 1234567891011121314151617* 缺点：如上所有div使用同一的样式### 外部样式* 定义css资源文件* 在head标签内，定义link标签，引入外部的资源文件```html&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../CSS资源/a.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;计算机专硕复试&lt;/div&gt;&lt;/body&gt; 1234//css资源文件div{ color: green;} 小结 1方式不常用，后期常用2，3 第三种格式引入css资源还可以携程 123&lt;style&gt; @import &quot;##css位置##&quot;&lt;/style&gt; CSS基本语法格式12345选择器{ 属性名1:属性值; 属性名2:属性值; ...} 选择器：筛选具有相似特征的元素 注意：每一对属性需要使用;分开，最后一对可以不用 选择器分类： 基础选择器 id选择器：建议在一个html页面中id值唯一 12345678910111213141516&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #d1{ color: crimson; } #d2{ color: aqua; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;d1&quot;&gt;我是第一行&lt;/div&gt; &lt;div id=&quot;d2&quot;&gt;我是第二行&lt;/div&gt;&lt;/body&gt; 元素选择器：选择具有相同标签名称的元素（id选择器的优先级更高，会覆盖元素选择器） 12345678910111213&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ color: aquamarine; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是第一行&lt;/div&gt; &lt;div&gt;我是第二行&lt;/div&gt;&lt;/body&gt; 类选择器：选择具有相同class属性值的元素 语法：.class属性值{} 注意：优先级：id选择器&gt;类选择器&gt;元素选择器 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .c1{ color: crimson; } .c2{ color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;c1&quot;&gt; 这是第一段 &lt;/p&gt; &lt;div class=&quot;c2&quot;&gt;这是一行&lt;/div&gt; &lt;div class=&quot;c1&quot;&gt;这是二行&lt;/div&gt;&lt;/body&gt; 扩展选择器 *：选择所有元素 并集选择器： 语法：选择器1，选择器2{ } 子选择器：筛选选择器1元素下的选择器2元素 语法：选择器1 选择器2{ } 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div p{ color: crimson; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是第一行&lt;/p&gt; &lt;p&gt;这是第二行&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 父选择器：筛选选择器2上的父元素选择器1 语法：选择器1&gt;选择器2{} 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&gt;p{ border: 1px solid; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;我是div内的p&lt;/p&gt; &lt;/div&gt; &lt;p&gt;我是div外面的p&lt;/p&gt;&lt;/body&gt; 属性选择器：选择元素名称，属性名=属性值的元素语法：元素名称[属性名=“属性值”]{} 12345678910111213&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; input[type=&quot;password&quot;]{ background: crimson; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;password&quot;&gt;&lt;/body&gt; 伪类选择器：选择一个元素具有的状态 语法：元素：状态{} 如： link：初始化的状态 visited：被访问过的状态 active：正在访问的状态 hover：鼠标悬浮状态 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*控制超链接初始状态*/ a:link{ color: pink; } /*控制超链接悬浮状态下的颜色*/ a:hover{ color: yellow; } /*控制访问过的超链接的颜色*/ a:visited{ color: gray; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;http://www.4399.com&quot; target=&quot;_blank&quot;&gt;click me to find a new world!!&lt;/a&gt;&lt;/body&gt; 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景 backgroundbackground: url(&quot;../image/timg.jpg&quot;) no-repeat; 边框 border：设置边框，复合属性 尺寸 width： height： 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况会影响整个盒子大小 设置box-sizing: border-box 可以解决 float：浮动 left right 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ border: 1px solid red; } .d1{ height: 500px; width: 500px; margin: 300px; padding: 100px; } .d2{ height: 200px; width: 200px; /* margin: 300px; padding: 100px;*/ } .d3{ float: left; } .d4{ float: left; } .d5{ float: right; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;d3&quot;&gt;1111&lt;/div&gt; &lt;div class=&quot;d4&quot;&gt;2222&lt;/div&gt; &lt;div class=&quot;d5&quot;&gt;3333&lt;/div&gt; &lt;br&gt; &lt;div class=&quot;d1&quot;&gt; &lt;div class=&quot;d2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style&gt; *{ margin:0px; padding: 0px; /*设置后不会因为边距改变元素大小*/ box-sizing: border-box; } body{ background: url(&quot;../image/future.jpg&quot;) center no-repeat; background-size: cover; } .layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*水平居中*/ margin: auto; margin-top: 30px; } .left{ /*border: 1px red solid;*/ float: left; width: 200px; } .left p:first-child{ font-size: 20px; color: #FFD026; } .left p:last-child{ font-size: 20px; color: #A6A6A6; } .mid{ /*border: 1px red solid;*/ float: left; width: 450px; padding-top: 10px; } .right{ /*border: 1px red solid;*/ float: right; margin:15px; } .right p:only-child{ font-size: 15px; } .right p a{ color: pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 30px; padding-top: 10px; } #username,#password,#email,#name,#phoneNum,#birthday,#vcode{ width: 200px; height: 30px; border-radius: 7px; border: 1px solid gray; padding-left: 10px; } #vcode{ width: 120px; } #img_check{ /*width: 50px;*/ height:30px; /*设置水平居中*/ vertical-align: middle; } #register{ width: 150px; height: 40px; background-color: bisque; border: 1px ; margin-top: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;User Register&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;div class=&quot;form&quot;&gt; &lt;form action=&quot;###&quot; method=&quot;post&quot;&gt; &lt;table &gt; &lt;!--第一行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第二行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;密码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第三行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;Email&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;邮件&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第四行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;姓名&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第五行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;手机号码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;phoneNum&quot; name=&quot;phoneNum&quot; placeholder=&quot;手机号码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第六行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;性别&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;!--第七行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;出生日期&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; id=&quot;birthday&quot; name=&quot;birthday&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第八行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;验证码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot;id=&quot;vcode&quot; name=&quot;vcode&quot; placeholder=&quot;验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;../image/验证码1.png&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--注册按钮--&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input id=&quot;register&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;http://www.baidu.com&quot;&gt;立即注册&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/29/%E6%8A%80%E6%9C%AF-html%E5%92%8Ccss/"},{"title":"http&amp;request&amp;response","text":"HTTP 概念：Hyber Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端与服务端通信时，发送数据的格式 特点： 基于TCP/IP的高级协议 默认端口80 基于请求/响应模型：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每次请求都会建立新的连接（非持久连接） 1.1 ：复用连接（持久连接） 请求消息数据格式 请求行 请求方式 请求url路径 请求的协议/版本 GET /login.html HTTP/1.1 请求方式： HTTP协议有其7种请求方式，常用两种 GET: 请求参数在请求行中（在url后）Request URL: http://localhost:8080/demo03?username=12 请求url长度有限制 不安全 POST: 请求参数在请求体中 请求url长度无限制 相对安全 请求头：客户端浏览器告诉服务器一些信息 请求头名称：请求头值 （同样的格式很多行） 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/table.html 告诉服务器“我”从哪里来 作用： 放盗链 统计工作 请求空行 空行，分割作用 请求体（正文） 封装POST请求消息的请求参数的 响应消息：服务器端发送给客户端的数据 数据格式 响应行 组成：协议/版本 响应状态码 状态码的描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的状态 状态码都是3位数字 分类：五大类（具体的去搜百度 http状态码） 1xx：服务器收到客户端消息，但没有接收完成，等待一段时间后，发送1xx多状态码（问客户端，你还有没有消息要发给我） 2xx：成功。代表：200 3xx：重定向。代表：302（重定向），304（服务器上该内容没有更改，去访问缓存） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qSkGOoVl-1589287182468)(http&amp;request&amp;response.assets/image-20200504212311002.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EbZO16bU-1589287182472)(http&amp;request&amp;response.assets/image-20200504212351845.png)] 4xx：客户端错误： 404（请求路径没有对应的资源） 405：请求方式没有对应的doXXX（doGet/doPost..)方法 5xx：服务器端错误. 代表：500（服务器内部出现异常） 响应头 格式：（每行都是）头名称：值 常见的响应头 Content-Type：服务器告诉客户端浏览器本次响应消息体数据格式以及编码格式 Content-dispostion：服务器告诉客户端以什么格式打开响应体数据 值： 默认值：in-line“默认值，在当前页面内打开 attachment；filename=xxx：以附件形式打开响应体。文件下载常用 响应空行 响应体：传输的数据 响应字符串格式 Request web服务的原理 tomcat服务器会根据url中的资源路径，创建对应的ServletDemo01对象 tomcat服务器会创建request对象和response对象，request对象中封装请求消息数据 tomcat将request和response两个对象传递给service方法，并且调用service方法 程序员，可以通过request对象获取请求消息数据，通过response对象设置响应消息数据 服务器在给浏览器做出响应之前，会从response对象中拿程序员设置的响应消息数据 request对象和response对象原理 request对象和response对象是由服务器创建的，我们来使用 request对象用来获取请求消息，response对象用来设置响应消息 request对象继承体系结构 ServletRequest ——接口 | HttpServletRequest ——接口 | org.apache.catalina.connector.RequestFacade 类（tomcat创建的） request功能： 获取请求消息数据 获取请求行数据 get /day14/demo01?name=zhangsan HTTP/1.1 方法 获取请求方法String getMethod() (用的多)获取虚拟目录：/day14String getContextPath() 获取Servlet路径：/demo1String getServletPath() 获取get方式的请求参数:name=zhangsanString getQueryString() (用的多)获取请求URI: /day14/demo1String getRequestURI()String getRequestURL()：http://localhost/day14/demo1 URL：统一资源定位符：中华人民共和国 URI：统一资源标识符：共和国 获取协议及版本：HTTP/1.1String getProtocol() 获取客户机的IP地址String getRemoteAddr() 获取请求头数据 方法 String getHeader(String name)：通过请求头的名称获取请求头的值 (用的少)Enumberation&lt;String&gt; getHeaderNames()：获取所有请求头的名称 (Enumberation，当成迭代器来使用) 12345678//获取所有请求头名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()){ //根据请求头名称获取请求头的值 String name = headerNames.nextElement(); String value=request.getHeader(name); System.out.println(name+&quot;--&quot;+value); } 获取请求体数据 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据（文件上传知识点后讲解） 从流对象中拿数据 1234567//获取请求体流对象 BufferedReader reader = request.getReader(); //读取数据 String line=null; while((line=reader.readLine())!=null){ System.out.println(line); } 其他功能 获取请求参数通用方式(不论是post还是get都可以用一下方式获取参数) 123protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } getParameter(String name)：根据参数名称来获取参数值 getParameterValues(String name)：根据参数名称获取参数值的数组 hobby=learn&amp;hobby=game Enumeration getParameterNames()：获取所有请求的参数名称 Map&lt;String,String[]&gt;getParameterMap()：获取所有参数的map集合 中文乱码问题 get方式：tomcat8已经帮我们解决 post方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;UTF-8&quot;); 请求转发：一种在服务器内部的资源跳转方式（ 多个Servlet配合实现一种功能） 步骤1. 通过request对象获取请求转发器对象 2. 使用RequestDispatcher对象进行转发(其参数是要转向的servlet的地址) * forward（request,response） 特点 浏览器地址栏路径没有发生变化 只能转发到当前服务器内部资源中，无法转发到外部网站 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法 setAttribute(String name，Object obj)：存储数据 getAttribute(String name)：通过键获取值，返回的是obj对象 removeAttribute(String name)：通过键移除键值对 获取ServletContext对象 request.getServletContext() ⭐登录案例需求 编写login.html登录页面 username&amp;password两个输入框 使用Druid数据库连接池，操作mysql数据库 使用jdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名，欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 登录逻辑[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jbPzoW9m-1589287182473)(http&amp;request&amp;response.assets/image-20200502204747437.png)] 具体案例 创建Java EE工程，选择Web Application 取消下面的Create web.xml勾选 在web文件夹下创建WEB-INF，再下面创建lib，将依赖jar包全部放入（mysql驱动，spring的jdbcTemplate，druid连接池）r然后右键lib点击add as library 将druid.properties放在src下（记得修改url） 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 创建数据库环境（创建表，添加数据） 创建包com.hhu.domain,创建User类JavaBean 123456789101112131415161718192021222324252627282930313233343536373839/*User的实体类，JavaBean*/public class User { private int id; private String username; private String password; @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username='&quot; + username + '\\'' + &quot;, password='&quot; + password + '\\'' + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; }} 创建com.hhu.util.JDBCUtils类，使用Druid连接池 12345678910111213141516171819202122232425262728public class JDBCUtils { //静态成员变量：数据库连接池 private static DataSource dataSource; //加载配置文件 static{ Properties properties=new Properties(); InputStream resourceAsStream = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); try { //将配置文件加载到集合中 properties.load(resourceAsStream); //从集合中读取配置，生成数据库连接池 dataSource= DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } //获取数据库连接池 public static DataSource getDataSource(){ return dataSource; } public static Connection getConnection() throws SQLException { return dataSource.getConnection(); }} 创建包com.hhu.dao,创建类UserDao，提供Login方法 12345678910111213141516171819public class UserDao { //声明jdbcTemplate对象，来公用（因为以后很多方法要用到） private JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils.getDataSource()); public User login(User loginUser){ try { //1.编写sql String sql=&quot;select* from user where username=? and password=?&quot;; //2.调用query方法 User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { //e.printStackTrace(); return null; } }} 编写com.hhu.web.servlet.LoginServlet类(和成功/失败Servlet），完成登录逻辑 123456789101112131415161718192021222324252627282930@WebServlet(&quot;/loginServlet&quot;)public class loginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置编码 request.setCharacterEncoding(&quot;UTF-8&quot;); //接收请求参数 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //封装User对象 User loginUser=new User(); loginUser.setUsername(username); loginUser.setPassword(password); //调用DAO实现登录功能 User user = new UserDao().login(loginUser); if(user==null){ request.getRequestDispatcher(&quot;/failServlet&quot;).forward(request,response); } else { //存储 request.setAttribute(&quot;user&quot;,user); //转发 request.getRequestDispatcher(&quot;/successServlet&quot;).forward(request, response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} failServlet 1234567891011121314@WebServlet(&quot;/failServlet&quot;)public class failServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 1234567891011121314151617@WebServlet(&quot;/successServlet&quot;)public class successServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 User user=(User)request.getAttribute(&quot;user&quot;); response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;，欢迎您！&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 最外面那个web目录下创建login.html，注意，login.html中form表单的action路径的写法：虚拟目录+servlet的urlpattern 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/web/loginServlet&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;输入用户名&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;text&quot; placeholder=&quot;输入密码&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; BeanUtils工具类，简化数据封装 用于封装JavaBean JavaBean：标准的java类 类必须被public修饰 必须提供空参的构造器 成员变量必须用private修饰 public修饰的setter和getter 功能：封装数据 方法： setProperty（） getProperty（） populate（Object obj,Map map）：将map集合的键值对信息，封装到对应的JavaBean对象中 概念： 成员变量和属性：属性大多数时候跟成员变量一样，但是实质是setter和getter截取后的产物，特例情况下和成员变量不同 如getUsername() 属性就是username 注意是导入apache下的BeanUtils 12345678910111213141516171819/* //接收请求参数 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //封装User对象 User loginUser=new User(); loginUser.setUsername(username); loginUser.setPassword(password);*/将上面的注释掉，改为下面的 //获取所有请求参数，封装成一个对象 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); User loginUser=new User(); //注意是导入apache下的BeanUtils try { BeanUtils.populate(loginUser,parameterMap); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } Response 功能：设置响应消息 设置相应行 格式：HTTP/1.1 200 ok 状态码设置：setStatus(int sc) 设置响应头 setHeader(String name,String value) 设置响应体 使用步骤： 获取输出流 字符输出流：printWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 案例： 完成重定向 重定向：资源跳转的方式 与前面学的Servlet的转发不同之处在于：Servlet的转发是服务器内部的资源跳转，而重定向是服务器返回消息告诉浏览器去别的Servlet去找资源 代码实现 123456//1.设置状态码为302response.setStatus(302);//2.设置响应头locationresponse.setHeader(&quot;location&quot;,&quot;/web/responseDemo2&quot;);//更为简单的实现重定向的方法response.sendRedirect(&quot;/web/responseDemo2&quot;); 重定向的特点(redirect) 地址栏发生变化 重定向可以访问其他站点（服务器）的资源 重定向是两次请求 转发的特点（forward） 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求（即可以用request.setAttribute()来完成一次请求内部的数据共享） 路径写法： 分类 相对路径：通过相对路径不可以确定唯一资源 如：./index.html 不以/开头，以./开头 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录（可以省略） ../：后退一级目录 （推荐使用）绝对路径：通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo02 可以简写成/day15/responseDemo02 以/开头的路径 规则：判断定义的路径是给谁用的（从谁发出的） 给浏览器使用：需要加虚拟目录（项目的访问路径：）（如重定向，超链接，表单action） 建议虚拟目录动态获取：使用request.getContextPath()获取后拼接到绝对路径前面 给服务器用：不需要加虚拟目录（如Servlet的转发） 服务器输出字符数据到浏览器 步骤 获取字符输出流 输出数据 中文乱码原因： 编码节码使用的字符集不同 PrintWriter pw=response.getWriter()获取的流的默认编码是ISO-8895-1 浏览器字符集：默认GBK（gb2312） 解决办法：获取流之前设置response.setContentType(&quot;text/html;charset=utf-8&quot;); 代码 123456response.setContentType(&quot;text/html;charset=utf-8&quot;);//1.获取字符输出流PrintWriter pw = response.getWriter();//2.输出数据pw.write(&quot;&lt;h1&gt;helloworld&lt;/h1&gt;&quot;);pw.write(&quot;&lt;h1&gt;你好你好你好&lt;/h1&gt;&quot;); 服务器输出字节数据到浏览器 步骤 获取字节输出流 输出数据 代码 12345//1.获取字节输出流 ServletOutputStream outputStream = response.getOutputStream(); //2.输出数据 outputStream.write(&quot;helloworld&quot;.getBytes()); outputStream.write(&quot;你好&quot;.getBytes()); 验证码案例 本质：图片 目的：防止恶意表单注册 略，毕设暂不需要 ServletContext 概念：代表整个web应用，可以和程序的容器（服务器）来通信 获取： 通过request对象获取：request.getServletContext() 通过HttpServlet获取：this.getServletContext() 两种方式获取的ServletContext是同一个（都代表本web应用） 功能： 获取MIME类型： MIME类型：在互联网通信过程中定义的一种文件数类型 格式：大类型/小类型 如text/html、image/jpeg 获取：String getMimeType(String file) 1234ServletContext servletContext = request.getServletContext(); String filename=&quot;a.jpg&quot;; String mimeType = servletContext.getMimeType(filename); response.getWriter().write(mimeType); 域对象：共享数据 setAttribute(String name,object value): getAttribute(String name) removeAttribut4e(String name) ServletContext对象范围：所有用户请求的数据（只要服务器开着，其中的域共享所有数据） 生命周期过长，谨慎使用，容易占用太多内存 获取文件的真实（服务器）路径 web项目的文件有两份，一份在本地的工作空间，另一份在tomcat服务器中，别人访问的都是tomcat中的内容 方法： (重要)getRealPath(String path) getRealPath(“b.txt”)：web目录下资源访问 getRealPath(“/WEB-INF/c.txt”)：WEB-INF目录下的资源访问 getRealPath(“/WEB=INF/classes/a.txt”) src路径下的资源访问 文件下载案例需求： 页面显示超链接 点击超链接之后弹出下载提示框 完成图片文件西在 分析： 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能，则弹出下载 我们的需求：任何资源必须弹出下载提示框 使用响应头设置资源的打开方式： response.setHeader() content-dispostion: attachment;filename=xxx 步骤： 定义页面，编辑超链接href属性，指向一个Servlet，传递资源名称filename 定义Servlet 获取文件的名称 使用字节输入流加载文件进内存（ServletContext获取文件真实路径） 指定response的响应头 content-dispostion: attachment;filename=xxx 将数据写出到response输出流 代码 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;/project/downloadServlet?filename=bg4.png&quot;&gt;图片&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031@WebServlet(&quot;/downloadServlet&quot;)public class downloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取请求参数：文件名称 String filename = request.getParameter(&quot;filename&quot;); //找到文件真实路径 String realPath = this.getServletContext().getRealPath(&quot;/img/&quot; + filename); //加载文件进内存，通过字节流关联 FileInputStream fileInputStream=new FileInputStream(realPath); //设置response响应头 //设置响应头类型 ServletContext servletContext = this.getServletContext();//获取文件的mime类型 response.setHeader(&quot;content-type&quot;,servletContext.getMimeType(filename)); //设置响应头打开方式 response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+filename); //将输入流的数据，写到输出流中 ServletOutputStream outputStream = response.getOutputStream(); byte[]buff=new byte[1024*8]; int len=0; while((len=fileInputStream.read(buff))!=-1){ //不等于-1，说明没有到文件末尾 outputStream.write(buff,0,len); } fileInputStream.close(); //输入流要关，输出流不用 } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} 中文文件名问题解决思路： 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方法不同 工具类： 1234567891011121314151617181920212223242526package cn.itcast.utils;import sun.misc.BASE64Encoder;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;public class DownLoadUtils { public static String getFileName(String agent, String filename) throws UnsupportedEncodingException { if (agent.contains(&quot;MSIE&quot;)) { // IE浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); filename = filename.replace(&quot;+&quot;, &quot; &quot;); } else if (agent.contains(&quot;Firefox&quot;)) { // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;; } else { // 其它浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); } return filename; }} 1234//获取user-agent请求头String agent=request.getHead(&quot;user-agent&quot;);String filename=DownLoadUtils.getFileName(agent,filename);//使用这个filename即可","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-http-request-response/"},{"title":"JDBC学习笔记","text":"JDBC基本概念 Java DataBase Connectivity Java数据库连接，Java语言操作数据库 JDBC本质：是Sun公司定义的一套操作关系型数据库的接口，各个数据库厂商去实现了这套接口，提供数据库驱动jar包。我们可以使用这套接口编程 快速入门 步骤 导入驱动jar包 复制文件到libs目录下(记得把数据库驱动也复制过去) 右键add as library 注册驱动 获取数据库的连接对象Connection（java与数据库的连接桥梁） 定义sql 获取执行sql语句的对象Statement 执行sql，接收返回结果 处理结果 释放资源 如果自定义JDBCUtils，则须在src下创建jdbc.properties 1234url=jdbc:mysql:///db1user=rootpassword=rootdriver=com.mysql.jdbc.Driver 代码实现 12345678910111213141516//1.导入jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db1&quot;, &quot;root&quot;, &quot;123&quot;); //4.定义sql语句 String sql =&quot;update user set name='goodboy' where id=1&quot;; //5.获取执行sql的对象 Statement statement = connection.createStatement(); //6.执行sql int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); connection.close(); 详解各个对象 DriverManager：驱动管理对象 功能： 注册驱动：告诉程序该使用哪个数据库驱动jar（！mysql5以后自动注册） static void registerDriver(Driver driver)：注册与给定的驱动程序DriverManager 写代码使用：Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在存在静态代码块 获取数据库连接 ： 方法：getConnection(String url,String user,String password) 参数 url:指定连接的路径 mysql语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称 例子：jdbc:mysql:..localhost(127.0.0.1):3306/bd1 细节：如果连接的是本机的mysql服务器，并且mysql服务默认端口是3306，则url可以简写为jdbc:mysql:///数据库名称 user：数据库用户名 password：数据库密码 Connection：数据库连接对象 功能 获取执行sql的对象 createStatement() prepareStatement(String sql) 管理事务 开启事务： setAutoCommit(boolean autoCommit)：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql)：可以执行任意sql，了解即可不常用 int excuteUpdate(String sql)：执行DML（增删改insert，update，delete）语句，（DDL不常用）DDL（create,alter,drop) 返回值：影响的行数。&gt;0执行成功 （最常用）ResultSet excuteQuery(String sql)：执行DQL（Select）语句 ResultSet：结果集对象,封装查询结果 boolean next()：游标向下移动衣阿华那个 getXxx(参数)：获取数据 Xxx：代表数据类型 如getInt() getString() 参数： int：代表列的编号，从1开始 String：代表列名称。如getString(“name”); 使用步骤 游标向下移动一行 判断是否有数据(看next的返回结果，如果为false则该行没数据 ) 获取数据 练习 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回（注意double类型接收数据库的小数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 查询emp表然后将结果封装成一个对象，然后放入集合，返回*/public class JDBC_demo05 { /*查询emp所有对象*/ public static List&lt;User&gt; findAll(){ Connection connection=null; Statement statement=null; ResultSet resultSet=null; ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 connection= DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //3.创建sql String sql=&quot;select*from user&quot;; //4.执行sql statement=connection.createStatement(); resultSet = statement.executeQuery(sql); //5.处理结果 while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(statement!=null) statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } return list; } public static void main(String[] args) { List&lt;User&gt; all = JDBC_demo05.findAll(); for(User user:all){ System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getGender()); } }} PreparedStatement：执行sql的对象（是Statement的子接口） SQL注入问题：在拼接sql时，有一些sql的特殊关键词参与字符串的拼接。会造成安全性问题 用户名随便，密码输入 a’ or ‘a’=’a’ sql: select*from user where username=xxx and password=’a’ or ‘a’=’a’,查询条件变成了恒等式 解决：使用PreparedStatement对象来解决 预编译的SQL：参数？作为占位符 步骤： 导入驱动jar包 注册驱动 获取数据库连接对象COnnection 定义sql 注意：sql的参数使用？作为占位符 获取PreparedStatement对象：Connection.getPreparedStatement(String sql) 给？赋值 方法：setXxx（参数1，参数2） 参数1：？的位置编号，从1开始 参数2：？的值 注意：后期都会使用PreparedStatement来完成增删改查的所有工作 可以防止SQL注入 效率更高 代码实现 1234567891011121314151617181920212223242526272829303132333435public class JDBC_demo03_标准 { public static void main(String[] args) { Connection connection=null; Statement statement=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;insert into user values(3,'小小余','男')&quot;; //5.执行 statement = connection.createStatement(); int result = statement.executeUpdate(sql); //6.打印结果 if(result&gt;0) System.out.println(&quot;执行成功！&quot;); else System.out.println(&quot;执行失败！&quot;); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041public class JDBC_demo04_excuteQuery { public static void main(String[] args) { Connection connection=null; Statement statement=null; ResultSet resultSet=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;select*from user&quot;; //5.执行 statement = connection.createStatement(); resultSet=statement.executeQuery(sql); //6.打印结果 while(resultSet.next()){ int id=resultSet.getInt(&quot;id&quot;); String name=resultSet.getString(&quot;name&quot;); String gender=resultSet.getString(&quot;gender&quot;); System.out.println(id+&quot;/&quot;+name+&quot;/&quot;+gender); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 抽取JDBC工具类：JDBCUtils 目的：简化书写 案例： User: 封装了数据库表的JavaBean 1234567891011121314151617181920212223242526272829303132333435363738394041public class User { private int id; private String name; private String gender; @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, gender='&quot; + gender + '\\'' + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public User() { }} JDBCUtils工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; //静态代码块加载配置文件,**静态代码块随着类的加载而加载，只执行一次** static { Properties properties=new Properties(); //获取src路径下的文件的方式——&gt;ClassLoader类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL propertiesURL = classLoader.getResource(&quot;jdbc.properties&quot;); try { properties.load(new FileReader(propertiesURL.getPath())); } catch (IOException e) { e.printStackTrace(); } url=properties.getProperty(&quot;url&quot;); user=properties.getProperty(&quot;user&quot;); password=properties.getProperty(&quot;password&quot;); driver=properties.getProperty(&quot;driver&quot;); //注册驱动 try { Class.forName(driver); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //获取Connection对象 public static Connection getConnection(){ Connection connection=null; try { connection= DriverManager.getConnection(url, user, password); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //执行sql语句,实现增删改 public static void update(String sql){ Connection connection=getConnection(); Statement statement=null; int result=-1; try { statement = connection.createStatement(); result = statement.executeUpdate(sql); if(result&gt;0) System.out.println(&quot;执行成功！&quot;); } catch (SQLException throwables) { throwables.printStackTrace(); }finally { closeUpdate(connection,statement); } } //update后关闭资源 public static void closeQuery(Connection connection, ResultSet resultSet, Statement statement){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } } //query后关闭资源 public static void closeUpdate(Connection connection,Statement statement){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 实现增删改 1234567public class JDBC_demo06 { public static void main(String[] args) { Connection connection= JDBCUtils.getConnection(); String sql=&quot;insert into user values(4,'小小余','女')&quot;; JDBCUtils.update(sql); }} 实现查询 12345678910111213141516171819202122232425262728public class JDBC_demo07 { public static void main(String[] args) { Statement statement=null; ResultSet resultSet=null; String sql=&quot;select*from user&quot;; Connection connection= JDBCUtils.getConnection(); ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { statement=connection.createStatement(); resultSet=statement.executeQuery(sql); while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (SQLException throwables) { throwables.printStackTrace(); } JDBCUtils.closeQuery(connection,resultSet,statement); for(User user:list){ System.out.println(user); } }} JDBC控制事务 事务：一个包含多个步骤的业务操作 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 setAutoCommit(boolean autoCommit（）：调用该方法，设置参数为false，即开启事务 在执行sql之前开启事务 commit()：提交事务 当所有sql都执行完提交事务 rollback()：回滚事务 在catch中回滚事务 数据库连接池 概念：其实就是一个容器（集合）：存放数据库连接的容。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户访问数据库时，从容器中获取连接对象，用户访问完后，会将对象归还给容器 好处 节约资源 高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：如果连接对象COnnection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还到连接池中 一般我们不去实现它，由数据库厂商来实现 C3P0：数据库连接池技术（老） Druid（德鲁伊）：由阿里巴巴来实现的 C3P0 略 Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂类来获取DruidDataSourceFactory 获取连接：getConnection() 代码实现 1234567891011//1.导入jar包，放入libs，右键add as library//2.定义配置文件，赋值，放在src下(记得修改一下url）//3.加载配置文件Properties properties=new Properties();InputStream inputStream = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);properties.load(inputStream);//4.获取连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//5.获取连接Connection connection=dataSource.getConnection();System.out.println(connection); 定义工具类 定义一个类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源： 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*Druid连接池的工具类*/public class JDBCUtils_Druid { //1.定义成员变量DataSource private static DataSource dataSource; static{ //1.加载配置文件 Properties properties=new Properties(); InputStream inputStream = JDBCUtils_Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); try { properties.load(inputStream); dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } //2.获取连接的方法 public static Connection getConnection(){ Connection connection=null; try { connection=dataSource.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //3.释放资源 public static void close(Statement statement,Connection connection){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); //归还连接 } catch (SQLException throwables) { throwables.printStackTrace(); } } } public static void close(ResultSet resultSet,Statement statement, Connection connection){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } close(statement,connection); } //4.获取连接池的方法 public static DataSource getDataSource(){ return dataSource; }} Spring JDBC Spring框架提供的JDBC简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 (记得还导入mysql驱动) 创建JdbcTemplate对象。依赖于数据源DataSource（数据库连接池） JdbcTemplate template=new JdbcTemplate(ds); 调用方法来完成crud操作 update()：执行DML语句 （增删改） queryForMap（）：查询结果将结果集封装为Map集合，只能查询结果为1个的语句 queryForList（）：查询结果将结果集封装为List集合 query()：查询结果，将结果封装为JavaBean对象 query的参数：RowMapper接口 一般我们使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装 例：new BeanPropertyRowMapper(Person.class) queryForObject（）：查询结果，将结果封装为对象（一般用于聚合函数的查询） ```java //1.导入jar包，加入library //2.创建JdbcTemplate对象，参数是数据库连接池 JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); //3.调用方法 String sql=&quot;update account set balance =100 where id=?&quot;; int result = jdbcTemplate.update(sql, 2); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* 练习： * **注意！JavaBean在封装时成员变量最好写成封装类型Integer Double等，否则在调用template进行封装时会出现，如果某个值为null就会报错** * 需求 1. 修改数据 2. 增加记录 3. 删除记录 4. 查询一定条件的结果，封装为map集合 5. 查询所有记录，分装为list 6. 查询所有记录，封装为emp对象的list集合 7. 查询总记录数（count聚合函数） ```java public class demo04_test { @Test public void test01(){ //查询结果以map的方式返回,**查询结果只能为1个** JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(&quot;select*from account where id=1&quot;); System.out.println(stringObjectMap); } @Test public void test02(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select*from account&quot;); System.out.println(list); } @Test public void test03(){ //遍历所有，将每行的结果封装为一个JavaBean JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new RowMapper&lt;Person&gt;() { @Override public Person mapRow(ResultSet resultSet, int i) throws SQLException { Person p = new Person(); p.setId(resultSet.getInt(&quot;id&quot;)); p.setBalance(resultSet.getInt(&quot;balance&quot;)); p.setName(resultSet.getString(&quot;name&quot;)); return p; } }); System.out.println(personList); } //简化版封装JavaBean @Test public void test04(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new BeanPropertyRowMapper&lt;Person&gt;(Person.class)); System.out.println(personList); } //查询记录条数 @Test public void test05(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Integer integer = jdbcTemplate.queryForObject(&quot;select count(*)from account&quot;, Integer.class); System.out.println(integer); } }","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"B树与B+树","text":"本文转载自http://www.cnblogs.com/nullzx/，主要介绍了B树和B+树的插入、删除操作。 B树B树的定义B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。 一颗m阶的B树定义如下： 1）每个结点最多有m-1个关键字。 2）根结点最少可以只有1个关键字。 3）非根结点至少有Math.ceil(m/2)-1个关键字。 4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。 上图是一颗阶数为4的B树。在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。我们将一个key和其对应的data称为一个记录。但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体。在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速速，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。 B树的插入操作插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。 1）根据要插入的key的值，找到叶子结点并插入。 2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。 3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。 下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key a）在空树中插入39 此时根结点就一个key，此时根结点也是叶子结点 b）继续插入22，97和41 根结点此时有4个key c）继续插入53 插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。 d）依次插入13，21，40，同样会造成分裂，结果如下图所示。 e）依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。 f）插入key值为26的记录，插入后的结果如下图所示。 当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。 进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。 分裂后当前结点指向新的根，此时无需调整。 g）最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。 在实现B树的代码中，为了使代码编写更加容易，我们可以将结点中存储记录的数组长度定义为m而非m-1，这样方便底层的结点由于分裂向上层插入一个记录时，上层有多余的位置存储这个记录。同时，每个结点还可以存储它的父结点的引用，这样就不必编写递归程序。 一般来说，对于确定的m和确定类型的记录，结点大小是固定的，无论它实际存储了多少个记录。但是分配固定结点大小的方法会存在浪费的情况，比如key为28,29所在的结点，还有2个key的位置没有使用，但是已经不可能继续在插入任何值了，因为这个结点的前序key是27,后继key是30,所有整数值都用完了。所以如果记录先按key的大小排好序，再插入到B树中，结点的使用率就会很低，最差情况下使用率仅为50%。 B树的删除操作删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。 1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步 2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。 3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。 否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。 有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。 下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key a）原始状态 b）在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。 c）在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。 删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。 d）在上述情况下接着32，结果如下图。 当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。 当前结点key的个数满足条件，故删除结束。 e）上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。 同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。 同理，对于当前结点而言只能继续合并了，最后结果如下所示。 合并后结点当前结点满足条件，删除结束。 B+树B+树的定义 各种资料上B+树的定义各有不同，一种定义方式是关键字个数和孩子结点个数相同。这里我们采取维基百科上所定义的方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。上图就是一颗阶数为4的B+树。 除此之外B+树还有以下的要求。 1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。 2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。 3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。 4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 B+树的插入操作1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。 2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。 3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。 下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。 a）空树中插入5 b）依次插入8，10，15 c）插入16 插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。 当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。 d）插入17 e）插入18，插入后如下图所示 当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。 当前结点的关键字个数满足条件，插入结束。 f）插入若干数据后 g）在上图中插入7，结果如下图所示 当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。 当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。 当前结点的关键字个数满足条件，插入结束。 B+树的删除操作如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤 1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。 2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。 3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。 4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步 5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步 6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。 注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。 下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。 a）初始状态 b）删除22,删除后结果如下图 删除后叶子结点中key的个数大于等于2，删除结束 c）删除15，删除后的结果如下图所示 删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。 d）删除7，删除后的结果如下图所示 当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。 此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。","link":"/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-B%E6%A0%91%E4%B8%8EB-%E6%A0%91/"},{"title":"内存管理","text":"内存的基础知识什么是内存？有何作用CPU运行速度大大快于硬盘，需要一个介于CPU和硬盘中间速度的介质来缓和这个矛盾，即内存。因此，程序执行前需要先放到内存中才能被CPU处理。 思考：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？ 存储单元和内存地址一个内存地址对应一个存储单元，存储单元的大小取决于计算机是按字节编址还是按字编址 进程运行的基本原理从写程序到程序运行：编辑—编译—链接—装入编译：由编译程序将用户源代码编译成若干目标模块（编译就是把高级语言翻译为机器语言） 链接：由链接程序将边以后形成的一组目标模块，以及所需要的库函数链接在一起，形成一个完成的装入模块装入（装在）：由装入程序将装入模块装入内存运行。（链接后，形成完成的逻辑地址） 装入时才关心逻辑地址到物理地址的转换 三种链接方式静态链接 在程序运行前，先将各自目标模块及它们所需的库函数连接成一个完成的可执行文件（装入模块），之后不再拆开。 装入时动态链接 将各目标模块装入内存时，边装入边链接的链接方式 运行时动态链接 在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。 三种装入方式说白了，绝对装入就是编译完地址都是绝对地址；静态重定位就是装入的时候将逻辑地址改为物理地址；动态重定位是运行时才将逻辑地址转换为物理地址。 绝对装入 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码（指令）。装入程序按照装入模块中的地址，将程序和数据装入内存。 Eg：如果知道装入模块要从地址为100的地方开始存放，则 绝对装入只适用于单道程序环境，灵活性很低。程序中使用的绝对地址，可以在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。 静态重定位 又称为可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变为物理地址（地址变换是在装入时一次性完成的）。 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。 动态重定位 现在的计算机系统一般都采用动态重定位方式。 动态重定位：又称为动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。 内存管理内存空间的分配和回收讨论的问题：操作系统要怎么记录哪些内存区域已经被分配出去了，哪些是空闲的？很多位置都可以放，进程那应该放在哪里？当进程运行结束之后，如何将进程占用的内存空间回收？ 连续分配管理方式连续分配：指为用户进程分配的必须是一个连续的内存空间。 单一连续分配 在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户程序独占整个用户区空间。 优点： 实现简单；无外部碎片（不可利用的外部空间）； 可以采用覆盖技术扩充内存（程序分段，内存分固定区和覆盖区）； 不一定需要采用内存保护。 缺点： 只能用于单用户、单任务的操作系统中； 有内部碎片（分配给某个进程的内存区域中，如果有些部分没有利用，就是内部碎片）； 存储器利用率极低。 固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。 （作业是应用层的概念，指的是某项任务，至少依赖一个进程来完成） 分区大小相等：缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合（比如，钢铁厂有n个炼钢炉，就可以把内存分为n个大小相等的区域存放n炼钢炉控制程序） 分区大小不等：增加了灵活性，可根据实际需求划分内存。（使用分区说明表，记录每个分区的大小、起始地址、状态） 优点： - 实现简单 - 无外部碎片 缺点： 当用户程序太大时，可能所有的分区都不满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能 会产生内部碎片，内存利用率低（所有内存已经被分区，不存在外部碎片） 动态分区分配动态分区分配又称为可变分区分配。这种分区方式不会预先划分内存区域，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。 问题1：系统要用什么样的数据结构来记录内存的使用情况？ 问题2：当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？ 四种动态分区分配算法 最佳适应 Best Fit 最差适应 Worst Fit 首次适应 First Fit 循环适应(邻近适应算法) Next Fit 问题3：如何进行分区的分配与回收操作？ 回收后与根据具体情况需要与前后合并。 分区分配增加表项，具体排列方式需要根据动态分区分配算法来确定。 动态分区分配没有内部碎片，但是有外部碎片。 （内部碎片：分配给某进程的内存区域中，某些没有利用上；外部碎片，指内存中的某些控线分区由于太小而难以利用） 紧凑技术不能使用绝对装入（绝对装入在编译时即确定物理地址）和静态重定位（装入时确定物理地址），采用动态重定位的装入方式比较合适。 紧凑之后需要做什么处理：修改PCB，调整进程起始地址。 非连续分配管理方式考虑支持多道程序设计的两种连续分配方式 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低 动态分区分配：会产生很多外部碎片，虽然可以用紧凑技术来处理，但是其时间代价很高 基本分页存储管理基本分页存储管理的思想：把内存分为一个一个相等的小分区，再按照分区大小把进程拆成一个个小部分 将进程地址分页之后，操作系统该如何实现逻辑地址到物理地址的转换？ 关于此问题我的想法：将进程地址空间分页后，不同页面映射到内存中的不同页框中，想要将某逻辑地址（某个存储单元，如果按字节编址则是一个字节，如果按字编址则是一个字）转换为物理地址，则先计算两样东西，1.在哪个页面 2.页内偏移量。 然后找出该页面对应的页框，再根据偏移量即可计算出最终的物理地址。 注：页号=逻辑地址/页面大小，业内偏移量=逻辑地址%页面大小 页表 *基本地址变换机构用于实现逻辑地址到物理地址转换的一组硬件机构 这里可以看出CPU进行上下文切换时候，会从接下来要执行的进程的PCB中读取一系列信息并写入寄存器中，包括页表始址、页表长度，进程中下一条指令的逻辑地址（放入程序计数器PC中） *具有快表的地址变换机构1.局部性原理 时间局部性：如果执行了程序中的某条指令，那么不就后其很可能再次被执行；如果某个数据被访问过，不久之后其很可能再次被访问。（因为程序中存在大量的循环） 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）。 2.什么是快表TLB 快表，又称为联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲器（不在内存中），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常成为慢表。 3.引入快表后，地址的变换过程 *两级页表单级页表存在的问题 需要给每个进程都分配连续的1024个页框，违背了离散分配的初衷。 如何解决单级页表的问题？ 基本分段存储管理 *分段、分页管理的对比 段页式存储管理 内存空间的扩充GTA5大小超过60GB，而系统内存只有16GB，为什么这款游戏可以顺利运行呢？ 答：因为使用了虚拟技术（OS的虚拟性） 覆盖技术思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段需要时调入内存。 内存中分为一个固定区和若干覆盖区。 需要常驻内存的段放在固定区中，调入后就不再调出（除非运行结束）。 不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存。 （注意：这里B、C不会被A同时调用，DEF也不会被同时调用） 优点：逻辑上，内存被拓展了。 缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已经成为历史。 交换技术思想：内存紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度），属于中级调度。 中级调度（内存调度）：就是要决定将哪个处于挂起状态的进程重新调入内存。 挂起状态：暂时换出外存等待的进程状态称之为挂起状态suspend，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。 三个问题 一. 应该在外存的什么位置保存被换出的进程？ 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。 由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出的速度，因此通常对换区采用连续分配方式。总之，对换区的IO速度比文件区的更快。 **二.**什么时候应该交换？ 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。 例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。‘ **三.**应该换出哪些进程？ 可优先换出阻塞进程； 可换出优先级低的进程； 为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间； （注意：PCB会常驻内存，不会被换出外存，OS是根据PCB来对并发执行的进程进行控制和管理的） 覆盖技术与交换技术的区别：覆盖是在同一个程序或进程中的，交换是在不同进程（或作业）之间的。 虚拟存储技术 传统存储管理方法的缺点： 一次性：作业必须一次性全部装入内存后才能开始运行（覆盖技术一定程度上可以缓解）。这会造成两个问题： 作业很大时，不能全部装入内存，导致大作业无法运行 大量作业要求运行时，由于内存无法容纳所有作业，因此只能有少量作业运行，导致多道程序并发度下降 驻留性：一单作业被装入内存，就会一直驻留在内存中，直到作业运行结束。事实上，根据局部性原理，在一个时间段内，只需要访问作业的一小部分数据就可以正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。 局部性原理： 时间局部性：如果一个指令或者数据被访问，那么稍后很可能还被访问（因为程序中存在大量循环） 空间局部性：如果一个数据被访问，内存中他附近的数据接下来很可能被访问（因为很多数据在内存中都是连续存储的） 虚拟内存的定义和特征： 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存**，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是虚拟内存。（操作系统虚拟性的一个提现，实际的物理内存大小没有变，知识在逻辑上进行了扩充） 易混淆知识点： 虚拟内存的最大容量：由CPU寻址范围确定（寻址，寻的是内存地址） 虚拟内存的实际容量：min(内存和外存容量之和，CPU寻址范围) 虚拟内存三大特征 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 如何实现虚拟内存技术 虚拟内存的实现需要建立在离散分配的内存管理方式基础上。 虚拟内存最重要的两个技术：请求调页(段)，页面置换(段置换)。 一个进内存、一个出内存。 请求分页存储管理 地址转换为了使编程更方便，程序员写程序时应该只关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 地址转换的实现方式 ，即三种装入方式： 绝对装入：编译时产生绝对地址（单道程序阶段使用，还没产生操作系统，由编译器实现） 可重定位装入（静态重定位）：装入时将逻辑地址转换为物理地址（用于早起的多道批处理操作系统） 动态运行时装入（动态重定位）：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器（现代操作系统） 存储保护操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。 内存保护可采取的两种方法： 在CPU中设置一对上下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。 采用重定位寄存器（又称为基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。 本博客所用图片，均来自B站王道操作系统视频的截图。","link":"/2021/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"论文精读","text":"溯源相关1、Cross-App Poisoning in Software-Defined Networking解决的问题 CAP攻击会毒害SDN（软件定义网络）控制器和其他SDN应用程序看到的网络视图的完整性，现在的RBAC解决方案不足以解决这个问题，本文提出基于溯源的防御provsdn，能够解决这个问题。 2、Linked Data Processing Provenace解决的问题 关联数据的增长为数据探索创造了一个有前景的环境，越来越多的工具允许用户交互式地集成来自不同源的数据。然而，要获得这种特别集成过程的结果的可靠性，一致性地重现结果，并在重新执行时识别更改，是比较困难的。 因此本文提出一种自动过程溯源跟踪创建的方法。 3、 Managing Provenance of Implicit Data Flows in Scientific Experiments解决的问题 为科学工作流建模的科学实验可能会创建、更改和访问工作流规范中没有明确引用的数据产品，从而导致隐式数据流。由于缺乏堆隐式数据流的了解，这些实验很难理解和重现。 本文提出一种即使在隐式数据流中也能识别数据产品的创建、更改和访问的方法。 4、Taming the Costs of Trustworthy Provenance through Policy Reduction解决的问题 自动溯源收集带来的过度存储负担威胁着它的实际价值，本文提出一种基于策略的溯源过滤方法来克服这一障碍。 5、Upsring: Provenance for Large-Scale Analytics Environments解决的问题 现代分析学创造了奇迹，但复制和验证这些奇迹是困难的。数据溯源通过收集关于如何创建和访问数据的信息来帮助解决这个问题。尽管溯源收集技术在较小规模上已经成功应用，但在大规模分析环境中跟踪溯源仍然是一个挑战，因为生成溯源的规模和异质性域。没有溯源，分析师很难追踪和重现他们的分析。 6、Abstracting PROV provenance graphs: A validity-preserving approach解决的问题 当来源内容敏感并受到披露限制时，需要有一种方法，在将溯源的部分内容传达给某些当事人之前，以一种原则性的方式隐藏部分来源。 7、Secure Provenance of Electronic Records Based on Blockchain解决的问题 目前电子记录的来源是集中存储的，集中方式存在巨大风险。 本文提出一种基于区块链的，分布式的安全的电子记录溯源保障技术，保证溯源信息的真实性、完整性、保密性和可靠性。 8、Decentralised provenance for healthcare data解决的问题 通过区块链溯源系统，来管理患者记录信息。 9、SmartProvenance: A Distributed,Blockchain Based Data Provenance System解决的问题： 为了避免数据欺骗，如伪造资料、漏报和伪造结果，提高研究的透明度和可信度，需要进行溯源 传统溯源是集中式的，容易受到攻击，需要改造成分布式的（区块链） 溯源过程要保护隐私 提出的方案： 作者使用区块链开发一个安全和防篡改的科学数据（如医学研究数据）溯源管理框架，以促进可信的数据溯源收集、验证和管理，可以安全地捕获和验证溯源数据，防止对捕获的数据进行任何恶意修改。 10、Decentralised provenance for healthcare data解决的问题 患者的医疗数据分布在各个医疗机构中，造成数据孤岛。 本文设计了一个区块链溯源的电子医疗记录的平台来透明地管理患者记录的溯源。 11、Decision Provenance: Harnessing data flow for accountable systems解决的问题 通过决策溯源，来促进监督、审计、合规、风险缓解和用户授权。 物联网相关1、Secure and Efficient Distributed Network Provenance for IoT: A Blockchain-Based Approach解决的问题 物联网的分布式特性导致溯源数据需要在不同的信任域进行管理，这引发了对跨域网络诊断的安全性、可信任度的担忧。 因此本文提出一种基于区块链的物联网分布式溯源方法。 2、Data Provenance for IoT With Light Weight Authentication and Privacy Preservation解决的问题 在物联网系统中开发了一种具有身份验证和隐私保护的数据溯源安全协议。 与目前最先进的协议相比，所需能量大大降低。 2、Blockchain-based Data Provenance for the Internet of Things解决的问题 物联网设备收集和提供的数据，可以通过数据溯源结合区块链的方案加强其可信度。 现有的方案没有解决物联网应用及其数据的异构特性。（本文提出了一个框架解决此问题） 未解决的问题 在可扩展性和隐私性方面存在一定的局限性。（文章指出状态通道、零知识证明、侧链等技术或许能够帮助解决这些缺陷） 3、An Index-Based Provenance Compression Scheme for Identifying Malicious Nodes in Multihop IoT Network解决的问题 物联网中的溯源数据，随着所经历的跳数的增加，数据源的规模将迅速增加，这与物联网设备的能源、存储、资源限制相冲突。 针对这一问题，本文提出了一种基于索引的数据源压缩算法。 4、A secure and extensible blockchain0based data provenance framework for the Internet of Things解决的问题 物联网中，区块链数据溯源解决方案未能考虑到物联网应用程序及其数据的异构性。 本文提出了一种安全、可扩展的物联网数据溯源架构。 5、Light-Weight Security and Data Provenance for Multi-Hop Internet of Things解决的问题 由于物联网中能源和存储空间的限制，加密解决方案不适用于物联网的小型和低能耗设备，因此Iot安全协议需要轻量化。 本文提出一种用于保护数据和实现数据溯源的轻量级协议。 6、Provenance-enabled packet path tracing in the RPL-based internet of things解决的问题 物联网网络的溯源管理面临着一些挑战，例如低能耗、带宽消耗和高效存储。 本文提出一种协议，进行优化。 7、A Lightweight Protocol for Secure Data Provenance in the Internet of Things Using Wireless Fingerprints解决的问题 现有的iot数据溯源工作基于复杂的计算或者昂贵的硬件，这对物联网系统来说可能不可行。 本文使用分析模型开发了一种基于阈值的机制，在IoT系统中建立数据溯源。 （提出的协议，使用从无线信道中提取的指纹来实现数据溯源、相互认证和匿名） 8、A secure and extensible blockchain-based data provenance framework for the internet of things解决的问题 通过区块链数据溯源，提高iot设备收集和提供数据的可信度。 此外，由区块链造成的可伸缩性和隐私的限制，文中提出了多种解决方案。 9、Secure and Provenance Enhanced Internet of Health Things Framework: A Blockchain Managed Federated Learning Approach解决的问题 健康物联网中必须为数据提供溯源，保护数据的隐私和安全性。 10、Enhancing transparency of MQTT brokers for IoT applications through provenance streams 解决的问题 iot系统产生和使用的个人数据如果被未经授权的代理使用，可能会侵犯用户隐私； 记录物联网系统行为的来源可以支持评估机制，确保系统组建符合数据访问限制。 提出的方法 本文描述了一种使用溯源的MQTT代理，该代理增强了记录消息转发期间实际代理行为的能力 11、Secure Data Provenance in IoT Network using Bloom Filters 解决的问题 物联网中溯源框架容易 ·遭到攻击，因为攻击者可以操纵溯源机制使用的数据和元数据，因此需要一种安全的溯源机制 由于物联网设备的计算和存储资源有限，因此这种安全机制需要高效且轻量。 提出的方法 本文提出使用布隆过滤器和外包属性加密，设计一种使用较少存储的物联网安全溯源机制 12、Prov-IoT: A Security-Aware IoT Provenance Model提出的方法，解决的问题： 物联网数据溯源，缺乏安全元数据 本文提出一种带有安全元数据的溯源模型 13、基于联盟练的物联网动态数据溯源机制解决的问题 物联网系统中，拒绝非授权用户对iot数据的修改，对iot动态数据操作的过程进行留痕和溯源 解决大量物联网设备产生的动态数据的安全存储和共享 14、Genoma: Distributed Provenance as a Service for IoT-based Systems解决的问题 现有的IoT溯源方法大多与底层数据处理框架紧密耦合，本文提出一种与物联网系统中底层数据处理分离的，溯源即服务模型PASS（Provenance as a service)，实现跨物联网设备、边缘和云的分布式溯源。 15、Data Provenance Model for Internet of Things(IoT) Systems解决的问题 提出一种物联网系统数据溯源的模型，以确保物联网应用程序的正确性和完整性 16、Securing Data Provenance in Internet of Things Systems解决的问题 为了使得物联网能够用于关键和敏感用例，需要 通过确保和验证这些应用中处理的数据的完整性和正确性来提高它们的可靠性 充分考虑隐私和保密问题 提出的方案 本文提出一种基于区块链技术和保密策略的加密溯源数据保护和访问控制框架 17、Towards Provenance Integration for Field Devices in Industrial IoT Systems解决的问题 工业互联网正在变得越来越复杂，为了应对这种复杂性并促进异构设备之间的进一步互操作性，需要全面了解现场设备和相关过程的不同类型的溯源信息。 提出的方案 本文研究了这种溯源与W3C物联网和当前工业标准的潜在集成，以实现更容易解释、更高效、更安全的工业物联网系统。 18、Data Provenance for IoT using Wireless Channel Characteristics and Physically Unclonable Functions解决的问题 本文采用信息论的方法来解决物联网系统中的数据溯源问题。 用屋里上不可克隆功能证明数据来源 使用接受信号强度指示器RSSI测量无线指纹来验证数据的物联网设备位置 19、云相关1、OptDebug: Fault-Inducing Operation Isolation for DataFlow Applications解决的问题 云环境下的大规模数据处理中，故障隔离是一个极具挑战性的问题，数据溯源是一种主要的现有方法，用于隔离对给定输出相关的数据记录。然而，数据溯源只涉及数据空间中的故障隔离，而不是代码空间的故障隔离。 本文提出的OptDebug，能够识别数据流应用程序中导致故障的操作。 2、ProvChain: A Blockchain-based Data Provenance Architecture in Cloud Environment with Enhanced Privacy and Availability解决的问题 安全的数据溯源对数据问责、取证和隐私极为重要。本文利用区块链技术，提出一种分散可信的云数据溯源架构ProChain，以较低的开销为云存储应用提供放防篡改溯源、用户隐私和可靠性等安全特性。 3、Cloud data provenace using IPFS and blockchain technology解决的问题 云存储的数据完全由云服务商掌控，存在安全隐患 集中式的管理存在安全隐患 4、Cloud infrastructure provenance collection and management to reproduce scientific workflows exection（18年）解决的问题 云计算的出现为科学工作流的执行提供了新的计算范式，随着实验数据规模的不断扩大器和处理工作流程的日益复杂，对重现性的需求也变得必不可少。 溯源是一种验证工作流程并提供流程可重复性的机制。 本文提出一种使用云感知溯源重现科学工作流执行的框架。 5、Attribute-based cloud storage with secure provenance over encrypted data（18年）解决的问题 为了云存储的安全性，需要设计一中云数据存储系统，通过加密保护存储服务器的数据隐私、允许细粒度的访问控制、支持数据提供者匿名和可追溯，通过提供无可辩驳的证据来证明谁在云中创建和修改了数据，从而提供安全的数据溯源。 6、Pipeline provenance for cloud-based big data analytics（2020）解决的问题 云环境中相关的数据科学和工程中，溯源信息有时是非常关键的。在数据分析中，有必要作出数据驱动的决策以追溯历史并重现最终或中间结果，甚至以实时的方式调整模型和调整参数。 特别在云中，用户需要评估数据和管道的可信度。 **提出的解决方案 ** 本文提出一种解决方案，为了实现这些大数据溯源的功能，需要改造数据管道或者一些大数据软件的基础设施，为管道事件生成结构化日志，然后将日志和数据分别存储在云中空间。 7、Multimedia access control with secure provenance in fog-cloud computing networks（2020）解决的问题 多媒体数据大多具有知识产权保护或具有高度敏感性，为了应对其共享和传播过程中的隐私泄露，追溯数据来源和转化历史很重要。 本文在雾计算网络中构建了具有溯源的多媒体访问控制系统。（基于属性加密和零知识技术）。 8、Towards building snapshot based provenance system for virtual machines in the cloud environment（2019）解决的问题 解决云中取证的问题。（云中多租户、快速弹性、多样性和复杂性给云取证带来了额外的挑战） 9、Provenance based data integerity checking and verification in cloud environments解决的问题 解决云中溯源链的保护问题。 10、Scientific Workflow Mining in clouds解决的问题 计算云已经成为部署和执行科学工作流的首选平台。需要通过溯源以实现实验结果的再现。 AI和大数据相关1、Influence-Based Provenance for Dataflow Applications with Taint Propagation解决的问题 调试大数据分析通常需要进行根源问题分析，以查明输入数据集中导致异常输出的源记录，现有的调试或数据溯源方法无法跟踪用户定义的应用程序代码中的细粒度控制和数据流，因此通常返回的源数据太大，无法进行手动检查，并且需要昂贵的事后分析。 2、Kakute: A Precise, Unified Information Flow Analysis System for Big-data Security解决的问题 大数据框架（如Spark）能够对第三方产生的海量数据进行计算，会导致信息泄露、编程错误等各种安全可靠性问题。现有的信息流跟踪系统对大数据框架来说既不高效也不完整。 3、LAMP: Data Provenance for Graph Based Machine Learning Algorithms through Derivative Computation解决的问题 数据溯源跟踪能够确定一个给定输出相关的一系列输入数据，这使得工程中的质量控制和问题诊断称为可能。大多数现有技术都是通过跟踪程序依赖关系来工作的，无法定量评估相关输入的重要性，而这对机器学习算法至关重要。 本文提出一种机器学习算法的溯源计算系统LAMP，其在数据工程的问题诊断中具有潜力。 4、SAC: A System for Big Data Lineage Tracking解决的问题 在大数据时代，一个数据处理流程包含各种类型的任务。要发现从其源到目标的数据流/移动，以便在企业环境中监视不同的转换和跳跃，这不是一件容易的事。因此，了解数据沿途如何转换、表示和参数如何更改，以及数据在每一跳之后如何拆分或汇聚，数据沿袭或溯源都很有用。然而，现有系统对分布式计算设置中的此类用例提供的支持有限。 5、Auditing Data Provenance in text-generateion models解决的问题 审计个人数据是否被作为训练数据被深度学习模型所使用。（帮助执行GDPR等数据保护法规，检测个人数据的非授权使用） 6、Capturing and querying structural provenance in spark with pebble解决的问题 分析和调试Spark processing pipelines是一项很繁琐的工作，尤其是在处理嵌套数据时。现有的解决方案不能精确追踪嵌套的数据项，本文使用Pebble来解决这个问题。 7、Data Platform for Machine Learning解决的问题 目前，主要的ML算法没有提供集成的数据管理系统，数据管理的负担（如版本控制和访问控制）落在用户身上。本文提出的数据管理系统，为各种数据提供极简和灵活的数据模型，版本管理，维护数据来源，以帮助用户跟踪ML管道中数据版本和模型之间的沿袭和依赖关系。 综述1、Security Services Using Blockchains: A State of the Art Survey其中第五节（14页）对区块链数据溯源做了比较完整的综述，介绍了现有的区块链溯源系统，现有区块链溯源的缺陷和未来的工作方向。 2、A survey on data provenance in IoT综述：数据溯源在物联网中的应用。分析了物联网数据的特点，提出了物联网数据溯源的要求，对现有的方案进行了阐述，总结了一些待解决的问题。 3、Special Session: The Future of Iot Security本文是一篇综述，主要探讨物联网安全的未来趋势。 各领域关注的问题 Iot领域 溯源模型和机制的设计（iot数据具有异构性、扩展性、弹性等特点） iot设备计算和存储资源有限，如何设计以满足iot网络的特殊环境（比如轻量级的传输协议，溯源数据上传到云，溯源数据压缩，溯源数据过滤） 如何保证数据的真实性和完整性 iot设备收集了大量个人数据，溯源过程中如何保护隐私/如何实现政策合规性 欧盟GDPR个人隐私保护法 中国《个人信息保护法》11月1日出台 通过溯源实现对敏感信息的细粒度的访问控制 溯源数据本身可能会被攻击，需要保护溯源数据的完整性（区块链实现），实现溯源数据的访问控制（ABE属性加密） 云存储/云计算领域 数据问责/审计 取证 溯源时的隐私保护 科学工作流的溯源，实现实验可再现性（注：计算云已经成为部署和执行科学工作流的首选平台） 通过溯源提高用户对云服务商的信任度 AI/大数据领域 通过溯源，提高Spark等大数据框架的安全性可靠性 通过溯源，对深度学习算法的异常输出进行诊断，对相关输入进行定位，对数据进行管理。 对大数据流转的过程进行溯源 通过溯源，改进大数据中的个人隐私问题","link":"/2021/11/09/%E8%AE%BA%E6%96%87-%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"title":"进程互斥与同步","text":"什么是进程同步答：进程同步指的是，由于进程并发执行具有异步性（即各自以独立地、不可预知的速度向前推进），但是某些情况下又需要进程之间进行配合和协调来完成一项工作（存在执行的顺序），因此操作系统需要提供一种机制来实现这一功能，即进程同步。 例： 读进程和写进程并发地执行，由于并发必然导致异步性，因此“写数据“和”读数据“两个操作执行的先后顺序是不确定的。而实际中，又必须按照”写数据-&gt;读数据“的顺序来执行。 同步亦称直接制约关系，它是指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 什么是进程互斥 进程同步需要”共享“的支持。各个并发执行的进程不可避免地需要共享一些资源（比如内存、打印机、摄像头） 两种资源共享的方式： 互斥共享：一段时间内只允许一个进程访问 同时共享：允许一段时间内多个进程”同时“方法（为什么同时加引号，因为CPU并发执行进程，没有真正的并行执行） 对临界资源的互斥访问，可以在逻辑上分为如下四个部分 进入区：负责检查是否可以进入临界区，进入则上锁 临界区：进程中访问临界资源的代码 退出区：负责解除锁 剩余区：做其他处理 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以后原则： 空闲让进：临界区空闲，允许一个请求进入临界区的进程立即进入临界区 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿） 让权等待：当进程不能进入临界区时，应该立即释放处理机，防止进程忙等待。(四种软件实现方法：单标志检查法、双标知) 进程互斥的软件实现方法单标志法 算法思想：两个进程在访问完临界区后会把临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 12345678910111213int turn=0;//p0进程：while(turn != 0);critical section; //访问临界区turn=1; //允许对方访问remainder section; //剩余区//p1进程：while(turn != 1);critical section; //访问临界区turn=0; //允许对方访问remainder section; //剩余区 单标志法存在的主要问题：违背空闲让进原则 双标志先检查法 算法思想：设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前有没有别的进程想要进入临界区，如果没有，则把自身对应的标志设置为true，之后开始访问临界区。 1234567891011121314151617bool flag[2];flag[0]=false; //刚开始设置为两个进程都不想进入临界区flag[1]=false;//p0进程while(flag[1]);flag[0]=true;critical section;flag[0]=false;remainder section;//p1进程while(flag[0]);flag[1]=true;critical section;flag[1]=false;remainder section; 双标志先检查法存在的主要问题：违反忙则等待原则。 原因在于：进入区的检查和上锁两个处理不是一气呵成的（不是原子性）。如果检查通过后，在访问临界区之前发生进程切换，则会造成多个进程同时访问临界区。 双标志后检查法 算法思想：双标志先检查法的改进版。通过先上锁，后检查来避免先检查法的缺陷。 1234567891011121314151617bool flag[2];flag[0]=false; //刚开始设置为两个进程都不想进入临界区flag[1]=false;//p0进程flag[0]=true; //先上锁while(flag[1]);critical section;flag[0]=false;remainder section;//p1进程flag[1]=true;while(flag[0]);critical section;flag[1]=false;remainder section; 存在的主要问题：违背了有限等待和空闲让进原则。会因各进程都无法长期访问临界资源而产生饥饿现象。 Peterson算法 算法思想：主动让对方先使用临界区。 1234567891011121314151617181920bool flag[2]; //进入临界区的意愿int turn=0; //允许谁使用临界区flag[0]=false;flag[1]=false;//进程0flag[0]=true;turn=1; //让给对方使用（注意这句不在while里，只会让一次，因此两个人不会一直让来让去）while(flag[1] &amp;&amp; turn==1);critical section;flag[0]=false;remainder section;//进程1flag[1]=true;turn=1;while(flag[0] &amp;&amp; turn ==1);critical section;flag[1]=false;remainder section; Peterson算法存在的主要问题：违背了让权等待原则（当进程无法进入临界区时，应该立即释放处理机）。 Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则。但是依然不够好。 进程互斥的硬件实现方法中断屏蔽方法利用开/关中断指令实现。关中断后，无法发生中断切换进程，则不存在两个进程同时访问某个临界区。 123关中断；临界区；开中断； 优点：简单、高效 缺点： 不适合多处理机（关中断只对某个处理机管用） 只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用非常危险） 自己想的一条缺点：关中断是无差别攻击，使得别的许多没有与当前进程竞争临界区的进程也无法获得处理机，降低了操作系统的灵活性。 TestAndSet（TS指令/TSL指令）简称TS指令，也有些地方称为TestAndSetLock指令，或者TSL指令。TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。 1234567891011121314//bool lock表示当前临界区是否被加锁//true标识已加锁，false表示未加锁bool TestAndSet(){ bool old; old=*lock; //old用来存放lock原来的值 *lock=true; //无论之前是否加锁，都讲lock设为true return old; //返回lock原来的值}//以下是使用TSL指令实现互斥的算法逻辑while(TestAndSet(&amp;lock)); //“上锁”并“检查”critical section; //临界区代码lock=false; //解锁remainder section; //剩余区代码 优点：实现简单，把“上锁”和“检查“通过硬件的方式变成原子操作；适用于多处理机环境。 缺点：仍然不满足让权等待原则（无法进入临界区时释放处理机）。 原因：暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。 Swap指令（XCHG指令）Swap指令，又叫XCHG指令，是用硬件实现的，执行的过程中不允许被中断。以下是C语言描述的逻辑 123456789101112131415Swap(bool *a,bool *b){ bool tmp; tmp=*a; *a=*b; *b=tmp;}//以下是用Swap指令实现互斥的算法逻辑//lock表示当前临界区是否被加锁bool old=true;while(old==true) Swap(&amp;lock,&amp;old);临界区代码...lock=false;剩余区代码... 逻辑上和TSL一样，优缺点和TSL也一样，不满足让权等待。 信号量机制1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法–信号量机制。 用户进程可以通过操作系统提供的一对原语（原语：无法中断、连续执行的一组操作）来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。 一对原语：wait（S）和signal（S），信号量为S。 wait、signal原语简称为P、V操作（来自荷兰语proberen和verhogen）。 整型信号量用一个整数型的变量作为信号量，用来标识系统中某种资源的数量。 与普通整型变量的区别：对信号量的操作只有三种，初始化、P操作、V操作 e.g. 某计算机系统中有一台打印机 1234567891011121314151617181920212223int S=1;void wait(int S){ while(S&lt;=0); S=S-1;}void signal(int S){ S=S+1;}//进程P0...wait(S);使用打印机资源signal(S);... //进程P1...wait(S);使用打印机资源...signal(S); 检查和上锁一气呵成，避免了并发、异步导致的问题。 存在的问题：不满足“让权等待”，会发生“忙等” 记录型信号量整形信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构标识的信号量。 1234567891011121314151617181920//记录型信号量的定义typedef struct{ int value; //剩余资源数 struct process *L; //等待队列}semaphore;//某进程需要使用资源时，通过wait原语申请void wait(semaphore S){ S.value--; if(S.value&lt;0) block(S.L); //使当前进程从运行态变为阻塞态，并把它挂到信号量S的等待队列上（即阻塞队列）}//进程使用完资源后，通过signal原语释放void signal(semaphore S){ S.value++; if(S.value&lt;=0) //说明还有别的进程在等待该资源 wakeup(S.L); //唤醒等待队列中的一个进程，使其从阻塞态变为就绪态} wait(S), signal(S)也可以记为P(S)、V(S) 该机制遵循了让权等待原则，不会发生忙等现象。原因在于，当一个进程无法进入临界区时，会自我阻塞！从而释放处理机的占用。 用信号量实现进程的互斥、同步、前驱关系实现进程互斥 分析并发进程的关键活动，划分临界区（如，打印机的访问就应该放在临界区） 设置互斥信号量mutex，初值为1 在临界区之前执行P(mutex) 在临界区之后执行V(mutex) 1234567891011121314151617semaphore mutex=1;P1(){ ... P(mutex); 临界区代码 V(mutex); ...}P2(){ ... P(mutex); 临界区代码 V(mutex); ...} P、V操作需要成对出现。缺少P不能保证互斥访问，缺少V则会导致资源永远不被释放，等待进程永远不会被唤醒。 注意，对不同的临界资源要设置不同的互斥信号量 实现进程同步进程同步：要让并发进程按照要求有序地推进。 用信号量实现进程同步： 分析什么地方需要实现“同步关系”，即必须保证一前一后执行的两个操作（或者两句代码 ） 设置同步信号量S，初值为0 在“前操作”之后执行V（S） 在“后操作”之前执行P（S） 实现进程的前驱关系前驱关系问题，本质上就是更复杂的同步问题 生产者消费者问题问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。生产者、消费者共享一个初始为空、大小为n个缓冲区。 123456789101112131415161718192021222324252627semaphore mutex1=1; //信号量1，用于缓冲区锁semaphore full=0; //信号量2，记录缓冲区的产品个数，用于同步semaphore empty=n; //信号量3, 记录缓冲区可用空间，用于同步//生产者进程Producer(){ while(1){ 生产产品 P(emoty); //查询缓冲区是否有可用个数 P(mutex1); //访问缓冲区 将产品放入缓冲区 V(mutex1); V(full); //缓冲区可用产品个数+1 }}//消费者进程Consumer(){ while(1){ P(full); //查询缓冲区是否有可用产品 P(mutex1); 取出产品 V(mutex1); V(empty); //缓冲区可用空间+1 }} 实现互斥的P操作一定要在实现同步的P操作之后，否则会发生死锁；V操作不会导致进程阻塞，因此两个V操作顺序可以交换。 12345678910111213141516171819202122232425262728293031323334353637semaphore mutex=1; //信号量，用于互斥访问文件格semaphore empty=9; //信号量，记录文件格可用空间semaphore A3=0; //信号量，记录A3纸的数量semaphore A4=0; //记录A4纸的数量PutPaper(){ while(1){ P(empty); //检查是否有空位置放纸 P(mutex); //互斥访问文件格 if(放A3纸) V(A3); else(放A4纸) V(A4); V(mutex); }}GetPaper(){ while(1){ if(取A3纸){ P(A3); P(mutex); 取A3纸 V(mutex); V(empty); }else{ P(A4); P(mutex); 取A4纸； V(mutex); V(empty); } }} 多生产者-多消费者问题问题描述：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸转向盘子中放苹果，妈妈专向盘子中放橘子，儿子专门吃橘子，女儿专门吃苹果。只有盘子为空时，爸爸或者妈妈才能向盘子中放入一个水果。仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出水果。请用PV操作实现上述过程。 1234567891011121314151617181920212223242526272829303132333435semaphore apple=0; //信号量，用于苹果的同步semaphore orange=0; //信号量，用于橘子的同步semaphore empty=1; //信号量，记录盘子中剩余位置Father(){ while(1){ P(empty); //盘子为空才能放水果 放入苹果; V(apple); }}Mother(){ while(1){ P(empty); 放入橘子; V(orange); }}Son(){ while(1){ P(apple); 拿出苹果; V(empty); }}Daughter(){ while(1){ P(orange); 拿出橘子; V(empty); }} 如果将题目中的缓冲区数量改成2，则需要假如mutex，对盘子的互斥访问。 12345678910111213141516171819202122232425262728293031323334353637383940semaphore mutex=0; //信号量，用于果盘的互斥访问（放入互斥，取出并不互斥）semaphore apple=0; //信号量，用于苹果的同步semaphore orange=0; //信号量，用于橘子的同步semaphore empty=2; //信号量，记录盘子中剩余位置Father(){ while(1){ P(empty); //盘子为空才能放水果 P(mutex); //互斥访问果盘 放入苹果; V(mutex); V(apple); }}Mother(){ while(1){ P(empty); P(mutex); 放入橘子; V(mutex); V(orange); }}Son(){ while(1){ P(apple); 拿出苹果; V(empty); }}Daughter(){ while(1){ P(orange); 拿出橘子; V(empty); }} 吸烟者问题问题描述：一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并且抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者无限地提供三种材料，供应者每次将两种材料放在桌子上，拥有剩下那种材料的抽烟者卷起一根烟并抽掉它，并给供应者进程一个信号告诉他完成了，供应者就会放另外两种材料在桌上，这一过程一直重复（让三个抽烟着轮流地抽烟）。 12345678910111213141516171819202122232425262728293031323334353637383940414243semaphore m1=0,m2=0,m3=0; //分别代表桌子上的烟草、纸和胶水semaphore table=1; int turn=0;Producer(){ while(1){ P(table); if(turn==0){ 在桌子上放烟草和纸 V(m1); }else if(turn==1){ 在桌子上放纸和胶水 V(m2); }else{ 在桌子上放胶水和烟草 V(m3); } turn=(turn+1)%3; }}Consumer1(){ while(1){ P(m1); 卷烟，抽烟 V(table); }}Consumer2(){ while(1){ P(m2); 卷烟，抽烟 V(table); }}Consumer3(){ while(1){ P(m3); 卷烟，抽烟 V(table); }} 缓冲区数量为1，实际运行过程中同一时刻只可能有一个进程访问缓冲区，因此无需额外设置mutex对缓冲区加锁 读者-写者问题问题描述：一个系统中有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但是若某个写进程和其他进程（读/写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求： 允许多个读者可以同时对文件执行读操作 只允许一个写者前往文件中写信息 任一写者在完成操作之前，不允许其他读者或写者工作 写者执行写操作前，应让已有的读者和写者全部退出。 123456789101112131415161718192021222324252627282930//读者优先semaphore mutex=1; //原子化操作semaphore lock=1; int reader=0; //读者人数Writer(){ while(1){ P(lock); 写入文件 V(lock); }}Reader(){ while(1){ P(mutex); //原子化变量的判断与增减 if(reader==0){ P(lock); } reader++; V(mutex); 读文件 P(mutex); reader--; if(reader==0) V(lock); V(mutex); }} 写者优先存在的问题：只要有一个读者残留，那么剩余读者就会源源不断地进入，导致写者饥饿（读者会在写者之前插队） 12345678910111213141516171819202122232425262728293031323334353637//写者优先semaphore mutex=1; //原子化操作semaphore lock=1; semaphore w=1; //用于读者优先int reader=0; //读者人数Writer(){ while(1){ P(w); //表示有写者意图进入 P(lock); 写入文件 V(lock); V(w); }}Reader(){ while(1){ P(w); //如果有写者意图进入，则等待 /*V(w)写在这里也可以，只要在读文件之前，不影响其他读者就可以*/ P(mutex); //原子化变量的判断与增减 if(reader==0){ P(lock); } reader++; V(mutex); V(w); //写者可以意图进入 读文件 P(mutex); reader--; if(reader==0) V(lock); V(mutex); }} 哲学家进餐问题一张圆桌上坐着五名哲学家，每两个哲学家之间的桌上摆了一根筷子，桌子的中间是一碗米饭。哲学家们思考和进餐，只有饥饿时会试图拿起左右两根筷子（一根一根拿起）。如果筷子已经在他人手上，这需要等待。进餐完毕后，放下筷子继续思考。 关系分析：筷子的访问是互斥关系 整体思路：每个哲学家进程需要同时持有两个临界资源才能开始进餐。如何避免临界资源分配不当造成的死锁现象，是哲学家就餐问题的精髓。 信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现5根筷子的互斥访问。并对哲学家按0~4进行编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。‘ 如果不施加任何条件，则会发生死锁 123456789semaphore chopstick[5]={1,1,1,1,1};Pi(){ //i号哲学家进程 P(chopstick[i]); //拿起左边筷子 P(chopstick[(i+1)%5]); //拿起右边筷子 就餐 V(chopstick[i]); //放下左边的筷子 V(chopstick[(i+1)%5]); //放下右边的筷子 思考} 如何防止死锁的发生？可以施加一些条件（下面任一条件均可防止死锁） 最多允许4人同时用餐 同时拿起两根筷子，如果做不到则等待 奇数先拿右手筷子，偶数先拿左手筷子（保证了相邻两个哲学家如果都拿起第一只筷子以后，其中一人可以拿起另一只吃饭，另一个人阻塞）","link":"/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"title":"Java基础","text":"1. 概述 冯诺依曼体系结构 组成：运算器，控制器，存储器，输入设备，输出设备 SUN公司1995年推出的一门高级编程语言 JDK：Java Development Kit （java开发工具包） 包括jre 其他开发工具：编译工具javac.exe，打包工具jar.exe JRE：Java Runtime Environmen（java运行时环境 ） 包括Java虚拟机（Java Virtual Machine）和Java程序所需要的核心类库等。 如果想运行一个开发好的java程序，计算机中只需要安装JRE即可。 Java内存模型 2. 基本语法2.1 关键字和标识符关键字 关键字的定义和特点 定义：被Java语言赋予了特殊含义的字符串 特点：都是小写 用于定义数据类型的关键字byte,short,int,long,float,double,boolean,void,class,interface,enum 用于流程控制的关键字if,else,switch,for,while,case,default,do,break,continue,return 用于定义访问权限修饰符的关键字public,protected,private 定义类，函数，变量修饰符的关键字abstract,final,static,synchronized 用于定义类与类之u见关系的关键字extends,implements 用于定义简历实例及引用实例，判断实例的关键字new,this,super,instanceof 用于异常处理的关键词try,catch,finally,throw,throws 用于包的关键字package,import 其他修饰符关键字native,strictfp,transient,volatile,assert 保留字现有Java版本尚未使用，但以后版本可能会作为关键字使用，如goto，const 标识符命名规范 包名：全部小写,xxxyyyzzz 类名、接口名：大驼峰 变量名、方法名：小驼峰 常量名：全部大写，多个单词用下划线连接 2.2 变量基本数据类型 Java语言数据类型的长度和表示范围不受OS影响 基本数据类型(primitive type) 数值型 整数类型 byte:1字节，范围：-128-127 short:2字节，范围:$-2^{15}$ ~ $2^{15}+1$ int:4字节，范围$-2^{31}$ ~ $2^{31}-1$（约21亿） long:8字节，范围$-2^{63}$ ~ $2^{63}-1$声明long类型常量须加小写l或者大写L 浮点类型 单精度float，占4字节，尾数可以精确到7位有效数字 float类型表示范围比long还大！ 因为float类型底层存储方式不同，$2^E*M$ 浮点数关注的是精度，整数类型关心的是范围，。 双精度double，占8字节，精度是float的两倍。通常采用此类型 java的浮点型常量默认为double类型，声明float类型，须后加小写f或者大写F 两种表示形式 十进制数形式：2.12, 512.0f, .34 科学计数法形式：5.12e2, 512E2, 100E-2 字符型 char，占2个字节 三种表示方式 单引号 转义字符\\r回车符，\\n换行符 Unicode值直接表示，\\uXXXX，XXXX代表一个十六进制整数 char类型可以运算，因为有对应的Unicode码 UTF-8是使用最广的一种Unicode的实现方式 布尔型 boolean 引用数据类型(reference type) 类(包括String） 接口 数组 基本数据类型之间的转换除了boolean类型，其他7种基本数据类型之间的转换自动类型提升 当容量（表示数的范围）小的数据类型的变量与容量大的数据类型的变量之间做运算时，结果自动提升为容量大的数据类型。 如果用int=int+long则会报错 容量（表示数的范围）从小到大是：byte（1字节）-&gt; char、short （2字节）-&gt; int -&gt; long -&gt; float -&gt; double (注意，float虽然是4个字节，但是比8个字节的long，能表示的数据范围要更大） 特别地，byte、char、short三种类型的变量之间做运算时（包括自己和自己，如byte+byte），结果为int类型 书上：java在做运算地时候，如果操作数均在int范围内，那么一律在int的空间内运算强制类型转换 需要使用强转符号() 可能造成精度损失 不加l或者L的整数，默认是int型 比如 long a=213214332143254324; 会报错，整数超过int类型 不加f或者F，默认是double类型 比如float b=12.3; 会报错 因为12.3默认是double类型，不能直接赋值给精度小的float类型常量 整型常量，默认类型为int型 浮点型常量，默认类型为double型String 声明String时，用双引号即可 不是基本数据类型，属于引用数据类型 字符串可以拼接其他字符串，也可以拼接其他数据类型的数据 可以与基本数据类型，直接做+运算 进制转换 对于整数，有四种表示方式 二进制binary，以0b或者0B开头 十进制decimal 八进制octal，以数字0开头 十六进制hex，以0x或者0X开头 二进制的整数有如下三种形式 原码：直接将一个数值转换成二进制。最高位是符号位 反码： 正数：和原码一样 负数：除符号位外，其他位对原码按位取反 补码： 正数：和原码一样 负数：反码+1 -127补码是1000 0001，-128补码是1000 0000，用-127减一即可 2.3 运算符Java中的运算符有 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 位运算符&gt;&gt;&gt;无符号右移 移位运算符和位运算符优先级如下~，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，^，| 2.4 数组对char型数组，System.out.println()打印的结果是内容的字符串形式对于其他类型的数组，打印的结果是类型@地址值，如[I@ed9d034 3. 封装面向对象的三大特征 封装 继承 多态3.1 java内存模型 堆Heap唯一目的是存放对象实例， 几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈Stack通常所说的栈Stack，指的是虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型(byte,short,char,int,long,boolean,float,double)、对象引用(reference类型，是对象在堆内存的首地址）。方法执行完，自动释放。 Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）， Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。对于我们来说，主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。 方法区Method Area用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(JDK8以后改成了元数据空间metaspace） 程序计数器1234程序计数器是一个记录着当前线程所执行的 字节码的行号指示器。JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。 首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，**每个线程工作时都有属于自己的独立计数器。** 运行时数据区包括：方法区、虚拟机栈、本地方法栈、堆、程序计数器 3.2 对象 对象的内存解析 对象数组的内存解析 注意： 此处的字符串“Tom”，是字符串常量，实际上是在方法区 引用类型的变量，只可能存储两类值：null 或 地址值（包含变量的类型）3.3 方法 方法重载概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数 或 参数类型不同即可。特点：与返回值类型无关，只看参数列表。 可变形参的方法允许直接定义能和多个实参相匹配的形参。从而，可以使用一种更简单的方式，来传递个数可变(任意个，包括0个）的参数。具体使用 格式：数据类型 ... 变量名 传入参数个数可以是：0个，1个，2个… 可以与形参不同的方法之间形成重载 与形参类型相同的数组，不能共存 在形参列表中，必须声明在末尾 形参列表中，最多只能声明一个可变形参定义123456public void show(String ... strs){ //可以像使用数组一样使用参数strs for(int i=0;i&lt;str.length();i++){ System.out.println(strs[i]); }} 方法参数的值传递机制Java里的方法的参数传递方式只有一种：值传递。即将实际参数值的副本传入方法内，而参数本身不受影响。 形参是基本数据类型：将其数据值传递给形参 形参是引用数据类型：将其地址值传递给形参 关于字符串作为形参的情况 123456789101112public class p1 { static void change(String s2) { s2 = &quot;bbb&quot;; } public static void main(String[] args) { String s1 = &quot;aaa&quot;; change(s1); System.out.println(s1); }}//打印结果：aaa Java中的String对象具有不可改变性，这里java在常量池中开辟了一块区域给aaa，s1指向aaa。change函数的形参仍然是地址传递（String是引用数据类型），s2也指向aaa，然后s2=&quot;bbb&quot;即将s2指向bbb，s1的指向并未改变。因此最终打印的结果仍然是aaa 3.4 四种权限修饰符封装性的体现： 我们将类的属性xxx私有化，同时，提供公共方法来获取和设置它。 不对外暴露的私有的方法 单例模式 … 我们设计程序追求“高内聚、低耦合” 高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅对外暴露少量的方法用于使用 Java规定了4种权限：private, (default), protected, public| 修饰符 | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 || ——— | —— | ——– | ———— | ———- || private | Yes | | | || (default) | Yes | Yes | | || protected | Yes | Yes | Yes | || public | Yes | Yes | Yes | Yes | 四种权限可以用来修饰类以及类的内部结构：属性、方法、构造器、内部类 对于class的权限修饰，只可以用public和default（缺省） public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 3.5 构造方法说明 如果没有显示地定义类的构造器的话，系统默认会提供一个空参的构造器；一旦我们显示定义了类的构造器之后，系统就不再提供默认的空参构造器。 定义构造器的格式：权限修饰符 类名(形参列表){...} 构造器可以重载 3.6 JavaBean说明 JavaBean是一种Java语言写成的可重用组件 所谓JavaBean，是指符合以下标准的Java类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get和set方法3.7 UML类图3.8 this说明 它在方法内部使用，即这个方法所属对象的引用 它在构造器内部使用，表示该构造器正在初始化的对象 用于构造器调用其他构造器（必须声明在当前构造器的首行，且最多只能使用一次）1234567891011public Person{ public Person(){...} public Person(int age){ this(); ... } public Person(int age,string name){ this(age); ... } } 3.9 JDK中主要的包介绍 java.lang：包含Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能 java.net：包含执行与网络相关操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用的工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具及(abstract window toolkits）的多个类，用于构建和管理应用程序的GUI，现在不常用了。3.10 MVC设计模式MVC是常用的设计模式之一，将整个程序分为三个层次：视图、控制器、数据模型。3.11 import关键字说明 可以使用xxx.*方式，导入xxx包下的所有结构（子包除外，需要再显示声明） java.lang包或本包下定义的类和接口，可以省略import 如果在源文件中，使用了两个不同包下的同名的类，则至少有一个要以全类名的方式书写（xxx.xxx.类名) import static ：导入指定类或接口中的静态结构（落脚点不是类，而是某个结构，属性或方法，或者写*），用的少。12345import static java.lang.System.*;import static java.Math.*;//这样可以省略System、Mathout.println(&quot;abc&quot;);long a=round(1.23); 4. 继承Java对继承的规定 单继承：一个子类只能有一个父类 直接继承的是直接父类，间接继承的是间接父类 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法，但是能否访问还得看权限修饰符。 4.1 Object类 如果我们没有显示地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除了java.lang.Object类）都直接或间接继承于java.lang.Object类4.2 方法重写 定义：在子类中可以根据需要对从父类继承来的方法进行改造。在程序执行时，子类的方法将覆盖父类的方法 要求： 重写的方法必须与父类具有相同的方法名和参数列表 重写的方法的返回值类型不能大于父类被重写的方法的返回值；如果父类返回的是基本数据类型，那么子类也必须是。 子类重写的方法使用的访问权限不能小于父类被重写的方法的权限 子类不能重写父类中声明为private权限的方法 子类方法跑出的异常不能大于父类被重写的方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static（不是重写）。因为static方法属于类，子类无法覆盖父类的static方法。 4.3 super关键字 说明 可以在子类的方法或构造其中，使用super.属性或者super.方法的方式，显示地调用父类中声明的方法或属性。通常情况下， 省略super 特殊情况下，当子类和父类方法名或属性名重名时，显示调用super super调用构造器 可以在子类的构造器中显示地使用super(形参列表)的方式，调用父类中声明的指定的构造器 必须在子类构造器的首行 类的构造器中，this(形参列表)和super(形参列表)只能二选一，不能同时出现 在构造器的首行，如果没有显示地声明 this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器；注意，子类构造器必须直接或间接地调用父类构造器，如果没有声明，则调用父类的默认空参构造器（如果父类没有，则报错）。4.4 子类对象实例化过程 从结果上看子类继承父类之后，就获取了父类中声明的属性和方法；创建子类的对象，在堆空间中，就会加载所有父类中声明的属性 从过程上看当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 5. 多态5.1 概述 理解多态性：是面向对象中最重要的概念，在Java中的体现就是父类的引用指向子类的对象。可以直接应用在抽象类和借口上。 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际给该变量赋值的对象决定。简而言之：编译时看左，运行时看右。 若编译时和运行时类型不一致，就出现了对象的多态性（Polymorphism） 多态情况下： 看左边：看的是父类的引用（父类中不具备子类特有的方法） 看右边：看的是子类的对象（实际运行的是子类重写父类的方法） 多态使用的前提 类的继承关系 方法的重写 多态性不适用于属性（编译和运行时都看左边） 多态的意义：多态是面向对象中最重要的概念，没有多态性，就没有后面的抽象类、接口等概念。 虚拟方法调用：子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。 如何证明多态是运行时行为？（编译时无法确定类型，动态绑定） 12345678910111213141516171819202122232425262728293031323334353637383940414243package July.demo01;import java.util.Random;public class Animal { void speak(){ } static Animal getInstance(int key){ switch(key){ case 0: return new Dog(); case 1: return new Cat(); default: return new Rabbit(); } } public static void main(String[] args) { int key= new Random().nextInt(3); Animal animal=getInstance(key); animal.speak(); }}class Dog extends Animal{ void speak(){ System.out.println(&quot;Dog!&quot;); }}class Cat extends Animal{ void speak(){ System.out.println(&quot;Cat!&quot;); }}class Rabbit extends Animal{ void speak(){ System.out.println(&quot;Rabbit!&quot;); }} 5.2 重载和重写 5.3 instanceof 操作符与向下转型如何才能调用子类特有的方法和属性？向下转型，使用强制类型转换符。使用强转的时候，可能出现ClassCastException异常。a instanceof A：如果a是A的实例，或者是A的子类的实例，则返回true 对于引用数据类型来说，强制类型转换的前提是，堆内存中存在转换后类型（或子类）的对象，否则不能转换。 123456//Man是Person的子类Person p=new Person();Man m=(Man)p; //错误！堆内存中是Person类型对象Object obj=new Man();Person p=(Person)obj; //可以执行！内存中有Man类型对象，也是Person子类的实例。 6. 补充内容6.1 Object类 Object类是所有Java的根父类 如果定义一个类没有声明父类，则默认继承java.lang.Object Object类只声明了一个空参的构造器 Object类方法（所有类的通用方法） equals toString getClass hashCode clone finalize6.2 ==和equals ==运算符 1.比较基本数据类型：比较值。注意可以类型不同，如int a=1; float b=1.0，a和b==运算的结果是true。（boolean不能参与运算） 2.比较引用数据类型：比较在内存中的地址值。 为何有些情况下，直接定义String的时候，可以直接用==判断两个String值相等？因为String存在字符串常量池的问题（但不是所有String都在里边，也有可能两个相同的String不指向同一个引用）。 equals方法 1.只能用于引用数据类型2.Object中的equals是用==实现的3.IDE自动生成的equals方法 6.2 包装类 基本数据类型、包装类和String之间的转换 自动装箱与自动拆箱包装类和基本数据类型之间可以直接进行互相赋值 123int a=1;Integer b=a;a=b; 基本数据类型、包装类–&gt;String方式一：使用&quot;&quot;+连接方式二：String.valueOf() String–&gt;基本数据类型、包装类 包装类的一些问题 6.3 关键字：static 修饰属性 修饰方法 单例设计模式 饿汉式： 优点：线程安全 缺点：资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类，那么这个实例仍然初始化 懒汉式： 优点：延迟加载，需要用到实例的时候再加载 缺点：线程不安全（有改进的方法） 1234567891011121314151617181920212223//单例之饿汉式public class House { private static House house=new House(); public static House getInstance(){return house;} private House(){}}//单例之懒汉式class Country{ private Country(){} private static Country count=null; public static Country getInstance(){ if(count==null) count=new Country(); return count; } } 单例模式应用场景6.4 类的成员：代码块 代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 可以定义多个，按照声明的先后顺序执行 分类： 静态代码块：随着类的加载而加载，并执行；随着类的加载而执行，而且只执行一次 非静态代码块：随着对象的创建而加载，并执行；每创建一个对象，就执行一次6.5 关键字：final 修饰类：不能被继承 修饰方法：不能被重写 修饰变量：此时的变量变为了一个常量。 基本数据类型：变量一旦赋值后，不能被重新赋值。 引用数据类型：引用指向不能发生改变。6.6 抽象类与抽象方法abstract可以用来修饰类、方法，不能修饰私有方法、静态方法、final的类、方法 修饰类：抽象类 此类不能实例化 仍然提供构造器（子类要调用），类中一定有构造器。 修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之不然。 子类重写父类中的所有抽象方法后，此子类方可实例化 抽象类的匿名子对象模板方法设计模式 抽象类和接口的区别 1抽象类是一种对事物的抽象，而接口是一种对行为的抽象； 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 抽象类是一种模板式设计，而接口是一种行为规范，是一种辐射式设计。 6.7 接口 Java不支持多继承，但是有了接口，就可以实现多重继承的效果。接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。 说明： interface接口不能定义构造器，意味着接口不能实例化。 类implements接口 如果类没有实现接口中的所有抽象方法，则此类仍然是一个抽象类 接口和接口之间可以继承，而且可以多继承 JDK8之后，除了定义全局常量public static final和抽象方法以外，还可以定义静态方法、默认方法。 接口中的所有属性（全局静态常量）和方法，都是public的，即使不加，系统也自动声明为public。 接口匿名实现类6.8 接口应用：代理模式（Proxy） 概述：代理模式是Java开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制这个对象的访问。如明星（被代理类）和经纪人（代理类），租房者（被代理类）和中介（代理类）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class proxyPatternDemo { public static void main(String[] args) { Proxy proxy=new Proxy(new Server()); while(true){ proxy.browse(); System.out.println(); } }}//浏览网页的接口interface NetWork { void browse();}//被代理类class Server implements NetWork{ @Override public void browse() { System.out.println(&quot;正在访问该网站&quot;); }}//代理类class Proxy implements NetWork{ private NetWork netWork; public Proxy(NetWork netWork){ this.netWork=netWork; } private boolean check() throws InterruptedException { System.out.println(&quot;正在做访问网络前的检查...&quot;); Thread.sleep(1000); return new Random().nextInt(100)%2==0; } @Override public void browse(){ try { boolean res=check(); if(res){ System.out.println(&quot;校验通过，允许访问！&quot;); netWork.browse(); }else{ System.out.println(&quot;校验不通过，不允许访问！&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} 应用场景 分类 静态代理（静态定义代理类） 动态代理 （动态生成代理类） JDK自带的动态代理，需要反射等知识。 6.9 接口的应用：工厂设计模式 工厂模式概念：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 核心本质：实例化对象，用工厂方法代替new操作；将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 工厂模式的分类 简单工厂模式：用来生产同一等级结构中的任意产品。（对于新增加的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） //简单工厂模式 123456789101112131415161718192021222324252627282930313233343536public interface Car { public void run();}class BMW implements Car{ @Override public void run(){ System.out.println(&quot;BMW is running~&quot;); }}class Mercedes_Benz implements Car{ @Override public void run(){ System.out.println(&quot;Benz is running~&quot;); }}//Car工厂类class carFactory{ public static BMW getBMW(){ return new BMW(); } public static Mercedes_Benz getBenz(){ return new Mercedes_Benz(); }}class Test{ public static void main(String[] args) { Car car1=carFactory.getBenz(); Car car2=carFactory.getBMW(); car1.run(); car2.run(); }} //工厂方法模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Car { void run();}class Benz implements Car{ @Override public void run() { System.out.println(&quot;Benz is running...&quot;); }}class Audi implements Car{ @Override public void run() { System.out.println(&quot;Audi is running...&quot;); }}//工厂接口interface carFactory{ Car getCar();}//宝马工厂class BenzFactory implements carFactory{ @Override public Benz getCar() { return new Benz(); }}//奥迪工厂class AudiFactory implements carFactory{ @Override public Car getCar() { return new Audi(); }}class Test{ public static void main(String[] args) { Car car1=new AudiFactory().getCar(); Car car2=new BenzFactory().getCar(); car1.run(); car2.run(); }} 6.10 JDK8接口静态方法、默认方法 静态方法：接口中定义的静态方法，只能通过接口来调用（不能用实现类来调用） 默认方法：类似让接口拥有类的功能，让实现类拥有该方法。通过实现类对象来调用（可以重写）。 public即使不加，系统也会自动加上1234567891011121314151617public interface Test { public static void method1(){ //... } static void method2(){ //... } public default void method3(){ //... } default void method4(){ //... }} 6.11 内部类 概念：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 Inner class 一般用在定义它的类或者语句块之内，在外部引用它时必须给出完整的名称。 分类 成员内部类：static成员内部类和非static成员内部类 局部内部类（不谈修饰符）：匿名内部类 1234567891011public class Person { //静态成员内部类 static class Cat{} //非静态成员内部类 class Dog{} void f(){ //局部内部类 class Fish{} } } 7. 异常处理7.1 异常概述与异常体系结构 为什么需要异常处理因为有很多问题不是靠代码能够避免的，比如：用户输入数据的格式，读取文件是否存在，网络是否始终保持畅通等等 异常：在程序执行过程中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常） 分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。如：StackOverflowError和OOM。一般不编写针对性的代码进行处理 Excepetion：其他因编程错误或者偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组访问越界 Exception又分为：编译时异常(checked受检异常）和运行时异常 7.2 常见异常编译时异常 IOException —-FileNotFoundException ClassNotFoundException 运行时异常（编程实践中，一般对运行时异常不做处理） NuLLPointerException12345678//试图堆一个空对象调用方法时，就会产生空指针异常public class Main { @Test public void test(){ Date date=null; date.getTime(); }} ArrayIndexOutOfBoundsException ClassCastException1234567public class Main { @Test public void test(){ Object obj=new String(&quot;abc&quot;); Main main=(Main)obj; }} NumberFormatException123456public class Main { @Test public void test(){ int num=Integer.parseInt(&quot;abc&quot;); }} InputMismatchExceptionScanner输入int，结果用户输入abc，会报此异常 ArithmeticException123456public class Main { @Test public void test(){ int a=10/0; }} 7.3 异常处理机制一：try-catch-finally使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于把一个编译时可能出现的异常，延时到运行时出现（转变为运行时异常）。所以，对于运行时异常，一般不做处理。使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的类，并且终止try中代码的执行，根据此异常的类型去catch中进行匹配。try-catch-finally执行完了，继续执行下面的其他代码。 常用的异常对象处理的方式1.String getMessage()2.void printStackTrace() try-catch-finally结构可以嵌套 注意：如果catch多个异常存在父子关系的话，子类要放在上边 7.4 异常处理机制二：throws1.使用throws向上抛出异常，出现异常时，异常后序的代码将不再执行2.throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 注意：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（或者不抛）（原因：多态时，父类引用指向子类对象，调用同名方法，并且进行异常处理时，如果子类方法异常类型大于父类类型，则无法处理） 1234567891011121314151617181920212223242526public class Main { @Test public void test() { f(new Son()); } public void f(Father person){ try { person.method(); } catch (IOException e) { e.printStackTrace(); } }}class Father{ void method()throws IOException{ }}class Son extends Father{ void method()throws FileNotFoundException{ }} 7.5 两种异常处理方式的选择1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理2.执行的方法A中，先后又调用了另外几个方法bcd，这几个方法是递进关系的（需要利用上一个方法的返回值）。建议这几个方法使用throws进行处理。而执行的方法A考虑使用try-catch-finally方式进行处理。（如果在b直接进行try-catch处理，cd会正常执行，但是利用的返回值是无效的） 7.6 手动抛出异常：throw关于异常对象的产生：1.系统自动生成的异常对象2.手动的生成一个异常对象，并throw 123456789101112131415public class ThrowTest { public static void main(String[] args) { new Student(-100); }}class Student{ private int id; Student(int id){ if(id&gt;0) this.id=id; else throw new RuntimeException(&quot;输入的id非法&quot;); }} 运行结果 12345678910111213141516171819public class ThrowTest { public static void main(String[] args) { try { new Student(-100); } catch (Exception e) { System.out.println(e.getMessage()); } }}class Student{ private int id; Student(int id) throws Exception{ if(id&gt;0) this.id=id; else throw new Exception(&quot;输入的id非法&quot;); }} 运行结果 7.7 用户自定义异常类如何自定义异常类?1.继承于现有的异常结构：RuntimeException, Exception2.提供全局常量序列号: serialVersionUID (类的唯一标识）3.提供重载的构造器 12345678910class MyException extends RuntimeException { static final long serialVersionUID = 123L; public MyException() { } public MyException(String msg) { super(msg); }}","link":"/2020/07/11/Java-java%E5%9F%BA%E7%A1%80/"},{"title":"Python学习笔记","text":"pip pip list 查看已安装依赖 pip -V 查看版本 pip install 包名[==版本号] 安装依赖 pip uninstall 包名 卸载 pip freeze &gt; requirements.txt 将项目依赖的包的名称和版本导入到指定文本中 pip install -r requirements.txt 使用pip安装文件中所标的所有依赖 算数运算符除了加减乘除外，还有 取整除 // 取余数% 幂 ** 逻辑运算符 and or not 变量 Python是弱类型语言，定义变量不需要指定类型 变量类型 数字型 int float bool True 非0即真 False 0 complex 非数字型 字符串 列表 元组 字典 变量的格式化输出 格式化字符串 含义 %s 字符串 %d 有符号十进制数，%06d表示输出的整数显示位数，不足的地方使用0补全 %f 浮点数，%.02f表示小数点后只显示两位 %% 输出% 变量的命名规则 Python中标识符是区分大小写的 变量进阶变量的引用 Python中函数的参数传递以及返回值都是靠引用传递的 引用的概念 在python中 变量和数据分开存储 变量中保存着数据在内存中的地址 变量中记录数据的地址，就叫做引用 使用id()函数可以查看变量总保存数据所在的内存地址 如果变量已经被定义，当给一个变量赋值时，变量改为对新赋值的数据引用 可变和不可变类型 不可变类型，内存中的数据不允许被修改 数据类型：int,bool,float,complex,long(2.x) 字符串str 元组tuple 可变类型，内存中的数据可以被修改 列表list 字典dict 注意：字典的key只能使用不可变类型的数据 注意 可变类型的数据变化，是通过方法来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量不再对之前的数据引用 变量改为对新赋值的数据引用 哈希hash Python中内置有一个函数叫hash(o) 接收一个不可变类型的数据作为参数 返回结果是一个整数 哈希是一种算法，其作用就是提取数据的特征码（指纹） 相同的内容得到相同的结果 不同的内容得到不同的结果 在Python中，设置字典的键值对时，会首先对key进行hash已决定好在内存中如何保存数据，以方便后续对字典的操作：增删改查 键值对的key必须是不可改变类型数据 键值对的value可以是任意类型的数据 局部变量和全局变量 函数不能直接需修改全局变量的引用——使用赋值语句修改全局变量的值 如何在函数内部修改全局变量的值 使用global进行声明 全局变量定义的位置 应该将全局变量定义在其他函数的上方 全局变量命名的建议 在定义全局变量时，有些公司会有一些开发要求 例如，增加g_或者gl_前缀 函数函数的文档注释 在开发中，如果希望给函数添加注释，应该在定义函数的下方，使用连续的三对引号 在连续的三对引号之间编号对函数的说明文字 12def multiple_table(): &quot;&quot;&quot;九乘九，乘法表&quot;&quot;&quot; 在函数调用位置，使用快捷键ctrl+Q可以查看函数的说明信息 因为函数体相对比较独立，函数定义的上放，应该和其他代码（包括注释）保留两个空行 给函数增加注释，包括对参数的说明 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Bdn4eNqC-1615807570855)(/images/python_1.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uV7AYnvD-1615807570856)(/images/python_2.png)] 缺省参数如对列表的排序 list_1.sort() list_2.sort(reverse=True) 指定函数的缺省函数 定义函数时，在参数列表中直接指定即可 如：print_info(name,gender=True): 缺省参数的注意事项 缺省参数的定义位置 必须保证带有默认值的缺省参数在参数列表末尾 调用带多个缺省参数的函数 在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释器才能知道参数的对应关系 多值参数定义支持多值参数的函数 有时可能需要一个函数能够处理的参数个数是不确定的，这时候就可以使用多值参数 python中有两种多值参数 参数名前增加一个*可以接收元组 参数名前增加两个*可以接收字典 一般在给多值参数命名时，习惯使用以下两个名字 *args——存放元组参数 arguments缩写 **kwargs——存放字典参数 keyword缩写 示例 123456def func(*args,**kwargs): print(args) print(kwargs)func(1,2,3,name='yfx',age=22) 元组和字典的拆包123456789def func(*args,**kwargs): print(args) print(kwargs)gl_nums=(1,2,3)gl_dict={'name':'yfx','age':23}func(*gl_nums,**gl_dict) 模块 模块是Python程序架构的 一个核心概念 模块就好比是工具包，要想使用这个工具包中的工具，就需要导入import这个模块 每一个以py结尾的python源代码文件都是一个模块 在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具 模块名也是一个标识符 由字母、下划线和数字组成 不能数字开头 不能与关键字重名 模块的两种导入方式第一种：import导入1import 模块名1，模块名2 提示：在导入模块时，每个导入应该独占一行 12import 模块名1import 模块名2 如果模块名过长，可以使用as指定模块的别名 注意，模块别名应该使用大驼峰命名法 第二种：from…import导入 如果希望从某个模块中，导入部分工具，可以使用from..import 导入之后 不需要通过模块名. 可以直接使用模块提供的工具——全局变量、函数、类 注意，如果两个模块存在同名函数，那么后导入模块的函数，会覆盖掉先导入的函数 一旦发生冲突，可以使用as关键词，给其中一个工具起一个别名 第三种：from…import* （了解）不需要使用模块名.，但是易发生重名冲突 这种方式不推荐，因为函数重名并没有任何的提示，出现问题不好排查 模块的搜索顺序（了解）python的解释器在导入模块时，会： 搜索当前目录指定模块名的文件，如果有就直接导入 如果没有，再搜索系统目录 在开发时，给文件起名，不要和系统的模块文件重名！ python中的每一个模块都有一个内置属性_file_可以查看模块的完整路径 导入文件的细节 一个独立的python文件就是一个模块 在导入文件时，所有没有任何缩进的代码都会被执行一遍 实际开发场景中 在实际开发中，每一个模块都是独立开发的，大多有专人负责 开发人员通常会在模块下方，增加一些测试的代码 仅在模块内使用，而被导入到其他文件中不需要执行 __name___属性 __name__属性可以做到，测试模块的代码，只在测试情况下被运行，而在被导入时，不会执行！ __name__是python的一个内置属性，记录着一个字符串 如果是被其他文件 导入的，__name__就是模块名 如果是当前执行的程序，__name__就是__main__ 在很多python文件中都会看到以下格式的代码 12345678910111213# 导入模块# 定义全局变量# 定义类# 定义函数# 在代码下方def main(): #... pass# 根据__name__判断是否执行以下代码if __name__ == &quot;__main__&quot;: # 测试代码 此时测试代码，在本模块被import后不会执行 包概念 包是一个包含多个模块的特殊目录 目录下有一个特殊文件__init__.py 包名的命名方式和变量名一致 好处 使用import 包名可以一次性导入包中所有的模块 __init__.py 要在外界使用包中的模块，需要在__init_——。py中指定对外界提供的模块列表 123# 从当前目录 导入 模块列表from . import send_messagefrom . import receive_message 发布模块和安装模块建议百度，不同平台不一样 高级变量类型列表 尽管python的列表可以存储不同类型的数据，但是在开发中，更多的应用场景是列表存储相同类型的数据 定义一个列表: list01=[] 输入list.按下TAB键，ipython会提示列表能够使用的方法 分类 关键字/函数/方法 说明 增加 insert(索引，数据) 指定位置插入数据 append(数据) 末尾追加数据 extend(列表2) 将列表2的数据追加到列表 修改 列表[索引]=数据 删除 del 列表[索引] 删除指定索引的数据 remove[数据] 删除第一个出现的指定数据 pop 删除末尾数据 clear 清空列表 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 排序 sort() 升序排序 sort(reverse=True) 降序排序 reverse() 逆序，反序 索引 .index(数据) 查找数据所在的索引 列表的循环遍历12for name in list_: print(name) 元组 Tuple元组与列表类似，不同之处在于元组不能修改 元组表示多个元素组成的序列 元组在python开发中，有特定的应用场景 tuple_1=(“zhangsan”, 18, 1.75) 只有一个元素的元组需要加逗号 tuple01=(5,) 元组的常用操作 count index 元组的应用场景 函数的参数和返回值，使一个函数可以接收任意多个参数，或者一次返回多个数据 格式字符串，格式化字符串后面的()本质上就是一个元组 让列表不可以被修改，以保护字符串 元组和列表之间的转换 list函数可以把元组转换为列表 tuple函数可以把列表转换为元组 元组作为返回值 可以省略括号 接收时可以写成 123def func(): return 1,2a,b=func() 字典字典的定义 dictionary（字典）是除列表以外python之中最灵活的数据类型 字典同样可以用来存储多个数据 通常用于存储描述一个物体的相关信息 和列表的区别 列表是有序的对象集合 字典是无序的对象集合 字典用{}来定义 字典使用键值对存储数据，键值对之间用,分隔 键key是索引 值value是数据 键和值之间使用:分隔 键必须是唯一的 值可以取任何数据类型，但键只能使用字符串、数字或元组 字典的取值 dict[键] 字典的增加/修改 dict[键]=值 字典的删除dict.pop(键) 统计键值对数量 len 合并字典 dict.update(新的字典) 清空字典 dict.clear() 字典的循环遍历 在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 方法：for循环遍历键，通过键找到值 字符串字符串常用操作 len count(字符串)统计小字符串在大字符串中出现的次数 index(字符串)某一个子字符串出现的位置 判断类型 方法 说明 string.isspace() 如果string中只包含空格（包括\\n\\t\\r)，则返回True string.isalnum() 如果string至少有一个字符并且所有字符都是字母或数字，返回True string.isalpha() 判断是否全是字母 isdecimal() 判断是否只包含数字，全角数字 isdigit() 判断是否只包含数字，全角数字,(1),\\u00b2 isnumeric() 判断是否只包含数字，全角数字，汉字数字 istitle() 判断是否是标题化字符串（每个单词首字母大写） islower() 至少包含一个区分大小写的字符，并且都是小写 isupper() 至少包含一个区分大小写的字符，并且都是大写 查找和替换 方法 说明 startswith(str) 是否以str开头 endswith(str) 是否以str结尾 find(str,start=0,end=len(string)) 检测str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 rfind() 从右边开始查找 index() 与find类似，不过str不在string中会报错 rindex() 从右边开始查找 replace(old_str,new_str,num=string.count(old)) 把string中的old_str替换成new_str，如果num指定，则替换不超过num次 文本对齐 方法 说明 ljust(width) 左对齐,ctrl+Q查看具体用法 rjust(width) 右对齐 center(width) 居中 大小写转换 方法 说明 capitalize() 第一个字符大写 title() 每个单词首字母大写 lower() upper() swapcase() 大小写翻转 去除空白字符 方法 说明 lstrip() 裁掉左边开始的空白字符 rstrip() 裁掉右边开始的空白字符 strip() 裁掉两边的空白字符 拆分和连接 方法 说明 partition(str) 将string分成str前面，str，str后面三部分 rpartition(str) 同上，不过从右边开始查找 split() splitlines() 按照\\r \\n \\r\\n分隔 string.join(seq) 以string作为分隔符，将seq中所有的元素（的字符串表示）合并为一个新的字符串 字符串的切片 切片方法适用于：字符串、列表、元组 字符串逆序 str[-1::-1]或者str[::-1] 公共方法Python内置函数 内置函数：无需import可以直接使用的函数 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除扮靓 del有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对key比较 min(item) 返回容器中元素最小值 如果是字典，只针对key比较 cmo(item1,item2) 比较两个值，-1小于/0等于/1大于 python3取消了cmp函数 注意 字符串比较符合以下规则：’0’&lt;’A’&lt;’a’ 切片切片是左闭右开的 字典是无序的，不能进行切片 对比列表追加方法12345678910list1=[1,2,3]list1+[4,5]和list1.extend([4,5])的区别是extend改变了list1，而`+`返回新的listlist1.append(6)list1.append([7,8])list1=[1,2,3,4,5,6,[7,8]] 成员运算符in和not in 对字典使用时，针对的是键 完整的for循环语法for 变量 in 集合: 循环体代码 else: for循环完整地执行完成后（没有中途break），执行else语句代码 类和对象类的设计 类名使用大驼峰命名法：GoodPerson 内置函数dir 使用dir传入标识符/数据，可以查看对象内的所有属性和方法 变量，数据，函数都是对象 self参数 由哪一个对象调用的方法，方法内部的self就是哪个对象的引用（类似C++/Java的this） 在类封装的方法内部，self就表示当前调用方法的对象自己 调用方法时，程序员不需要传递self参数 在方法内部 可以通过self访问对象属性 也可以通过self，调用其他对象的方法 给对象增加属性 在类外，对对象直接添加，不推荐 tom.name='TOM' 初始化方法 当使用类名()创建对象时，会自动执行以下操作 为对象在内存中分配空间——创建对象 为对象的属性设置初始值——初始化方法init 这个初始化方法就是_init_方法，该方法是对象的内置方法 _init_方法是专门用来定义一个类具有哪些属性的方法！ 123456def __init__(self,name,age): self.name=name self.age=agedef show(self): print('My name is %s'%self.name) print('My age is %s'%self.age) 内置方法和属性 _del_方法 对象被从内存中销毁前，会被自动调用 如果希望在对象被销毁前，再做一些事情，可以考虑_del_方法 _str_方法 返回对象的描述信息，print函数输出使用 必须返回一个字符串 身份运算符身份运算符用于比较两个对象的内存地址是否一直（即是否是同一个对象的引用） 在Python中针对None比较时，建议使用is判断 is is not is和==的区别 is用于判断两个变量引用对象是否是同一个 ==用于判断引用变量的值是否相等 私有属性和私有方法 定义方式 定义属性或者方法时，在属性名或方法名前增加两个下划线，定义的就是私有属性和私有方法 子类对象不能直接访问父类的私有属性或私有方法，可通过父类的公有方法间接访问 伪私有属性和私有方法（了解） 在日常开发中，不要使用这种方式，访问对象的私有属性或私有方法 在Python中，没有真正意义的私有 在给属性、方法命名时，实际上是对名称做了一些特殊处理，使得外界无法访问 处理方式：在名称前加上_类名=&gt;_类名__名称 （前面一个杠，后边两个杠） 继承单继承写法：class Dog(Animal): 方法的重写重写父类方法有两种情况 覆盖父类的方法 对父类方法进行扩展 在需要的位置使用super().父类方法来调用父类方法的执行 1234class Cat(Animal): def eat(self): super().eat() print(&quot;Cat is eating !&quot;) super()就是使用父类创建出来的对象 多继承 写法：class 子类名（父1，父2...） 应避免父类之间存在同名属性或方法的情形，此情形下应尽量避免使用多继承 MRO——方法搜索顺序（了解） Python中针对类提供了一个内置属性__mro__，可以查看方法搜索顺序 MRO是method resolution order，主要用于在多继承时判断方法，属性的调用路径 1234567class A: passclass B: passclass C(A,B): passprint(C.__mro__) 12结果：(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;) 新式类与旧式类 object是python中为所有对象提供的基类，提供有一些内置的属性和方法，可以使用dir函数查看 新式类:以object类为基类的类，推荐使用 经典类：不以object类为基类的类，不推荐使用 python3中定义的类，如果没有指定父类，默认是新式类 为了保证编写的代码能够在python2和python3的解释器下运行，如果没有父类，建议统一继承object class A(object): 多态多态不同的子类对象调用相同的父类方法，产生不同的执行结果 类是一个特殊的对象 Python中一切皆对象 在程序运行时，类同样会被加载到内存 在Python中，类是一个特殊的对象——类对象 在程序运行时，类对象在内存中只有一份，使用一个类可以创建出很多个对象实例 除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法 通过类名.的方式，可以访问类的属性或调用类的方法 类属性和实例属性例如： 123456class Group: count = 0 def __init__(self): Group.count += 1 此时，每创建一个对象，Group类的count就会+1 属性的获取机制（了解）访问类属性有两种方式 类名.类属性 对象名.类属性（不推荐） 会导致歧义，如果写出对象.类属性=值，只会给对象添加一个属性，而不会影响类属性的值 类方法类方法语法如下 1234class Person: @classmethod def work(cls): print(&quot;Working now&quot;) 静态方法 如果一个方法，不需要访问实例属性，也不需要访问类属性，则可以将其封装成一个静态方法 1234567class Cat: @staticmethod def run(): print(&quot;running now！&quot;) Cat.run() 单例设计模式 设计模式： 设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案。 使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码的可靠性 单例设计模式 目的：让类创建的对象，在系统中只有唯一一个实例 每次执行类名（）返回的对象，内存地址都是相同的 单例设计模式的应用场景 打印机对象 音乐播放器对象 __new__方法 使用类名（）创建对象时，python解释器会先调用__new__方法为对象分配空间 __new__是一个由object基类提供的内置静态方法，主要作用由两个： 在内存中为对象分配内存空间 返回对象的引用 python解释器获得对象的引用后，将引用作为第一个参数，传递给__init__方法 重写__new__方法的代码非常固定 重写__new__方法一定要 return super().__new__(cls) 否则python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法 注意：__new__是一个静态方法，在调用时需要主动传递cls参数 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-POpScgrh-1615807570858)(/images/python_3.png)] 单例设计模式案例123456789101112131415class MusicPlayer(object): instance=None # 初始化动作记录 init_flag=False def __new__(cls, *args, **kwargs): if MusicPlayer.instance is None: cls.instance=super().__new__(cls) return cls.instance def __init__(self): if MusicPlayer.init_flag: return MusicPlayer.init_flag=True print(&quot;初始化播放器&quot;) 异常异常的概念 程序在运行时，如果python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常 程序停止执行并且提示错误信息这个动作，我们称之为：抛出(ralse)异常 程序开发时，很难将所有的特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性 捕获异常简单的捕获异常语法1234try: 尝试执行的代码except: 出现错误的处理 错误类型捕获 在程序执行中，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 12345678try: num=int(input(&quot;Enter a num:&quot;)) result=8/num print(&quot;result is %.1f&quot;%result)except ZeroDivisionError: print(&quot;除0错误！&quot;)except ValueError: print(&quot;输入数字有误！&quot;) 未知异常捕获12345678try: num=int(input(&quot;Enter a num:&quot;)) n=8/num print(&quot;result is %.1f&quot;%n)except ValueError: print(&quot;输入数字有误！&quot;)except Exception as result: print(&quot;未知错误%s&quot;%result) 异常捕获完整语法123456789101112try: passexcept 错误类型1: passexcept (错误类型2，错误类型3): passexcept Exception as result: print(result)else: 没有异常时，执行的代码finally: 无论是否出现异常，都会执行的代码 异常的传递 异常的传递——当函数/方法执行出现异常时，会将异常传递给方法/函数的调用一方 如果传递到主程序，仍然没有异常处理，程序才会被终止 提示 在开发中，可以在主函数中增加异常捕获 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中 这样就不需要再代码中，增加大量的异常捕获，能够保证代码的整洁 12345678def func1(): return 8/int(input(&quot;ENter a num:&quot;))def func2(): print(func1())try: func2()except Exception as abc: print(&quot;错误类型：%s&quot;%abc) raise异常应用场景 在开发中，除了代码执行出错，python解释器会抛出异常之外 还可以根据应用程序特有的业务需求主动抛出异常 案例： 1234567891011121314def input_password(): pwd = input(&quot;输入密码&quot;) pwd_len = len(pwd) if pwd_len &lt; 8: ex=Exception(&quot;密码少于8位&quot;) raise ex return pwdtry: print(input_password())except Exception as result: print(&quot;发生错误！错误类型：%s&quot; % result) 文件文件的基本操作1.操作文件的套路在计算机中要操作文件的套路非常固定，一共三个步骤 打开文件 读写文件 读：将文件内容读入内存 写：将内存内容写入文件 关闭文件 2.操作文件的函数/方法 在python中要操作文件需要记住1个函数和3个方法 序号 方法 说明 1 open 打开文件，并且返回文件操作对象 2 read 将文件内容读取到内存 3 write 将指定内容写入文件 4 close 关闭文件 open函数负责打开文件、并且返回文件独享 read/write/close三个方法都需要通过文件对象来调用 3.read方法 open函数的第一个参数是要打开的文件名（区分大小写） 文件存在，返回文件操作对象 不存在，则会抛出异常 read方法可以一次性读入并返回文件的所有内容 close方法负责关闭文件 如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 注意：方法执行后，会把文件指针移动到文件的末尾 提示 在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读写操作 文件指针 文件指针标记从哪个位置开始读取数据 第一次打开文件时，通常文件指针会指向文件的开始位置 当执行了read方法后，文件指针会移动到读取内容的末尾 默认情况下会移动到文件末尾 思考 如果执行了一次read方法，读取了所有内容，那么再次调用read方法，还能得到内容吗？ 答案：不能！因为文件指针已经在文末。 4.打开文件的方式 open函数默认以只读方式打开文件，并且返回文件对象 语法如下: f=open(&quot;文件名&quot;，“访问方式”) 访问方式 说明 f 以只读方式打开文件。默认方式 w 以只写方式打开文件。如果文件存在会被覆盖。文件不存在，则创建新文件 a 以追加方式打开文件。文件不存在，则创建新文件 r+ 以读写方式打开文件。文件不存在，则抛出异常 w+ 以读写方式打开文件。文件存在，则被覆盖。文件不存在，则创建新文件 a+ 以读写方式打开文件。文件存在，则指针放结尾。不存在，则创建新文件。 提示： 频繁地移动文件指针，会影响文件地读写效率，开发中更多地时候，会以只读，只写的方式来操作文件 5.按行读取文件内容 read方法默认会把文件的所有内容一次性读取到内存 如果文件太大，对内存的占用会很严重 readline方法 readline方法可以一次读取一行内容 方法执行后，会把文件指针移动到下一行，准备再次读取 读取大文件的正确姿势 1234567891011121314151617# 打开文件file = open(&quot;D:\\\\new.txt&quot;)while True: # 读取一行内容 text = file.readline() # 判断是否读取到内容 if not text: break # 每读取一行的末尾已经有了一个'\\n' print(text, end=&quot;&quot;)# 关闭文件file.close() 复制文件案例 1234567891011file1=open(&quot;file1.txt&quot;)file2=open(&quot;file2.txt&quot;,&quot;w&quot;)while True: text=file1.readline() if not text: break file2.write(text)file2.close()file1.close() 6.文件/目录的常用管理操作 在终端/文件浏览器，中可以执行常规的文件/目录管理操作，例如： 创建、重命名、删除、改变路径、查看目录内容… 在python中，如果希望实现上述功能，需要导入os模块 文件操作 序号 方法名 说明 示例 1 rename 重命名文件 os.rename(源文件名，目标文件名) 2 remove 删除文件 os.remove(文件名) 目录操作 序号 方法名 说明 示例 1 listdir 目录列表 os.listdir(目录名) 2 mkdir 创建目录 os.mkdir(目录名) 3 rmdir 删除目录 os.rmdir(目录名) 4 getcwd 获取当前目录 os.getcwd() 5 chdir 修改工作目录 os.chdir(目标目录) 6 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示：文件或者目录操作都支持相对路径和绝对路径 7.文本文件的编码格式 文本文件存储的内容是基于字符编码的文件 python2默认使用ASCII编码 python2中不能直接使用中文，要使用则需在文件第一行 # *-* codeing:utf-8 *-* 或者# coding=utf-8 在python2中遍历含中文字符串会乱码，需要在字符串前加u u”hello世界” 告诉解释器这是一个utf-8格式的字符串 python3默认使用UTF-8编码 ASCII编码和UNICODE编码 计算机中只有256个ASCII字符 一个ASCII在内存中占用1个字节，2的8次方为256 UTF-8编码格式 计算机中使用1~6个字节来表示一个utf-8字符，涵盖了地球上几乎所有地区的文字 大多数汉字会使用3个字节表示 utf-8是UNICODE编码的一种编码格式 eval函数evaluate：评估的缩写 eval()函数十分强大——将字符串当成有效的表达式来求值，并返回计算结果 123456789101112131415# 基本的数学计算result=eval(&quot;2*3+1&quot;)print(result)# 字符串重复str=&quot;'#'*10&quot;print(eval(str))# 将字符串转换成列表str=&quot;[1,2,3,4,5]&quot;print(type(eval(str)))# 将字符串转换成字典str=&quot;{'name':'xiaoming','age':18}&quot;print(type(eval(str))) 不要滥用eval 在开发时千万不要使用eval直接转换input的结果 用户可以通过输入__import__('os').system('ls')等，对系统发出命令！ 等价于 12import osos.system(&quot;终端命令&quot;) 补充知识点 id()可以查看内存地址 可以将None赋值为任何一个变量 随机数 import random random.randint(a,b) 返回[a,b]之间的整数，包含a和b 函数调用不能放在函数定义之前，因为python是解释型语言，一行一行执行的 Pycharm中F8 Step Over可以单步执行，会把函数调用看作一行代码直接执行 F7 Step into可以单步执行代码，如果是函数会进入函数内部 pyc文件： c是compiled编译过的意思 python解释器为了提高程序执行速度，将模块的源码转换为**字节码 # todo注释 提示自己有什么活还没干 返回值是元组时，省略小括号 列表变量调用+=本质上是在执行列表变量的extend方法，不会修改变量的引用p 所以在函数中，普通变量+=不会影响外界数据，但是列表的+=会影响x5 python能够自动将一对括号内部大的代码连接在一起，可以放心换行 python占位符pass，无意义，用来暂时保证程序不报错 object是所有类的基类 join(列表、字典、元组)将序列中的元素以指定的字符连接生成一个新的字符串 要求列表..中是字符串 list1=[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;] str1=&quot;,&quot;.join(list1) print(str1) list2=[1,2,3,4] str2=&quot;,&quot;.join(str(n) for n in list2) print(str2)","link":"/2021/03/15/Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"C++编程中遇到的问题","text":"普通问题 C++中默认的取整方式是向下取整 如果需要计算a/b向上取整，则写成(a+b-1)/b即可 其含义是，将a提升一个b的倍数，但是因为减一，又到不到上面一个倍数 C++左值、右值、左值引用、右值引用 左值和右值的概念 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 引用 引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。 引用可以改变指针的指向，还可以改变指针所指向的值。 引用的基本规则： 声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义； 对引用的一切操作，就相当于对原对象的操作。 bool类型数字，赋值任意非0数字，最后保存的都是1（使用的C++98是这样的） 复制数组memcpy(目标数组,被拷贝数组,字节数); 容器求和函数 123#include &lt;numeric&gt;vector&lt;int&gt;arr(3,5);cout&lt;&lt;accumulate(arr.begin(),arr.end(),0); //第三个参数是sum初始值 C++是静态类型语言,对象的类型在编译时必须确定,且运行时不能更改。类型转换只不过是将某种类型的对象当做另一种类型的对象来用而已,对象本身的类型不会改变 所以试图对变量或者对象本身进行类型转换是不切实际的，如int a; (long long)a;或者a=(long long)a; C++ 伪随机数 由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。） 这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数 123456789#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;int main(){ srand((unsigned)time(NULL)); for(int i=0;i&lt;100;i++) printf(&quot;%d &quot;,rand()); return 0;} next_permutation()使用之前必须排好序！ lower_bound是找数组或者容器中第一个大于等于val的值 upper_bound是找数组或容器中第一个大于val的值 对于需要使用long long的时候，注意用int进行计算之前就要对第一个数进行强制类型转换，如下 123456LL ans=0;for(int i=1;i&lt;=2019;i++){ if(check(i)){ ans+=(LL)i*i*i; }} stringstream重复使用一定要clear 定义一个引用，Typename &amp;A=xxx 大多数编译器要求创建数组时，长度是常量，即直接给出长度。 可以使用new或者malloc来进行动态创建 C++中的log函数 以e为底：log(n) 以10为底：log10(n) 以m为底：log(n)/log(m) C语言&lt;limits.h&gt;有INT_MAX、INT_MIN，C++中推荐使用&lt;climits&gt; 队列用push, set用insert CodeBlocks没有代码补全解决方法： 建立工程文件 修改settings-editor-code completion，像如下这样设置 然后重启codeblocks C++中，访问迭代器指向的元素需要使用(*it)，若是访问对象的成员则使用it-&gt;first。而auto则直接使用，访问成员则使用.。 C++中除了函数以外，如类、结构体，结尾都要加; C++11新增的emplace与之前容器所用的insert,push等的区别是，emplace自动调用构造函数先对元素进行构造再插入，而之前的是之前插入元素。 lower_bound()用来寻找[first,last)范围内第一个大于等于target的元素，如果时数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。如果不存在，那么返回可以插入该元素的位置的指针或迭代器。 此外用其返回值-nums.begin()，可以直接得到其位置。 upper_bound()同理 函数指针 12345678910111213int add(int a,int b){ return a+b;}int sum(int a,int b,int c,int (*func)(int,int)){ int t=func(a,b); return func(t,c);}int main(){ int a=1,b=2,c=3; printf(&quot;%d&quot;,sum(a,b,c,add)); return 0;} 创建对象数组时，如果该对象写了构造方法则会把默认构造顶掉，需要补上。这样才能创建对象数组。 Clion不能debug，是因为新版本问题，使用2020.2.5版本即可 CodeBlocks不能debug是因为没有建立工程 bool变量在java里默认是false, C+ +里没有规定,所以依赖编译器实现，千万不要让编译器决定你的默认值，永远初始化 codeblocks下载下来编译器有问题，就去重新下自带mingw的 gcc、g++、mingw gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。 现在你在编译代码时调用的gcc，已经不是当初那个c语言编译器了，更确切的说他是一个驱动程序，根据代码的后缀名来判断调用c编译器还是c++编译器 (g++)。比如你的代码后缀是*.c，他会调用c编译器还有linker去链接c的library。如果你的代码后缀是cpp, 他会调用g++编译器，当然library call也是c++版本的。 就把gcc当成c语言编译器，g++当成c++语言编译器用就是了。 mingw作为gcc在windows上的一个实现 访问迭代器所指向的对象的内部成员，括号要这样写:(*it)-&gt;parent C++中判断子串用s1.find(s2)!=string::npos表示s2是s1的子串 typedef long long LL; 运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041struct fraction { int up; int down; //构造函数，并保证分子分母互质 fraction(int a, int b) { int t = gcd(a, b); while (t != 1) { a /= t; b /= t; t = gcd(a, b); } up = a; down = b; } //求最大公因数 int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } //分数除法 friend fraction operator/(fraction &amp;f1, fraction &amp;f2) { return {f1.up * f2.down, f1.down * f2.up}; } //分数比大小 friend bool operator&lt;(fraction &amp;f1, fraction &amp;f2) { return f1.up * f2.down &lt; f2.up * f1.down; } friend bool operator&gt;(fraction &amp;f1, fraction &amp;f2) { return !operator&lt;(f1, f2); } //拷贝构造函数 fraction(fraction &amp;b) { up = b.up; down = b.down; }}; C++中除了0，都是true 故不要用 return person1.age-person2.age作为运算符重载的返回值 数组作为参数传递时会退化成指针，无法在函数内得出长度 二维数组可以使用全排列next_permutation()吗？ 对于含有重复元素的序列，next_permutation()会自动去重吗？ 是！ 注意！使用之前，序列必须已经排好序！ bool型占1个字节，int占4字节 创建标记数组时，优先使用bool型！ 因为竞赛题中，对内存大小的使用是有限制的 c/c++的编译器中有一个变量表，表的关键字段有（数据类型，变量名，首地址，值），每声明一个变量，就把这个变量的相关信息填进表中 next_permunation的使用，注意需要添加using namespace std;和algorithm 注意！使用之前，序列必须已经排好序！ 123456789101112#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int main(){ char *arr=new char[3]{'a','b','c'}; do{ for(char*p=arr;p&lt;arr+3;p++) printf(&quot;%c &quot;,*p); putchar('\\n'); }while(next_permutation(arr,arr+3)); return 0;} 以数组为参数的函数内部，无法正确用sizeof(arr)/sizeof(arr[0])计算出数组长度，因为这时的数组名arr已经退化为普通的指针，失去了原来作为数组名的特殊数据结构，所以只能在外边计算完len，作为参数传入才可。 使用memset需要添加&lt;cstring&gt;头文件，只能赋值0或者1，因为它是以字节为单位进行赋值的，如果赋其他值，可能会出错，赋其他值可以用fill函数，但更慢 memeset(数组名，值，sizeof(数组名)) 注意：这里sizeof（数组名）是计算出这个数组有多少个字节！，直接写数组的长度会出错 C++中的随机数 123456#include &lt;cstdlib&gt;#include &lt;ctime&gt;srand((unsigned)time(NULL));for(int i=0;i&lt;10;i++){ printf(&quot;%d &quot;,rand());} 其范围是[0,RAND_MAX]，RAND_MAX是stdlib头文件中的一个常数 故如果要输出[a,b]范围内的随机数，需要使用rand()%(b-a+1)+a, C++全排列的写法，注意，next_permutation第二个参数要多一位 注意！使用之前，序列必须已经排好序！ 123456789#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[]={1,2,3}; do{ printf(&quot;%d %d %d\\n&quot;,arr[0],arr[1],arr[2]); }while(next_permutation(arr,arr+3)); //注意这里是arr+3！！} C++动态创建多维数组的方法 1234int a,b,c,m;scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;m);int *ships=new int[a*b*c];int (*attack)[7]=new int[m][7]; 二维数组初始化 bool mark[N][N]={false}; set集合添加基本数据类型以外的数据，需要添加比较器，如添加char* 123456struct cmp{ bool operator()(char*a,char*b){ //必须重载()括号运算符 return strcmp(a,b)&lt;0; }};set&lt;char *,cmp&gt; record_digits; 结构体作为vector、set、que等的参数可以直接写成这样 123456789101112131415#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct Node{ char*s; int key; Node(char*_s,int _key):s(_s),key(_key){}};int main(){ queue&lt;Node&gt;que; char*s=&quot;abc&quot;; que.push({s,2}); que.push(Node(s,1)); return 0;} VSCode中文乱码问题 因为windows默认编码是GB2312（即GBK），VSCode默认是UTF-8，所以发生中文乱码 在设置中找到Files:Encoding,修改为Simplified Chinese(GB 2312)即可 当前页面，需要点击右下角的编码进行适配 fstream对象打开文件时，如何用自定义的文件名称ofs.open(date.c_str(), ios::out|ios::app);使用字符串的方法c_str()即可 字符数组清空char arr[10]={0}; 获取系统时间 1234567891011121314151617181920212223struct tm t; //tm结构指针time_t now; //声明time_t类型变量time(&amp;now); //获取系统日期和时间localtime_s(&amp;t, &amp;now); //获取当地日期和时间tm_sec分钟后的几秒 (0-59)。tm_min小时后的分钟 (0-59)。tm_hour午夜后经过的小时 (0-23)。tm_mday月 (1-31) 天。tm_mon月 (0 – 11;年 1 月 = 0）。tm_year年份 （当前年份减去 1900年）。tm_wday星期几 (0 – 6;星期日 = 0）。tm_yday每年的一天 (0-365;1 月 1 日 = 0)。tm_isdst如果夏令时有效，则为，正值夏时制不起作用; 如果为 0如果夏时制的状态是未知的负值。 如果 TZ 设置环境变量，C 运行库会假定规则适用于美国境内用于实现夏令时 (DST) 计算。 switch语句中，如果要定义局部变量，需要在那句case加{} 直接在文件夹里打开codeblocks生成的exe文件，报错找不到libgcc_s_dw2-1.dll, 尝试重新安装该程序以解决问题 只需要在电脑中搜索这个文件名，然后添加到系统环境变量path里D:\\Softwares\\CodeBlocks\\MinGW\\bin,添加其bin目录即可 判断int n是否素数只需判断是否整除2~&radic;n(向下取整)项 ClodeBlocks要在General setting—Encoding settings里设置位UTF-8 在写1&lt;x&lt;2时，只能写成1&lt;x&amp;&amp;x&lt;2 使用递归计算阶乘时，要么参数传引用可以使用**–n**,要么直接传参，只能使用n-1作为下一层递归的参数 123456int fac(int &amp;n) //使用传引用 { if(n==1) return 1; return n*fac(--n); //此时--n可以改变n的值} 123456int fac(int n) //直接传参{ if(n==1) return 1; return n*fac(n-1); //只能用n-1作为新的参数，--n不能改变n的值} 因为0的ASCII码值为48，因此数字0~9转化为字符，只需+48即可 二维数组作为参数，行数可以不写，列数要写 给二维数组赋值 123char CountryName[3][30]; //定义二维字符数组 for(int i=0;i&lt;3;i++) cin&gt;&gt;CountryName[i]; 定义一个函数，要求该函数能够返回一个指向字符串“I love C”的指针并能在主程序中正确得到该字符串的内容 123456789char *getString(){ char str[]=&quot;abc&quot;; //此种写法错误！！！ 此时的str字符数组是一个局部变量 return str; //当函数getString执行完毕后，str【】就被系统回收}int main(){ cout&lt;&lt;getString(); //无法得出} 123456//应该使用指针，则系统不会回收char *getString(){ char *str=&quot;abc&quot;; return str;} int型转字符串 C++11标准库已添加to_string方法 利用指针给数组、二维数组赋值、输出，更方便，不过注意定义指向二维数组的指针时，需要如下 1int *p=&amp;maxtrix[0][0] 使用cin给字符串指针赋值，必须先new一个实体 12string *str=new string;cin&gt;&gt;*str; //正确 12string *str;cin&gt;&gt;*str; //错误！ 声明函数时记得带上返回值 类模板的声明和实现貌似不能分开（不能放在不同文件中） 在实现复数与int型数相加时，重载运算符+函数为友元函数时，参数不能使用引用！ 1friend Complex operator+(Complex,Complex); //使用引用会导致类型转换出错 写头文件的时候报错[Error] ‘ostream’ does not name a type io库的都在std中, 使用前要声明一下 在头文件中使用了cout，同样要using namespace std; 文件操作 文件概念：文件是磁盘中的数据 ASCII文件，每个字节存放一个ASCII字符 二进制文件，把内存中的存储形式原样输出到磁盘上存放 C++中有三个用于文件操作的文件类 ifstream，由istream派生来，支持从磁盘输入（输入到内存） ofstream，由ostream派生来，支持从磁盘输出 （从内存输出） fstream，由iostream派生来，支持对磁盘文件的输入输出 文件操作的过程： 要以磁盘文件为对象进行输入输出，必须定义一个文件流对象，通过文件流对象将数据从内存输出到磁盘文件，或者将磁盘文件输入到内存。 定义文件流对象后，还需要将其与指定磁盘文件建立关联，并确定工作方式（输入还是输出，ASCII还是二进制）。 相对路径与绝对路径（windows下） 相对路径 ./当前文件夹下 ../上一级文件夹下 这里有个坑：Clion的exe文件和.cpp文件不在同一文件夹下，所以直接使用./xxx.txt或者xxx.txt不可以 绝对路径 E:\\\\dir1\\\\dir\\\\a.txt 对ASCII文件的操作 会自动跳过空格、回车和制表符 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){ ofstream outfile(&quot;a.txt&quot;, ios::out); if (!outfile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } // 写入数字 1-5 到文件中 for (int i = 1; i &lt; 6; i++) { outfile &lt;&lt; i &lt;&lt; '\\n'; } outfile.close(); ifstream infile(&quot;a.txt&quot;, ios::in); if (!infile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char data; // 从文件中读出数字 1-5 for (int i = 1; i &lt; 6; i++) { infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; '\\n'; } infile.close(); return 0;} 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;char strs[201];int main(){ //读取文件 ifstream ifs(&quot;D:\\\\tmp.txt&quot;,ios::in); if(!ifs.is_open()){ cerr&lt;&lt;&quot;Fail to open file&quot;; return 0; } //会自动跳过空格回车换行符 int i=0; while(!ifs.eof()){ //一直读到文件末尾 ifs&gt;&gt;strs[i++]; } for(int i=0;i&lt;200;i++){ cout&lt;&lt;strs[i]; } return 0;} 对二进制文件的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){ ofstream outfile(&quot;a.txt&quot;, ios::binary); if (!outfile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char a[] = {'h', 'e', 'l', 'l', 'o', ','}; char b[] = {'s', 'e', 'n', 'i', 'u', 's', 'e', 'n', '!'}; outfile.write(a, 6); // 将以 a 为首地址的 6 个字符写入文件 outfile.write(b, 9); outfile.close(); ifstream infile(&quot;a.txt&quot;, ios::binary); if (!infile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char data[6]; infile.read(data, 6); // 从文件中读出 6 个字符到以 data 为首地址的字符数组中 for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; data[i]; } char datb[6]; infile.read(datb, 9); for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; datb[i]; } infile.close(); return 0;} 输入输出问题 printf对浮点数的摄入规则四舍六入五成双—— 四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一 那么如何手动实现四舍五入的效果呢？比如要实现四舍五入保留两位小数，则double a=1.0050;printf(&quot;%.2f&quot;,(a*100+0.5)/100) 输入一行数据两种方法的比较：gets(char*),scanf(&quot;%s&quot;,&amp;arr) gets(char*)： 遇到buff中的第一个\\n立马结束输入，然后将字符数组的字符串结尾处后一个设置为\\0 如果控制台只输入一个\\n（buff中第一个就是回车），那么gets会立即结束输入，并且将字符数组第一个位置写成\\0 scanf(&quot;%s&quot;,&amp;arr) 会将两个enter之间的内容放入arr字符数组中，并且结尾后一位会放上\\0 如果buff中\\n\\n\\nabc\\n，则会吸收掉前面三个回车和后边一个回车，将abc写入字符数组 输入一行数据（字符串）的两种方法 第一种：getline(cin,str) 第二种：cin.getline(char []buff,100) 12string temp;getline(cin,temp); 1234char buff[100];cin.getline(buff,100);int len=strlen(buff);string temp2(buff,len); 注意在使用之前，如果有cin，或者scanf（除%c外），则需要吸收回车 cin和scanf的区别 scanf使用的是输入缓冲，cin使用的是输入流，但是输入流会主动与输入缓冲同步 std::ios::sync_with_stdio(false);输入流可以设置设置不与输入缓冲同步 scanf(&quot;%c&quot;) %c是一个很奇葩的设定，单独读入一个字符，包括不可见的控制字符（换行等），而其他格式化符号（如%d %lld %f %lf %s等）会在读入未完成时将换行符、空格、制表符等空白字符统统舍弃忽略（但是会留在输入缓冲中），直到读到了足够的数据或遇到文件结尾才结束。 换行符（等其他不可见控制字符）问题 cin（cin所有类型，包括cin&gt;&gt;char类型变量)，和，scanf除%c以外的scanf的情况，遇到控制字符（如换行符）在读取时会直接跳过（不读取），但是输入的最后一个控制字符（如换行符），会留在输入缓冲中。因此如果后边紧跟着scanf的%c，一定要用getchar来吸收掉控制字符。 %c和其他（如cin，%f）等连用的问题 如上边所说，如果前边有除scanf %c以外的所有输入情况，都得吸收控制字符。 以上讨论暂不包括行输入。 两种输入一行字符串的方法getline(cin,str)和cin.get(char arr[],100)，完成输入之后，不会在输入缓冲区留下控回车 输入一行数据，可以使用getline(cin,str) 关于换行符的问题：因为scanf()会将换行符留在缓存中，所以如果geline前边有scanf，则需要getchar()吸收回车，循环getline之间并不需要吸收换行符。 对字符进行输入时，一行结束，要吸收空格 把时间中的3点12分输出成03:12 printf(&quot;%02:%02d&quot; ,h,m) 读入一行数据可以使用(注意读入一行数据前如果有单个数据读入，需要吸收换行符） 将一行数据中的某些信息（如字符串中的数字）进行提取，可以使用sscanf; 123456789int N;cin&gt;&gt;N;cin.get(); //吸收换行符char line[100];cin.getline(line,100)int len=strlen(line);sscanf(line,&quot;%d:%d:%d (+%d)&quot;,&amp;h,&amp;m,&amp;s,&amp;d); printf输出浮点数采取的保留小数措施是四舍六入五成双，比如保留2位小数时 第二位小数，如果&lt;=4则舍去，如果&gt;=6则进位 如果==5 5后边还有数，那么舍5进1 5后没有数 5前是奇数，则舍5进1 5前是偶数，则舍去5 %5s表示输出宽度为5的字符串（如果长度不够，左边补空字符） printf(&quot;%*s&quot;,5,&quot;abc&quot;);有上述同样的效果 scanf中 float是%f，double是%lf long long是%lld printf中 float和double都是%f long long仍然是%lld 字符串相关问题 c++分割字符串的方法stringstream和getline；stringstream，需要.str仅仅clear并没有释放内存，会导致内存使用超出 根据分隔符分割字符串 123456789101112131415//将一个字符串，根据分隔符来切分vector&lt;string&gt; splitStr(string s,char seq){ vector&lt;string&gt;ans; string tmp; for(auto&amp;ch:s){ if(ch!=seq) tmp.push_back(ch); else{ ans.push_back(tmp); tmp.clear(); } } ans.push_back(tmp); return ans;} C++字符转string类型的方法是，将字符放在字符数组中，使用string的构造函数来实现。 string str(char *arr, 字符个数) string的find返回的是找到的子串的开头index，如果没找到返回-1 在父串中查找存在多少子串 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt;first_pos;int hasHowManySub(string str1,int left,int right,string str2){ if(left&gt;right) return 0; int pos=str1.find(str2,left); if(pos==-1){ return 0; } first_pos.insert(pos); return 1+hasHowManySub(str1,left+1,right,str2);}int main(){ string str1=&quot;2020203332020&quot;; string str2=&quot;2020&quot;; int ans=hasHowManySub(str1,0,str1.length()-1,str2); cout&lt;&lt;ans&lt;&lt;endl; for(set&lt;int&gt;::iterator it=first_pos.begin();it!=first_pos.end();it++){ cout&lt;&lt;*(it); }} print(&quot;%s&quot;)无法打印string类型的数据，因为string是STL容器，前边的这种写法只能打印字符数组（结尾是\\0） C++取子串的两种方式 string str2(str1, 起始下标，截取连续多少个字符） str1.substr(起始下标，截取连续多少个字符） 可以用字符数组生成一个string对象 char words[1000001]; gets(words); string text(words); C++中字符串==是比较字典序是否相同 数字转字符串使用&lt;sstream&gt; 注意，在进行多次类型转换前，必须先运行clear() 可以使用&lt;algorithm&gt;中的sort来对字符串进行排序 逆置字符串:reverse(s.begin(),s.end()); 手动拷贝字符数组（字符串）时，要在末尾加\\0 关于字符和字符串的输入，某些情况下，要注意用getchar()吸收回车 1234567char a,b;scanf(&quot;%c&quot;,&amp;a);scanf(&quot;%c&quot;,&amp;b);printf(&quot;a=%c,b=%c&quot;,a,b);//控制台如下a //输入a然后enter，没等输入b直接出了结果，把回车（换行符）赋给了ba=a,b= 数字转字符串 12345678910111213#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;void intToStr(int x,string&amp;res){ stringstream ss; ss&lt;&lt;x; ss&gt;&gt;res;}int main(){ string s; intToStr(123,s); cout&lt;&lt;s&lt;&lt;endl;} 字符串查找子串 1234string a=&quot;abc&quot;;if(a.find(&quot;d&quot;)==string::npos) cout&lt;&lt;&quot;There is no 'd'&quot;&lt;&lt;endl;//如果找到了 sscanf的用法（在C标准库中,&lt;cstdio&gt;或者&lt;stdio.h&gt;） 1234char ss[]=&quot;10:12:32&quot;;int h,m,s;sscanf(ss,&quot;%d:%d:%d&quot;,&amp;h,&amp;m,&amp;s);printf(&quot;%d,%d,%d&quot;,h,m,s); 结构体作为参数时的快捷写法 12345678910struct Point{ int x; int y;};//void f(int i,int j){ queue&lt;Point&gt;que; que.push({i,j}); } 应该是编译器做了优化，对两个内容相同的字符串指针进行比较，结果是true 123456789101112131415161718192021222324int main(){ char*a=&quot;abc&quot;; char*b=&quot;abc&quot;; int c=1,d=1; int *cc=&amp;c; int *dd=&amp;d; set&lt;int*&gt;s1; set&lt;char*&gt;s2; s2.insert(a); s2.insert(b); s1.insert(cc); s1.insert(dd); printf(&quot;%d\\n&quot;, s1.size()); printf(&quot;%d&quot;,s2.size());}//结果是21 对一个字符指针来说 使用%s则输出字符串 使用%p则输出字符指针地址 迭代器STL相关问题 比较STL容器内容是否完全相同，可以用==（内部进行了运算符重载） 在一个函数内部定义一个容器，然后返回他，函数结束之后返回的容器会被销毁吗？ 答：不会！因为返回时会调用拷贝构造函数，函数中的局部变量容器确实可能会被销毁。如果返回的是引用或者地址，则可能会被销毁！因为没有调用拷贝构造函数。 map 比较两个map内容是否完全相同，可以用== 注意：map1中key1:0，map2中没有key1，则判断结果为false 访问不存在的索引时，会自动插入该索引key，并且将value初始化（数字则初始化为0，字符串则初始化为空字符串） 因此在某些场景下，如统计字符串中每个字符的个数，可以直接map[xx]++；但是在其他场景下，会导致额外的key被插入map，应当要先判断key是否存在。 vector set转vector vector&lt;int&gt;vec(s.begin(), s.end() ); 复制vector只需要vector t1,t2; t2=t1; C++98 vector初始化方法 vector&lt;int&gt; ilist1 vector&lt;int&gt; ilist2(ilist) 或者 vector&lt;int&gt; ilist2 = ilist vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1) vector&lt;int&gt; ilist4(7) 或者 vector&lt;int&gt; ilist5(7,3)指定长度为7，每个元素都为3 vector的初始化 vector&lt;int&gt; ilist1 vector&lt;int&gt; ilist2(ilist) 或者 vector&lt;int&gt; ilist2 = ilist vector&lt;int&gt; ilist = {1,2,3.0,4,5,6,7}或者vector&lt;int&gt; ilist {1,2,3.0,4,5,6,7} vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1) vector&lt;int&gt; ilist4(7) 或者 vector&lt;int&gt; ilist5(7,3)指定长度为7，每个元素都为3 指定位置插入数据1234567v2.insert(v2.begin()+4, L&quot;3&quot;); //在指定位置，例如在第五个元素前插入一个元素 v2.insert(v2.end(), L&quot;3&quot;); //在末尾插入一个元素 v2.push_back(L&quot;9&quot;); //在末尾插入一个元素 v2.insert(v2.begin(), L&quot;3&quot;); //在开头插入一个元素 插入数据使用push_back 除了vector&lt;bool&gt;以外，都可以用for(auto&amp;i:vector)进行遍历，如果是bool，不能加引用&amp; pair 需要添加头文件&lt;utility&gt;和using namespace std;； 或者添加&lt;map&gt;，因为map中会自动添加&lt;utility&gt; pair作为set或map集合的元素时，其唯一性判断是根据pair的第一个参数来的，与第二个参数无关 创建pair的方法 make_pair(&quot;haha&quot;,2); pair&lt;string,int&gt;(&quot;haha&quot;,2) pair中已经定义好了比大小、判断相等的函数 因此pair&lt;type T1,Type T2&gt;中如果是基本数据类型，则可以直接进行比大小 规则是：先比第一个，再比第二个 set set合并：用insert即可 set集合去重的原理 使operator&lt;函数，在a&lt;b时返回true，在a==b或者a&gt;b时，都返回false 尽量不要自己自定义去重逻辑，会出现很大问题 其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：1）将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值 2）将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中；如果1、2两步的返回值都是true，则可能发生未知行为，因此，记住一个准则：永远让比较函数对相同元素返回false。 其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：1）将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值2）将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。 如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中 如果1、2两步的返回值都是true，则可能发生未知行为 重载&lt;运算符，和自定义struct比较器，都是一样的逻辑 为甚么要重载&lt;运算符呢？能不能重载”&lt;=”或者”&gt;=”运算符？答案是不可以。几乎所有的方法或容器都需要排序来满足数学意义上的标准严格弱序化，否则这些方法或容器的行为将不可预知。假设f(x,y)是一个比较函数。 如果该函数满足如下条件则它是严格弱序化的。 这是一个成功的案例 12345678910111213141516171819202122232425262728293031struct Node { char outer[13]; char mid[9]; char inner[5]; Node(string a, string b, string c) { for (int i = 0; i &lt; 12; i++) outer[i] = a[i]; for (int i = 0; i &lt; 8; i++) mid[i] = b[i]; for (int i = 0; i &lt; 4; i++) inner[i] = c[i]; outer[12]='\\0'; mid[8]='\\0'; inner[4]='\\0'; } //逻辑：不满足a&lt;b，的统统返回false bool operator&lt;(const Node &amp;a) const { if (strcmp(outer, a.outer) &lt; 0) return true; if (strcmp(outer, a.outer) &gt; 0) return false; //如果等于，得看下一层 if (strcmp(mid, a.mid) &lt; 0) return true; if (strcmp(mid, a.mid) &gt; 0) return false; //还等于，还得看下一层 return strcmp(inner, a.inner) &lt; 0; //除a&lt;b,其他情况都返回false }}; set集合添加基本数据类型以外的数据，有两种方式 添加比较器 在类（结构体）中进行&lt;运算符重载 123456struct cmp{ bool operator()(char*a,char*b){ //必须重载()括号运算符 return strcmp(a,b)&lt;0; }};set&lt;char *,cmp&gt; record_digits; priority_queue 注意优先级队列的比较跟set他们是反着的 priority_queue对比大小的三种定义方式 定义一个结构体类型的比较方法 友元函数 在自定义类型中定义比较函数 12345678910struct cmp{ //作用是，让第二个参数小的优先级高 bool operator()(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;&amp;p2) { return p1.second&gt;p2.second; }}; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,cmp&gt; pq; 123456struct person{ int age; friend bool operator&lt;(person p1,person p2){ return p1.age&lt;p2.age; //表示age大的优先级高 }}; 12345678struct Node{ int time; int id; Node(int t,int i):time(t),id(i){} bool operator&lt;(const Node &amp;n)const{ return time&lt;n.time; }}; priority_queue使用的例子 题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 注意，priority_queue的cmp比较，与sort中是相反的123456789101112131415161718192021222324252627282930313233343536373839404142struct cmp{ //作用是，让第二个参数小的优先级高 bool operator()(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;&amp;p2) { return p1.second&gt;p2.second; }};class Solution{public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { map&lt;int,int&gt;mp; for(int i=0; i&lt;nums.size(); i++) { mp[nums[i]]++; } //优先级队列，频次低的优先级高 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,cmp&gt; pq; for(map&lt;int,int&gt;::iterator it=mp.begin(); it!=mp.end(); it++) { if(pq.size()&lt;k) { pq.push({it-&gt;first,it-&gt;second}); } else{ if(pq.top().second &lt; it-&gt;second){ pq.pop(); pq.push({it-&gt;first,it-&gt;second}); } } } vector&lt;int&gt;ans; while(!pq.empty()){ ans.push_back(pq.top().first); pq.pop(); } return ans; }}; priority_queue默认是一个大根堆 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q：第二个参数vector&lt;int&gt;表示用来承载底层数据结构堆(heap)的容器，less&lt;int&gt;表示数字大的优先级越大，而greater&lt;int&gt;表示数字越小的优先级越大。 priority_queue的使用 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct person{ int age; friend bool operator&lt;(person p1,person p2){ return p1.age&lt;p2.age; //表示age大的优先级高 }};int main() { priority_queue&lt;person&gt;priorityQueue; priorityQueue.push(person{1}); priorityQueue.push(person{3}); priorityQueue.push(person{2}); priorityQueue.push(person{5}); while(!priorityQueue.empty()){ person front=priorityQueue.top(); printf(&quot;%d\\n&quot;,front.age); priorityQueue.pop(); } return 0;}//打印结果5321 deque双端队列的头文件&lt;deque&gt;具体用法见：deque用法 others 使用pair需要添加头文件utility和using namespace std; 嵌套vector&lt;&lt;vector&gt; &gt;，中间要加括号，否则有些C++11之前的编译器，会把它当成移位操作 STL中，只有在vector和string中，才允许使用vi.begin()+3这种迭代器加上整数的写法 sort函数需要加上&lt;algorithm&gt;和using namespace std; sort(首元素地址，尾元素的下一个地址,比较函数) 123bool cmp(int a,int b){ return a&gt;b;} //从高到低排列 第三个参数填入cmp，即可实现从大到小排序，注意，如果在类里边定义cmp函数，需要加static，如下：12345678910class Solution {public: static bool cmp(int a,int b){ return a&gt;b; } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(),nums.end(),cmp); return nums[k-1]; }}; 队列出队，先用front再用pop 12Point head=que.front();que.pop(); 动态二维数组 12345vector&lt;vector&lt;int&gt; &gt;group;//指定外层初始长度vector&lt;vector&lt;int&gt; &gt;group(K);//指定外层和内层初始长度vector&lt;vector&lt;int&gt; &gt;group(K,vector&lt;int&gt;(3)); lambda表达式1、概念lambda表达式是C++11中引入的，它是一种匿名函数，通常它作为一个参数传递给接收函数指针或者函数符的函数使用。在C++的STL算法使用过程中，经常可以看到它的身影。 2、优点 遵守就近原则：随时定义随时使用，lambda表达式的定义和使用在同一个地方，并且lambda表达式可以直接在其他函数中定义使用，其他函数没有这个优势。 简洁明了：lambda表达式相比较其他函数的更加的简洁明了。 效率相对高些：lambda表达式不会阻止编译器的内联，而函数指针则会阻止编译器内联。 捕获动态变量：lambda表达式可以捕获它可以访问的作用域内的任何动态变量。3、基本语法capture list (params list) mutable exception-&gt; return type { function body }表达式中各个参数的含义如下： (params list):形参列表mutable:表示能不能修改捕获的变量exception:异常设定return type:返回类型function body:函数体虽然lambda中的参数变量很多，通常情况下并不需要把每一个都使用上，根据自己的需要使用即可，大多数情况下可以直接省略-&gt;、mutable、exception，不需要返回类型的话也可以省略return type。一个简单的lambda表达式：[](int x){return x*x;}。 4、捕获外部变量的办法 参数以值传递方式被捕获：参数以值传递的方式传入到lambda表达式中，值传递方式参数在lambda表达式中值不能被修改。 参数引用传递方式被捕获：参数以引用的方式传入到lambda表达式中，引用传递方式参数在lambda表达式内部修改和表达式外部的修改会相互影响。 表达式自行推导捕获：当捕获列表capture list中不传入任何变量而是写成[=]或者[&amp;]，lambda表达式会以值传递[=]或[&amp;]引用传递的方式捕获参数，参数的捕获根据表达式中变量使用情况来推导。 语法问题 两个int相乘或者相加，要注意溢出的问题 正确写法：先强转再相乘 12int a=xxx;long long b=(long long )a*a; 错误写法：先相乘再强转，已经丢失精度了 12int a=xxx;long long b=(long long )(a*a); 蓝桥杯注意事项（ISO98标准） 非静态成员不能初始化 嵌套容器的&gt; &gt;要空一格 vector&lt;pair&lt;int,int&gt; &gt;不能直接vec.push_back({1,2});这是C++11的语法 需要写成vec.push_bakc(make_pair(1,2)); 二维vector初始化vector&lt;vector&lt;bool&gt; &gt;mark(A.size(),vector&lt;bool&gt;(A[0].size(),true)); 数组无法直接转换成vector，需要使用for循环一个一个添加 有double的题目，一定要小心，不要把double写成int了！ 存在long long数据的时候，写函数一定要注意相应的函数参数不能写成int； 读入一行最好的方法是sacnf(&quot;%s&quot;,字符数组名) 因为其会舍弃前后的enter，只将中间的内容写入字符数组","link":"/2021/03/15/C-C-%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"操作系统知识巩固","text":"概述 操作系统基本功能 统一管理所有计算机资源 处理器资源 存储资源 IO资源 文件资源 实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统四大特性 并发 并行：多个事件同一时刻发生 并发： 多个事件同一时间间隔内交替发生（多道程序交替执行） 共享 共享性：操作系统中的资源可以供多个并发的程序共同使用 分类： 互斥共享 同时共享 虚拟 虚拟性：把一个物理实体转变为若干个逻辑实体 虚拟技术又分为：时分复用和空分复用。 时分复用技术：资源在时间上进行复用，不同程序并发使用；多道程序分时使用计算机硬件资源 虚拟处理器技术 借助多道程序设计技术，为每个程序建立进程，多个程序（进程）分时复用处理器 虚拟设备技术 物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问 空分复用技术：用来实现虚拟磁盘、虚拟内存等，提高资源的利用率，提升编程效率。 虚拟磁盘技术 物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 异步 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）进程管理 为什么需要进程 没有配置OS之前，资源属于当前运行的程序（单道程序设计） 配置OS之后，引入多道程序设计的概念 合理地隔离资源、运行环境，提升资源利用率 进程的作用 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体，保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升1234面试官：请你谈一谈你对进程的认识。答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。 进程的实体 主存中的进程形态： 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据） IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器事件、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。 进程控制块(PCB)中记录的数据，可以分为四类 进程标识符 处理机状态 进程调度信息 进程控制信息进程与线程一个进程(Process)可以有一个或多个线程(Thread) 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位 线程包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程资源 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 开销大 开销小 通信 进程IPC 读写同一进程数据通信 五状态模型进程的五状态模型包括：创建，就绪，执行，阻塞，中止 就绪状态 定义：其他资源都准备好，只差CPU资源的状态称为就绪状态 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行 多个处于就绪状态的进程通常排列成一个队列，称为就绪队列 执行状态 定义：进程获得CPU，其程序正在执行，称为执行状态 在单处理机中，在某个时刻只能有一个进程是处于执行状态 阻塞状态 定义：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 阻塞进程会组成一个队列，称为阻塞队列 创建状态 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态 操作系统提供fork函数接口创建进程 终止状态 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态 ## 进程同步 为什么需要进程间同步 需要进行进程同步的两个经典问题生产者消费者问题 哲学家就餐问题 上述两个模型发生问题的根源：彼此之间没有通信 进程之间同步所解决的问题 1.对竞争资源在多进程之间进行次序的协调 2.使得并发执行的多个进程之间可以有效使用资源和相互合作 临界资源指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。 进程间同步的原则 1.空闲让进：资源无占用，允许使用2.忙着等待：资源有占用，请求进程等待3.有限等待：保证有限等待时间能够使用资源3.让权等待：等待时，进程需要让出CPU 线程与线程的同步方法 进程同步方法 1.消息队列 2.共享存储 3.信号量 线程同步方法 1.互斥量 2.读写锁 3.自旋锁 4.条件变量 Linux的进程管理Linux进程的相关概念 进程的类型： 前台进程： 1.前台进程就是具有中断，可以与用户交互的进程 后台进程： 1.与前台进程相对，没有占用终端的就是后台进程； 2.后台程序基本上不和用户交互，优先级比前台进程低 3.将需要执行的命令以&amp;符号结束 守护进程： 1.守护(daemon)进程是特殊的后台进程； 2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭； 3.linux有很多典型的守护进程； 4.进程名字以d结尾的一般都是守护进程，如crond,sshd,httpd,mysqld 操作系统提供fork函数接口创建进程 进程的标记 进程ID 1.唯一性 2.负整数，最大值由操作系统限定 3.ID为0的进程为idle进程，是系统创建的第一个进程 4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 5.Init进程是所有用户进程的祖先进程 状态符号 ### 操作Linux进程的相关命令 ps命令 1.ps是process status的缩写2.可以添加-ef或者-aux展示详细进程详细信息3.搜索某个进程的详细信息ps -ef | grep python34.查询进程树ps -ef --forest5.查询某个用户的进程ps -u yfx6.按照cpu的使用频率进行排序ps -aux --sort=-pcpu7.按照内存使用的状况进行排序ps - aux --sort=-pmem top命令 1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态 kill命令 1.kill -9 进程号 无条件终止进程 作业管理作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。 进程调度进程调度概述 进程调度：计算机通过决策决定哪个就绪进程可以获得CPU的使用权（多道程序设计） 进程调度的步骤 1.保留旧进程的运行信息，请出旧进程2.选择新进程，准备运行环境并分配cpu 新老进程的上下文切换机制进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 ### 进程调度算法 两种调度的方式 1.非抢占式的调度2.抢占式的调度 进程调度算法 1.先来先服务2.短进程优先3.高优先权优先4.时间片轮转 死锁死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。 死锁的产生 死锁产生的原因 1.竞争资源2.进程调度顺序不当 死锁的四个必要条件（如果出现死锁，必然存在下边四个条件） 互斥条件资源同一时间只能允许一个进程访问 请求保持条件进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源 不可剥夺条件只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。 循环等待条件多个进程之间存在资源请求的环路死锁的处理 预防死锁 破坏请求保持条件 1.进程运行之前，一次性申请所有需要的资源 2.并且在运行期间不会提出新的资源请求 破坏不可剥夺条件 1.当一个进程请求新的资源得不到满足时，必须释放占有的资源 2.进程运行时占用的资源可以被释放 破坏环路等待条件 1.可用资源线性排序，申请必须按照需要递增申请 假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。 但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。 避免死锁 避免死锁和预防死锁的区别二者都是通过施加某些限制条件，来预防死锁发生。 差别： 1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个） 2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态） 银行家算法 是一个可操作的著名的避免死锁的算法 以银行借贷系统分配策略为基础的算法 存储管理内存分配单一连续分配只能在单用户、单进程的操作系统中使用 固定分区分配1.内存空间被划分为若干固定大小的区域2.每个分区只提供给一个程序使用，互不干扰 动态内存分配根据进程实际需要，动态分配内存空间 动态分区空闲表数据结构 动态分区空闲链数据结构 内存分配过程 首次适应算法（First Fit)： 算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件缺点：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。(2)每次都是从低址部分查找，使得查找空闲分区的开销增大2. 循环首次适应算法(Next Fit) ：算法思想：配内存时不是从链首进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；优点：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存3. 最佳适应算法（Best Fist）算法思想：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的缺点：产生大量难以利用的外部碎片。4. 快速适应算法（Quick Fit）算法思想：快速适应算法要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区 内存回收一共有四中情况，如下图1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去 页式存储管理管理方式1.将进程逻辑空间等分为若干大小的页面2.相应地把物理内存空间分成与页面大小相同的物理块3.以页面为单位把进程空间装进物理内存中分散的物理块 页面大小1.过大难以分配，过小内存碎片过多2.通常是512B~8K 页表1.页表记录进程逻辑空间与物理空间的映射2.某个页表项的地址=页表起始地址+页表项大小x页号3.实际物理地址=字块大小x字块号+块内偏移地址 多级页表页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。 缺陷有一段连续的逻辑分布在多个页面中，将大大降低执行效率 段式存储管理管理方式1.将进程逻辑空间划分成若干段（非等分）2.段的长度由连续逻辑的长度决定3.主函数MAIN，子程序段X，子函数Y等 段式和页式对比1.二者都离散地管理了进程的逻辑空间2.页是物理单位，段式逻辑单位3.分页是为了合理利用空间，分段是满足用户要求4.页大小由硬件固定，段长度可动态变化5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度） 段页式存储管理为何需要段页式存储管理1.分页可以有效提高内存利用率2.分段可以更好地满足用户需求3.二者结合，形成段页式存储管理 如何管理1.先将逻辑空间按按段式管理分成若干段2.再把段内空间按页式管理分成若干页 虚拟内存问题一个游戏十几G，物理内存只有8G，游戏如何运行起来的？ 虚拟内存概述有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。程序局部性原理指CPU访问存储器，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。 虚拟内存的置换算法1.先进先出算法FIFO2.最不经常使用算法LFU3.最近最少使用算法LRU 与高速缓存的替换区别1.替换策略发生在Cache-主存层次、主存-辅存层次2.Cache-主存层次的替换策略主要是为了解决速度问题3.主存-辅存层次主要是为了解决容量问题 Linux存储管理Buddy内存管理算法概述1.Buddy算法（伙伴算法）是经典的内存管理算法2.基于计算机处理二进制的优势，效率极高3.主要是为了解决内存外碎片的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB） Buddy管理算法的目的努力让内存分配与相邻内存合并能够快速进行 内存分配原则向上取整为2的幂大小（外碎片转化为内碎片）(1)申请70k -&gt; 分配128k(2)申请129k -&gt; 分配256k(3)申请666k -&gt; 分配1024k 伙伴系统伙伴指的是内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存 内存分配过程1.创建一系列空闲块链表，每一种都是2的幂大小2.假设存储空间有1M大小3.分配100k内存(1)100k向上取2的幂=128k(2)查询是否有128k的空闲内存块？(3)没有！查询是否有256k空闲内存块？(4)没有！查询是否有512k空闲内存块？(5)没有！查询是否有1M空闲块内存？(6)有，摘下1M空闲内存块，分配出去(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去(8)拆下256K放在空闲链上，其余分配出去(9)拆下128K放在空闲链上，其余分配出去(10)分配完毕 4.回收内存过程(1)判断刚才分配的内存伙伴在空闲链表上吗？(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴…?(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴…?(4)在！移出伙伴，合并为1M空闲内存(5)插入1M空闲链表，回收完成 Linux交换空间概述1.交换空间（Swap）是磁盘的一个分区2.Linux物理内存满时，会把一些内存交换到Swap空间 作用1.冷启动内存依赖许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。2.系统睡眠依赖Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。3.大进程空间依赖有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。 Swap空间和虚拟内存的对比Swap空间(1)存在于磁盘(2)与主存发生置换(3)是操作系统概念(4)解决系统物理内存不足问题 虚拟内存(1)存在于磁盘(2)与主存发生置换(3)是进程概念(4)解决进程物理内存不足问题 文件管理文件的逻辑结构 逻辑结构的文件类型有结构文件1.文件内容由定长记录和可变长记录组成2.定长记录存储文件格式、文件描述等结构化数据项3.可变长记录存储文件的具体内容 无结构文件也成为流式文件，文件内容长度以字节为单位。如exe文件、dll文件、so文件 linux静态链接库文件.a 动态链接库文件.sowindows静态链接库文件.lib 动态链接库文件.dll 顺序文件1.顺序文件是指按照顺序存放在存储介质中的文件2.磁带的存储特性使得磁带文件只能存储顺序文件3.顺序文件是所有逻辑文件当中存储效率最高的4.顺序文件的增删查改是比较困难的 索引文件1.可变长的文件不适合用顺序文件格式存储2.索引文件是为了解决可变长文件存储而发明的一种文件格式3.索引文件需要配合索引表完成存储 辅存的存储空间分配 连续分配 1.顺序读取文件非常容易，速度很快 2.对存储要求高，要求满足容量的连续存储空间 链接分配1.链接分配可以将文件存储在离散的盘块中2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中-&gt;隐式链接，记录在FAT中-&gt;显示分配） 隐式链接分配显式链接分配缺点：1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块） 索引分配1.每个文件拥有一个索引块，记录所有盘块信息2.索引分配方式支持直接访问盘块3.文件较大时，索引分配方式具有明显优势4.现在主流文件系统都是使用索引分配 (空闲块)存储空间管理三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。 空闲表 空闲链表1.把所有空闲盘区组成一个空闲链表2.每个链表节点存储空闲盘块和空闲的数目 位示图1.位示图维护成本低2.非常容易找到空闲盘块3.使用0/1比特，占用空间小 目录管理任何文件或目录都只有唯一路径 Linux文件的基本操作Linux目录|目录|描述 ||–|–||/bin |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里 ||/etc |存放系统管理和配置文件 ||/home |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user ||/usr |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：unix software resources ||/opt |额外安装的可选应用程序宝所放置的位置 ||/proc |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息 ||root |超级用户（系统管理员）的主目录 ||/sbin |存放二进制可执行文件，只有root才能访问 ||/dev |用于存放设备文件 ||/mnt |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。 ||/boot |存放用于系统引导时使用的各种文件 ||/lib |存放文件系统中的程序运行所需要的共享库及内核模块 ||/var |用于存放运行时需要改变数据的文件 | Linux文件常用操作 命令 操作 touch 创建文件 mkdir 创建文件夹 rm 删除文件 cat 查看文件 gedit 使用gedit编辑文件 Linux文件类型 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信 使用ls -al命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型 Linux文件系统设备管理","link":"/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%B7%A9%E5%9B%BA/"},{"title":"物联网溯源相关论文","text":"工业物联网知识工业物联网架构《An Experimental Analysis of Security Vulnerabilities in Industrial IoT Devices》 《A Secure and Fine-Grained Scheme for Data Security in Industrial IoT Platforms for Smart City》 常见的工业物联网控制系统可以大致分为两类：一类是以智能电网和数字油田为代表的SCADA系统，第二类是以智能工厂为代表的基于云平台的工业物联网控制系统。 一般来说，SCADA系统有两个主要角色:1)中心和2)外围。外围设备是数据的持有者，通常是基础设施。在数字油田的情况下，外围是油井。为了保证井的正常运行，井中分布了大量的传感器，用于传感现场数据。此外，采集现场的每个基础设施还配备了PLC和RTU，用于将电信号转换为数字信号、处理数据和控制设备。中心是数据请求者或命令发起者。控制器与监控中心之间的数据交互一般通过无线网络进行传输。一般情况下，由监控中心进行统一监控管理，将权限分配给不同的运营商，对不同区域的基础设施进行监控。SCADA系统结构如图1所示 智能工厂和智能家居设备的运营是典型的基于云的工业物联网控制系统。智能工厂利用物联网技术和设备监控技术加强信息化管理和服务，实现车间无人管理。如图2所示，不同车间的每条装配线都配备了车间控制器，负责下达车间生产条件和接收指令。由于参与工业生产的企业众多，无法实现集中管理。因此，车间控制器连接到云，而云连接到公司网络。云对数据进行初步处理和分析，并将数据交付给相应的公司和车间进行进一步处理。 SCADA系统底层设备往往较弱，需要在现场配备数据采集和控制设备。而基于云的工业物联网控制系统增加了云，将部分计算任务转移到云上，减轻了监控中心的负担 相关知识 第一问题：工业物联网相比于物联网有什么特殊之处（因为这些特性，所以在做安全或者溯源的时候要区分于物联网） 不太需要User参与 数据量巨大 产业链上的不同厂家与云的物联网相连接，共享数据 工业上数据被篡改、窃取，可能会造成重大经济损失；云中心对工业现场下达的指令被篡改，可能会造成重大事故。因此IIoT的安全问题，更加突出。 因为云常常使用第三方，因此对于涉及商业机密的敏感信息，不能直接上传到云 IIoT收集的数据上传到云，一般的应用有：上下游企业、关联企业生产供应链动态协同；机器人、车辆路径规划；数据挖掘；深度学习优化生产过程； 物联网设备在与云数据中心连接时，由于工业环境中的复杂性和恶劣性，节点之间的通信质量难以保证，造成物联网设备连接性差。此时，需要考虑更稳定的连接和更加靠近数据的连接。（如果结合雾计算，那么雾节点可能在野外：矿场、海上平台等） IIoT applications are ususally safety critical and time constrained(e.g., controlling robotic arms operating alongside a human). Hence, attack detection techniques must be performed in place, as delegating remote servers or cloud systems will introduce variability in the system timing, thus affecting realtime constraints.At the same time, such solutions might expose new attack surfaces.Thus, solving security and privacy issues on IIoT systems requires consideration of a higher number of dimensions with respect to targeting the same problem for classic IoT applications. IIoT应用通常具有安全关键性和时间限制性（例如，控制与人类一起工作的机器人手臂）。因此，攻击检测技术必须到位，因为委派远程服务器或云系统将引入系统定时的可变性，从而影响实时约束。同时，此类解决方案可能会暴露新的攻击面。因此，解决IIoT系统上的安全和隐私问题需要考虑更高的维度，以针对经典物联网应用的相同问题。 工业物联网可以做的事 production monitoring and control, or communication data analysis for logistics 解决IIot下的两个问题 溯源（基于区块链） 认证/授权方案（基于区块链） 定义 是指在当前制造业中使用过程自动化和数据交换的趋势或概念，它汇集了物联网、网络增强系统和云计算的应用。 工业物联网是许多新技术的融合，如自助机器人、高级机器人、大数据、云/边缘计算、数字无处不在(digital ubiquity)、智能工厂、机器学习、人工智能和基于物联网的网络物理(cyber physical on the basis of IoT) 工业物联网主要将仪器、连接传感器和其他设备用于机械、运输车辆以及能源和工业部门。 传统的物联网应用，如联网冰箱，它是IIoT的一个子集。 工业物联网有四个设计原则 互操作性：机器和相关组件与人连接和通信的可能性 信息透明度：创建物理世界的虚拟副本的必要性 技术协助：基本的综合聚合和信息可视化，以支持人的能力 决策分散化：网络支持的系统独立作出决策和执行自己专有功能的能力 基于物联网的工业物联网为跨不同工作场所的数据传输提供了无缝方式。实时监控系统和数据传输能够优化和提高生产力，获得更好的质量产品，帮助企业变得更加智能和高效。 《工业物联网白皮书》对IIoT的定义 工业物联网是通过工业资源的网络互联、数据互通和系统互操作，实现制造原料的灵活配置、制造过程的按需执行、制造工艺的合理优化和制造环境的快速适应，达到资源的高效利用，从而构建服务驱动型的新工业生态体系。 工业物联网表现出六大典型特征：智能感知、泛在连接、精准控制、数字建模、实时分析和迭代优化 关于溯源的问题 溯源是我们研究的对象（要去解决的问题），需要用什么样的方法来实现溯源，而非是用溯源去解决什么问题，溯源本身就是安全下面的一个问题（就像对排序的研究，不是排序去解决什么问题，而是研究怎样排序更高效，比如冒泡、快速排序） 我们需要解决两个具体的问题，使用什么样的方法，可以将溯源作为一个具体要解决的问题（有很多方法实现溯源，我们采用什么方法：区块链的方法），然后再找另一个问题，凑成两个问题写论文；也可以在溯源下，找两个需要解决的问题，例如如何保证溯源数据的完整性不可篡改性、如何更高效查询、如何减少压缩溯源数据。 论文题目： 研究溯源下的两个问题 工业物联网中溯源问题研究 一种基于区块链的工业物联网溯源方法 研究包括溯源在内的两个工业物联网中的两个安全相关的问题 工业物联网安全问题研究 区块链在身份认证和访问控制方面的东西可以看一下，到时候结合到我的系统中 使用分布式公钥基础设施来验证用户 使用特定的安全套接字层SSL证书，替换了传统密码 著名的做工业物联网的公司：Kepware 工业物联网和工业互联网的区别 工业互联网涵盖了工业物联网，工业物联网是要实现[人、机、物]的全面互联，追求的是数字化 工业物联网强调的是“物与物”的连接，追求的是自动化 工业物联网是物联网和互联网的交叉网络系统，同时也是自动化与信息化深度融合的突破口 相关可用技术 PUF物理不可克隆 SDN软件定义网络 云计算、雾计算、边缘计算 Hyperledger Fabric、Ethereum MQTT（提高物联网设备/机器人之间的互操作性） 针对工业环境中的攻击的研究主要集中在（来自综述A Comprehensive Survey on Attacks,Security Issues and Blockchain Solutions for IoT and IIoT ） 重放攻击 MiTM DDoS攻击 IOTA 代理重加密、属性加密 DHT分布式哈希表 由于传统区块链技术具有以下缺陷，因此需要为工业物联网设计可伸缩、可计算和节能的安全区块链。（IOTA专门为物联网设计） 可扩展性差：随着规模增大，冗余数据量越来越大 通信和同步开销：每添加到区块链一个新事务，需要广播到所有的对等体，涉及大量的通信开销，所有对等体都需要同步和维护区块链的相同副本（可以考虑采用云存储解决） 效率：批准交易，需要所有其他对等端验证，因此验证算法在每个节点上运行太多次，大大降低了操作效率 浪费能源：pow共识机制浪费资源 工业4.0下的工业系统 最近，IOT应用在工业中，将生产世界和网络连接集成在CPS（Cyber Physical Systems)中，被称为工业物联网IIoT。IIoT的目标是，生产智能制造产品，从而在客户和商业伙伴之间简历紧密联系的智能工厂。随着工业物联网的出现，工业4.0形成了一个子集，特别强调制造业场景，其重点是数字化和整合整个组织的所有物理过程。工业4.0是工业3.0的一个进步，机器配备了传感器、无线连接并与CPS连接，以便可视化整个生产流程以作出智能决策。 该系统分为四层： 感知层：不同类型的传感器、FRID扫描仪、监控摄像头、GPS模块等 对于一套工业设置来说，所有这些设备可能伴随着自动引导车辆AGC、输送系统、工业机器人等设备。这些设备负责捕获感官数据，监测环境条件和生产车间，运输原材料等。 网络层：WiFi、蓝牙、Zigbee、3G、4G、5G等，使用IPv4、IPv5等协议，负责将信息传输到下一层的处理系统。在工业环境中，工业以太网构成这一层的基础，并将数据传输到云和其他设备中。 处理层：由服务器和数据库组成，负责执行决策、计算优化算法、存储大量数据等多项任务。 应用层：负责交付特定应用程序的需求，以满足最终用户的需求。 一些重要的基于物联网的应用包括：智能家居、只能城市、电子医疗、车载自足网VANET等 智能电网、智能工厂、智能机器人、供应链、智能仓储 以上描述的集中式的物联网/工业物联网架构，有以下缺点 存在故障中心点，可能导致整个网络瘫痪 用户对存储在集中服务器上的数据几乎没有任何有限的控制，用户的敏感数据可能会被误用 存储在集中服务器中的数据可能会被篡改或者删除，因此缺乏可保证的可追溯性和可问责性 由于对大量端到端通信的低效处理，集中式服务器可以显著限制物联网的增长 物联网/工业物联网中存在的攻击 物理攻击 网络攻击 软件攻击 数据攻击 数据不一致：物联网中，对数据完整性的攻击导致传输中的数据或存储在中央数据库中的数据不一致 未授权访问：在未经授权的情况下，恶意用户可以访问敏感数据(对应访问控制、身份认证) 数据泄露：以未经授权的方式泄露个人、敏感或机密数据。（对应数据加密） 工业物联网 随着第四次工业革命的欻先，在工业环境中使用某些物联网技术和各种智能对象来促进行业独特的目标被称为工业物联网。 工业物联网系统能够在没有人工干预的情况下监测、收集、分析和智能地改变行为或环境。 一个被称为监视控制和数据采集SCADA的成熟的软件和硬件系统已经在行业中存在了20多年。SCADA系统由两部分组成 a.要监视或控制的过程/机械 b.控制这些过程/机械的智能设备网络 然后，由于以下四个方面的改进，工业物联网已经成为了建立在SCADA之上的技术： a.可扩展性：工业物联网可以利用从云端收集的资源，在任何需要的时候建立新的工厂 b.数据分析：工业物联网需要允许长期数据存储，然后大数据处理和机器学习技术可以应用于预测结果 c.标准化：工业物联网旨在标准化传感网络、数据收集和融合，以实现工厂内部的实时通信。 d.互操作性：工业物联网使用MQTT等协议，使平台能够跨设备进行可交流和可编程，无论供应商是什么 将物联网技术融入工业带来了生产力、效率方面的好处。然后，这些系统相互连接、始终在线的特性意味着整个工厂可能容易遭到毁灭性的网络攻击。网络攻击主要针对工业控制系统ICS、可编程逻辑控制器PLC、分布式控制系统DCS、人机接口HMI、监控和数据采集系统SCADA。工业物联网容易遭受网络攻击的原因如下： a.10年前的设备和控制系统从来就不是为暴露在互联网上而设计的，因此也不是为安全而设计的 b.连接到每个组织的工业物联网的传感器和设备数量的大幅增加，需要它们之间进行适当的协调。然而传统算法在处理这种协调时，往往效率低下。 c.潜在攻击者的数量增加了。现在的攻击者包括老练的国家、使用勒索软件的网络罪犯 汇报 什么是IIoT的secure data management。由于通信技术、云计算等技术的快速发展，越来越多的工业物联网数据被存储在云中。因此存储在云中的工业物联网数据的安全性和隐私性需要保护（一般企业使用的是第三方云服务） 可以将雾计算和区块链结合，做安全数据管理 《工业物联网信息安全防护技术研究》王斌，写的太好了，对IIot做了全面的介绍 雾计算和边缘计算的区别 雾计算过程发生在局域网(LAN)级网络架构上，使用与智能网关 和嵌入式计算机系统交互的集中式系统。 而边缘计算处理的大部分数据来源于所在的物联网设备本身。 雾计算+区块链，实现数据的安全管理、不可篡改性（哈希值正确时，保证数据的正确性）、可追溯性。 每个区域物联网设备的网关节点，为一个雾节点，其中运行着区块链节点 当物联网设备将采集的数据传输的雾节点时，雾节点进行一定的处理（如压缩、过滤、加密、甚至AI处理等），然后此transaction记录在区块链中（数据采集的设备、采集的时间、经过处理后数据的hash值），传播到区块链网络中。 云中也有区块链节点，可以进行溯源（多个transaction可以组成溯源），对处理的数据的真实性、可靠性进行验证 每个雾节点存储各个雾节点之间也可 问题是：云，是对物联网系统发出指令，还是仅仅就是对物联网产生的数据进行分析 我目前的理解，物联网系统收集数据经过雾节点的处理后发送给云进行处理，云中分析后下达一定的指令返回物联网系统 雾节点自身也可以作出部分决策，或者对上传到云的数据进行一定的处理（压缩、加密等），因为工业物联网的数据量巨大，对通信造成了巨大压力，并且很多数据都是无效的。 是否需要部署雾计算节点，取决于以下几个条件 物联网设备连接性差。物联网设备在与云数据中心连接时，由于工业环境中的复杂性和恶劣性，节点之间的通信质量难以保证，造成物联网设备连接性差。此时，需要考虑更稳定的连接和更加靠近数据的连接。 为了安全和隐私（这不就和secure data management结合起来了嘛！），需要在工厂内保存数据。实际的工业生产中，工厂通常不具有独立的云数据中心，往往是租用其他云服务提供商。因此，在一些敏感型数据传输到云中之前，工厂希望能够将这些数据留在本地进行独立保存。如果雾节点检测到网络攻击，它可以阻止其他攻击者的传输通信，来保护内部的工厂关键网络。功能类似网关。 边缘处的原始数据需要预处理以减少计算。将所有数据全部上传到云中是不明智的，这将占用大量宝贵的贷款资源。因此有必要在上传数据之前，对原始数据进行预处理，进行初步的分析和剪裁，以减少不必要的数据传输和计算。 应用程序依赖人工智能学习，需要对海量数据进行分析。由于雾计算模式中，作为与传感器相连，直接负责数据的传输和计算的网关借点，我们称之为雾节点。雾节点作为计算资源，更加靠近数据产出的位置。对于节点产生的大量数据可以提供快速的计算和反馈，这是用于机器学习的重要前提。 典型应用领域是面部识别，智能导航等。在一些特定的应用领域，我们通常需要部署雾计算，这将会带来计算效率的大幅提高。值得注意的是，如果物联网设备必须始终连接到中央云，则部署雾计算的效率并不高。 澄清一个概念，就是IIot，不一定是所有物联网设备在工厂之中，首先物联网设备可能分布在分散的工厂之中，也可能在工厂之外的地方（如油矿钻井平台、远海气象站、沙漠水库），甚至各种移动车辆或工程机械之中，自动巡逻或工作的机器人上，无人机。（注意，可以考虑供应链上的企业协同进行工业物联网的连接，这样隐私保护、访问控制就有事可做了） 区块链+雾节点可以做的事情 保证数据的不可篡改性（访问数据时根据hash值保证真实完整性） 数据可追溯性（可以对有关联交易进行处理，恢复出溯源图DAG） Hyperledger Fabric平台的搭建和性能测试 数据上云前的预处理，（自定义规则）对敏感数据进行处理 访问控制，用智能合约实现，这样可以让供应链上的多加企业的IIoT设备，自动化地安全共享数据 属性加密+区块链+智能合约（我的方法/工作量） 即使入侵了某些节点，也无法实现访问无权的内容，系统具有健壮性 徐荣华提出了BlendCAC，引入了基于联合功能的委派模型FCDM，支持分层和多跳委派，提出了一种基于身份的健壮能力令牌管理策略，利用智能合约来进行访问授权的注册、传播和注销。 潘健立，设计了EdgeChain，边缘物联网框架。 访问控制/权限的修改呢？ 区块链系统还可以识别恶意节点（或者被入侵的节点），将其提出区块链系统？；在系统存在一定恶意节点的情况下， 仍然能够继续运行 物联网中针对数据的三种攻击：数据窃取、数据欺诈（中间人攻击）、数据篡改 常见的三种分层：感知层、传输层（网络层）、应用层 感知层：数据hash 传输层：区块链 应用层：智能合约+属性加密实现访问控制 注意哦，智能合约可以调用其他智能合约，那就意味着，每个节点可以写自己的智能合约用于其他节点访问自己的数据，其他节点访问自己的时候，可以直接调用这个合约。 一个有意思的例子：Seyoung等，提出基于以太坊的区块链平台，其中智能合约用于跟踪电表使用情况和设置策略来控制空调和灯泡的开关，以节省能源消耗，从而管理物联网设备。 意味着智能合约中可以定义策略来执行某些操作。 在共识协议上进行小的修改： PoX类 BFT类 CFT类协议，如Raft是典型的崩溃容错共识协议，以强可用性著称 部分许可链可以选择降低可信需求，将拜占庭容错转换为崩溃容错，从而提升了共识速度（论文里可以与BFT进行对比） 和老师交流的收获与想法2021-12-10 尽量不要涉及雾计算，雾计算是一种计算范式，如果引入雾计算，全文就都要以雾计算为基础来做，这样就扯的太远了，老师不想让我扯的太远 我们之前讨论的三点1.数据防篡改 2.访问控制 3.数据防泄漏/泄漏追踪 老俞建议将题目命名为《基于区块链的工业物联网安全数据共享技术研究》，现在的当务之急是要去看“安全数据共享”这个概念在IIoT中是否有意义，其次要去看数据防泄漏相关概念和技术以及是否能与区块链相结合。 老师说，三点之中，第一点没什么好做的，因为区块链自带放篡改性质，这一点到时候直接继承到系统中，在论文中提一下就行了。第二点访问控制，要考虑做到什么程度，深了做不了，浅了没意义。第三点，数据防泄漏 老师说 不要局限自己的思想， 即不要看到一篇文章用了什么技术，就自己也非得用那个技术（如雾计算） 你再看看，还是要结合具体问题深入一点，不要仅仅局限在区块链的简单实现上；深入一点就是，有专家会问，你用区块链做防篡改，是不是你的方法能用于所有数据的防篡改？和工业物联网有什么关系？以此类推，所有你给出的方法，都要紧密结合工业物联网的特点。 我问”我们论文的工作量主要应该在哪里，是方案的设计？还是别的技术移植到我的场景，我对这个技术进行优化/改造？或者说是方案的实现，具体的实验过程的描述？“ 老师答：方法研究；不同的应用场景下必然会有特定的问题出现；不是，其实你这样考虑，工业物联网环境下安全数据共享，存在哪些问题？例如，数据的防篡改、访问控制、防泄露等。那么，下面你要给出方法，解决这个问题。我们准备的方法就是区块链，包括区块链的各项技术，但要注意，我不能做一个普通的区块链，或者放到哪里都能用的区块链，我们是要用区块链的各项技术来解决安全数据共享问题，即解决我们想要解决的防篡改、访问控制、防泄露等问题。对于你论文来说，有两个问题差不多了。 其实，你可以关注一下，如果数据共享了，如何解决泄露/追踪问题。这个问题其实应该是最有意思的。比防篡改有意思多了，防篡改用区块链解决，其实就是篡改后能检测。 待办任务 《A Secure and Fine-Grained Scheme for Data Security in Industrial IoT Platforms for Smart City》写一篇总结，IIoT数据安全的概念，产生的原因，相应的解决方案。 （过时了，要看安全数据共享 或者 数据共享 或信息共享） 现在的当务之急是要去看“安全数据共享”这个概念在IIoT/IoT中是否有意义，其次要去看数据防泄漏相关概念和技术以及是否能与区块链相结合。、 我现在有哪些问题 安全数据共享共享在IIoT或IoT中是否有意义 《区块链在数据安全领域的研究进展》一文中谈到，”共享场景下的数据安全解决方案和具体的应用场景紧密关联,通常是上述数据安全方案的融合“ 《Cross-domain secure data sharing using blockchain for industrial IoT》一文说明跨域安全数据共享是有意义的，文章是CCF B类的 虽然这篇论文谈了跨域安全数据共享这个问题，并且也结合了区块链来做，但是其并未讨论所谓的防篡改、身份认证、访问控制、防泄露，而是说使用智能合约对跨域数据共享中的有行为不端的实体进行惩罚，设计了一种跨域数据共享的框架和平台。 什么是数据防泄露技术，有哪些，是否能和区块链结合 IIoT中存在哪些安全问题，哪些可以结合区块链来解决 数据防泄露在IIoT中能有什么特殊之处？可能无法做到结合IIoT的特殊场景来做研究，这是个问题 我所理解的数据防泄露，就是防止数据明文传输被窃取（加密）、或者数据加密了但是被破解（密钥泄露）、防止对数据的非法访问（访问控制），难道不就是加密、保护密钥、进行访问控制，这些手段吗？老师理解的数据防泄露、或者说公认的定义是什么，有什么常见的技术？ 日常随笔2021-12-14 我要做IIoT的访问控制、数据放篡改、数据泄露追踪、安全数据共享、数据安全传输，那么这些问题是IIoT独有的吗？或者说这些问题在IIoT上有什么特殊性吗？ 将下面这种算法，融入到区块链中，实现数据泄露的防御和追踪？ 2021-12-8 今日任务： 把老俞问的问题：数据安全概念和组成、相关技术热点这个问题解决了，写成文档 先看数据安全/安全数据管理 然后看物联网领域的数据安全/安全数据管理 做PPT，包括回答老俞的问题、我这一周的工作内容、IIoT的介绍、我的想法、我的问题、接下来的工作方向 2021-12-6 IIoT的可以做的应用 一是改进库存管理-基于云的库存系统。IIoT以各种 方式使库存规划流程受益。例如，当耗材低于特定阈 值时，可以使用货架级传感器订购，考虑存储成本、 过期材料等因素，减少过度订购造成的浪费，保持了 生产线移动所需的供应。 二是获得供应链的可见性。 IIoT技术使用户可以通过跟踪材料、制造周期和单个 产品在全球供应链中移动获取实时信息，这些数据可 以帮助制造商预测潜在问题，基于各种因素做出采购 决策。在供应商方面，IIoT支持更高的透明度，从而 准确评估周转时间、可用材料和工作进度等状态。 三是改进产品设计和质量控制。IIoT传感器可用于收 集与产品周期中每个阶段关联的产品数据和第三方数 据，帮助确定外部因素对最终产品的影响。例如，工 厂温度、使用哪种原材料以及其他环境因素。跟踪浪 费或运输影响等情况，以努力创建更可持续的最终产 品。 四是实时洞察提供业务敏捷性。IIoT通过从各种 “事物”收集数据，与高级分析软件以及交易信息、 客户反馈和市场信号共同进行分析，能够在宏观层面 上评估数据，从而能够就维护需求、潜在供应链中断 和流程改进方面做出明智决策。 五是位置跟踪提供的 成本节约。IIoT传感器允许组织在设备上启用位置跟 踪，帮助工人能够很方便地找到设备所在位置。跟踪 设备可以减少步行时间，帮助组织减少盗窃行为。这 对于在非工作时间将设备留在工地的建筑公司来说非 常有帮助。 六是通过预测性维护减少停机时间和维修 成本。设备监控是一种预防性工作，无论是否需要服 务，都是根据时间安排手动完成。IIoT预测性维护使 组织能够节省与预防性维护相关的不必要的人工成 本，使用IIoT技术确定何时需要服务，帮助公司提前 发现系统故障，延长昂贵设备的使用寿命，降低与零 件、人工和停机时间相关的成本。 七是保障安全和合 规。IIoT可用于保护工人和消费者的安全。在能源部 门，传感器可用于指示气体泄漏。或者，它可能会提 醒操作员某个油井正在接近危险的压力水平，在爆炸 前发出警告。IIoT可以帮助确保制造设施内的工人安 全，传感器可用于在操作危险设备或在设施的远程部 分执行维修时监控工人的位置，连接到IIoT的安全设 备可以提醒附近人员，确保立即采取安全行动 八是 捕获实时动态并立即采取行动。IIoT是更大的物联网 生态系统的一部分，该生态系统由收集和传输数据的设备、计算机和对象网络组成，然后将该信息发送 到云。边缘计算优化了IIoT系统中使用的传感器、 计算机和设备，使计算更接近那些主动生成数据， 捕获实时动态并及时发现安全威胁，从而减少系统 中的故障点。 2021-12-5 区块链溯源，提供了一种好处叫，可审计性，至于审什么，俺不管 搜索工业物联网相关内容如安全、区块链、雾计算等，不好搜的时候，搜物联网或者工业互联网，也未尝不可 2021-12-4 现在的思路应该是，比如做secure data management，那么就应该看传统的安全数据管理有哪些方法，然后再看iiot在安全数据管理方面有什么特殊需求，然后结合区块链，加以应用。 看了几篇论文，懂了什么叫安全数据管理管理，主要是为了解决大量物联网设备产生的大量数据的管理问题，通常涉及的技术 可搜索加密 SDN 雾计算/边缘计算 云计算 IOTA：为了解决传统区块链低效、需要代币、吞吐量低等问题 两种比较好的物联网平台，AWS iot，Azure iot 今天看到一篇硕士论文对IIoT做了比较好的定义： 工业物联网是工业自动化和物联网系统的融合，具有全面感知、互联传输、智能处理以及自组织与自维护等特点。 其应用遍及智能交通、智慧工厂、智能电网、智能环境监测等众多领域。 写论文的时候，可以引入一些国内发布的物联网/工业物联网方面的报告/白皮书。 2021-12-3 今天跟老俞聊天的收获 接下来的任务：去看数据安全领域的最新论文在做什么，然后再看工业物联网数据安全在做什么，然后再根据他们提的问题，看看结合区块链能解决什么问题。（主要看数据安全，隐私保护简单看一下，可能都是比较老的问题了） 启发 把溯源扔掉，只是利用其中的一些观点，比如在工业物联网的数据安全方面，用区块链实现可追溯性 数据安全的内涵，可能包括数据的CIA（机密性、完整性、可用性），数据的可追溯性（老俞补充的） 不要想着解决很多问题，数据安全已经是一个很大的领域了 很多的加密方法如可搜索加密、属性加密等，我们直接拿来用，应用在区块链/结合到我们的方法上，不要在加密方法上进行创新 额外的启发 以后汇报可以做ppt 以后写毕业论文，要注重摘要的表述，因为评审有可能看看摘要就定基本分和评语了，要把要解决的问题讲清楚，并且后面文章的主题内容不能偏离摘要 2021-12-1 今天跟老俞聊天的收获 溯源是我们研究的对象（要去解决的问题），需要用什么样的方法来实现溯源，而非是用溯源去解决什么问题，溯源本身就是安全下面的一个问题（就像对排序的研究，不是排序去解决什么问题，而是研究怎样排序更高效，比如冒泡、快速排序） 我们需要解决两个具体的问题，使用什么样的方法，可以将溯源作为一个具体的问题，然后再找另一个问题，凑成两个问题写论文；也可以在溯源下，找两个需要解决的问题，例如如何保证溯源数据的完整性不可篡改性、如何更高效查询、如何减少压缩溯源数据。 我们要解决工业物联网中的数据安全、隐私保护、访问控制问题，这些说法都太笼统了，比如解决iiot中的溯源问题，其属于数据安全问题范畴之下，就很棒。比如解决在提高工业设施/设备互操作性的过程中，进行访问控制。（举个例子，可能并不恰当） 为什么IoHT比车联网更加适合应用区块链数据溯源 健康物联网比车联网更有价值，车联网能做的事情，智能手机已经可以完成，如获取导航、路况、加油站排队、停车场空位的等信息。 因为溯源的目的是为了 考虑到实验更好做QAQ 由于iot设备存储有限，因此大量数据要被传送到云端 溯源，溯什么源 区块链与IoHT相结合，怎么结合？区块链部署在每个物联网设备上？还是部署在云端？ 部署在云上：传感器收集了数据，则将数据交给网关，同时将此transaction提交给云中的区块链平台，加以记录 部署在每个相关节点上（设备、云、机构、医生），但存储问题如何解决？记录元数据，定期清理 用户以及医疗机构处，都安装有一个设施，专门用于存储本地数据和充当区块链节点（来自BIoMT_Blockchain_for_the_Internet_of_Medical_Things的idea） IoHT(health)/IoMT(medical)相关 健康物联网设备包括了 可穿戴设备 无线传感器 智能手机 收集什么数据 血压，体温，心率，呼吸频率，血糖，位置和时间（作为实时数据） 作息时间 饮水量 药物使用情况 智能马桶 视频、图像（防止老人摔倒） 个人信息（身体信息、病历等） 跟踪预防慢性病 三层架构 感知层 网络层 应用层 需要解决的问题 数据真实性、完整性 数据的机密性（隐私保护，未授权数据不允许访问、未授权不可修改数据） 设备身份认证（区块链平台实现）、 人员身份认证（患者、医生、医疗机构） 密钥管理 数据泄露的追责 区块链及溯源可以解决的问题 溯源以保证数据真实性、完整性（智能合约方便地进行溯源数据收集和查询） 产生错误数据时，追溯相关设备（传感器、医疗设备）或医生或医疗机构（数据流转可能经过医生、医疗机构、云健康分析中心） 身份认证+访问控制（区块链智能合约实现，简单统一的接口） 健康物联网进行溯源的目的 追溯数据的收集、流转过程，提高数据的可信度 隐私保护 发生错误时，追溯发生问题的设备，追溯相关公司的责任 敏感信息泄露追责（数据流转也可能经过医疗机构或者医生） 药物实验等，制药厂可以进行实时数据追踪 可采用的技术 IBC机制（基于身份的凭证identity-based credential) Pufs物理不可克隆 FRID 云/雾计算 MQTT PKI公钥基础设施 1区块链技术可以确保通信系统的安全，而不需要第三方认证，因为它被用作一种可信的通信和计算平台，而无需中央实体(Pustiek等人，2016年)。应为要添加到区块链平台的每个区块生成智能合同。智能合约具有代理块的凭证，该凭证在每个交易中得到验证，以供证明和处理(博济奇等人，2016；Kapitonov等人，2017年；Ramezan和Leung，2018)。区块链可以保护参与物联网系统的每个设备身份，没有单点故障。它还使用公钥基础设施保护去中心化网络中的用户和设备身份(Ernest和石光，2020年；Kshetri，2017年；李等，2019)。 来自文章Authentication and Identity Management of IoHT Devices:Achievements,Challenges,and Futrue Directions 以太坊 雾计算：以高扩展性、可用性、安全保证减少了发生的延迟和事件延迟。 溯源不是全部，我们需要解决一个应用场景中的两个问题，溯源解决其中一个就可以了？其他问题用其他技术来解决。 健康物联网可能遭受的攻击 健康物联网可能遭受的攻击 Sybil attacks，女巫攻击（大量伪造节点） cyberattacks，网络攻击 malicious users，恶意用户 malicious devices，恶意设备 DDoS，分布式拒绝攻击 spoofing，IP地址欺骗 eavesdropping，窃听 man-in-the-middle（MitM）attacks，中间人攻击 ransomware，勒索病毒 misconfiguration，错误配置 inside threats，内部威胁 identity and credential theft，身份和凭据盗窃 malicious code，恶意代码 function interruptions，功能中断 物联网模拟平台 Micrsoft Azure IoT Azure物联网是一种基于云的服务，用于测试、部署和管理物联网应用程序。Azure提供基础设施即服务(IaaS)和平台即服务(PaaS)技术，分别提供完全控制和管理 Amazon Web Services IoT Device Simulator AWS通过图形用户界面(GUI)提供无服务器的物联网应用模拟解决方案，以帮助用户收集、处理、管理和分析物联网设备，而无需管理物联网基础设施和提供安全的、可扩展的物联网应用程序 Oracle IoT Platform Oracle基于平台即服务(PaaS)技术，提供实时数据分析、物联网设备管理和快速消息传递服务 Hyperledger Fabric from IBM Hyperledger fabric是一个开源模拟器，它使用智能合约以三种模式对物联网设备进行身份验证:设备合约(DCs)、策略合约(pc)和访问合约(ACs)。超级账本具有较高的安全性、可访问性和可扩展性，并具有较高的接受率和大规模的高吞吐量;它比传统的应急接入系统具有更好的性能 关于iot中的设备认证和身份认证，可以阅读论文《Authentication and Identity Management of IoHT Devices: Achievements, Challenges, and Future Directions》 溯源的意义 提供数据起源和演变的信息，例如数据创建和数据修改的各个阶段，是谁发起的，何时以及如何发生的。通过这样的溯源，可以提高数据的可信度。（健康物联网中则可以追溯健康数据是从哪个设备收集的，又流转经过哪些设备，这些设备是否受信任，对数据进行了什么操作，有无泄露的风险） 物联网中需要确保各种设备收集的信息的可信度，所以需要进行溯源 取证 如果iot中要将数据传送到云端，云端建立区块链溯源机制，可以提高用户对云服务商的信任。 区块链+溯源，是为了保证溯源数据的真实性 车辆之间的通信方式 无线网络 蜂窝网络 DSRC专用短程通信 周五要找老俞，聊啥呢？ 确定研究领域：健康物联网还是车联网，如果是车联网应该是车内总线数据溯源、还是v2v、v2i的溯源？ 怎么确定？看这两个领域，哪个更需要溯源，更好做溯源（V2C的溯源，进行隐私保护和数据的真实性） 溯源的意义在哪里： 可以追溯责任人 验证产品、结果可复制性、知识共享与冲用、评估数据质量和有效性 区块俩溯源的作用：保证数据的不可篡改性 区块链是为了建立信任的，车联网就是一个缺乏信任的去中心化的网络，但是区块链溯源？ 车联网存在的问题 信任问题 数据的完整性、真实性 隐私保护（车主信息、车辆信息、出行数据、车内多媒体数据） 需要问老俞，车联网的实验好做吗？模拟实验，以节点模拟车辆或者路边基础设施可以吗？ 解决两个问题 v2v,v2I的隐私问题、数据的真实性完整性 v2C，车辆数据上传云端，进行故障的检测，车辆保养的规划 通过区块链、智能合约、溯源、多种加密技术来实现 我做的是一种基础设施性的服务，在保护隐私的前提下，提供车辆网服务（v2v,v2I） 车联网的意义 所有下面说的，比如获取路况信息、停车信息、加油站服务区的排队信息，都不应该是v2v，应该是v2C(cloud)或者v2I更加合适 比如通过其他车辆来获取加油站车辆排队的等待时间，来判断去哪个加油站（或者直接同加油站进行v2i的交流） 获取交通信息（交通信息共享）、缓解拥堵（前车或者基础设施直接给出拥堵信息），车位信息，气象信息，限速信息提前预警、超速警告、路况提示（直接与基础设施联系，优于导航的提示，因为导航的信息有可可能会过时）、公交车调度 共享车速，可以预判路况的拥塞程度 本车在停车场通过v2I获取停车场空位信息，然后可以将此信息共享给想要到此停车场的车。（从云端获取更加合理） 结队出行 但是在用户不知情的情况下，车辆自主与其他车或基础设施建立关系，是否会侵犯隐私？ 假名实现用户和数据的匿名话 差分隐私 零知识证明 安全多方计算 加密 雾计算 同态加密是否有用？ 车辆上的隐私信息 车主私人信息 车内网络上的传感器包括车内车主的驾驶视频和语音 图片、地点、活动等。 可以在车载社交平台上分享，移动保健应用程序也将收集车主生理健康数据 相关论文搜索关键字 Internet of Vehicles 车联网 vechicle-to-vehicle(v2v) v2p,v2x(vehicle-to-everything) Vehicular ad hoc networks (VANETs) 车辆自组织网络 物联网安全存在的五大技术挑战 数据共享的隐私保护方法 有限资源的设备安全保护方法 更加有效的入侵检测系统与设备测试方法 针对自动化操作的访问控制策略 移动设备的跨域认证方法 物联网几个典型的应用场景 智慧城市 智慧交通（车联网） 智慧医疗 智能家居 智能电网 工业与公共基础设施 物联网中进行溯源的目的 溯源能检测数据的真实性、完整性，创造可靠可信的物联网系统。 溯源能识别数据在物联网网络中的路径，以检测可能的威胁（数据经过风险节点，或者经过未授权的节点） 随着复杂（工业）物联网系统中异构现场设备和软件组件之间连接的增加，需要信息技术和操作技术的融合来协调整个自动化执行，例如： 为了检查特定制造过程在多大程度上增加了现场设备的退化和维护成本，工厂经理需要以下溯源信息： 该过程的产量报告位于何处 使用了什么控制逻辑 涉及哪些现场设备 这些设备的背景是什么 它们在车间里是如何相互关联的 iot溯源关注的几个热点问题 iot网络中收集和使用的数据具有很强的异构性，如何设计溯源机制以满足iot网络的需求（如溯源数据的模型设计） iot设备计算和存储资源有限，如何设计溯源机制以满足iot网络的特殊环境（比如轻量级的传输协议，溯源数据上传到云） iot设备收集了大量个人数据，溯源过程中如何保护隐私/如何实现政策合规性 如何保证数据的真实性和完整性 溯源数据本身可能会被攻击，如何保护溯源数据的完整性？ 溯源即服务，使得溯源成为一个可拔插的工具，可以组装在任意的iot网络中 iot溯源在做三件事（可以创新的三个地方） 收集溯源数据 管理溯源数据 分析/查询溯源数据 物联网设备之间的消息通讯，可以通过发布/订阅的方式 传统的溯源都是集中式的，iot系统需要分布式的溯源，所以我的论文题目可以写成基于区跨链的iot分布式溯源xxx PAAS，Provenance as a service溯源即服务，溯源作为一种服务/插件，可以集成在任意的iot系统中（分布式和松耦合的物联网溯源，鲜有研究） 来自会议文章Genoma: Distributed Provenance as a Service for IoT-based Systems 非常好的体系结构设计，来自论文Securing Data Provenance in Internet of Things Systems 这里的区块链部分，可以改为云上存储 溯源可以构建DAG图，来进行可视化 边缘计算，和我这个有关吗？ 区块链在身份认证方面的作用 基于区块链的分布式身份认证技术研究，魏老师学生王佳贺 附录iot相关工具和软件、报告 可以参考的报告 Palo Alto Networks发布的《2020年物联网威胁报告》 Apache Atlas或许可以用于溯源元数据的管理 atlas 是apache下的大数据的元数据管理和数据治理平台，是Hadoop社区为解决Hadoop生态系统的元数据治理问题而产生的开源项目，它为Hadoop集群提供了包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理在内的元数据治理核心能力。支持对hive、storm、kafka、hbase、sqoop等进行元数据管理以及以图库的形式展示数据的血缘关系。 MQTT: 轻量级的iot通信协议 Apache Pulasr 企业级的发布-订阅消息系统 sNSP和WireShark，可以模拟通信行为数据的抓取和分析 Arduino Arduino是一款便捷灵活、方便上手的开源电子原型平台。包含硬件（各种型号的Arduino板）和软件（ArduinoIDE）。构建于开放原始码simple I/O介面版，并且具有使用类似Java、C语言的Processing/Wiring开发环境。主要包含两个的部分：硬件部分是可以用来做电路连接的Arduino电路板；另外一个则是Arduino IDE，你的计算机中的程序开发环境。你只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序便会告诉Arduino电路板要做些什么了。","link":"/2021/11/14/%E8%AE%BA%E6%96%87-%E7%89%A9%E8%81%94%E7%BD%91%E6%BA%AF%E6%BA%90%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"title":"Java入门","text":"第一章 IDEA基本配置和快捷键IDEA快捷键 快捷键 功能 shift+F6 选中目标内容后，更改所有用到它的内容 ctrl+Y 删除当前行 ctrl+D 复制当前行 Alt+Enter 导入包自动修正代码 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消 ctrl+shift+/ 选中代码注释，再按取消 Alt+Ins 自动生成代码：如toString,set,get等方法 Alt+Shift+上下箭头 移动当前行 Shift+F6 更改类文件名称 ctrl+alt+t 包括代码块，添加try-catch等信息 ## 操作技巧 5.fori 可以快速输入循环体 for(int i=0;i&lt;5;i++) arryA.fori可以快速输入循环体for(int i=0;i&lt;arr.length;i++) Alt+Enter 快速为对象.方法 创建一个接收者 IDEA注释最好看的颜色#088D52 第二章 JAVA基本知识基础知识 所有的引用类型都可以赋值为null，代表其中什么都没有 获取数组长度 数组名称.length方法使用方法的注意事项 1.方法应该定义在类中，不能在方法中定义方法 2.方法定义的前后顺序无所谓方法重载 1.要求具有不同的参数列表（参数个数不同，参数数据类型不同，参数的数据类型排列顺序不同，满足其一即可） 修饰符如public,static等无关数组数组的初始化 动态初始化（指定长度） 1234int[]arr=new int[10];//或者拆分成两个步骤int[]arr;arr=new int[10]; 静态初始化（指定内容） 1234int[]arr=new int[]{1,2,3};//或者分为两步int[]arr;arr=new int[]{1,2,3}; 数组省略格式(无法拆分成两个步骤） 1int[]arr={1,2,3}; 数组的访问 使用动态初始化时，其中的元素会自动拥有一个默认值，规则如下: 如果是整数类型，默认为0 如果是浮点类型，默认为0.0 如果是字符类型，默认为’\\u0000’ （是一个不可见字符） 如果是布尔类型，默认为false 如果是引用类型，那么默认为null(空常量）利用数组实现多个返回值 JAVA内存 java的内存需要划分为5个部分： 栈(Stack):存放的都是方法中的局部变量，方法的运行一定要在栈中 局部变量：方法的参数，或者是方法内部的变量 作用域：一旦超出作用域，立刻从栈内存当中消失 堆(Heap):凡是new出来的东西，都在堆当中 堆内存里面的东西都有一个地址值：16进制 堆内存里面的数据，都有默认值，规则在上 面。 方法区(Method Area):存储.class(.java编译之后用来运行的字节码文件)是相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register):与CPU相关数组在内存中的存储 内存中的两个不同数组 两个引用指向同一个数组对象在内存中的存储 当一个对象作为参数传递到方法中时，实际上传递进去的是地址值 当一个对象类型作为方法的返回值时，返回值其实就是对象的地址值 一个对象在内存中的存储 两个引用指向同一个对象final关键字概念和四种用法 常见四种用法：1.修饰一个类 2.修饰一个方法3.修饰一个局部变量4.修饰一个成员变量 注意事项：对于类和方法来说，abstract和final不能同时使用，因为矛盾 final修饰一个类时public final class...含义：当前类不能有任何子类 final修饰一个方法时修饰符 final 返回值类型‘含义：该方法不能被覆盖重写 final修饰变量，一次赋值，终身不变含义：1.对于基本数据类型来说，不可改变的是数值 2.对于引用数据类型来说，不可改变的是地址值 final修饰成员变量，这个变量也是不可变的 1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值2.对于final成员变量，要么直接赋值，要么通过构造方法赋值（必须保证所有重载的构造都对final成员变量赋值） 四种权限修饰符public &gt; protected &gt; (default) &gt; private 同一个类中 同一个包中 不同包子类（父子关系） 不同包非子类（无关系） public protected (default) private 同一个类 √ √ √ √ 同一个包 √ √ √ × 不同包子类 √ √ × × 不同包非子类 √ × × × ## 内部类 分类：1.成员内部类 2.局部内部类（包含匿名内部类） ### 成员内部类 格式：直接定义在类体内就行 注意：内用外，随意访问；外用内，需要内部类对象 如何使用内部类？有两种方式： 1.间接方式：在外部类的方法中使用内部类，然后main方法中调用外部类的方法 2.直接方法，公式：外部类名称.内部类名称 对象名=new 外部类名称().new 内部类名称(); 内部类的同名变量访问1234567891011public class Outer { int num=10; public class Inner{ int num=20; public void method(){ int num=30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); } } 局部内部类如果一个类是定义在方法内部的，那么这就是一个局部内部类 *局部的含义**：只有当前的方法能使用它，出了这个方法就不能使用格式:123456修饰符 class 外部类名称{ 修饰符 返回值 外部类方法名称(参数列表){ class 局部内部类名称{ ... }} 局部内部类使用方法在成员方法中new局部内部类对象，然后调用成员方法即可 小结：类的权限修饰符1.外部类：public / (default)2.成员内部类:public / protected / (default) / private3.局部内部类：什么都不能写 局部内部类的final问题局部内部类中，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的.备注：从JAVA8+开始，只要局部变量事实不变，那么final关键字可以省略原因：1.new出来的对象是在堆当中的2.局部变量是跟着方法走的，在栈内存中3.方法运行结束后，立刻出栈，局部变量就会立刻消失4.但是new出来的对象会一直存在于栈内存中，直到垃圾回收消失。因此该对象会copy一份使用到的变量，方法消失后保证数据依旧存在。故该方法的局部变量不能改变。 匿名内部类（重点）如果接口的实现类（或父类的子类）只需要使用唯一的一次，那么就可以省略掉该类的定义，而改为使用匿名内部类匿名内部类的使用格式：其中，obj是匿名内部类的对象，匿名内部类省略了繁琐地完整创建一个.class文件 1234567891011public class Temp { public static void main(String[] args) { MyInterface obj=new MyInterface() { @Override public void method() { System.out.println(&quot;使用了匿名内部类！&quot;); } }; obj.method(); }} 使用匿名内部类的注意事项对格式*new 接口名称(){…}*进行解析 1.new代表创建对象的动作2.接口名称就是匿名内部类需要实现的接口3.*{…}*这才是匿名内部类的内容 还需注意 1.匿名内部类，在创建对象时，只能使用一次（但不是匿名对象，创建出来的对象可以一直使用）2.匿名内部类和匿名对象不是一回事3.匿名内部类和匿名对象同时使用 123456789public static void main(String[] args) { new MyInterface(){ @Override public void method() { System.out.println(&quot;使用了匿名内部类和匿名对象&quot;); } }.method(); } 第三章 面向对象程序设计 面向对象技术三大特性：继承性、封装性、多态性基础知识 成员变量是直接定义在类中的，在方法体外边 成员方法不要写static关键词 通常情况下，需要根据类创建一个对象才能使用 使用一个类的步骤 导包 import 包名称.类名称; import cn.hhu.day06.demo01.Student; 若位于同一包下无需导入 创建 Student stu=new Student(); 使用 如果成员变量没有赋值，那么将会有一个默认值，规则和数组一样 成员变量和局部变量的区别 定义的位置不同 局部变量：在方法的内部 成员变量：在方法的外部，直接写在类当中 作用域不同 局部变量：只有方法当中才可以使用 成员变量：整个类全都可以用 默认值不同 局部变量：没有默认值，必须手动赋值 成员变量：有默认值，规则和数组相同 内存的位置不同（了解） 局部变量：位于栈内存 成员变量：位于堆内存（new出来的都放在堆里，赋初值） 生命周期不同 局部变量：随着方法进栈诞生，随着方法出栈消失 成员变量：随着对象创建诞生，随着对象被垃圾回收而消失 匿名对象的说明匿名对象就是只有右边的对象，没有左边的名字和赋值运算符 12new Person().name=&quot;赵丽颖&quot;; //只能使用这一次 抽象 抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束 抽象类：抽象方法所在的类必须是抽象类。在class之间写上abstract即可 如何使用抽象类和抽象方法 不能直接new抽象类对象，必须用一个子类继承抽象父类 子类必须覆盖重写（也叫实现）父类中的所有抽象方法 注意事项 抽象类中，可以有构造方法，供子类创建对象时，初始化父类成员时使用 抽象类中不一定包含抽象方法，但是包含抽象方法的必须是抽象类 除非子类也是抽象类，否则必须重写抽象父类中的所有抽象方法 抽象类不能创建对象，无论是否含有抽象方法继承性 JAVA语言是单继承的（一个类只能有一个直接父类），但是可以多级继承 如果类的定义中不含选项extends父类名，则java虚拟机一般会自动给当定义的类添加默认的选项extends java.lang.Object。故除了类java.lang.Object之外，任何类都有父类，而且类java.lang.Object是除它自身之外的所有类的父类。 当前定义的类的构造方法必须调用其父类的构造方法，而且该调用语句必须是当前定义的类的构造方法的第一句语句，其调用格式是 如果发生重名，成员方法属于谁，就优先用谁的成员变量12super(调用参数列表)//其中super是关键字，表示直接父类的构造方法。 java.lang.Object类是所有类的 公共最高父类三种重名 成员变量重名父类成员变量使用super.子类成员变量使用this.局部变量直接写 1234567891011121314151617//Father.javapublic class Father { int num=30;}//Son.javapublic class Son extends Father { int num = 20; public void method() { int num = 10; System.out.println(&quot;Father:&quot; + super.num); System.out.println(&quot;Son:&quot; + this.num); System.out.println(&quot;Temp:&quot; + num); }} 成员方法重名 方法覆盖 必须保证父子类之间方法的名称相同，参数列表也相同 子类方法的返回值必须小于等于父类方法的返回值范围 @Override:这叫做注解，写在方法前面，用来检测是否有效地正确覆盖。（如果报错说明未发生覆盖） 子类方法的权限必须大于等于父类方法的权限修饰符。 public&gt;protected&gt;留空(default)&gt;private继承中构造方法的访问特点 子类构造方法当中，有一个默认隐含的super()调用，所以一定是先调用父类构造方法，后执行子类构造方法 可以通过super关键字在子类中调用父类重载构造函数 super的父类构造调用，必须是子类构造方法的第一个语句。不能多次调用super构造。super关键字的三种用法this关键字的三种用法 在本类的成员方法中，访问本类的成员变量（成员方法中含有重名的局部变量，也生效） 在本类的成员方法中，访问本类的另一个成员方法 在本类的构造方法中，访问本类的另一个重载构造方法 1234567public Temp01(){ System.out.println(&quot;调用无参构造函数&quot;);}public Temp01(int n){ this(); System.out.println(&quot;调用重载构造函数&quot;);} 第三种方法中注意：this()构造方法也必须是语句的第一句注意：this和super两种构造调用不能同时使用，因为构造方法必须放在第一句，也就必须要保证唯一性 子类与父类之间的类型转换 隐式类型转换：无需强制类型转换符，将子类型的数据转换成父类型数据 12Teacher tom=new Teacher();Employee a=tom; 显式类型转换：需要强制类型转换符()，将父类型数据转换为子类型数据 123Teacher tom=new Teacher();Employee a=tom;Teacher b=(Teacher)a; 如果两个类型不存在子类型与父类型之间的关系，则一般不能进行类型转换。可以使用引用类型表达式instanceof引用类型来判断一个引用表达式所指向的实例对象是否是某种引用类型的实例对象 123Teacher a=new Teacher();Employee b=new Employee();Employee c=a; 则表达式a instanceof Teacher返回true表达式a instanceof Employee返回true表达式b instanceof Teacher返回false表达式c instanceof Employee返回true表达式c instanceof Teacher返回true instanceof运算符可以用再引用类型转换中，即先判断一个引用表达式所指向的实例对象是否是目标类型的实例对象，可以避免错误如 123if(a instanceof Teacher) b=(Teacher)a;else b=new Teacher(); 多态性 多态性指的是：在类定义中出现多个构造方法或者出现多个同名的成员方法。对于同名的成员方法，多态性还包括在当前定义的类型中出现与其父类型的成员方法同名的成员方法。多态性包括：静态多态性和动态多态性。 静态多态性 静态多态性指的是在同一个类中同名方法在功能上的重载overload，这也包括一个类对其父类同名方法在功能上的重载，而且在方法声明的形式上要求同名的方法具有不同的参数列表。这里的方法，可以是成员方法，也可以是构造方法。一般建议，重载的方法应当具有相似的功能。 动态多态性 动态多态性指的是在子类和父类的类体中均定义了具有基本相同声明的非静态成员方法。所谓非静态成员方法指的是在成员方法定义中成员方法的声明不包含方法修饰词static，这时也称为子类的成员方法对其父类进本相同声明的成员方法的覆盖override。（基本相同声明的成员方法要求具有相同的方法名，相同的参数个数，对应参数的类型也相同，而且子类的成员方法应当比其父类对应的成员方法有更广的访问控制方式） 利用动态多态性使得可以通过父类型的引用调用子类型的成员方法。这里要求父类型的引用 所指向的实例对象实际上是其子类型的实例对象，而且调用的子类型的成员方法是对父类型同名成员方法的覆盖。 由于动态多态性使得子类型的成员方法屏蔽了父类型的被覆盖的成员方法，因此通过关键字super可以解决在子类型的成员方法中调用父类型的被覆盖的成员方法的问题。 在子类型的非静态成员方法中访问其父类型的成员与，格式： super.父类型的成员域 在子类型的非静态成员方法中调用其父类型的成员方法，其格式： super.父类型的成员方法(调用参数列表) 在子类的构造方法的第一条语句处调用其父类的构造方法，其格式： super(父类构造方法的调用参数列表); 与super对应的关键字是this，其调用的是同一个类的成员域或成员方法。 需要注意的是，动态多态性只针对非静态的成员方法。 封装性 封装性在JAVA中的体现 方法是一种封装 关键字private也是一种封装 一旦使用private进行修饰，在本类中可以随意访问，但是超出本类范围就不能再直接访问了。 间接访问private成员变量，就是定义一对儿get/set方法，必须叫getXXX/setXXX。对于基本数据类型中的boolean类型，get方法必须写成isXXX。 当方法的局部变量（如参数）和类的成员变量重名的时候，根据就近原则，优先使用局部变量。如果需要访问本类当中的成员变量，需要使用this.成员变量名 **通过谁调用的方法，谁就是this ** 构造方法 构造方法注意事项 构造方法的名称必须和所在的类名完全一样 构造方法无返回值 如果没有编写任何构造方法，那么编译器会默认一个构造方法，没有参数，方法体什么事都不做 构造方法可以进行重载一个标准的类 一个标准的类要拥有下面四个部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对get/set方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做 Java Bean. 可以使用快捷键Alt+Insert或菜单中Code-Generate Static关键字 Static修饰成员field只在类中保存一份，所有本类对象共享一份。属于类而不是属于单独某一个对象。可以利用这一点，自动给对象顺序赋id 123456789private String name;private int id;static String teacher=&quot;胡景月&quot;;private static int idCount=0; //给成员变量赋初值public Student(String name) { this.name = name; id=++idCount;} Static修饰方法 静态方法属于类，不属于对象 如果没有static，必须创建对象才能使用方法 如果有static，对于静态方法来说，可以通过对象调用方法（不推荐），也可以通过类名调用方法。 本类当中的静态方法可以省略类名 静态不能直接访问非静态（原因：内存中先有的静态内容，后有的非静态内容） 静态方法中不能用this，因为this指的是当前对象，而静态内容属于类而不属于对象 静态Static的内存图静态内容与对象无关，即使写成对象.静态内容,也会被编译成为类.静态内容 静态代码块特点：1. 第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优于非静态，所以静态代码块比构造方法先执行 静态代码块的典型用途 一次性地对静态成员进行赋值 第四章 APIAPI概念API全程Application Programming Interface,应用程序编程接口。API使用步骤 打开帮助文档 点击显示，找到索引，看到输入框 输入框里输入想找的类 看包。java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法Scanner类——键盘输入类 基本功能：可以实现键盘输入数据到程序当中 引用类型的一般使用步骤： 导包 如果需要使用的目标类和当前类位于同一包下，则可以省略导包语句；只有java.lang包下的内容(如java.lang.String)不需要导包，其它的包都需要import语句。 创建 Scanner sc=new Scanner(System.in); //代表从键盘输入 使用 获取键盘输入的一个int数字：int num=sc.nextInt(); 其实键盘输入的都是字符串， nextInt是将输入的字符串里的数字转换成int型数 获取键盘输入的一个字符串：String str=sc.next();如果只需使用一次，可以使用匿名对象 12345678910111213141516int num=new Scanner(System.in).nextInt();//还可以使用匿名对象作为参数public class Demo04Anonymous { public static void printInt(Scanner sc){ int temp=sc.nextInt(); System.out.println(&quot;Num is &quot;+temp); } public static void main(String[] args) { printInt(new Scanner(System.in)); }}//匿名对象还可以作为返回值public static Scanner methodReturn() { return new Scanner(System.in); } Random类——产生随机数字 random类的使用 12Random r=new Random(); int a=r.nextInt(); //范围-21亿到+21亿 Random生成指定范围的随机数12345678910Random r=new Random(); for (int i = 0; i &lt; 10; i++) { int temp = r.nextInt(10); //范围是[0,10) 左闭右开 System.out.print(temp); System.out.print(&quot; &quot;); }//若想1~10就 r.nextInt(10)+1; 对象数组 1234567Person[]arr=new Person[3]; Person one=new Person(&quot;余丰旭&quot;,22); Person two=new Person(&quot;陈香玉&quot;,24); Person three=new Person(&quot;小小余&quot;,1); arr[0]=one; arr[1]=two; arr[2]=three; ArrayList 数组的长度不能改变，但是ArrayList集合的长度是可以随意变化的 对于ArrayList来说，有一个尖括号代表泛型，也就是装在集合当中的所有元素，全都是的什么类型。 注意：泛型只能是引用类型，不能是基本类型。原因是：ArrayList中存储的都是引用类型对象的地址，而基本数据类型没有地址。解决方案：使用基本类型对应的包装类。包装类：都位于java.lang包下（无需导包）从JDK1.5+开始，支持自动装箱、自动拆箱。自动装箱：基本类型–&gt;包装类型自动拆箱：包装类型–&gt;基本类型 基本类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 对于ArrayList集合来说，直接打印的到的不是地址值，而是内容 12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;余丰旭&quot;); list.add(&quot;陈香玉&quot;); list.add(&quot;小小余&quot;); System.out.println(list); ArrayList常用方法 public boolean add(E e):向集合当中添加元素，类型与泛型一致 public E get(int index):从集合中获取元素，参数是索引编号 public E remove(int index):从集合中删除元素 public int size():获取集合的尺寸长度（集合中的元素个数） 注意，ArrayList作为方法参数时，不要忘了&lt;E(泛型)&gt;String一.String类基本知识 java中只要是” “中的内容，都是String实例，无论new否 字符串特点 字符串的内容永不可变 正是因为字符串不可改变，所以字符串是可以共享使用的 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组 字符串的构造方法和直接创建，常见3+1种方式三种构造方法： public String():创建一个空白字符串，不含有任何内容 public String(char[ ]array):根据字符数组的内容，来创建对应的字符串 public String(byte[ ] array):根据字节数组的内容，来创建对应的字符串1234567891011121314public static void main(String[] args) { String str = new String(); System.out.println(&quot;First String is &quot; + str); char[] arr = {'a', 'b', 'c'}; String str2 = new String(arr); System.out.println(&quot;Second String is &quot; + str2); byte[] arr_byte = {97, 98, 99}; String str3 = new String(arr_byte); System.out.println(&quot;Third String is &quot; + str3); String str4=&quot;abc&quot;; System.out.println(&quot;Forth String is &quot;+str4); 二.字符串的常量池 字符串常量池：程序中直接写上的双引号字符串，就在字符串常量池中对于基本类型来说，==是进行数值的比较；对于引用类型来说，==是进行地址值的比较。 1234567String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);System.out.println(str1==str2); //tureSystem.out.println(str1==str3); //falseSystem.out.println(str2==str3); //false 双引号直接写的字符串在常量池中，new的不在池当中 三.字符串的比较相关方法 ==是进行对象的地址值的比较，如果确实需要字符串的内容比较，可以使用两个方法public boolean equals(Object obj):参数可以是任何对象public boolean equalsIgnoreCase(String str):忽略大小写，进行内容比较 123456789101112String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);if(str1.equals(str2)) System.out.println(&quot;str1=str2&quot;);if(str1.equals(str3)) System.out.println(&quot;str1=str3&quot;);if(str1.equals(&quot;abc&quot;)) System.out.println(&quot;str1=abc&quot;);if(&quot;abc&quot;.equals(str1)) System.out.println(&quot;abc=str1&quot;); ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200122191346564.png) 字符串的获取相关方法String当中与获取相关的常用方法有： public int Length():获取字符串中含有的字符个数 public String concat(String str):将当前字符串和参数字符串拼接成为返回值新的字符串 public char charAt(int index):获取指定索引位置的单个字符 public int indexOf(String str):查找参数字符串在本字符串中首次出现的索引位置，如果没有返回-1字符串的截取方法 public String substring(int index):从参数位置一直到末尾，返回新字符串 public String substring(int begin,int end):从begin开始，一直到end结束，中间的字符串，左闭右开字符串的转换方法 public char[ ] toCharArray():将当前字符串拆分成为字符数组作为返回值 public byte[ ] getBytes():获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString):将所有出现的老字符串替换成为新的字符串，返回替换后的结果新字符串备注：CharSequence就是说可以接受字符串类型字符串的分割方法分割字符串的方法;public String[ ] split(String regex):根据参数的规则，将字符串切分为若干部分 12String str=&quot;Yu,Feng,XU&quot;;String[]strString=str.split(&quot;,&quot;); 注意事项:split方法的参数其实是一个正则表达式，今后学习，今天要注意，如果按照英文句点.进行切分，必须写\\\\.两个反斜杠 ArraysArrays是一个与数组相关的工具类，里面提供了大量静态方法，来实现数组的常见操作（方便，静态方法不用new）常用方法 public static String toString(数组) 功能：将参数数组变成字符串（按照默认格式，即[xx,xx,xx..]） public static void sort(数组) 功能：按照默认升序对数组元素进行排序 备注：1. 如果是数值，sort默认按升序从小到大 2. 如果是字符串，sort默认按字母升序 3. 如果是自定义类型，**那么这个自定义类需要有Comparable或Comparator接口的支持 数学工具类Math常用方法： public static double abc(double num) abc是absolute的缩写，计算绝对值 public static double ceil(double num) 向上取整 public static double floor(double num) 向下取整4.public static long round(double num) 四舍五入 Math.PI 代表近似的圆周率值Object类重写equals方法(可以使用快捷键Alt+Insert)因为java中==对于基本数据类型比较的是数值，对于引用数据类型比较的是地址值，所以对于自己创建的对象，继承了Object类的equals方法，需要对equals方法进行重写1234567891011121314151617@Overridepublic boolean equals(Object obj) { //如果传递进来的是自身，直接返回true,提高程序效率 if(obj==this) return true; //如果传空，直接返回false，提高程序效率 if(obj==null) return false; //如果不是Student对象，直接返回false if (!(obj instanceof Student)) return false; //向下转型，并进行比较 Student stu = (Student) obj; if (this.age == stu.age &amp;&amp; this.name == stu.name) return true; return false;} Objects类有一个equals方法，可以容忍空指针（注意不是Object类，是Objects类）123456public static void main(String[] args) { Student stu=new Student(&quot;余丰旭&quot;,22); Student stu2=null; boolean b=Objects.equals(stu,stu2); System.out.println(b);} 因为其Objects.equals(再次注意不是Object类是Objects类）方法如下123public static boolean equals(Object a,Object b){ return (a==b)||(a!=null&amp;&amp;a.equals(b)); } 重写toString方法（也可以快捷键）1234@Overridepublic String toString() { return name+&quot;:&quot;+age+&quot;岁&quot;;} Object类位于java.util.objects JDK7中添加了Objects工具类，它有一些静态方法，这些方法是null-save(空指针安全的）或null-tolerant(容忍空指针的），用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象 在比较两个对象时，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题 源码如下12public static boolean equals(Object a,Object b){return (a==b)||(a!=null&amp;&amp;a.equals(b)); Date类 System.currentTimeMillis()获取当前系统时间到1970年1月1日00：00：00（英国格林威治时间）经历了多少毫秒（long类型）构造方法 1.无参构造 1234Date date=new Date();System.out.println(date);输出结果Mon Jan 27 19:47:17 CST 2020 2.带参构造（long类型）即毫秒值 1234Date date2=new Date(1580125811479L);System.out.println(date2);输出结果Mon Jan 27 19:50:11 CST 2020 常用方法 long getTime()把日期转换为毫秒值DateFormat类DateFormat类是抽象类，不能直接使用。所以需要常用子类java.text.SimpleDateFormat，这个类需要一个模式来指定格式化或解析的标准，构造方法为： public SimpleDateFormat(String pattern):用给定的模式和默认语言环境的日期符号构造SimpleDateFormat 格式规则| 标识字母（区分大小写） | 含义 || ———————- | —- || y | 年 || M | 月 || d | 日 || H | 时 || m | 分 || s | 秒 | 备注：更详细的格式规则，请见API文档 写对应的模式，会把模式替换为对应的日期和时间：yyyy-MM-dd HH:mm:ss或yyyy年MM月dd日 HH时mm分ss秒其中连接符可以任意写 format方法传入date类型的参数，按照SimpleDateFormat中指定的模式输出字符串 12345Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);System.out.println(sdf.format(today));输出结果2020年02月04日 11时55分41秒 parse方法把符合模式的字符串解析为Date日期public Date parse(String source)throws ParseExceptionparse方法声明了一个异常叫ParseException解析异常，如果字符串和构造方法中的模式不一样，那么程序就会抛出异常，调用一个抛出了异常的方法，就必须处理这个异常，那么throws继续声明抛出这一个异常，要么try..catch自己处理这个异常（暂时用Alt+enter 让虚拟机自己处理） 12345678Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);Date day=sdf.parse(&quot;2020年02月04日 11时55分41秒&quot;);System.out.println(&quot;parse方法将符合指定模式的字符串转换为Date类型数据:\\n&quot;+day);输出结果：parse方法将符合指定模式的字符串转换为Date类型数据:Tue Feb 04 11:55:41 CST 2020 小练习：计算距出生多少天12345678910111213public class demo02 { public static void main(String[] args) throws ParseException { System.out.println(&quot;请按照格式输入出生日期: yyyy-MM-dd&quot;); Scanner sc=new Scanner(System.in); String birthString=sc.next(); SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date birthday=sdf.parse(birthString); long birthdayMS=birthday.getTime(); long nowMS=new Date().getTime(); long distance=nowMS-birthdayMS; System.out.println(&quot;此人距出生已经历&quot;+distance/1000/60/60/24+&quot;天&quot;); }} Calendar抽象类很多Date类的方法已被Calendar类替代，java.util.Calendar类是一个抽象类，提供了很多操作日历字段的方法（YEAR,MONTH,DAY_OF_MONTH,HOUR)Calendar类无法直接创建对象使用，其含有静态方法getInstance(),该方法返回一个Calendar类的子类对象static Calendar getInstance()使用默认时区和语言环境获得一个日历 12使用了多态，用父类型接收子类对象Calendar c=Calendar.getInstance(); Calendar类常用方法public int get(int field)：返回给定日历字段的值public void set(int field,int value)：将给定日历字段设置为给定值public abstract void add(int field,int amout)：根据日历的规则，为给定的日历字段添加或减去指定的时间量public Date getTime()：转换为Date类对象 System类常用方法 public static long currentTimeMillis()：返回以毫秒值为单位的当前时间 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)：将数组中指定的数据拷贝到另一个数组中。参数含义：src-源数组、srcPos-源数组中的起始位置、dest-目标数组、destPos-目标数组中的起始位置、length-复制的元素数量StringBuilder类 字符串是常量，它们的值在创建之后不能改变。字符串的底层是一个被final修饰的数组，不能改变，是一个常量。因此会导致一个问题：拼接多个字符串时会产生大量字符串占用内存（如拼接a+b+c,内存中会产生a,b,c,ab,abc五个字符串 为了提高效率，可以使用字符串缓冲区（可以看成长度可以变化的字符串），底层也是数组，但是没有被final修饰，可以改变长度。 StringBuilder在内存中始终是一个数组，占用空间少，效率高；如果超出StringBuilder的容量，会自动扩容*构造方法 public StringBuilder()：构造一个空的StringBuilder容器 public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去常用成员方法 public StringBuilder append(...)：添加任意类型数据，并返回当前对象自身（可以链式编程） public String toString()：将当前StringBuilder对象转换为String对象第五章 包装类基本数据类型使用方便，效率高，但是缺少对应的方法来操作这些数据，故有时采用包装类。（除了char-Character和int-Integer,其他包装类都是首字母大写）装箱与拆箱 装箱：基本类型转换为对应包装类对象 通过构造方法(已过时）：Integer(int i)Integer(String s)：其中s必须时基本类型字符串，否则抛出异常 静态方法：static Integer valueOf(int i)：返回一个Integer实例static Integer valueOf(String s) 拆箱：包装类对象转换为基本类型成员方法：int intValue()自动装箱与拆箱从JDK1.5开始，基本类型和包装类的装箱与拆箱可以自动完成如ArrayList&lt;Integer&gt;中只能存储Integer包装类，但是可以直接写123ArrayList&lt;Integer&gt;list;list.add(999); //自动装箱int a=list[0]; //自动拆箱 基本数据类型与字符串之间的转换基本类型转字符串总共三种方式 基本数据类型+””即可 使用包装类中的静态方法toString（参数) 重载了Object的toString方法 使用String类中的静态方法valueOf(参数)String转基本数据类型除了Character类以外，所有包装类都具有parseXxx静态方法，可以将字符串参数转换为对应的基本类型 第六章 接口基础知识 接口就是一种公共的规范标准，如全中国的插座都一样。只要符合标准就可以大家通用 代码中，接口就是多个类的公共规范 接口是一种引用数据类型，其中最重要的内容就是抽象方法 接口的格式 123public interface 接口名称{接口内容} 备注：换成了关键字interface后，编译生成的字节码文件仍然是.java-&gt;.class 如果是JAVA7，则接口中可以包含的内容有：1.常量 2.抽象方法 如果是JAVA8，则：3.默认方法 4.静态方法 如果是JAVA9，则：5.私有方法接口使用步骤 注意事项： 1.接口中的抽象方法，修饰符必须是两个固定的关键词：public abstract2.这两个关键字可以选择性地省略，忽略任意一个或者两个一起省略都可以 接口使用步骤 接口不能直接使用，必须有一个实现类(类似子类）来实现该接口public class 实现类名称 implements 接口名称{...} 接口的实现类必须覆盖重写（实现）接口中的所有抽象方法 创建实现类的对象，进行使用接口的默认方法定义 接口中的默认方法可以解决接口升级的问题（已经实现了原有接口的类，在接口添加了新的抽象类后，由于实现类必须实现接口所有的抽象方法，而不能再使用）使用带方法体的默认方法即可解决这个问题 格式 1public default 返回值类型 方法名称（参数列表）{方法体} 注意事项 1.接口的默认方法，可以通过接口实现类对象直接调用2.接口的默认方法，也可以被接口实现类进行覆盖重写 接口中的Static方法 从JAVA8开始，接口中允许定义Static方法 格式 1public static 返回值类型 方法名称（参数列表）{方法体} 不能通过接口实现类的对象来调用接口当中的静态方法；正确用法：通过接口名称直接调用静态方法（静态只与类/接口，有关系）接口中的私有方法 通过抽取一个共有方法，用来解决两个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。 从JAVA9开始，接口中可以定义私有方法 1.普通私有方法 ：解决多个默认方法之间重复代码问题 1private 返回值类型 方法名称（参数列表）{方法体} 2.静态私有方法 ：解决多个静态方法之间重复代码问题 1private static 返回值类型 方法名称（参数列表）{方法体} 接口的常量定义 接口中也可以定义“成员变量”，但必须加上public static final三个修饰符（可以省略，但是不写也照样是这样，不能写别的），从效果上来说，这就是接口的常量*(final关键词修饰，说明不可改变） 格式1public static final 常量名称=数据值; 接口中的常量，要完全大写，下划线分割，必须赋初值 使用时，直接用接口名称.常量即可使用接口的注意事项 接口是没有静态代码块或构造方法的 一个类只有一个直接父类，但是一个类可以同时实现多个接口格式：123public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{ //覆盖重写所有抽象方法 } 如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是一个抽象类。 如果实现类所实现的多个接口中，存在着重复的默认方法，则实现类一定要对冲突的默认方法进行覆盖重写。 继承优先于接口实现：一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先使用父类中的方法接口之间的多继承 类与类之间是多继承的，直接父类只有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的注意事项： 1.多个父接口当中的抽象方法如果重复，没关系（因为抽象方法没有方法体）2.多个父接口当中的默认方法如果重复，那么子接口必须对重复的默认方法进行覆盖重写，default关键字不能省略 第七章 多态多态的基本概念 学生类继承人类，小明是一个学生对象，那么小明：既是一个学生，也是一个人，体现了对象的多态性 代码中体现多态性就是：父类引用指向子类对象格式(左父右子）： 123父类名称 对象名=new 子类名称();或者接口名称 对象名称=new 实现类名称(); 多态中成员方法的使用特点 看new的是谁，就优先用谁，没有则向上找 父子都有，优先用子 成员方法：编译看左，运行看右 成员变量：编译看左，运行还看左 使用多态的好处等号左边形式统一 1234Worker teacher=new Teacher(); Worker cooker=new Cooker(); teacher.work(); cooker.work(); 对象的向上转型对象的向上转型，其实就是多态写法父类名称 对象名=new 子类名称()含义：右侧创建一个子类对象，把它当作父类来看待使用注意事项：向上转型一定是安全的 对象的向下转型 因为对象的向上转型有个缺点：无法通过父类引用指向子类对象的方式，调用子类特有方法 对象的向下转型，其实是一个还原动作，这样就可以调用子类独特方法 格式：子类名称 对象名=（子类名称）父类对象 注意事项：必须保证对象创建的时候本来就是猫，才能向下转型为猫instanceof的使用cat instanceof Cat第八章 Collection集合集合是JAVA提供的一种容器，可以存储多个数据与数组的区别： 集合长度可变 集合存储的是对象，且对象类型可以不一致一、Collection集合 集合框架 Collection常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可以操作所有的单列集合 public boolean add(E e):给定对象添加到集合中 public void clear()：清空集合中所有元素 public boolean remove(E e)：把给定的对象在当前集合中删除 public boolean contains(E e)：判断当前集合中是否包含给定对象 public boolean isEmpty()：判断集合是否为空 public int size()：返回集合元素数量 public Object[ ] toArray() ：把集合中的元素存储到数组中二、Iterator迭代器JDK中提供的专门用来遍历集合的接口（不是所有集合都有索引，即有些不能直接用for循环遍历） *迭代：即Collection集合元素通用的获取方式。取出元素前先判断集合中有没有元素，如果有则取出，再继续判断，一直到取完。这种取出方法的专业术语成为迭代Iterator迭代器是一个接口，无法直接使用，需要接口的实现类对象。其获取实现类的方式特殊**，Collection类中有一个方法叫iterator(),返回的就是Iterator的实现类对象常用方法boolean hasNext()：如果仍有元素可以迭代，返回trueE next()：返回迭代的下一个元素1234567891011121314Collection&lt;String&gt;coll=new ArrayList&lt;&gt;();coll.add(&quot;我爱你&quot;);coll.add(&quot;中国&quot;);coll.add(&quot;我爱你&quot;);coll.add(&quot;塞北的雪&quot;);Iterator&lt;String&gt;iter=coll.iterator();while(iter.hasNext()){ System.out.print(iter.next());}或者for(Iterator&lt;String&gt;iter=coll.iterator();iter.hasNext();){ System.out.print(iter.next());} 三、增强for增强for循环也称为for each循环，是JDK1.5以后出来的高级循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历中不能对集合中的元素进行增删操作。12345678910111213//foreach遍历数组 （注意只能遍历，不能增删，因为其只是Iterator遍历的简化格式）String[]arr={&quot;我爱你&quot;,&quot;中国&quot;,&quot;亲爱的宝宝&quot;};for(String i:arr){System.out.println(i);}//增强for循环遍历集合Collection&lt;Integer&gt;coll=new ArrayList&lt;&gt;();coll.add(1);coll.add(2);coll.add(3);for(Integer i:coll){System.out.println(i);} 四、List接口三个特点：1.有序 2.有索引 3.允许重复List接口中带索引的方法（特有） public void add(int index,E element)：将指定元素插入到指定位置 public E get(int index)：获取指定位置上的元素 public E remove(int index)：删除指定位置上的元素，并返回该元素 public E set(int index,E element)：用指定元素替换指定位置，并返回原来的元素List的子类1.ArrayList底层是数组，查询快，增删慢。增加元素时需要创建一个比原来数组大1的新数组，再调用System.arraycopy将原有数组拷贝到新数组，效率低。因此开发中，增删用的多不建议使用ArrayList2.LinkedList特点： 底层是链表结构：查询慢，增删快 包含大量操作首尾元素方法 常用方法 public void addFirst(E e) public void addList(E e) public E getFirst() public E getLast() public E removeFirst() public E removeLast()：等效于add方法 public E pop()：从此列表所表示的堆栈处弹出一个元素等效于removeFirst public void push(E e)：将元素推入此列表所表示的堆栈 等效于addFirst public boolean isEmpty() 注意：获取元素时注意如果集合中没有元素，则会报错，需要用isEmpty先判断一下 3.Vector集合单线程的，速度慢，JDK1.2后被ArrayList取代。了解即可 五、Set接口 特点： 不重复 没索引HashSet 特点： 不允许重复 没有索引 是无序集合，存储和取出的顺序可能不同 底层是一个哈希表结构（查询速度很快） 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址，是一个逻辑地址，不是实际地址）Object类中有一个方法，可以获取对象的哈希值int hashCode() 返回该对象的哈希值 hashCode源码：public native int hashCode(); *native**代表调用的是本地OS的方法 String类重写了Object类的hashCode方法HashSet集合存储数据的结构——哈希表JDK1.8之前：哈希表=数组+链表JDK1.8之后：哈希表=数组+链表/红黑树（提高查询速度）超过8个用红黑树 哈希表的特点：速度快 HashSet集合不重复原理 HashSet集合不允许存储重复元素的原理：在Set集合调用add方法时，会先调用hashCode方法，如果没有发生哈希冲突则存储到集合中；若发生冲突，则再调用equals方法与冲突位置上的各元素比较，如果有相同的则不存储。 *前提**：存储的元素必须重写hashCode方法和equals方法HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一12345678910111213@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } LinkedHashSetLinkedHashSet继承了HashSet，底层是哈希表（数组+红黑树/链表）和一条链表（记录元素存储顺序），HashSet是无序的（不能保证存储和取出顺序一致），LinkedHashSet额外实现了有序（存储和取出顺序一致），也不允许重复 可变参数使用前提： 参数列表的类型已经确定，但参数个数不确定时 一个方法的参数列表只能有一个可变参数 如果参数有多个，可变参数必须写在参数列表的末尾 底层原理：可变参数底层是一个数组，根据传入参数个数会创建不同长度的数组终极形式：object...obj 1234567891011public static void main(String[] args) { System.out.println(add(1,2)); System.out.println(add(1,2,3,4));}public static int add(int...arr){ int sum=0; for(int i:arr){ sum+=i; } return sum;} 六、Collections工具类常用功能java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。（使用前提，必须实现Comparable，重写接口中的compareTo方法/自己-目标是升序/） public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparable与Comparator的区别Comparable：即该类自身带有Comparable方法，可以实现本类的比较，需要实现Comparable接口，重写比较规则compareTo方法Comparator：相当于找一个第三方裁判，无需实现接口；规则：o1-o2升序 例子： 12345678910111213141516171819202122232425import java.util.*;public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); ArrayList&lt;String&gt;list=new ArrayList&lt;&gt;(); while(n--&gt;0) list.add(sc.next()); Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { int a=Integer.parseInt(o1+o2); int b=Integer.parseInt(o2+o1); if(a&gt;=b) return -1; return 1; } }); StringBuilder sb=new StringBuilder(); for(String e:list) sb.append(e); System.out.println(sb); }} 第九章 Map集合Map集合特点 Map集合是双列集合，一个元素包含两个值 key不可以重复，value可以重复 一个key唯一对应一个value常用子类HashMap集合特点： 底层是哈希表（查询速度快）JDK1.8之前：数组+单向链表 JDK1.8及以后：数组+单项链表/红黑树（8个+用红黑树） HashMap是无序集合（存储和取出顺序有可能不同）LinkedHashMap集合继承了HashMap集合特点： LinkedHashMap底层：哈希表+链表（保证迭代顺序） 有序（存储和取出顺序一致）Hashtable集合特点： 不允许存储null键-null值 线程安全的（同步的、单线程、速度慢）HashMap是多线程的，非线程安全，不同步，速度快 和Vector集合一样在JDK1.2后被取代（ArrayList，HashMap）但是Hashtable的子类Properties依然活跃，它是唯一一个与IO流结合的集合 Map接口中常用的方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。如果key重复则替换value（返回被替换的值），不重复则添加（返回null） public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。123456789101112131415Map&lt;String,String&gt; map=new HashMap&lt;&gt;();map.put(&quot;大伯&quot;,&quot;大妈&quot;);map.put(&quot;二伯&quot;,&quot;二妈&quot;);map.put(&quot;老爸&quot;,&quot;老妈&quot;);//利用keySet遍历MapSet&lt;String&gt; set = map.keySet();Iterator&lt;String&gt; iter = set.iterator();while(iter.hasNext()){ System.out.println(map.get(iter.next()));} 或者使用灵活版的foreach循环 for(String i:map.keySet()){ String value=map.get(i); System.out.println(i+&quot;和&quot;+value); } Entry（项）键值对对象Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718Map&lt;String,Integer&gt;map=new HashMap&lt;&gt;();map.put(&quot;余丰旭&quot;,171);map.put(&quot;陈香玉&quot;,160);map.put(&quot;小小余&quot;,180);//遍历Map的第二种方法，使用Entey键值对对象//使用迭代器进行遍历Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator();while(iter.hasNext()){ Map.Entry&lt;String,Integer&gt; entry=iter.next(); String key=entry.getKey(); Integer value=entry.getValue(); System.out.println(key+&quot;身高是&quot;+value+&quot;厘米&quot;);}//使用增强for循环for(Map.Entry&lt;String,Integer&gt; i:map.entrySet()){ System.out.println(i.getKey()+&quot;身高为&quot;+i.getValue()+&quot;cm&quot;);} HashMap存储自定义类型键值Map集合保证key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 第十章 泛型当我们不知道使用什么数据类型的时候，我们可以使用泛型。创建集合对象的时候就会确定泛型的数据类型 一、泛型概述 创建集合对象，不使用泛型 *好处**：元素类型不必一致，默认类型是Object类 *弊端**：不安全，使用了多态导致子类独特内容被屏蔽，需要向下转型（循环中又无法统一向下转型） 创建集合对象，使用泛型 *好处**： 1.避免了类型转换的麻烦，存储的什么类型，取出来就是什么类型2.把运行期异常（代码运行之后抛出的异常），提升到编译期。不使用泛型，需要向下转型，循环中会出现类型转换异常 弊端：泛型是什么类型，就只能存储什么类型 二、定义和使用有泛型的类定义了带泛型的类，创建对象时不写则默认为Object类 123456789101112131415161718public class One&lt;E&gt; { private E data; public One() { } public One(E data) { this.data = data; } public E getData() { return data; } public void setData(E data) { this.data = data; }} 1234567public static void main(String[] args) { One&lt;String&gt;one=new One&lt;&gt;(&quot;使用了泛型&quot;); System.out.println(one.getData()); One&lt;Integer&gt;two=new One&lt;&gt;(); two.setData(12); System.out.println(two.getData());} 含有泛型的方法含有泛型的方法，在调用方法时确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型 格式：修饰符&lt;泛型&gt; 返回值类型 方法名（参数列表*(使用泛型)*）{方法体} 含有泛型的接口 定义格式： 1修饰符 interface 接口名 &lt;代表泛型的变量&gt;{}共有两种使用方式 接口的抽象方法以泛型为参数 接口的实现类的泛型跟着接口的泛型走1public class Two&lt;E&gt;implements MyInterface&lt;E&gt; 泛型通配符用来表示暂时未知的类型1234567891011121314151617181920212223public class Demo { public static void main(String[] args) { ArrayList&lt;Integer&gt;list1=new ArrayList&lt;&gt;(); list1.add(1); list1.add(2); list1.add(3); ArrayList&lt;String&gt;list2=new ArrayList&lt;&gt;(); list2.add(&quot;我爱你&quot;); list2.add(&quot;塞北的雪&quot;); traverseList(list1); traverseList(list2); } public static void traverseList(ArrayList&lt;?&gt;list){ /*for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); }*/ //使用迭代器遍历 Iterator&lt;?&gt;iterator=list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } }} 通配符高级使用——受限泛型 泛型的上限* 格式：类型名称 &lt;? extends 类&gt; 对象名称 意义：只能接收该类型及子类型 泛型的下限* 格式：类型名称 &lt;? super 类&gt; 对象名称 意义：只能接收该类型及其父类型java 此时参数只能接收Person类及其子类对象 public static void func(Collection&lt;? extends Person&gt; coll) 此时参数只能接收Person类及其父类对象 public static void func(Collection&lt;? super Person&gt; coll) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EKBUBlAi-1580906486394)(img\\Collection与Map.bmp)]","link":"/2020/01/29/Java-java%E5%85%A5%E9%97%A8/"},{"title":"区块链溯源相关的问题与思考","text":"对于课题的疑问 到底做哪种溯源？单纯地数据分发下的（数据基本不发生变化），还是将数据经过多次流转、抽取、迁移、集成、计算的过程全部溯源。 我建议只做数据分发下的，数据不发生改变，不然太困难了 如果是任何改变都溯源，是只溯源头还是源头和过程都溯？难度又不是一个量级的 溯源的目的是什么，或者说意义和价值在哪里。 数据溯源的目的是为用户提供当前数据的历史档案，通过溯源展现数据从产生到最终状态的整个演变过程，确保数据的安全、可靠和完整，增强用户对数据的信任。 在大数据环境中，数据的生成规模、传播速度急剧增长，数据的来源以及衍生路径呈现出多样化、复杂化的特点，给传统静态的信息资源管理方式带来挑战。众多领域，如科学研究、应急管理、决策支持、信用监管、循证医学、犯罪证据等，对于数据的真实性与有效性有着很高的要求。但是，“许多数据不是直接测量获得的，而是通过计算机程序的应用从其他数据中得到的”。在数据的共享、交换与交易过程中，原生数据常常经过多次流转、复制、迁移、集成、抽取、计算等操作后形成海量派生数据，如果不对原生数据的溯源信息进行记录，将在很大程度上降低派生数据的真实性和有效性，以致给数据的应用带来风险。为了增加数据的可靠性和可信性，追溯数据的派生过程和原生系统，数据溯源技术应运而生。 区块链溯源的优势 充分利用区块链的技术优势，多方面探索和完善基于区块链的数据溯源模型、方法及应用。 区块链通过分布式账本技术和共识机制实现去中心化，确保溯源数据的完整性和不可篡改性; 通过智能合约降低数据的收集成本并提高数据的应用效率，保证了数据的高质量和有效性。 区块链溯源面临的问题 当前，一些基于区块链的数据溯源研究与实践也暴露出了一些具体问题。 例如无法支持复杂场景下可信数据的有效管理，大规模链式结构或日志结构上的溯源信息查询还相当低效; 特别地，区块链作为一种创新技术，在很多具体领域尚无特别有效的应用场景和成功经验，甚至在有些领域还与现有系统的管理技术、手段和制度发生冲突。 但是，许多区块链溯源研究充分证明了区块链的应用价值。随着技术的成熟，数据溯源的应用场景将会不断扩展，不但可以验证与扩展已有的标准、模型和方法，也可以更多地解决现实问题，如政府数据治理、共享与开放，等等。 ICS工业控制系统 可以额外做的点 溯源分割、溯源压缩 溯源的意义： 入侵检测 判断工业流程、工业过程安全合规性 工业控制系统 RTU和PCL rtu是SCADA系统的基本组成单元。rtu是安装在远程现场的电子设备，用来监视测量和采集安装在远程现场的传感器和设备，负责对现场信号、工业设备的监测和控制。rtu将测得的状态或信号转换成可在通信媒体上发送的数据格式。 plc是可编程逻辑控制器，在场站内进行数据汇总和指令处理。它具有多种控制功能、数据采集存储和处理功能、数学运算功能、输入/输出接口调理功能。另外还有通信联网功能、人机界面功能以及编辑调试功能。 两者区别： 1、rtu一般不受地理环境限制，可在室外现场测量点附近安装，一个rtu可以就地控制几个、几十个或几百个I/O测量点，因而它的适应恶劣环境能力强。其工作温度一般在-40~85；防护等级高，可用于潜水艇工作；一个电池组供电工作时间有时长达数月。plc一般主要用于厂站内工业流水线的控制。工作环境温度要求0–55，空气湿度应小于85%。超过温度55要安装风扇通风，高于温度60要安装风扇或冷风机降温。 2、由于rtu不受工作环境约束，故要求其技术规格符合恶劣环境要求和特定要求。它的数据存储量大，模拟量采集能力强(最多24路)，模拟功能远比plc更强大。 3、rtu通信功能强大。由于rtu要将采集的模拟量、开关量、数字量信息最终传输给调度中心，而调度中心有时远隔千里之外，故要求它具有远程通讯功能。plc虽然也有通讯功能，但仅限于厂站内部近距离传送数据，其通信功能与rtu相比稍逊一筹。 4、传统的rtu没有可编程运算功能，现在的rtu大都具备了可编程运算功能，还有PID控制功能或逻辑控制功能、流量累计功能等。它具有梯形图和C语言编程，屏幕组态软件编程等技术运算能力强，可带液晶就地显示和控制。这一些都是plc不能比拟的。 5、rtu与plc使用功效也不尽相同。rtu具有远方功能、当地功能以及自检与自调功能。它与调度中心相距遥远，与调度中心计算机通过信道相连接；它的当地功能是指rtu通过自身或连接的显示、记录设备，就地实现对网络的监视和控制的能力；rtu的程序自恢复能力是指rtu在受到某种干扰影响而使程序“走飞”时，能够自行恢复正常运行的能力。plc仅有当地功能。 本文重点介绍了rtu和plc是什么，以及它们有着怎样的区别。总体来说rtu和plc在使用上不尽相同，所以大家需要根据具体的情况选择，另外安装使用rtu和plc也有不同的要求，这些细节问题也是需要注意的。 数据溯源 数据起源被定义为“系统转换数据的历史”[13]。一条数据的来源描述了每个过程的输入和输出是什么，执行了什么过程，以及谁在执行过程中控制了这些过程。起源通常表示为有向无环图(DAG)，节点表示数据、流程和控制实体。边表示这些节点之间的因果关系。 关于课题的想法2021-12-1 今天跟老俞聊天的收获 溯源是我们研究的对象（要去解决的问题），需要用什么样的方法来实现溯源，而非是用溯源去解决什么问题，溯源本身就是安全下面的一个问题（就像对排序的研究，不是排序去解决什么问题，而是研究怎样排序更高效，比如冒泡、快速排序） 我们需要解决两个具体的问题，使用什么样的方法，可以将溯源作为一个具体的问题，然后再找另一个问题，凑成两个问题写论文；也可以在溯源下，找两个需要解决的问题，例如如何保证溯源数据的完整性不可篡改性、如何更高效查询、如何减少压缩溯源数据。 2021-11-29《区块链技术研究综述：原理、进展与应用 》 2021-11-28 简单地说，区块链技术可以被认为是一种使用加密技术和数据冗余实现安全日志记录的先进技术。 老俞想做ICS（industrial control system）的东西 溯源在ICS中有什么用？1.为入侵检测提供完整数据，2. 检测故障，故障诊断 溯源与区块链存储数据应该分离，不需要使用智能合约来进行溯源，溯源应该单独在应用层实现，数据使用区块链中的数据。 2021-11-23 车联网数据数据溯源的一大用处，是事故溯源，尤其是对拥有人工智能驾驶的汽车来说。 不过这也不叫车联网，这就是行车数据溯源呀！跟有没有iot没什么关系 2021-11-16 今天去找老俞聊天，老俞说： 笼统地总结（所有领域的）溯源的定义（数据的创建，流传，修改…），溯源要解决什么问题（真实性、完整性、机密性、访问控制） 聚焦某个领域，如健康物联网、工业现场物联网、车联网（搞清楚是车内数据，还是v2v,还是v2i vehicle to infrastructure) 需要去了解具体领域的特点 然后解决这个领域的某两个问题（比如数据真实性、访问控制） 2021-11-9 我的迷惑：不知道在创新点在哪里 是在设计溯源机制、优化溯源机制，提高效率提高安全性提高可用性上 还是说在场景应用的创新上，区块链溯源与不同场景进行溯源。 师姐关于车联网溯源的想法 就是你血车联网的时候，他不是要组网吗？你给他搞什么各种复杂的网络，什么卫星网络之类的，然后涉及到这种复杂的网络，就有一种动态负载的那种素颜，你在搞个什么素颜路径优化算法，你这个毕业论文就稳了 2021-11-8 今天跟老俞交流的几个收获 看ACM，IEEE的论文(2017以后的），一区二区A类B类的，别的别看了，只能参考，研究的不细 做领域上的创新，然后解决其中的一两个问题（解决现有论文上的问题，难度较大，完成不了） 去了解王丽曌在做什么，在她做的系统上，完成我的研究 本周找所有好的论文（数据溯源provenance、trace相关，一区二区A类B类），然后再找出与区块链有关的。只看摘要，只看解决了什么问题（不看怎么解决的）。先了解整个溯源、区块链溯源，在关注什么问题，解决什么问题。 窄带互联网nbiot 不要局限，我们定的只有“溯源”和“区块链”，其他和iot、云存储、深度学习相结合，都是可以的。 要经常找老师,多跟王丽曌交流，了解她在做什么，回头要在 英文论文看《中国计算机学会推荐国际学术期刊》里的AB类，中文看好学校的硕士和博士论文（解放军信息工程大学、西电、北邮、中科院大学、南京大学等），软件学报、计算机学报和电子学报 2021-9-13 区块链是共享、分布式、容错数据库 2021-9-12 数据溯源到底追溯什么？ 原来的想法：在数据不会被修改的状况下，追溯数据分发的路径，如C手中的这份数据是经过A-B-C这样的顺序过来的。 现在看到有的论文描述数据溯源，包括三个方面（实现起来较为困难） 对产生当前数据项的源头数据的追溯和描述 对源头数据如何演变为当前数据状态的过程信息的追溯、捕获或记录。包括数据的移动、变化、交付、执行、操作、传播和利用等动作，以及在这一过程中产生的派生数据内容。 在从源头数据到当前数据状态这一过程中，对所有能够影响数据状态的因素（比如影响数据的实体、工具等）进行追溯、描述和记录。 因此，数据溯源既可能是一种从数据当前状态向源头数据追溯的逆向运动过程，也可能是从源头数据运动之始就对数据变动信息进行捕获和记录的过程。追溯过程中所记录下来的信息，形成了一套内容丰富、全面系统、联系紧密的数据集，也就是数据溯源的结果信息。 今天看到论文《数据科学视角下数据溯源研究与实践进展》对区块链数据溯源的许多研究文章和进展进行了总结，非常棒。可以去把里边提到的那些论文先看一遍。（重要的部分在2.5和3.5） 区块链可以应用于溯源，是源于区块链的不可篡改性，不可篡改性又源于共识（本地区块可以篡改，但是无法篡改共识） 2021-9-11 我的课题重点在哪里？是对区块结构的设计（更易于溯源），还是对整个系统的设计，还是对共识算法的改进？ 2021/9/10关于数据分发与溯源，网上各种论文的一般做法是：在系统中有很多独立的节点，可以互相分发数据。区块链系统由双链构成，一条链存储分发的数据，永远保证数据的完整性和不可篡改性，一条链记录数据的传输路径，用于溯源。共识算法一般采用实用拜占庭算法。 我的疑问： 数据溯源的意义在哪里？A把数据分发给B和C，C又分发给E和F，我通过这样一套系统能够溯源A-C-E的数据分发路径，有什么用？还是说不讨论具体的用途，只是实现它？ 轻节点与重节点？不需要，因为大量数据存储在中心云服务器，区块链仅仅是用于记录数据分发的路径，数据量小。 溯源功能如何实现 溯源的前提是转发的路径不能被篡改。 大数据如何体现（创新点）？ 在数据量巨大的情况下（PB级别），数据上链非常影响区块链的效率。那就采用中心数据库与区块链分布式系统相结合，中心数据库（云端）存储大量数据（加密的）。 当一个用户想要分发某数据时，需要先加密上传到云端，然后通过代理重加密技术（能够保证云服务商无法查看数据）和访问控制相关的技术如属性加密，将分发信息上链，只有合法目标用户可以从云端下载并解密相关数据； 当某用户想要转发时，要向区块链系统发出请求，只有超过半数的节点判定此请求合法时，才会被纳入区块链的历史中称为合法请求。 数据上传、分发、下载、转发的信息，均被存储在区块链中，可以进行溯源。 这不就是百度云吗？但是百度云不能记录分发的路径，不能进行分发路径的溯源。 如何做到隐私保护 代理重加密：保证云服务商无法查看用户数据，非转发目标用户无法查看数据 属性加密：考虑了访问权限 将访问权限分为三级 可访问 可访问、可以授权他人访问 可访问、可以授权他人访问、可授权他人转发 （困难在于，无法阻止没有转发权限的用户进行转发，它可以下载再上传，然后转发） 中心服务器数据存储优化 将数据分段、分块存储；因为是大数据环境下，数据海量，可能有大量重复的数据。通过数据块的哈希值，能快快速判定某数据库块是否已经在中心服务器中。 涉及的技术 属性加密 代理重加密技术 以太坊区块链 微众银行FISCO BCOS 公有链 其他问题 如何做好版权保护？阻止无转发权限的用户 是否需要加入交易系统？数据的有价值有价格，交易有费用。 中心云服务器存储大数据+区块链系统记录数据分发信息实现溯源，这种方案老师是否认可？ 2021/4/9今天去找了老师聊了一下，老俞的意思是说 主要是通过区块链，来保证大数据分发每个环节数据的真实性、不可篡改性； 当发生非法转发时，可以追溯到责任人； 授权访问、访问控制不是重点； 我的任务是在师姐搭好的平台上，实现相应的算法 跟师姐又聊了一下，师姐让我去看看MMR算法，默克尔山脉；提到了蚂蚁面试时问到了语言机、Oracle，另外面试官对大数据下的区块链溯源比较感兴趣。师姐让我把区块链平台搭好。 2021/3/10 什么是大数据分发？其模型是这样的吗？ 大数据分发和溯源平台是是公司内部使用，对员工或部分使用数据进行溯源？还是大众使用？还是说设计一套通用的。 大数据分发的溯源，溯的是什么源？（谁请求了这个数据，又转发给了谁，能否修改？） 重点在哪：是溯源，还是说大数据分发平台的构建和溯源同等重要？ 溯源的目的是什么？ 当数据发生泄漏时，快速定位泄露的环节和责任人。 还是说只负责溯源，具体的对溯源数据怎么使用，不是我的课题所关心的。 老俞的想法是，在一个大数据的环境下进行数据分发，比如授权A访问某项数据，并且A还可以转发给B（要能对这种转发的权限进行控制）。那么我要做的就是使数据被访问（涉不涉及到修改？）的路径可以被追溯。老俞还提到保护数据隐私（什么叫保护数据隐私？即没有授权的用户不能访问特定数据，或者转发给没有被授权的用户他不能访问？） 感觉百度云的分享模式再加个溯源就很符合老俞说的场景？ 我认为无法对转发进行限制（线下转发），只能是在系统内部进行转发时，加以记录然后溯源。 区块链原理相关问题 各个节点的本地时间可能不同，或者被恶意修改，区块链的时间戳使用了错误的时间会有影响吗？ Each block contains a Unix time timestamp. In addition to serving as a source of variation for the block hash, they also make it more difficult for an adversary to manipulate the block chain. A timestamp is accepted as valid if it is greater than the median timestamp of previous 11 blocks, and less than the network-adjusted time + 2 hours. &quot;Network-adjusted time&quot; is the median of the timestamps returned by all nodes connected to you. As a result block timestamps are not exactly accurate, and they do not need to be. Block times are accurate only to within an hour or two. Whenever a node connects to another node, it gets a UTC timestamp from it, and stores its offset from node-local UTC. The network-adjusted time is then the node-local UTC plus the median offset from all connected nodes. Network time is never adjusted more than 70 minutes from local system time, however. Bitcoin uses an unsigned integer for the timestamp, so the year 2038 problem is delayed for another 68 years. 合法的时间戳必须大于前11个区块的中位数，并且小于网络调整时间+2小时。 网络调整时间是你能连接的所有节点的中位数，当然，这个时间不一定是一个严格准确的时间，甚至不能保证顺序。 区块链时间戳有什么用？ 首先不受时区影响，记录的是UNIX时间，即从1970年1月1日0时开始经过了多少秒 其次，某个区块加上了时间戳，由于区块链的不可篡改性，使得某某时间发生了某件事具有真实性。（比如，写好了一篇论文想让某大牛帮我改改，又怕他窃取我的知识成果，于是上传区块链盖上时间戳，这样我就拥有了这篇文章的版权，时间戳会证明某某时间之前我已经写好了那篇论文） 如何解决双花问题？ 双花问题指的是把一笔比特币同时转给A和B，那么我把这笔交易广播到全网，有的矿工M1会打包给A的这笔，有的矿工M2会打包B的这笔。甚至有的矿工会接收到这两笔交易，当然他如果将两笔交易同时打包在一个区块，会过不了合法性验证。M1、M2会将打包的区块发布到全网，最终哪种结果会生效，取决于哪个块在最长链上。对于其他所有节点来说，先收到M1的块，后续接收M2的块会导致分叉，至于他们认可哪个，取决于后续哪个块所在的链更长。 最长链，一般重要交易会等6个块确认 那我的问题来了，如果按照上述描述，M1的打包若是生效，M2的打包即其所耗费的大量算力就白费了，那么我作为一个普通的节点，我不是同时双花，而是同时十花、一百花、一千花、一万花，会不会导致全网算力的大幅浪费？从而导致短暂的全网算力下降？ 答案是不会，只会短暂产生大量分叉。我设想的场景是这样的，比如我把一笔钱同时转给10个人，那么就向全网广播了这10笔交易.矿工M1先收到的是我转给A，那么通过大量计算解出puzzle然后打包，剩下9个矿工分别先收到的是我转给B、C、D..的交易，都通过大量计算然后获得记账权然后打包。然后我想的是浪费了剩下九个人的算力。。如果同时转给一万个人，那么9999个人的算力都浪费了。不过答案是，算力本来就是用来浪费的，本来就只有一个人的结果才会成为最终共识的 区块链的不可篡改性，是对于共识的不可篡改，修改本地的区块，会导致其他节点对该节点的内容的不认可，从而导致该节点被提出共识圈子 区块链所指的不可篡改性，指的是区块链系统的共识不可篡改，而不是某个节点的内容不可篡改。 比特币使用POW的方法来实现共识，其共识是：大家都只认最长链上的块是合法的（前提是块通过了合法性验证）。 你给我转账，到底转没转，我只看最长链上有没有你给我转账的记录（需要等待6个块确认）。那在哪看呢？看自己本地的区块链吗？应该是的 那如果对方的这笔转账不向全网广播，只发送给我一个人，可以欺骗我吗？答案是不可以，因为只有交易不成块，我是不认的 那如果他挖出块，然后把给我转账的信息写入，然后只发给我，我会被欺骗吗？答案是不会，因为我会等待6个交易确认，那么他抢先在所有人之前连续挖出6个块的几率几乎为0，因为他的算力太小。 Merkle树的作用 快速验证某交易是否合法，不过是用于被转账人交易验证？还是旷工生成块时验证？ 旷工计算出合法随机数，获得记账权后可以进行打包区块，如果向区块中打包非法的交易呢？ 得到hash只是第一部，在此基础上发布的块要合规才行。如果里边加入了不合法的交易（签名不准确或者余额不足），其他节点也是不会承认的。不被承认，就白白浪费了这一次的记账机会，当然也没有拿到奖励。 关于区块链的一百个基础问题网上摘录的，地址: 关于区块链的一百个基础问题 1. 什么是区块链? 区块链（Blockchain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。（引用自：维基百科） 区块链的概念首次在2008年末由中本聪（Satoshi Nakamoto）发表在比特币论坛的论文《Bitcoin: A Peer-to-Peer Electronic Cash System》中提出。 2. 什么是比特币？ 比特币（Bitcoin，缩写：BTC）被部分观点认为是一种去中心化，非普遍全球可支付的电子加密货币，而一些观点则认为比特币属于虚拟商品，并非货币。比特币由中本聪（化名）于2009年1月3日，基于无国界的对等网络，用共识主动性开源软件发明创立。自比特币出现一直至今，比特币是加密数字货币市场总市值最高的加密货币。（引用自：维基百科） 3. 区块链和比特币是什么关系？ 区块链是比特币实现的底层技术，区块链技术构建了比特币数据结构以及记录交易的共识方式，该技术实现了比特币的挖矿与交易。而比特币是中本聪开发的第一个区块链应用。 4. 一共有多少个比特币？ 比特币一共大致有2100万个。最终产生的比特币数量，准确的说是20999999.97690000个，比2100万少一点。这个数字可以通过计算得到： a) 比特币约定大约每四年作为一个阶段。 b) 每四年生成的比特币将会减半。 c) 第一阶段的比特币每次生成50个。 d) 计算可得大约2140年将不会产生新的比特币。 e) 比特币在2140年以后将保持在大约2100万个。 5. 比特币的特征有哪些？ 比特币的特征如下： a) 不可伪造，除了原始签名人，其他任何人都不能代表原始签名人生成有效的签名。 b) 不可双花，同一个比特币不可同时被使用两次。 c) 可传递性，比特币可以自由的转移。 d) 匿名性，比特币的持有者均是匿名持有。 e) 独立性，不依赖于第三方中间系统而运作。 6. 什么是双花问题（双重消费）？ 双花问题即指将同一笔钱同时用作两笔及以上的不同交易。举例说明：A一共有50个币，A将50个币发送给B然后广播“A将50个币发送给B”，与此同时A又广播“A将50个币发送给C“，导致A的同一笔50个币可能被交易了两次。 7. 比特币如何解决双花问题（双重消费）？ 举例说明：A一共有50个币，A进行广播宣称将50个币发送给B，同时宣称将50个币付给C。广播出去两条信息后，其他的DEFGHI等节点将会进行核查和确认，当他们发现这个比特币已经被使用了，那么就会投反对票否决这笔交易。所以这笔交易就不可能成功，无法记录到区块链中，从而避免双花问题。 技术上每当节点在把新收到的交易单加入Block之前，会向前遍历检查，检查当前交易所用的币是否确实属于当前交易发起方，此检查可遍历到该币的最初诞生点（即产生它的那块Block源）。虽然多份交易单可以任意顺序进行广播，但是它们最终被加入Block时必定呈现一定的顺序。Block之间以Hash值作为时间戳生成Block，这决定了任意一笔交易资金来源都可以被唯一确定。 8. 如何获得比特币？ 比特币可以通过挖矿或者交易获得。 挖矿是通过贡献算力来获得奖励比特币，而交易是通过购买获得比特币。 9. 比特币和法币有何不同？ 法币由是政府发行的纸币，依靠政府的法令使其成为合法流通的货币。 比特币是加密电子货币，不受任何人控制，数量有限。 10. 比特币的挖矿是什么意思？ 挖矿就是将一段时间内比特币网络中发生的交易进行确认，并记录在区块链上形成新区块的过程，挖矿的人被形象的称为矿工。 11. 如何才能挖矿？ 挖矿首先需要有一个作为连入比特币网络的全节点，其次需要下载相应的挖矿软件到挖矿的机器上，然后就可以挖矿了。此外挖矿可以是节点直接挖矿，也可以是节点上挂很多的矿机或者叫服务器（这些矿机并不作为一个网络的全节点）进行挖矿。最先计算出来并被认可的节点获得奖励收益。 12. 挖矿的收益是如何产生的？ 比特币中大约平均每10分钟会产生一个区块，在这期间所有的挖矿计算机都在尝试计算并打包这个区块，然后提交到节点上并广播，第一个成功生成这个数据块的矿机，就可以得到一笔比特币作为奖励。最初，大约每10分钟就可以产生50个比特币的比特币报酬。但是该报酬每4年减半，现在每10分钟比特币网络可以产生12.5个比特币。 13. 什么是比特币网络中的（全）节点？ 节点就是通过互联网相连的服务器，他们彼此之间能够访问，其中下载了完整的区块链及其软件，并且能参与交易和挖矿的节点称之为全节点。目前全球有10000多个全节点。 14. 比特币如何进行转账？ 举例说明：你要发送10个比特币给朋友。当你发送交易申请后，周边的节点会检查你的账户是否拥有 10 个比特币，如果有，则同意这次交易，并且把这条信息广播到附近的节点，一传十，十传百，很快整个网络都会确认这笔交易信息，然后写入到区块中，你的朋友将会收到 10 个比特币，交易就算完成了。一般人使用钱包进行比特币转账。 15. 比特币的钱包是什么？ 比特币钱包是一种软件，用于管理比特币地址，以及比特币的交易。钱包往往需要同步区块链的全数据，但通常钱包安装在手机上，此时只同步与自己相关的区块链数据。 16. 什么是比特币地址？ 比特币地址是一串由字母和数字组成的26位到34位字符串，比特币地址就是个人的比特币账户，所有的比特币转账交易都是通过比特币地址进行的，类似银行卡的卡号。 17. 一共有多少个比特币地址或账号？ 一共有2^160（2的160次方）个，也就是 (1,461,501,637,330,902,918,203,684,832,716,283,019,655,932,542,97)个地址，意味着75亿的地球人，每人可以分到2^127个地址。 18. 比特币地址如何生成？ 比特币地址通过使用数字签名技术得到。首先随机选出256位二进制数字，形成私钥，由私钥生成公钥，然后通过加密函数来生成地址。这个生成方向是单向的。也就是你知道了地址是无法通过解密方法来计算出私钥的。 19. 什么是数字签名？ 数字签名（又称公钥数字签名，英文为Digital Signature）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。（引用自：维基百科） 20. 什么是私钥？ 是一个证明你有权从一个特定的钱包消费电子货币的保密数据块。私钥是个随机数，这个随机数的概率空间很大（256位，也即是2的256次方），因此在概率论上是不可能生成一样的私钥的。私钥决定了比特币的产权，若私钥丢失，则比特币也丢失。 21. 什么是公钥？ 公钥可以看作是你的比特币账户。私钥经过椭圆曲线乘法运算，可以得到公钥。但从公钥逆推私钥是不可能的。公钥用于生成比特币地址，同时也进行签名的验证。公钥和私钥成对出现，公钥可以生成对应的唯一地址，通过该地址可以确认发送的交易是否使用了对应的私钥。 22. 比特币的记账方式是什么？ 比特币是使用UTXO（Unspent Transaction Outputs，中文为未花费的交易输出）的方式来记账的，每一笔交易都会产生一笔输出，账户的余额是通过输出值的加和来算出的。所以比特币记录的是一笔笔的账目。 23. 比特币交易都存放在哪里？ 所有的比特币交易最终需要被记到统一的账本区块链上，账本上的每一页也就是每一个区块上记录的就是一笔笔具体的交易。每一个新区块，都会被打上时间戳，最终依照时间前后顺序排列起来。 24. 区块的组成是什么？ 区块主要包含区块头和区块体。区块头中主要记录了上一个区块的哈希值，时间戳，随机数和区块大小等。区块体记录交易信息等数据。区块相当于账本中的一页，一个区块是一些或所有最新比特币交易的记录集，且未被其他先前的区块记录。 25. 区块如何连接成区块链？ 区块链由一串使用密码学算法产生的区块连接而成，比特币在生成新区块时，需要根据前一个区块的哈希值，新交易区块和随机数来计算新的哈希值和随机数，每一个区块都是由前一个区块生成的，最后连接成区块链。 26. 目前比特币的所有区块有多大？ 截至2018年3月，比特币所有区块大约160GB。所有区块大小的增速取决于交易的数量，交易越多，被增加的区块就越多，区块总大小就越大。 27. 什么是51%攻击问题？ 51%攻击是指掌握了比特币全网的51%算力之后，用这些算力来重新计算已经确认过的区块，使区块链产生分叉并且获得利益的行为。理论上存在，但在公网环境里实际上很难发生，因为掌握51%算力的成本及其高昂。 28. 如何保证历史交易数据不可篡改？ 区块链中每个节点都完整地保留一份交易的历史记录。这样任何单个人或节点想修改这些历史记录，需要所有人确认，但是别的人或节点都可以拿出自己的那一份备份，来证明这个修改无效。 29. 什么是比特币分叉？ 比特币分叉是比特币区块链产生了两条及以上的不同分支的情况。当矿工挖矿时，可能有两个或两个以上矿工都挖出了新的区块，并且都是满足要求的不同的区块。在广播后，不同的节点可能将不同的区块分别加入到各自的比特币区块链中，产生不同的区块链，就可能产生分叉。 30. 在比特币里，分叉问题如何避免？ 比特币里产生分叉时，由于两条链的增长速度是不一样的，在一段时间之后，总有一条链的长度要超过另一条。当矿工发现全网有一条更长的链时，他就会抛弃他当前的链，把新的更长的链全部复制回来，在这条链的基础上继续挖矿。所有矿工都这样操作，这条链就成为了主链，分叉出来被抛弃掉的链就消失了。最终只有一条链会留下来，从而避免分叉。 31. 什么是以太坊？ 以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机” Ethereum Virtual Machine）来处理点对点合约。（引用自：维基百科） 32. 什么是ICO？ ICO（是Initial Coin Offering缩写），首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，募集比特币、解决以太坊等通用数字货币的行为。（引用自：维基百科） 33. 区块链如何分类？ 目前大部分人认为区块链可以分为三类：公有链、联盟链、私有链。 34. 什么是公有链？ 公有链（Public Blockchain）是指任何人都可以随时进入到系统中读取数据、发送可确认交易、竞争记账的区块链。公有链通常被认为是“完全去中心化”的，因为没有任何个人或者机构可以控制或篡改其中数据的读写。公有链一般会通过代币机制来鼓励参与者竞争记账，来确保数据的安全性。比特币、以太坊都是典型的公有链。 35. 什么是联盟链？ 联盟链（Consortium Blockchain）是指有若干个机构共同参与管理的区块链，每个机构都运行着一个或多个节点，其中的数据只允许系统内不同的机构进行读写和发送交易，并且共同来记录交易数据。联盟链可视为“部分去中心化”，公众可以查阅和交易，但不能验证交易，或不能发布智能合约，需获得联盟许可。Hyperledger Fabric是典型的联盟链。 36. 什么是私有链？ 私有链（Private Blockchain）指其写入权限仅在一个组织手里的区块链。读取权限或者对外开放，或者被任意程度地进行了限制。相关的应用囊括数据库管理、审计等，在很多情形下，公共的可读性并非是必须的。 37. 到目前为止，区块链的发展的经历了几个阶段？ 目前普遍认为有三个阶段： 第一个阶段，或称区块链1.0，以比特币为代表的数字货币领域创新，如货币转移、兑付和支付系统等。 第二个阶段，或称区块链2.0，以智能合约为代表的企业级应用领域，此时更多的是做一些合约方面的创新，是涉及交易方面的商业合同，比如股票、证券的登记、期货、贷款、清算结算等。 第三个阶段，或称区块链3.0，区块链进入社会治理领域，包括了身份认证、公证、仲裁、审计、物流、医疗、签证、投票等领域，应用范围扩大到了整个社会，区块链技术有可能成为“万物互联”的一种最底层的协议。 38. 区块链的特点有哪些？ 区块链的主要特点有以下几点： a) 去中心化——无需第三方介入，实现人与人点对点交易和互动。 b) 信息不可篡改——数据信息一旦被写入区块中就不能更改撤销。 c) 公开透明——极短时间内，区块信息会被复制到网络中的所有区块，实现全网数据同步，每个节点都能回溯交易双方过去的所有交易信息。 d) 集体维护性——在区块链中，是由所有节点共同维护整个区块链信息的可靠和安全性。 e) 可靠数据库——只有掌握整个系统51%节点，才能对区块链信息进行篡改，这样显然不可能做到，因为整个系统参与者众多，掌握这么多节点成本极高，也无法实现，这样能确保数据的完整性、真实性和安全性。 39. 拜占庭将军问题是什么？ 由Leslie Lamport，Robert Shostak和Marshall Pease在其1982年的论文“拜占庭将军问题”中提出的，被称为The Byzantine Generals Problem或者Byzantine Failure。问题大意：在古罗马拜占庭帝国，几位将军带领各自的军队围攻一个城堡，必须有大于一半的军队同时进攻才能取胜。将军们只能通过信使彼此沟通，观察敌人后，将军们必须决定一个共同的行动计划（同时进攻或者同时撤退）。 但是，有些将军可能是叛徒，试图阻止忠诚的将军达成一致。在这种状态下，将军们必须找到一个算法来满足下面两个条件： a) 所有忠诚的将军都决定采取相同的行动计划。 忠诚的将军们都会按照算法所说的去做，但是叛徒可以做任何他们想做的事情。该算法必须保证不管叛徒做什么，忠诚的将军能达成一致合理的计划。所以还必须保证： b) 少数叛徒不能使忠诚的将军采取坏事计划。 什么是坏事计划，很难形式化，在这里进行简化定义为：每个忠诚的将军都正确的表达了自己的意思。不会因为叛徒的捣乱，让别的将军认为忠诚的将军是叛徒。 至此，我们将拜占庭将军问题简化成了：所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动。而形式化的要求就是，“一致性”与“正确性”。 这个算法称为拜占庭容错算法，并不容易实现。直到1999年，Miguel Castro和BarbaraLiskov提出了实用拜占庭容错算法（PBFT），能够实现只要叛徒不超过三分之一，忠诚的将军们就一定能达成一致结果。 40. 比特币区块链中如何解决拜占庭将军问题呢？ 中本聪发明的比特币，对解决拜占庭将军问题提出了一种全新的思路，它就是PoW(Proof of Work) 工作量证明共识机制。在拜占庭将军问题中，如果将军们几乎同时发起消息，势必会造成混乱，造成各说各的攻击时间方案，行动难以一致。中本聪巧妙地在系统加入了发送信息的成本，降低了信息传递的速率。即：一段时间内（10分钟）只有一个节点可以传播信息。它加入的成本就是工作量，节点必须完成一个计算工作才能向其他将军传播消息，当然，谁第一个完成工作，谁才能传播消息。也就是比特币网络中每10分钟产生一个新的区块，每10分钟才广播一条消息，同时消息是签名加密的。通过PoW机制，一个节点必须经过大量尝试性计算才能得出一个结果，而其它节点只需极少的时间就能证明其真伪，这样能够减少垃圾消息、假消息在节点间传播的状况。 另外，在PoW共识机制下，如果要做叛徒，攻击整个网络，需要付出相应的成本，就是要掌握整个网络50%以上的算力。换句话说，有50%以上的叛徒才行，这是比PBFT高得多的容错率，而且大家可以想象一下这是多高的成本。如果真的掌握那么大的算力的话，用这些算力维护网络（诚实地挖矿）获得的收益其实会远高于破坏网络。 用工作量证明、加密等技术，使比特币网络从一个去中心化的不可信网络变为可信网络，使所有参与者可以在某些事情上达成一致，使价值传递成为了可能。比特币创造性的解决了拜占庭将军问题。 41. 什么是共识机制？ 共识机制是为了解决拜占庭将军问题提出的，它是区块链的核心。也就是就某件事或某个交易，在分布式，互不信任的环境中，各参与者之间达成一致的过程。 42. 共识机制的目标是什么？ 共识机制的目标有两点： a) 一致性：所有诚实节点保存的区块链的前缀部分完全相同。 b) 有效性：由某诚实节点发布的信息终将被其他所有诚实节点记录在自己的区块链中。 43. 区块链目前主要有哪些共识机制？ 区块链目前主要的共识机制有： a) POW(Proof of Work)工作量证明； b) POS (Proof of Stake) 权益证明机制； c) DPoS (Delegated Proof of Stake) 委托权益证明机制； d) PBFT (Practical Byzantine Fault Tolerance) 实用拜占庭容错； e) DBFT (Delegated BFT) 授权拜占庭容错算法。 44. 几种区块链平台目前都使用什么共识机制？ 目前主要区块链平台使用以下共识机制： a) 比特币：工作量证明（POW）； b) 以太坊：以太坊前三个阶段采用的是POW共识机制，第四个阶段将采用自己创建的POS机制； c) Hyperledger：可插拔设计，主要有 Solo, Kafka, PBFT等，可根据需要选择。 45. 工作量证明机制POW是什么？ 在基于工作量证明机制构建的区块链网络中，节点通过计算随机哈希散列的数值解争夺记账权，求得正确的数值解以生成区块的能力是节点算力的具体表现。工作量证明机制具有完全去中心化的优点，在以工作量证明机制为共识的区块链中，节点可以自由进出。 46. 权益证明机制POS是什么？ 权益证明要求证明人提供一定数量的加密货币的所有权即可。权益证明机制的运作方式是，当创造一个新区块时，矿工需要创建一个“币权”交易，交易会按照预先设定的比例把一些币发送给矿工本身。权益证明机制根据每个节点拥有代币的比例和时间，依据算法等比例地降低节点的挖矿难度，从而加快了寻找随机数的速度。 47. 实用拜占庭容错PBFT是什么？ 实用拜占庭容错的共识机制是少数服从多数，根据信息在分布式网络中节点间互相交换后各节点列出所有得到的信息，一个节点代表一票，选择大多数的结果作为解决办法。PBET将容错量控制在全部节点数的1/3，即只要有超过2/3的正常节点，整个系统便可正常运作。 48. 什么是去中心化？ 去中心化（Decentralization）是相对于“中心化”而言的新型网络内容生产过程。内容不再是由专业网站或特定人群所产生，而是由全体节点共同参与、共同生产信息。 49. 什么是对等式网络（Peer-to-Peer Network）？ 对等网络是指通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统。以比特币为例：网络以这样一种方式构建——每个用户都在传播其他用户的交易。而且重要的是，不需要银行或其他金融机构作为第三方。 50. 什么是哈希散列？ 哈希散列是密码学里的经典技术，把任意长度的输入通过哈希算法，变换成固定长度的由字母和数字组成的输出。在区块链里主要实现区块间的连接以及数据加密等功能。 51. 什么是智能合约？ 智能合约（Smart Contract ）是一种旨在以信息化方式传播、验证或执行合同的计算机程序协议。智能合约允许在没有第三方的情况下进行可信交易。（引用自：维基百科） 52. 时间戳的价值是什么？ 区块链通过时间戳保证每个区块依次顺序相连。时间戳使区块链上每一笔数据都具有时间标记，任何人无法篡改。 53. 区块链的分层结构是什么样的？ 区块链的分层结构可以参考下图，从底层到应用层，可以分为： a) 数据层：包含区块链的数据处理相关技术实现，数字签名、链式结构等。 b) 网络层：包含点对点网络、传播机制、验证机制等。 c) 共识层：这层实现的是共识算法，典型的有POW、POS。 d) 合约层：主要是智能合约等的实现，以及相关虚拟机的实现等。 e) 激励机制：对于公有链里最常见，各种币的分发方式和奖励机制。 f) 应用层：基于以上基层的分布式应用的实现。 54. 区块链能避免拒绝服务攻击（DDOS）吗？ 区块链本身属于分布性网络，没有一个中央服务器作为攻击主节点，在此前提下，DDOS的目标服务器只能是一台或几台节点，无法对整个区块链网络造成实质影响。 55. 目前的区块链联盟有哪些？ 区块链联盟主要包含以下几家： a) 由Linux基金会发起的超级账本(Hyperledger)。 b) 由R3CEV(一家总部位于纽约的区块链创业公司)发起的R3区块链联盟，至今已吸引了40多家银行巨头的参与。 c) 由Ripple公司发起的支付区块链联盟Ripple。 d) 由俄罗斯俄罗斯支付公司Qiwi发起的被称为“俄罗斯版R3”的俄罗斯区块链联盟。 e) 由11家国内机构共同发起的China Ledger联盟等。 56. 区块链技术平台有哪些？ 区块链的技术平台主要有比特币Bitcoin、以太坊Etheruem、瑞波Ripple、超级帐本Hyperledger等。 57. 企业区块链应用一般选择什么技术平台？ 企业应用区块链主要还是联盟链形式，联盟链里面目前最为有效的应该就是Hyperledger体系。 58. 几种区块链技术平台的性能有什么不同？ 几种主流的区块链技术平台性能比较如下所示： a) 比特币： 每笔交易最终确认需要60分钟；每秒7笔。 b) 以太坊：每笔交易最终确认需要15秒；每秒20笔。 c) Hyperledger： 每笔交易不到1秒；每秒上万笔。 59. 比特币每秒7笔怎么计算出来的？ 比特币能承载的交易量受区块大小限制，目前每个区块上限1MB，每10分钟1个区块，一个交易记录0.25KB，每秒平均能打包1000/0.25/60/10=6.67个交易，这也是很多资料提到比特币每秒处理7笔交易的由来。 60. 一般来说，联盟链相对于公有链的优势在哪里？ 联盟链相对于公有链的优势在于以下三个方面： a) 性能更好，交易只需被几个受信的高算力节点验证就可以了，而无需全网确认。 b) 节点可管控，只有经过许可的节点才能加入区块链网络，故障可以迅速通过人工干预来修复。 c) 对用户身份进行管理，读取权限受到限制，可以提供更好的隐私保护。 61. Hyperledger是什么？ Hyperledger （超级账本）是一个开源的区块链和相关工具的总括项目，由 Linux基金会在2015年12月发起该项目，以支持基于区块链技术的去中心化账本的协作开发。详细信息可参考如下官方网站: https://www.hyperledger.org/ 62. Hyperledger框架项目主要包含哪些？ Hyperledger项目孵化了众多开源项目，总体分为框架和工具两大类，其框架项目主要有以下几个： a) Hyperledger Sawtooth b) Hyperledger Iroha c) Hyperledger Burrow d) Hyperledger Indy e) Hyperledger Fabric 以上框架类项目中，每个项目都有各自的设计理念和特色，支持的共识算法、开发语言各不相同。目前只有Sawtooth和Fabric达到了生产稳定状态，可以应用于企业开发。而Fabric是目前最流行、使用最广泛的企业级框架。 工具类项目，目前有：Blockchain-explorer、Cello、Composer等。 具体可见：https://www.hyperledger.org/ 63. Hyperledger Sawtooth是什么？ Hyperledger Sawtooth是Intel贡献和主导的分布式账本技术平台，它支持PoET（Proof of Elapsed Time）和Quorum Voting两种共识机制，当节点数量很多（公有链环境）时，使用第6代Intel Core CPU所提供的SGX扩展功能提供的一种称为时间流逝证明PoET的机制来形成共识，它的性能和可靠性由Intel CPU硬件来保障，PoET算法以最少的资源消耗为目标，使我们能以较少的能源消耗建立数百至数千个节点的非常广泛和扁平的区块链网络，是公有链系统里很有价值的一个共识机制。 另一方面，当节点数量少且受控时，Sawtooth可以采用法定人数投票Quorum Voting共识机制，Quorum Voting是瑞波币和恒星币的修正版，用于满足需要即时确定交易的应用场景，非常适合于联盟链场景，这样Sawtooth就摇身一变成为很好用的联盟链了。 所以Sawtooth既可以用于需要许可的联盟链中，也可以用于不需要许可的公有链中。另外，Sawtooth提供的SDK比较多，有Go, C++, Java, Node.js, Python等。 64. Hyperledger Burrow是什么？ Hyperledger Burrow是由 Monax贡献，Intel共同赞助的智能合约解释器。它是超级账本Hyperledger中第一个来源以太坊的项目，是第一个采用以太坊虚拟机（EVM）标准的带权限许可的智能合约解释器。Burrow对EVM做了一些扩展，同时保持与EVM兼容。Burrow被设计成一个通用的智能合同机器，采用对PBFT做了优化的Tendermint共识算法，有比较好的性能。 借助遵循Apache许可的以太坊虚拟机Burrow，使Hyperledger中的其他分布式账本项目（比如Fabric、Sawtooth、Lake、Iroha）可以将EVM融合到各自的平台，比如通过与Burrow集成，Sawtooth已经可以支持以太坊的智能合约。这也意味着超级账本组织和以太坊社区，包括企业级以太坊联盟，开始建立一种富有成效的关系。 65. Hyperledger Iroha 是什么？ Hyperledger Iroha是由日本公司Soramitsu发起和贡献的轻量级分布式账本，它的设计和架构参考Fabric。Iroha的目标是： a) 为C++开发人员提供一个为Hyperledger做出贡献的环境，在C++中创建可重用组件来补充Fabric、Sawtooth和其他潜在项目，这些组件可以使用Go等语言进行调用； b) 为移动和Web应用程序支持提供基础设施（提供iOS, Android和JavaScript类库）； c) 提供一个框架来试验新的API和共识算法，这些算法可能会在将来被纳入Fabric。 此外，Iroha还支持数字资产(Digital Asset)的发行。 66. Hyperledger Indy是什么？ Hyperledger Indy由Sovrin基金会贡献，Sovrin基金会成立于2016年，致力于打造一个基于区块链的去中心化的全球数字身份自治管理的公共基础设施。Indy提供了工具、程序库和可重复使用的组件，用于提供基于区块链或者其它分布式账本的数字身份，从而让它们可以跨账本、跨管理域、跨应用进行互操作。Indy为Fabric、SawtoothLake、Corda等提供了强大的跨账本身份管理功能。 由于分布式账本事后无法更改的特点，因此基于分布式账本的身份用例应仔细考虑基本组件，包括性能，规模，信任模型和隐私保护。Hyperledger Indy开发了去中心化身份的规范，术语和设计模式，并实现了这些概念，可以在Hyperledger联盟内部和外部使用。 67. Hyperledger Fabric是什么？ Hyperledger Fabric是来源于IBM的分布式账本技术平台，是目前为止在设计上最贴近联盟链思想的区块链，Fabric有完备的权限控制和安全保障，数据保密机制，它采用模块化设计，可插拔架构，允许组件（如共识算法和会员管理）即插即用。 Hyperledger Fabric利用容器技术来运行称为Chaincode的智能合约。Fabric获得众多重量级企业的支持，是目前应用最广泛的企业级区块链框架。 68. Fabric的技术特点是什么？ 同其他的主流的开源区块链技术平台相比，Fabric有以下特点： a) Fabric有完备的权限控制和安全保障，兼顾数据共享和隐私保护。 b) Fabric采用模块化设计，可插拔架构，Key-Value数据库，身份管理，共识机制和加密算法等都是可插拔的，可以根据实际情况选择替换。 c) 同其他几种主流的开源技术框架相比，Fabric有更高性能和更好的扩展性。 d) Fabric提供多种语言的SDK，可根据实际的项目需要选用。 69. Hyperledger Fabric 1.0的系统逻辑构架包括哪几部分? Fabric架构的核心包括三部分：Identity身份管理, Ledger及Transactions, Smart Contract. 如下图： 70. Fabric的成员管理(Identity)主要有什么功能？ Identity，也就是成员管理，Fabric是目前为止在设计上最贴近联盟链思想的区块链。联盟链考虑到商业应用对安全、隐私、监管、审计、性能的需求，提高准入门槛，成员必须被许可才能加入网络。Fabric成员管理服务为整个区块链网络提供身份管理、隐私、保密和可审计的服务。 71. Fabric的账本(Ledger)包括哪些内容？ Fabric账本Ledger主要包含两块：Blockchain和State。Blockchain就是一系列连在一起的Block，用来记录历史交易。State对应账本的当前最新状态，它是一个Key-Value数据库。Fabric默认采用LevelDB, 可以替换成其他的Key-Value数据库，如CouchDB。在智能合约中对账本进行读写操作。 72. Fabric的Transactions是什么？ Fabric上的Transactions事务分两种，部署事务(Deploy Transactions)和调用事务(Invoke Transactions)。 a) 部署事务把链码(Chaincode)部署到Peer节点上并准备好被调用，当一个部署交易成功执行时，Chaincode就被部署到各个Peer节点上，类似于把一个Web应用部署到应用服务器上的不同实例上。 b) 调用事务在先前部署的链码的上下文中执行操作。客户端应用程序通过Fabric提供的API调用先前已部署好的某个Chaincode的某个函数执行事务，包括读取和写入状态数据库，返回结果等。 73. Fabric的智能合约Smart Contract是什么？ Fabric的智能合约Smart Contract称为链码Chaincode，是一段代码，它处理网络成员所同意的业务逻辑。和以太坊相比，Fabric链码和底层账本是分开的，升级链码时并不需要迁移账本数据到新链码当中，真正实现了逻辑与数据的分离。 74. Fabric的账本(Ledger)数据是如何共享的？ Fabric的账本共享方式和比特币等有所不同。诸如比特币和以太坊，交易数据大家都可以查看，虽然不知道是谁的数据，但是数据本身是对所有人都可见共享的。但在 Fabric中，账本不是共享给所有人的。而是通过 Channel 隔离数据，虽然大家都在同一个区块链网络里，但是不在同一个Channel，也没办法共享账本。所以，通过建立不同的Channel可以达到按需共享的目的。 75. Fabric的业务网络由什么组成？ 业务网络，也叫共识网络或区块链网络，Fabric业务网络由不同的节点构成。节点是区块链的通信实体，节点是一个逻辑概念，不同类型的节点可以运行在同一台物理服务器上。这些节点可能部署在云上面或者本地。可能来自不同的公司或者组织。在区块链网络中有两种类型的节点：Peer节点和Orderer节点。 76. Fabric里的Peer节点有哪些？ Peer节点目前有两种： 背书节点Endorser和提交节点Committer。 a) Endorser 完成对交易提案的背书处理。主要工作是验证签名，进行权限和合法性检查，检查通过则模拟运行交易，对交易导致的状态变化（读写集）进行背书并返回结果给客户端。 b) Committer 负责维护区块链和账本结构。对从Orderer发送来的批量交易区块数据结构，进行最终检查（包括交易消息结构、签名完整性、是否重复、读写集合版本是否匹配等），检查通过后执行合法的交易，将结果写入账本。 77. Fabric里的Orderer节点的作用是什么？ Orderer节点主要用于对事务进行排序（共识），批量打包，生成区块，发给Peer节点。一个区块链网络中会有多个Orderer节点，它们共同提供排序服务。排序服务可以实现为多种不同的方式，从一个中心化的服务（被用于开发和测试，如Solo），到分布式协议（如Kafka），再到PBFT的共识方式等。 78. Fabric的事务(Transaction)执行流程是怎样的？ 事务执行主流程分四步，如下图: \\1. 首先由客户端通过SDK提交交易初始化给Peer节点，请求背书（Endorse）。 \\2. Peer节点收到消息后，进行背书Endorse，并将背书结果通知应用程序。 \\3. 应用程序收到背书结果将之提交Ordering服务节点进行排序（也就是执行共识）并生成Block。 \\4. 然后Ordering服务通知Committing Peer, Committing Peer对该交易进行验证，验证通过，则写入账本。最后通知客户端交易成功。 79. Fabric的开发流程是什么？ 如下图所示，开发者创建客户端应用和智能合约（Chaincode），Chaincode被部署到区块链网络的Peer节点上面。通过Chaincode来操作账本，当你调用一个交易Transaction时，你实际上是在调用Chaincode中的一个函数方法，它实现业务逻辑，并对账本进行Get、Put、Delete操作。客户端应用提供用户交互界面，并提交交易到区块链网络上。 80. 如何基于Fabric开发区块链智能合约？ Fabric的智能合约Smart Contract称为链码Chaincode，是一段代码，它处理网络成员所同意的业务逻辑。目前支持用Go、Java、Node.js语言进行开发。 81. 如何基于Fabric开发客户端的应用？ Fabric目前提供的SDK支持：Go、Python、Node.js和Java。前端应用通过SDK调用服务端的智能合约Chaincode。有些BaaS(Blockchain as a Service)云平台也提供REST接口，方便客户端调用后端的智能合约。 82. Fabric上开发好的应用如何部署？ Fabric上开发好的前端应用的部署和传统应用没什么不同，可部署在应用服务器或者云服务上。后端开发的主要工作是写智能合约，实现业务逻辑，可以部署在区块链云服务上或者自己搭建的本地Fabric环境上。 83. Fabric目前最新的版本是多少？ 截止到2018年3月，最新发布的是1.1版本。1.1相比1.0版本多了以下一些功能： a) 可以采用Node.js开发Chaincode。 b) 基于通道的事件服务 - 使客户能够按每个通道订阅区块和区块事务（交易）事件。 c) 可以把CouchDB索引和Chaincode一起打包，以提高性能。 d) 能够动态更新客户身份和隶属关系。 e) Node.js SDK连接配置文件可简化与Fabric节点的连接。 f) 性能提升，提高了交易吞吐量，并降低了响应时间。 84. Fabric在安全方面有哪些优势？ 企业比较重视安全性， Fabric有以下一些优势： a) 成员必须被许可才能加入网络，通过证书、加密、签名等手段保证安全。 b) 通过多通道Channel功能实现数据访问控制和隔离，保证只有参与交易的节点能访问到数据，其他的节点看不到。满足数据保护方面的法律法规要求。如有些行业，需要知道谁访问了特定的数据。 c) 另外Fabric的加密算法也是可插拔的，可替换的。 85. 企业如何快速上链？ 企业快速上链可以采用两种方式：一是基于Hyperledger自行搭建，但周期较长；二是选择在BaaS(Blockchain as a Service)云平台上构建自己的应用，享受云计算的快速部署、按需付费、弹性扩展等好处。 86. Fabric为什么成为企业区块链框架的首选方案？ Fabric具有一些重要特性满足企业的需求，企业选择区块链技术框架主要考虑的因素有：框架的身份管理、框架的可扩展性、框架的企业安全性、框架的性能、业务逻辑实现、开放的API以及是否提供主流语言的SDK等。 87. 区块链应用与传统应用有什么区别？ 主要的区别在数据存储上，传统架构基于数据库及缓存，区块链采用分布式账本存储数据。 88. 为什么说区块链是更先进的企业间共享数据的技术？ 如下图，企业间的数据共享和交换经历了下面几个阶段，区块链技术的P2P架构，实时数据同步，不可篡改，数据是加密的等特点。实时性、可靠性、安全性更好。 89. 金融业区块链典型场景有哪些？ 目前区块链应用最广泛的行业就是金融行业，典型的有：加密货币、支付、清算与结算、票据与供应链金融 、证券发行交易、金融领域的征信与反欺诈等。区块链诞生于比特币，应该说区块链天然适合于金融领域，尤其对于金融清结算，金融基础设施都有较大的积极意义和影响。金融的本质是价值流通，而区块链常被称为“价值网络”，因为它能让金钱的流动如同数据的流动般自由高效。资产数字化日益成为行业的发展趋势，而区块链的出现令资产数字化的时代加速到来。此外Fintech的三驾马车就有区块链、认知物联网和人工智能，如果将三者有机结合将创造巨大的价值。 90. 运输物流业区块链典型场景有哪些？ 供应链场景下，可以利用区块链的数据实时同步特点进行数据共享，利用区块链的防篡改保证数据的真实性, 提高流程的自动化处理水平，降低耗时、减少人为失误、降低欺诈风险、减少争议。如：马士基联合保险机构、区块链企业等多方共同打造的全球首个针对海运保险的区块链平台，形成跨专业的链上联盟。 91. 制造业区块链典型场景有哪些？ a) 可用于制造业企业的供应链管理，如跟踪追溯原材料，零部件的来源信息。 b) 可用于制造业的供应链金融链条中，共享企业的各项资产核心企业及上下游企业的信息流、物流、资金流信息的整合至关重要。但目前各企业维护自己的数据信息，信息孤岛增大了信息整合的难度。而区块链技术将每个交易方变成网络中的一个节点，企业的各项资产、产品以数字化的形式在网络中体现，任一节点间的交易都会被全网认定，物流信息也可通过产品地理位置信息的改变在网络中体现。同时，区块链保证交易信息不可篡改。 92. 政府行业区块链典型场景有哪些？ a) 可用于食品、药品或者违禁品、危险品的追溯，利用区块链的防篡改和信息实时共享的特征。 b) 可用于房产土地等不动产交易，增强透明性，降低成本。如迪拜欲将房地产交易业务转移到区块链上。 c) 可用于颁发各种证件，如美国伊利诺伊州发起出生证明区块链试点项目，MIT把毕业证放到区块链上，防篡改并方便查询。 93. 电信行业区块链典型场景有哪些？ 区块链的P2P点对点，数据加密，防篡改等特点，可以用于电信业的数据传输。美国电信巨头AT&amp;T正在申请一项关于使用区块链技术创建家庭用户服务器的专利。该专利将成为美国电信行业在区块链领域的首个应用探索。这样一个家庭用户服务器，主要为电视订阅用户一类的群体提供身份验证和媒体传输的功能。AT&amp;T希望通过分布式的节点存储和传输信息来提高多媒体传输的安全性。 94. 医疗行业区块链典型场景有哪些？ 随着医疗保健进入数字化时代，医疗数据安全和患者隐私保障变得越来越重要。区块链技术可以让医院、患者和医疗利益链上的各方在区块链网络里共享数据，而不必担忧数据的安全性和完整性。如区块链创业公司Akiri开发一个医疗数据分布式账本平台Akiri Switch，用于在整个美国医疗系统中安全地传输包括病人记录在内的私人医疗数据。 95. 媒体行业区块链典型场景有哪些？ 媒体行业主要的场景包括版权保护：区块链可用准确地追踪每个内容产品的版权所属，由此将更好地保障内容所有者的合法收入，防止侵权和盗版。 发布内容：格莱美提名的英国录音艺术家伊莫金·希普2016年通过以太坊区块链发布了单曲“Tiny Human”，每次下载0.60美元。虽然活动的收入不如人意，但希普证明了该技术的可行性，使用区块链技术为唱片产业带来公平贸易。 96. 社会管理领域区块链典型场景有哪些？ 社会管理领域主要可以应用到以下场景： a) 城市管理：广东佛山市禅城区就率先开启了基于区块链的政务服务项目。不同于以往的身份证和一卡通，区块链带来的身份认证具有迅速传播、便利共享、选择性显示等传统认证不具备的数据优势，使得城市管理更加便捷、透明和公平。 b) 选举投票：选举需要对选民身份认证、安全的保存记录以追踪选票，以及能够信赖的计数器来决定谁是胜选者。区块链可以为投票过程，选票跟踪和统计选票而服务，以至于不会存在选民欺诈、记录丢失或者不公平的行为。 97. 物联网领域区块链典型场景有哪些？ 区块链可以降低物联网的运营成本，物联网中记录和存储物联网的信息都会汇总到中央服务器，大量的设备产生海量的数据，将导致中心不堪重负，难以进行计算和有效存储，运营成本极高。区块链技术可以为物联网提供点对点直接互联的方式来传输数据，还可以充分利用分布在不同位置的数以亿计闲置设备的计算力、存储容量和带宽，用于交易处理，大幅度降低计算和储存的成本。 98. 公益领域区块链典型场景有哪些？ 慈善最令人诟病的就是善款去向不明、信息不公开。区块链可以帮助公益慈善事业更透明。不可篡改的特点使数据有公信力，可匿名性还能保护捐款者的隐私。GovCoin Systems Limited公司是一家总部位于伦敦的金融科技公司，其正在支持英国政府在福利分配领域的工作。 99. 社交通讯领域区块链典型场景有哪些？ 区块链对传输的数据进行加密，可以保护隐私。目前社交通讯领域的典型应用有： a) Steemit是一个用区块链技术搭建的内容社交平台。在Steemit上发帖、回帖、讨论等可以获得代币奖励。 b) Status是一个在以太坊区块链上开发的社交APP客户端，可以理解成区块链领域里的微信。让用户能够相互发送加密信息、也可以用Status浏览器搜索去中心化APP。 100. 共享经济领域区块链典型场景有哪些？ 区块链的去中心化特点，意味无须经过任何第三方的共享经济成为可能，比如无须经过Uber、Airbnb就可以实现点对点的汽车共享、房屋共享等。以色列创业公司La’Zooz想成为一个“反UBER”，它使用自己的专有的数字货币，类似比特币，使用区块链数字化技术记录货币。人们可以不再使用一个集中的网络出租车叫车服务，人们用La’Zooz找到其他人的旅行路线，并通过交换数字货币来进行搭车。有些数字货币将可以在未来搭车的交易中使用。用户挣取或挖掘这些数字货币的过程可让这个APP跟踪他们的位置。 作者：吴洋的简书链接：https://www.jianshu.com/p/96d3cf8a0cc7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2021/03/19/%E8%AE%BA%E6%96%87-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%BA%AF%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%9D%E8%80%83/"},{"title":"日常编程心得","text":"2022年2022年6月 对于$O(N^2)$问题的优化,一般有以下几个思路 固定一边,去寻找另一边 二分 dp / 前缀和差分 滑动窗口 固定一边,不去寻找另一边,而是看元素自身有什么特征,需要的另一半必须有什么特征 然后使用hash,空间换时间 2022年4月 单调栈和单调队列的最核心的用处是：只保留有用的数据 我做题的几种常见思路 模拟 贪心 二分 搜索 dp 双指针(滑动窗口) 数据结构：堆、双向链表、哈希表 转化：未知转换成已知 写题要熟练运用各种数据结构，及其互相的组合包括： 堆（优先级队列） 双向链表（擅长处理要处理的问题带有顺序的情况） 哈希 栈 队列 双指针在链表中可以实现两指针间固定距离移动（滑动窗口） 可用于，求链表中倒数第k个节点 2022年3月 简单方法实现向上取整 (x+k-1)/k 简单方法实现四舍五入保留小数，例如保留两位小数double x; (x*100+0.5)/100 printf的保留小数策略是四舍六入五成双，具体规则为： 小于5则舍去 大于5则进1 如果是5的话 若后边一位有数字时则1 若后边是0，则 5前边一位是奇数，则进1 5前边一位是偶数，则舍去5 2021年2021年8月 1个字节8位二进制下，最小值-128的二进制是1000 0000这是人为规定的，-1的二进制是1111 1111。想一下为什么是这两个形式，因为-127=-128+1是1000 0001，-126是-128+21000 0010，那么-1就是-128+127=1111 1111。 最短路径，通常用BFS来解决。单源最短路径使用djikstra算法。任意两点间最短路径使用floyd算法。 向上取整除法:$\\frac{N-1}{M}+1$，非常巧妙 红黑树（自平衡二叉查找树）能实现增删查logN的时间复杂度 其中查是使用AVL树的二分查找 如果遇到一个场景，既需要logN时间复杂度（二分）的查找，又需要LogN时间复杂的插入，则应该考虑底层是红黑树的数据结构。C++中set, map。Java中TreeSet，TreeMap。 C++lower_bound()和set.lower_bound()和map.lower_bound()查找有序序列中第一个大于等于目标值的元素的第一个元素的迭代器。 如果返回值==set.begin()说明所有元素均$\\geq$目标值 如果返回值==set.end()说明所有元素均$&lt;$目标值 set.lower_bound()效率比lower_bound(set.begin(),set.end()效率高！ 是否能使用递归取决于，子问题的最优解的叠加是否等于父问题的最优解。在316去除重复字母这一题中，我尝试使用递归解法，最后发现结果错误。原因就是，这一题中每一步达到最优解，最终结果不一定是最优解。 算法中一个很重要的思想就是：逆向思维。有时候正向思考得不出答案，就需要猜测能否逆向来完成。 「使……最大值尽可能小」是二分搜索题目常见的问法 将一个数变为其相反数，只需要i=~i+1，因为计算机底层是用补码来存储数据。（原码和补码相互转换是除了符号位以外，按位取反，然后+1，那么计算机中的一个数的相反数，即所有位按位取反，然后+1即可）2021-7-27 今天刷题发现一个问题，同一题下，vector预先申请了长度，能够顺利AC，但是如果不预先申请，而是不停的insert，则会严重超时。 对于循环数组问题，通常可以用数组长度翻倍来解决，即复制原来的数组，然后接到原来的数组后边。2021-7-19 全手工实现LRU（Least Recently Used）算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;struct Node { int key, val; Node *pre, *next; Node() : pre(NULL), next(NULL) {} Node(int k, int v) : key(k), val(v) {}};class DoubleList {public: //构造 DoubleList() { head = new Node(0, 0); tail = new Node(0, 0); head-&gt;next = tail; tail-&gt;pre = head; size = 0; } //在链表尾部添加元素，时间复杂度O（1） void addLast(Node *x) { tail-&gt;pre-&gt;next = x; x-&gt;pre = tail-&gt;pre; x-&gt;next = tail; tail-&gt;pre = x; size++; } //删除链表中的x节点（该节点一定存在）节点指针（地址）由哈希表给出 void remove(Node *x) { x-&gt;pre-&gt;next = x-&gt;next; x-&gt;next-&gt;pre = x-&gt;pre; //free(x); 此处不能free，因为挪动节点到开头需要用到此函数 size--; } //删除链表中的第一个节点，并返回该节点，时间O（1） Node *removeFirst() { if (head-&gt;next == tail) return NULL; Node *first = head-&gt;next; head-&gt;next = first-&gt;next; head-&gt;next-&gt;pre = head; size--; return first; } int getSize() { return size; } //按照LRU顺序，展示所有键值，用于测试 void show(){ Node*p=tail; while(p-&gt;pre!=head){ cout&lt;&lt;p-&gt;pre-&gt;key&lt;&lt;&quot;:&quot;&lt;&lt;p-&gt;pre-&gt;val&lt;&lt;&quot; &quot;; p=p-&gt;pre; } }private: //头尾虚节点 Node *head, *tail; //链表元素个数 int size;};class LRUCache {public: //构造：提供最大容量 LRUCache(int capacity) { this-&gt;capacity = capacity; } //获取某键的缓存值 int get(int key) { //没有该键的缓存值 if (Map.find(key) == Map.end()) { return -1; } //将该键提升为最近使用的键 makeRencent(key); return Map[key]-&gt;val; } //存放某键的缓存值 void put(int key, int val) { //缓存键已存在，则更新键值 if (Map.find(key) != Map.end()) { deleteKey(key); addRencent(key, val); return; } //如果已满，则淘汰最近最少使用的缓存 if (cache.getSize() == capacity) { removeLeastRecently(); } //添加为最近使用的元素 addRencent(key, val); } //测试用，按LRU顺序展示缓存中所有内容 void show(){ cache.show(); cout&lt;&lt;endl; } //将某个key提升为最近使用的 void makeRencent(int key) { Node *x = Map[key]; cache.remove(x); cache.addLast(x); } //添加最近使用的元素 void addRencent(int key, int val) { Node *x = new Node(key, val); Map[key] = x; cache.addLast(x); } //删除某个key void deleteKey(int key) { Node *x = Map[key]; cache.remove(x); Map.erase(key); free(x); } /*删除最久未使用元素*/ void removeLeastRecently() { Node *target = cache.removeFirst(); int key = target-&gt;val; //这就是为什么双向链表中节点要存储key，是为了删除的时候，反向查找在map中的位置并删除 Map.erase(key); free(target); }private: //哈希表 map&lt;int, Node *&gt; Map; DoubleList cache; int capacity;};int main() { LRUCache lru(4); while(1){ string op; cin&gt;&gt;op; if(op==&quot;get&quot;){ int key; cin&gt;&gt;key; int res=lru.get(key); if(res==-1){ cout&lt;&lt;&quot;Not exist!&quot;&lt;&lt;endl; continue; } cout&lt;&lt;key&lt;&lt;&quot;:&quot;&lt;&lt;res&lt;&lt;endl; lru.show(); }else if(op==&quot;put&quot;){ int key,val; cin&gt;&gt;key&gt;&gt;val; lru.put(key,val); lru.show(); }else{ cout&lt;&lt;&quot;wrong command!&quot;&lt;&lt;endl; continue; } }} 2021-7-18 并查集Union-find算法，主要解决的是图论中的动态连通性 并查集数组实现（路径压缩）1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;#define MAXN 10int fa[MAXN+1];void init(){ for(int i=1;i&lt;=MAXN;i++) fa[i]=i;}//返回当前节点的根节点，并进行路径压缩int find(int x){ if(fa[x]==x) return x; fa[x]=find(fa[x]); return fa[x];}//合并两个节点，注意在同一棵树上的问题void merge(int a,int b){ fa[find(a)]=find(b);} 按秩合并优化版：路径压缩版本只能在find的时候实现，因此合并过程中，还是会出现很复杂的树。为了避免树过深，可以选择按秩合并（即高度低的树，合并到高度高的树上，来避免树高度的增长，当然两棵树高度相同的情况下，合并后必然有一棵树高度会+1）1234567891011121314151617181920212223242526272829int parent[N]; //记录每个节点的直接父节点int Rank[N]; //以i节点为祖宗的树的高度(的上限)，初始为1/*为什么说是上限，因为路径压缩之后，其并不是准确的树高 * 但其仍然有意义，因为不会出现a比b树高，但是rank[a]&lt;Rank[b]的情况*//*找到祖宗节点,并进行路径压缩*/int findParent(int k) { if (parent[k] == k) return k; parent[k] = findParent(parent[k]); return parent[k];}/*将两个节点合并到一个集合中，并优化*/void merge(int a, int b) { int pa = findParent(a); //根结点 int pb = findParent(b); //根结点 if (pa == pb) return; /*按照树高决定连接方式，可以优化搜索路径*/ if (Rank[pa] &gt; Rank[pb]) { parent[pb] = pa; } else { parent[pa] = pb; if (Rank[pa] == Rank[pb]) Rank[pb]++; }} 2021-7-17 今天做一道leetcode题目1373二叉搜索子树的最大键值和 我花了两个小时的时间，研究怎么在一个非BST的子树中，找出最大BST键值和，费了老劲。最后发现题解中，只需要用一个flagMAX记录一下最大值即可啊！！！气。 还吸取了一个教训，找BST的时候，空节点直接视为一棵空BST，有时更为简单。 关于判断BST合法性这个问题，有三种思路 利用BST中序遍历有序这个性质，先对该树进行中序遍历，再判断是否是升序即可。 对于树的操作应该着眼于当前节点，根据BST的定义，当前节点的值应该大于所有左子树节点的值（大于左子树最大值），且小于所有右子树节点的值（ 小于右子树最小值）。据此可以写出递归函数，不过要在空节点的返回值上要加以设计。 本题还可以为为每个节点设置阈值（上限和下限），通过递归传递和更新阈值。（此方法把节点之间缠绕在一起，单独做此题目容易，如果BST和其他问题结合，则不好处理）1234567891011121314class Solution {public: bool isValidBST(TreeNode* root) { return checkBST(root,LONG_LONG_MIN,LONG_LONG_MAX); } bool checkBST(TreeNode*root,long long low,long long high){ if(!root) return true; if(root-&gt;val&lt;=low || root-&gt;val&gt;=high) return false; return checkBST(root-&gt;left,low,root-&gt;val) &amp;&amp; checkBST(root-&gt;right,root-&gt;val,high); }}; 1234567891011121314151617181920class Solution {public://树的递归中，以当前节点为思考对象，最佳 bool isValidBST(TreeNode* root) { return checkBST(root)[0]; } //三个返回值：1.是否是BST 2.最小值 3. 最大值 vector&lt;long long&gt;checkBST(TreeNode*root){ if(!root) return {1,LONG_LONG_MAX,LONG_LONG_MIN}; vector&lt;long long&gt;l_res=checkBST(root-&gt;left); vector&lt;long long&gt;r_res=checkBST(root-&gt;right); if(l_res[0] &amp;&amp; r_res[0] &amp;&amp; root-&gt;val&gt;l_res[2] &amp;&amp; root-&gt;val&lt;r_res[1]){ long long l_min=l_res[1]; long long r_max=r_res[2]; return {1,l_min!=LONG_LONG_MAX?l_min:root-&gt;val,r_max!=LONG_LONG_MIN?r_max:root-&gt;val}; } return {0,0,0}; }}; 2021-7-16 昨天会写的二叉树的序列化，今天再去想这个问题，竟然不会写。发现自己还是没有完全领悟二叉树和递归的思维。二叉树中递归的思维，应该着眼于根节点，处理好一个节点的行为，递归下去便完成了对整棵树的操作。 考虑二叉树序列化这个问题，对于以root为根节点的二叉树来说，先得直到左子树和右子树的序列化内容，才能返回左子树序列化+根节点val字符串+右子树序列化，因此要使用后序遍历 需要先直到子树内容，才能知道当前树内容的，通通用后续遍历。12345678910111213141516171819202122232425//用**后序遍历**的方式，实现二叉树**前序的序列化** string serializeTree(TreeNode*root){ //终止条件 if(!root) return &quot;&quot;; //逻辑 string ans=intToStr(root-&gt;val); string lStr=serializeTree(root-&gt;left); string rStr=serializeTree(root-&gt;right); if(lStr!=&quot;&quot;){ ans+=','+lStr; } if(rStr!=&quot;&quot;){ ans+=','+rStr; } return ans; } string intToStr(int n){ string s; stringstream ss; ss&lt;&lt;n; ss&gt;&gt;s; ss.clear(); return s; } 今天对补码有了全新的认识其中1000 0000 是规定的最小值，然后简单+1就是-127，可以一直简单+1到127补码的好处就是让如1-2的运算，变成硬件最简单操作的相加运算1-2=0000 0001+1111 1110=1111 1111=-1 C++中如何获取int型的最大值和最小值 方法一：头文件climits中有INT_MAX,INT_MIN 方法二： 最小值：1&lt;&lt;31，即1000 0000...0000，补码规定的负数的最小值,$-2^{31}-1$ 最大值：unsigned int a=0; ~a&gt;&gt;1即为0111 1111...1111，$2^{31}$2021-7-15 二叉搜索树BST 判断一棵树是否是BST：需要借助两个变量记录每个节点应该遵循的上限和下限，然后递归即可 增加节点：递归找到位置（NULL），然后接在上面即可。 删除节点： 第五种情况，操作如下： 第一步 第二步 第三步 第四步 2021-7-14 二叉搜索树（BST，Binary Search Tree)是递归定义的 BST为空，或者 对于二叉搜索树的每一个节点root，左子树所有节点得值小于root值，右子树所有节点的值大于root值 对于BST的每一个节点，它的左子树和右子树都是BST 没有键值相等的结点 二叉搜索树的重要性质：中序遍历是有序的 二叉树的各种递归，无非是：1.前序遍历 2.中序遍历 3.后序遍历 二叉树的序列化，使用后序遍历（注意要以#处理叶节点的子节点） 对于二叉树的递归构造，应该想方设法构造根节点，只要根节点构造出来了，其他所有节点根据递归就全部都构造出来了。2021-7-13 快慢指针、双指针、多指针，在链式结构中是十分重要的思想。 ”链表是一种兼具迭代性质和递归性质的数据结构”，很有道理。 今天做反转链表这道题目，迭代和递归方法都非常精妙，其中博主labuladong对递归的思考方式令我印象深刻，受益匪浅。 Leetcode206 反转链表 “不要跳进递归（你的脑袋能压几个栈呀？）”，博主如是说 下面这一步十分精妙 - 我认为，实现递归的代码，不应该跳进递归的轮回中，应该**假装递归方法已经实现**，直接调用，然后补其具体递归逻辑。 - 此外，递归最为重要的就是，**递归函数的含义**。 ## 2021/7/11 对于递归函数来说，最重要的就是递归函数的含义。 写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。2021/6/3 做dp的题目，首先要搞清楚状态转移方程，然后应该举个小例子草稿实现一下dp，以使对边界条件有个清晰的认识。 关于字符串的dp，经常把dp[i]定义成以i位置字符结尾的串的个数2021/6/2 遇到问题类似最少多步、最少多少次这类问题，一定要想到用bfs或者最短路径算法 蓝桥杯国赛比赛之前默念：搜索、位运算、全排列、数学问题 当设计递归函数遇到困难，搞不清楚时，举个例子模拟一下过程就好了。 当算法中出现大量重复问题的时候，可以采用记录的方法，可以大大降低时间复杂度2021/6/1 感悟：今天重做蓝桥杯题目对局匹配的时候，更加深刻地明白了两个道理 懂和会写，是完全两件事，明白怎么写不等于能写出通过oj的代码 编程不能闭门造车，要吸收别人优秀的代码和思想。 遇到统计方案数的题目，一定要注意重复问题 dfs有爆栈的风险，可以用bfs来替代 对于图的相关问题如发现环，或者排序，首先要想到拓扑排序2021/5/31 无向图的生成树（使用尽可能少的边将所有顶点连在一起） 包含所有顶点 任意两顶点之间有边构成唯一路径 百度百科定义：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边 书上定义：极小连通子图为某一顶点子集所确定的连通子图中包含边最少的连通子图（n个顶点，无向连通图最少n-1条边，有向连通图最少n条边——成环）。图全部顶点所确定的极小连通子图即为连通图的生成树。即包含所有顶点的极小联通子图就是生成树。 在代码中实现，用并查集保持无环，且包含了所有节点即可。 蓝桥杯国赛凑平方数这题太经典了，将解题过程加以记录 涉及到dfs的优化、状态压缩、位运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;typedef long long ll;using namespace std;vector&lt;int&gt; state; //11001中1表示消耗了数字int len; //合法平方数个数void init() { for (ll i = 0; i * i &lt;= 9876543210l; i++) { ll tmp = i * i; int st = 0; if (tmp == 0) { st = 1; state.push_back(st); continue; } bool flag = true; while (tmp) { int t = tmp % 10; tmp /= 10; if (st &amp; (1 &lt;&lt; t)) { //存在1冲突 flag = false; break; } else st |= (1 &lt;&lt; t); } if (flag) { state.push_back(st); } } len = state.size();}//判断当前剩余数字能否实现numbool check(int st, int numSt) { return !(st &amp; numSt);}ll ans = 0;//在下标k~len-1范围内，找第一个合法的平方数void f(int k, int st) { //st 0表示可用 if(st==(1&lt;&lt;10)-1){ //0~9都是1 ans++; return; } for (int i = k; i &lt; len; i++) { if (check(st, state[i])) { f(i + 1, st | state[i]); } }}int main() { //将范围内的平方数都找出来，将其消耗的数字的信息，存入state中 init(); //递归 f(0, 0); cout &lt;&lt; ans; return 0;} 自己用递归实现全排列的好处在于，可以进行剪枝 今天发现了一个一直以来没发现的大问题：BFS找最短路径的时候，不用每个节点单独记录路径 所有节点共享一个set就行了，因为如果某个节点下一步走已经在集体公用set中的节点，则你这个节点必然已经落后了。2021/5/30 今天写蓝桥杯国赛真题遇到2020十一届C++B组H题答疑这一题 作为B组倒数第二题，JavaC组最后一题，竟然经过一定的数学推导，代码比填空题第一题还简单。 看到一个对前缀和、树状数组、线段树的总结，写的不错 视频链接 最长递增子序列这道经典的算法题，用动态规划解法的时间复杂度是$O(n^2)$ 使用一个队列，每轮不断优化其元素，使每个元素达到尽可能小（给后续递增留出最大的空间），其时间复杂度可达$O(n\\log{n})$ (需要用到二分来查找插入位置，lower_bound()可以实现） 这样只能算出来LIS的长度，最后的结果不一定是LIS 因为往前替换元素，违背了子序列顺序的定义，这种方法只能求出来LIS的长度，不能用于求解LIS本身。 2021/5/29 求数组中第K大的数字，可以使用基于快速排序的选择算法，降低时间复杂度 快速排序中，每一轮确定一个元素的最终位置，即它是第几大元素（从大到小） 如果该元素的下标是我所求的第K大，则直接返回该元素 否则根据情况向左、向右分治2021/5/26 将无穷大这个值设置为0x3f3f3f3f的好处和1e9+7一样，量级在10^9，一般数字都小于它，可以用于无穷大。并且两个0x3f3f3f3f相加，不会超出4字节32位int的表示范围。此外，用memset进行初始化的时候，可以直接写成memset(arr,0x3f,sizeof arr)，非常方便 唯一分解定理，算数基本定理：一个正数，如果是合数，则可以唯一分解为多个质数的乘积 注意在做方格题目的时候，如果是边7*7的矩形，则边上的点是8*8的 2021/5/25 再次反省，做题一定要考虑两件事 数据范围（long long，时间复杂度） 特殊情况（边界条件） dijkstra算法和floyd算法的区别是 floyd代码简单，时间复杂度O(N^3) dijkstra代码复杂，时间复杂度低 kruskal算法和prim算法的区别 prim基于节点 适用于点少，边多的稠密图 kruskal算法基于边 适用于点多，边少的稀疏图 2021/5/24 今天写蓝桥杯国赛搭积木这一题 发现递归中，如果把一切问题都丢给下一层去解决，会造成栈溢出（虽然下一层第一步就返回了记忆化的结果） 将记忆化存储中已经有的答案直接返回， 减少不必要的递归，似乎能够很好地提高效率 但是平时写递归的时候，还是建议本层只处理本层的问题。 存在大量相同子问题的问题 动态规划 记忆化搜索 记忆化递归（也可以理解为一种搜索） 不是所有都适合动态规划，比如蓝桥杯国赛搭积木这一题，记忆化递归是最优方案 蓝桥杯遇到不会的题就想 贪心 模拟 搜索 dp 状态压缩 二分、分治 图论 数论：gcd，最小公倍数，余数，差分，前缀和 全排列 什么时候用BFS，什么时候用迪杰斯特拉\\弗洛伊德？ BFS：当任意两节点之间的距离是某些特定值，如蓝桥杯国赛调手表那题，只能是1和k。 距离不固定： 迪杰斯特拉：复杂度低,O(N) 佛洛依德：复杂度高，三重循环O（N^3） 算法思想：如果a到c+c到b，比a到b近，则用c这条路替换 遇到题目，先想常规方法（如最优解，通常用BFS），再想特殊方法（如前缀和，dp，状态压缩，数学） 常规方法中，可以先想暴力法，再进行复杂度的优化。 2021/5/22 取余同余、前缀和、差分，这些都是重要的解题手段 动态规划其降低复杂度的原因在于，减少重复计算 所以如果写出来的dp转移方程，dp[i]需要与前i-1项分别发生作用，那么就失去了动态规划的作用 2021/5/21 再一次发现逆向思维的重要性 在平方数那个问题中，如果直接遍历1、2、3..，然后判断i是否是平方数，则复杂度是O(n2），但是如果直接遍历平方数，即12,22,32..，则时间复杂度为O(n) 在贴瓷砖那题中，因为每个瓷砖是两个方块，如果枚举墙面每块的所有可能性再进行check，会发现非常难以进行检查。但是如果贴瓷砖的时候就按照两个两个进行贴，那么问题就非常简单了！ 人的思维是很容易有漏洞的！不要想当然，多写写画画！ 在做蓝桥杯国赛贴瓷砖那题，我理所当然认为，既然是从左上往右下贴，那么当前位置的下方和右方一定没有被访问过，但其实是有可能被访问过的，画个图就发现了。 对于二维数组，要想直接用指针+相对位置来访问某个元素 *(*arr+100) 这样才行 因为arr自身是二维指针2021/5/20 不要把邻接表的含义搞错了！它仅能表示一个节点和哪些节点相连，其链式结构不能等同于图中的先后顺序！ 邻接表中要删除一条边，不能直接将一条链中某个节点的next置为NULL，会导致该链上后续的节点也被遗弃！ 2021/5/19 在图中查找回路，采用拓扑排序的思想 对于有向图，每轮消掉所有入度为0的节点，最后剩下的就是回路 对于无向图，每轮消掉度数为1的节点，最后剩下来的就是回路 BFS中需要使用set记录的path，来防止自己走回头路 今天在实现邻接表的时候发现一个大坑： 将指针a的指向赋给指针b，则两者指向的内容相同（a和b的存储单元中存储的地址值相同） 这时候如果修改b的指向（修改b存储单元地址值）是不影响a的指向的！ 比赛遇到不会的，就考虑最朴素的暴力 图的表示有两种方法 邻接表（在面对大规模数据的时候，节省存储空间） 邻接矩阵 2021/5/18 状态压缩可用的地方很多，不止是状态压缩dp 前缀和前缀和，遇事不决前缀和 逆向思维非常重要 状态压缩中的，二进制状态，别忘了是用int表示的，前面还有很多位！！ 你以为的11011状态，其实是0000...0011011共32位 使用二进制串表示状态时，如果不方便进行状态调整，可以将0和1的意思反过来，也许就方便了。 2021/5/17 数据规模往往决定着该题用什么算法 注意，树状数组的下标，一定要从1开始，否则lowbit操作和树状数组的逻辑不匹配 一个非负数，取二进制最低位的1和后边的0，即lowbit操作 lowbit(a)=a &amp;(~a+1)=a &amp; (-a) 因为计算机中数字是以补码形式存放，负数的补码就是原码（除符号位）按位取反然后加一 那么一个正数取相反数的操作就是 符号位取反 （除符号位）按位取反，然后加一 这两步组合在一起就是，所有位按位取反，然后加一，故~a +1=-a Docker docker的特点 互相隔离 快速装载和卸载 规格标准化 docker和虚拟机的根本区别：容器技术只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统，这里的运行时环境指的是程序运行依赖的各种库以及配置。 蓝桥杯遇到题目不会写，想一下是否是考察以下知识点 差分、前缀和 dp、状态压缩dp 并查集 贪心 搜索 二分 数论 减少时间复杂度的方法 减少循环 使用哈希 二分 提前保存结果并利用 2021/5/15 差分和前缀和是对立统一的存在。 学到了，自建博客，解决图片问题，用外链图床就行了！ 2021/5/14 在二维空间中，向量外积的一个几何意义就是：|a×b|在数值上等于由向量a和向量b构成的平行四边形的面积 $S_\\Delta=|\\frac 1 2\\cdot \\vec{a}\\times\\vec{b}|=|(x_1\\cdot{y_2}-x_2\\cdot{y_1})|$ 已知三角形顶点坐标求面积 使用海伦公式p=(a+b+c)/2; S=sqrt(p(p-a)(p-b)(p-c) ) 对于一个（正方形）二维数组的下标来说 区分主对角线两边元素的方法是： 若看y-x大于0，则在主对角线以上 区分副对角线两边元素的方法是： 若x+y&lt;行数-1，则在副对角线以上 并查集判环的方法是 加入当前边之前，两个顶点如果已经在一个集合中了，那么加入该边后一定形成环 2021/5/13 拓扑排序 使用BFS广度优先遍历实现比较好 将所有入度为0的（从未入过队的）节点加入队列 不断取出队列中的节点，放入结果集末尾，并将其直接子节点的入度减一 重复步骤1和步骤2，直到队列为空 其核心思想是，每次将入度为0的节点加入结果集尾部，并且将该节点的直接子节点的入度减一 注意：如果存在环，则无法将环中节点加入结果集 一个常见的BUG是，把变量含义弄错，尤其是i和arr[i] 解决二分图问题，使用染色法 广度优先搜索进行染色 使用lower_bound和upper_bound找到一个结果时，要想得到其下标，只需要用迭代器减去arr.begin()即可 lower_bound和upper_bound是基于二分的，也就意味着序列需要是从小到大排序好的 排序是重要算法思想 数学技巧：如果c位于a和b之间，那么c到a的距离+c到b的距离，是一个固定值，为(b-a); 在一些累积性的问题中，前缀和是非常有效的解题思路。 写代码前 理清思路，并且优化思路 关注数据大小，关注边界条件 然后开始编码 蓄水池抽样算法（又叫水库采样算法） 适用于总数未知的随机抽样 在对一个链表（长度未知）进行随机采样的时候，遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点作为结果，并且覆盖掉之前的结果。12345678910111213141516171819202122232425class Solution {public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ ListNode*myList; Solution(ListNode* head) { myList=head; srand((unsigned int)time(NULL)); } /** Returns a random node's value. */ int getRandom() { int ans=myList-&gt;val; //初始选中第一个节点 ListNode*node=myList-&gt;next; int i=2; while(node){ if(rand()%i==0){ //1/i的概率选中当前的节点 ans=node-&gt;val; //覆盖掉之前的选择 } i++; node=node-&gt;next; } return ans; }}; 写算法时，首先关注数据大小和边界条件 战术上的勤奋并不能弥补战略上的懒惰 方向错了，怎么努力也没有用 Fisher-Yates洗牌算法 原理：通过随机交换位置来实现随机打乱，有正向和反向两种写法 反向洗牌比较好记，反向，并且只和序号小于等于自己的交换123456789//反向洗牌for (int i = n - 1; i &gt;= 0; --i) {swap(shuffled[i], shuffled[rand() % (i + 1)]);} //正向洗牌： for (int i = 0; i &lt; n; ++i) { int pos = rand() % (n - i); swap(shuffled[i], shuffled[i+pos]); } C++的rand()随机数是伪随机数，每次打印rand()是打印特定种子下的小M多项式序列的每一项 如果随机种子不变，那么每次执行程序，打印出来的一组随机数都与之前一组相同 并且该序列的周期是65535 头文件&lt;cstdlib&gt; 2021/5/12 找出int范围内3^x的最大值，x为整数 1234567891011int findLargest3Power(){ int x=3; while(1){ int next=3*x; //发生溢出时返回x if(next/3!=x){ return x; } x=next; }} 判断一个数能否被开方 使用逆向思维！12345//判断a能是否能被开方bool canBeExtract(int a){ int res=sqrt(a); return a==b*b;} C++判断一个浮点数小数部分是否为0 使用C++的浮点数取模函数fmod(double , double) fmod(a,1)==0 今日教训：写题目一定要草稿纸勾勾画画，不要想当然。 今天遇到一道很有意思的题目 开始采用的是返回min(2的数量，5的数量），后来题解中说因子5的数量远远小于因子2的数量，所以答案就是5的数量。 写算法三大注意事项 关注数据大小和数据量 估算算法时空复杂度 注意边界条件 算数基本定理：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积 也可以表述为：任何一个合数都可以分解为质数的乘积。（1既不是素数（质数），也不是合数） 这里的唯一指的是，分解结果不看顺序的话，如3,4,5和5,4,3是一样的分解。 质数的定义：在大于1的自然数中，除了1和它本身以外，不再有其他因数的自然数。（只能被1和自身整除的大于1的自然数） 自然数肯定包括0，否则应该叫正数才对。 拓展欧几里得算法 用于计算xa+yb=gcd(a,b); 根据定理此式必有解 使用的时候，预先定义变量x和y，最后结果在存在x和y中 12345678910int extGcd(int a, int b, int &amp;x, int &amp;y) { int gcd = a; if (!b) { x = 1, y = 0; } else { gcd = extGcd(b, a % b, y, x); y -= (a / b) * x; } return gcd;} 2021/5/11 写一道算法题，开始写代码之前要做的事 理清思路，搭好框架 估计所用方法的时间空间复杂度，对于题目中数据量 关注题中的数据大小 关注边界条件 今天刷到洛谷上一道题，觉得很有启发性。这一题要记录两行的状态，才比较方便解决问题 逻辑运算中，今天遇到一个大坑 一道状态压缩题目，炮兵攻击距离是3，也就是三排之间不能在一列 这时候判断三排的所有士兵不能在一列 正确写法return !(st1 &amp; st2) &amp;&amp; !(st1 &amp; st3) &amp;&amp; !(st2 &amp; st3) 错误写法return !(st1 &amp; st2 &amp; st3); 使用递归输出一个十进制数的二进制形式 123456void printBinary(int num) { if(!num) return; printBinary(num&gt;&gt;1); cout&lt;&lt;(num&amp;1);} C++scanf输入数字之后，如果要输入别的类型（如字符，字符串）一定要吸收换行符！(getchar()) 做动态规划的题目，应该先理清思路，最好写出状态转移方程 如果输入的是一个二进制数如1101，如何存储为十进制？ int t=0;每次读取一个字符c，然后t&lt;&lt;=1;t+=c;即可 动态规划的问题要倒过来思考，正过来写代码 思想上是用后边的状态倒推前边的，但是写代码的时候要现有前边的状态才能求出后边的状态 2021/5/9 编程比赛中，该写cstdio头文件，还是要写，只有iostream的话，printf和scanf有可能会报错 &amp;的优先级比+低！！ 使用与或非的时候，一定要加括号！ 取INF时用1e9+7是不错的选择 两个数相加不爆int 两个数相乘不爆long long 对于TSP问题中需要回到出发点的问题，不要在状压dp中加以考虑，全部状态计算完之后，再单独处理，加上最后访问点到原点的距离即可。 计算最短路径的两种经典算法（图片截图自B站up主WAY_zhong的讲解视频） 迪杰斯特拉Dijkstra算法基于贪心 贪心：计算出每个节点到原点的最短距离，直到计算到des节点 佛洛依德Floyd算法基于动态规划 核心思想：如果f(a,c)+f(c,d)&lt;f(a,d) 则更新f(a,d)=f(a,c)+f(c,d)，如果需要路径的话将d的前驱记录为c即可 右边的二维表记录（有向图）某个节点最短路径上前一个节点。如果只需要计算最短路径长度，则不需要右边的二维表。 代码十分简洁，三重循环，选出src、des、mid节点即可。 有向图floyd 12345678910 void floyd() { for (int i = 0; i &lt; N; i++) //src for (int j = 0; j &lt; N; j++) //des for (int k = 0; k &lt; N; k++) { //mid if (i == j || i == k || j == k) continue; if (dist[i][j] &gt; dist[i][k] + dist[k][j]) dist[i][j] = dist[i][k] + dist[k][j]; }}无向图floyd 1234567for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) for(int k=0;k&lt;n;k++) //基于无向图的优化 if(dist[i][k]+dist[k][j]&lt;dist[i][j]){ dist[i][j]=dist[i][k]+dist[k][j]; dist[j][i]=dist[i][j]; } 2021/5/8 处理股票买卖的动态规划问题时，有时建立hold持有和unhold不持有两个dp数组会比buy和sell更好，因为对一支股票每天只有两种状态，持有或者不持有。 遇到复杂问题的编程，要把过程想清楚（最好画图），用注释搭好框架再写，如下边这题1234567891011121314151617181920212223class Solution {public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { int arr[2001]; fill(arr,arr+2001,0); arr[nums[0]+1000]++; arr[-nums[0]+1000]++; // 记录已经能表示的target for(int i=1;i&lt;nums.size();i++){ int N=nums[i]; int temp[2001]; fill(temp,temp+2001,0); for(int j=0;j&lt;2001;j++){ if(arr[j]&gt;0){ temp[j-N]+=arr[j]; temp[j+N]+=arr[j]; } } memcpy(arr,temp,2001*4); } return arr[target+1000]; }}; 对一些在顺序上左右为难的问题，不妨先进行排序！ 动态规划注意事项 注意人工增加项的初始化（尤其是多维dp的第一行第一列） 注意dp含义的设定与题目求解问题的关系（直接还是间接） 处理环形数组的办法是：丢弃第一个或者丢弃最后一个，最后取两种方案较优的那种 多个条件的动态规划，就像切几根香肠，把每一根（每个条件）都切成一片一片，然后来解决问题。2021/5/7 今天花了一个下午做一道hard动态规划题目，最大的感触是，一定要定义好dp的含义，从含义出发，找dp[i][j]和之前的dp的关系。其次就是，多状态问题（如股票买卖），最好将多种状态分开dp。同时，总结结果时也从必须根据dp的定义来返回。buy[i][j]表示，0~i天进行一共进行j次买入，能够获取的最大利润sell[i][j]表示，0~i天进行一共j次卖出，能够获取的最大利润 这里的一共j次的一共非常重要，意味着第i天可以进行买\\卖，也可以不买\\不卖 1234567891011121314151617181920class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { int d=prices.size(); //buy[i][j]表示，0~i天进行一共进行j次买入，能够获取的最大利润 vector&lt;vector&lt;int&gt; &gt;buy(d+1,vector&lt;int&gt;(k+1,INT_MIN)); //sell[i][j]表示，0~i天进行一共j次卖出，能够获取的最大利润 vector&lt;vector&lt;int&gt; &gt;sell(d+1,vector&lt;int&gt;(k+1,0)); for(int i=1;i&lt;d+1;i++){ int price=prices[i-1]; for(int j=1;j&lt;=k;j++){ //两种情况，在第i天买入股票，或者不买 buy[i][j]=max(buy[i-1][j],sell[i-1][j-1]-price); //两种情况，在第i天卖出股票，或者不卖 sell[i][j]=max(sell[i-1][j],buy[i][j]+price); } } return sell[d][k]; }}; dp一般有两种描述 一种是跨度，从0到i项一共xxx 一种是标度，第i项xxx2021/5/6 当有多个变化的条件时，从一个条件的变化出发，比较容易有思路 当没有低复杂度的算法时，从高复杂度的算法出发，然后进行优化 记录一道很棒的动态规划的题目，我对*的处理值得回味 1234567891011121314151617181920212223242526class Solution {public: bool isMatch(string s, string p) { int len1 = p.length(), len2 = s.length(); vector&lt;vector&lt;bool&gt; &gt; dp(len1 + 1, vector&lt;bool&gt;(len2 + 1, false)); dp[0][0] = true; for (int i = 1; i &lt; len1 + 1; i++) for (int j = 0; j &lt; len2 + 1; j++) { //第一列特殊处理 if (j == 0) { dp[i][j] = (p[i - 1] == '*' &amp;&amp; dp[i - 2][j]); continue; } //p串末尾是* if (p[i - 1] == '*') { //情形1：*表示0个前边的元素 //清醒2：*表示n(n&gt;0)个前边的元素 dp[i][j] = dp[i - 2][j] || ((p[i - 2] == s[j - 1] || p[i - 2] == '.') &amp;&amp; dp[i][j - 1]); continue; } //p串末尾不是* dp[i][j] = (p[i - 1] == s[j - 1] || p[i - 1] == '.') &amp;&amp; dp[i - 1][j - 1]; } return dp[len1][len2]; }}; 2021/5/5 leetcode这一题太经典了，记录下来1234567891011121314151617181920212223242526272829303132class Solution {public: //统计字符串中0和1的个数 void count(string &amp;str,int &amp;count0,int &amp;count1){ for(int i=0;i&lt;str.length();i++){ if(str[i]=='0') count0++; else count1++; } } int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int len=strs.size(); //dp[i][j]表示，有i个0和j个1的情况下最多容纳几个子集 vector&lt;vector&lt;int&gt; &gt;dp(m+1,vector&lt;int&gt;(n+1,0)); //每个字符串是压缩空间前的横坐标 for(int k=0;k&lt;strs.size();k++){ string &amp;str=strs[k]; int count0=0,count1=0; count(str,count0,count1); //01背包，后向遍历，防止重复使用本轮的字符串 for(int i=m;i&gt;=count0;i--){ //i&lt;count0,无法容纳该字符串，则dp[i][j]维持上一轮的数据 for(int j=n;j&gt;=count1;j--){ //分两种情况，一种选中这个字符串，一种不选中这个字符串 dp[i][j]=max(dp[i][j],1+dp[i-count0][j-count1]);//第一个dp[i][j]是上一轮的结果 } } } return dp[m][n]; }}; 0-1背包多为费用问题和一维费用问题本质是相同的，即通过假设占用部分（多维）容量，由于剩下的（多维）容量以前已经处理过了，所以可以进行动态规划。 0-1背包问题要点如下 不压缩空间：横坐标是要装的物品，纵坐标是背包容量 选中当前物品，则假设占用部分容量，看剩下部分容量之前如何处置的 不选中当前物品 压缩空间：后向遍历，以避免本轮物品的重复取用 对于多费用的01背包问题，其解题过程和普通的01背包问题相同（强烈建议使用空间压缩，注意后向遍历），其动态规划形式似下图: 普通01背包 普通01背包压缩空间多维费用01背包多维费用01背包压缩空间后 自认为我分析得很精妙的一题 我的思考，既然要求最长递增子序列，那么我就维护一个最长递增子序列，nums中从左到右每个元素都是用来优化这个维护着的序列的。 如何优化？答：尽可能地使维护序列中的每个元素最小。这样就为序列的增长提供了最充足的空间！ 使用lower_bound解决问题！（找到第一个大于等于key的数，返回其迭代器） 12345678910111213141516171819class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt;res; for(int i=0;i&lt;nums.size();i++){ int key=nums[i]; if(res.empty()){ res.push_back(key); continue; } if(key&gt;res[res.size()-1]) res.push_back(key); else{ *lower_bound(res.begin(),res.end(),key)=key; } } return res.size(); }}; 使用dp数组时，有时dp下标和所求事物的下标有差异（主要是0作首位还是1作首位），这时候重新定一个变量index记录所求事物下标，会让思路更清晰，如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int numDecodings(string s) { //dp[i]表示：0~i位置一共有多少种编码方法 int len=s.length(); vector&lt;int&gt;dp(len+1,0); //s的下标对应dp的1、2、3... //首个是0就无解 if(s[0]=='0') return 0; //排除长度为1的情况 if(len==1) return 1; //开始dp dp[0]=1,dp[1]=1; stringstream ss; int t; //i是dp的下标 for(int i=2;i&lt;len+1;i++){ //s的下标 int index=i-1; //独立算 if(s[index]!='0') dp[i]+=dp[i-1]; //和前边合并算 if(s[index-1]!='0'){ ss&lt;&lt;s.substr(index-1,2); ss&gt;&gt;t; ss.clear(); if(t&gt;=10 &amp;&amp; t&lt;=26) dp[i]+=dp[i-2]; } if(dp[i]==0) break; } return dp[len]; }}; 2021/5/4 写代码时，养成习惯：先理清思路，接着搭好框架（注释），最后再编码 在使用动态规划时，可以进一步思考是否可以空间优化。 重新写爬楼梯leetcode70这一题，想都没想直接用递归，结果测试用例给了个44，超出时间限制。 我的思维存在的漏洞：在有一个思路之后，并没有考虑时间复杂度和问题规模。 这一题如果使用递归的话，其复杂度是2^n，1s最多能容纳的n的规模约为27。 1s不同复杂度能处理的规模 n : 108 n^2 : 104 n^3 : 500以下 2^n : 27以下 logn : 2^(108) ⭐ 所以这一题应该使用动态规划求解，避免重复计算子问题的答案2021/4/17 多个选项中选多个的题目，计算合法方案数。这种题目可以利用全排列来写 六个里边选三个int arr[]={0,0,0,1,1,1,}; 消除尾一：x=x&amp;(x+1) 经典的二进制题目！ 10个数的全排列，时间复杂度为10! 最大公共子串和最大公共子序列在二维动态规划时，是不一样的 前者的状态转移是if(s1[i-1]==s2[i-1]) dp[i][j]=dp[i-1][j-1]+1; 后者需要分三种情况进行讨论。 背包问题的精髓在于：在递归或动态规划时，假设背包中已经装了xx的情况下，看剩下的容量怎么装。 2021/4/16 若a、b、c三者和的余数为K，a的余数为i，b的余数为j 则c的余数为(K-i+K-j)%K 即（i以外需要凑的余数+j以外需要凑的余数）对K取余 多重循环时间复杂度优化 减少层数 减少范围 能否二分 空间换时间 倍数问题大多跟余数有关！ 多个数的和是某个数的倍数，意味着，各个数的余数的和等于目标数； 动手编程之前，把问题想清楚，思路理清楚，每一步要做什么搞清楚，先注释，再编程。 对于多维数组的问题，可以转换成一维进行处理 如三维转一维1234int convert(int i,int j,int k){ int a=i-1,b=j-1,c=k-1; return a*row*column+b*column+c;} 2021/4/14 python的数不会溢出，因此比赛填空题有些可以用python来解决 取模与取余的区别在于 取余是向0方向舍入(fix函数） 取模是向负无穷方向舍入(floor函数） 如-7 mod 4= 1 （到-8不足1）， -7 %4 = -3 （到-4少了-3）2021/4/13 快速幂的精髓在于，将底数不断膨胀，幂不断缩小 递归写法 12345678910long long fastPow(long long base,int pow){ if(pow==0) return 1; if(pow==1) return base; if(pow%2==1){ return base*fastPow(base*base,pow/2); } return fastPow(base*base,pow/2);} 非递归位运算写法 123456789101112long long fastPow(long long base,int pow){ long long res=1; while(pow){ //处理奇数 if(pow&amp;1){ res*=base; } base*=base; pow&gt;&gt;=1; } return res;} 2021/4/12 凡是在一组值中，选出一部分，在一定规则下组合成一个目标值，就可以看作是背包问题 背包问题的精髓在于将目标值分解成0~n来逐个解决，每次选取数组中一个值时，对背包剩下的容量进行调整（一般是减少，也可能增加），装入背包后，剩余容量用已有的dp[j]来解决是背包问题能动态规划的核心原因。 2021/4/11 一些动态规划的问题，考虑将dp[i]是为，以i为结尾的xxx; 使用dp数组，首先要搞明白dp[i]代表什么含义，可以是题中的要求求解的量，也可以是中间结果。并思考，dp[i]和dp[i-1]（或者dp[i]和dp[0],dp[1]…dp[i-1]）有什么关系。 对于动态规划（或者其他问题）中的环形问题，可以采取分类的方法 选第一个且不选最后一个，求出最优解 选最后一个且不选第一个，求出最优解 有一部分动态规划问题的精髓在于，对每一种情况进行试探，从而找出最优解。（不是返回dp[len-1]就行了，而是max(dp[i]) ） 比如leetcode121题股票交易，这是一道easy题，但是我想了好久没做出来，为什么？因为对动态规划题目定势思维了，认为dp[i]存储的就是最终结果，其实它也可以是中间结果，或者是需要进一步处理的信息。 对这种题目，我们可以尝试在每一天卖出股票，从而找到最优的方案。 2021/4/10 动态问题一定要搞清楚对谁进行0~n的划分（如果coins问题是对金额进行划分），也有可能是多个变量进行划分（二维、三维dp，但也可压缩。 01背包问题为什么要倒序遍历（压缩的）dp数组 比如在leetcode474中，这样一个临时的二维dp 假如从左上角往右下角遍历，每次利用i，j位置之前的数据修改dp[i][i]，就会造成上一轮的临时数据已经被修改，后边的数据无法利用上一轮的临时数据了。而从右下角向左上角遍历，就不会出现这个问题。 01背包问题，动态规划的思路是：物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：选与不选2021/4/9 对于动态规划中的初始条件问题（尤其是二维dp)，可以额外写一个函数来处理，如下这个LCS最长公共子序列问题，使用safeReturn函数来处理第一行第一列的特殊情况：12345678910111213141516171819202122232425262728293031class Solution{public: int safeReturn(vector&lt;vector&lt;int&gt; &gt;&amp;dp,int x,int y) { if(x&lt;0 || y&lt;0) return 0; return dp[x][y]; } int longestCommonSubsequence(string text1, string text2) { int len1=text1.size(),len2=text2.size(); //dp[i][j]表示，text1前i个字符和text2前j个字符的LCS数 vector&lt;vector&lt;int&gt; &gt;dp(len1,vector&lt;int&gt;(len2,0)); for(int i=0; i&lt;len1; i++) for(int j=0; j&lt;len2; j++) { if(text1[i]==text2[j]) { dp[i][j]+=1; dp[i][j]+=safeReturn(dp,i-1,j-1); } else { dp[i][j]=max(safeReturn(dp,i-1,j),safeReturn(dp,i,j-1)); } } return dp[len1-1][len2-1]; }}; 对于动态规划问题，dp[i]记录的可以是中间结果，也可以是最终结果。如果记录的是中间结果，最后不能忘了遍历并返回最大值或最小值。2021/4/7 排列与组合 对于排列题，使用next_permutation或者自定义DFS+回溯的递归函数实现； 对于组合题，使用递归对每个位置采取选中和不选中两种方法。 使用DFS+回溯编写不重复的全排列，在for循环的交换中，可以使用set集合来避免重复 注意！使用之前，序列必须已经排好序！ 注意！内部交换时，仅仅让交换过来的数不等于自身，是远远不够的，因为可能多次交换过来同一个数，需要使用set才能完全去重。1234567891011121314151617void permutation(vector&lt;int&gt;&amp;nums,int k){ //在下一轮进行判断 if(k==nums.size()){ ans.push_back(nums); return; } set&lt;int&gt;record; for(int i=k;i&lt;nums.size();i++){ int target=nums[i]; if(record.find(target)!=record.end()){ continue; } record.insert(target); swap(nums[i],nums[k]); permutation(nums,k+1); swap(nums[i],nums[k]); } 2021/3/29 在递归中，有两种判断终止条件的写法 第一种，当前轮进行判断 第二种，下一轮进行判断 递归中，只有满足当前层条件才能进入下一层，如果能够进入最后一层的下一层（不存在的层），则说明满足了所有层的条件。故在每一层种只需要设置否定条件，能够进入下一层即代表满足条件。 排列数和组合数都可以用递归+回溯实现，其递归函数逻辑如下123456789101112//实现排列数，n个数全排列void f(int k){ if(k==n+1){ 生成一种排列; return; } for(int i=k;i&lt;=n;i++){ swap(nums[i], nums[k]); f(k+1); swap(nums[i], nums[k]); }} 1234567891011121314//实现组合数，从n个数种挑选m个void f(int k){ if(已选中的个数==m){ 生成一种组合; return; } if(k==n+1){ return; } 选中第k个数; f(k+1); 不选第k个数； f(k+2);} 2021/3/27 蓝桥杯只使用ANSI C/ANSI C++ 标准，不能使用C++11语法。具体则是在CodeBlocks中勾选 ISO1998标准。 2021/3/26 在处理一些带有棘手的边界问题和特殊情况的问题时，建议把它边界问题和特殊情况单独拿出来进行处理，不要总想着用一套通用的代码解决所有问题。 比如在写K-th Element问题 ，需要用到一个辅助函数，用来确定基准元素的最终位置的。其中对i和j下标溢出的问题单独做了处理，那么就不需要那么费神来写一套能够完美覆盖溢出情况的代码了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 题目描述：在一个未排序的数组中，找到第 k 大的数字class Solution {public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { int l = 0, r = nums.size() - 1, target = r - k + 1; while (1) { int p = fix(nums, l, r); if (p == target) break; if (target &lt; p) { r = p - 1; } else l = p + 1; } return nums[target]; } //找到l位置元素的最终index，并返回 int fix(vector&lt;int&gt; &amp;nums, int l, int r) { int i=l,j=r; while(1){ while(i&lt;=r &amp;&amp; nums[i]&lt;=nums[l]) i++; if(i==r+1){ swap(nums[l],nums[r]); return r; } while(j&gt;=l &amp;&amp; nums[j]&gt;=nums[l]) j--; if(j==l-1){ return l; } if(i&gt;j) break; swap(nums[i],nums[j]); } swap(nums[l],nums[j]); return j; }};int main() { vector&lt;int&gt; vec = {10, 5, 6, 0, 0, 1, 2}; cout &lt;&lt; Solution().findKthLargest(vec,3)&lt;&lt;endl; return 0;} 2021/3/24 K-th Element问题，使用改造的快速排序来解决，是最好的。 因为快速排序的本质是每次确定第i个位置的元素，那么只要确定第k个位置的元素就可以结束递归，实际并不关心是否 快速排序或类快速排序的算法，需要先打乱顺序，否则最坏情况下时间复杂度会达到O(n2)2021/3/22 选出数组中第K大的数 先从大到小排序，再选出第K个 时间复杂度更低的方法：使用选择排序或者快速排序的思想（每轮确定一个元素的最终位置 ）2021/3/20 牛顿迭代法求平方根（保留整数，如sqrt(8)=2)12345678910class Solution {public: int mySqrt(int x) { long long a=x; while(a*a&gt;x){ a=(a+x/a)/2; } return a; }}; 做题目时，一定要考虑边界情况和溢出的情况。 寻找最小或最合适的区间的问题，用滑动窗口解决最优。 ASCII码一共128个字符，因此统计一个字符串中每个字符出现的次数，可以使用int chars[128]。2021/3/18 C++11用nullptr代替了NULL表示空指针，因为NULL在某些情况下会产生歧义 int*a=NULL;判断a是否为NULL/nullptr可以用if(!a)表示a是NULL 写了篇Floyd判圈法的博文。2021/3/17 贪心的思想是，每次都选择局部最优的方案以达到全局最优。 对于有多种处理方式的情况，可以进行分类讨论再汇总 32位有符号int型的范围是-231~231-1 因为有1位要表示符号 0要占用正数一个位置，所以正整数范围是1~231-1 负数没有0的占位，所以负整数的范围是-231~-1 leetcode452题用最少量的箭引爆气球 最大的体会是：一定要多画图，考虑不同的情况 leetcode435题无重叠区间 使用贪心算法解决，核心是看区间末尾位置。贪心中，每次选择区间末尾位置最早的，就意味着为其他区间留下了最多的空间。 lambda表达式可以作为sort的参数（前提是C++11） 在leetcode135题分糖果中，要求两侧孩子胃口要是大于中间的孩子，必须分的糖果比中间孩子多，问最少要多少糖果。遇到两侧情况这种题目，可以从左到右贪心一次，再从右到左贪心一次。 注意从左往右遍历的时候，要不断利用已经更新的结果。 123456789101112131415161718class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { int size=ratings.size(); if(size&lt;2) return size; vector&lt;int&gt;num(size,1); for(int i=1;i&lt;size;i++){ if(ratings[i]&gt;ratings[i-1]) num[i]=num[i-1]+1; } for(int i=size-1;i&gt;0;i--){ if(ratings[i]&lt;ratings[i-1]) num[i-1]=max(num[i-1],num[i]+1); } return accumulate(num.begin(),num.end(),0); }}; ## 2021/1/4 快慢指针的精髓在于：快指针最终会追上慢指针，以证明链上有环存在 为什么判断质数的时候只需要验证[2,floor(n1/2)] 注意右边是闭区间中数是否能被n整除，因为大于n1/2的数不可能被n整除 找n以内的质数个数，更优的方法：筛质数 从2开始，每次将2的所有倍数做False标记，然后是3，将3的所有倍数做False标记…最终从2开始所有没有标记到的就是质数的合集 python同时变量两个序列，可以用用zip for a,b in zip(s1,s2): python中的空set初始化要用a=set() 非空则可以写成a=set([1,2,1]) 或者a={1,2,1} 其存储的是{1,2} Hash可以降低时间复杂度，通常由set集合和dict来实现 判断一个序列是否有重复元素，可以通过判断转变成set集合后，序列的长度是否发生变化 2021/1/11 关于数字的处理，尤其是关于2的幂次，可采用位运算 如判断一个数是否是2的幂，即看其二进制形式是否只有一个1 遇到一个复杂问题的时候，首先想能不能分解成多个子问题 快慢指针可以快速找到链表的中间节点 找最近公共祖先的方法就是，从头遍历，找到第一个分裂的点，即是最近公共祖先 在链表中可以通过指向某个节点（非末尾节点，且链表长度&gt;1）的指针，直接将这个节点删除 方法：将下一个节点的所有内容复制到这个节点即可。 2021/1/12 单线程完成尽可能多的任务（每个任务工作时长不同），每次选择最早结束的任务即可！ 对于等差数列求和，用求和公式速度更快 2021/1/13 子串不同于子序列，子串是连续的而子序列可以不连续 对于题目给定问题规模不那么大的时候，完全可以使用复杂度较高的暴力方法进行解题，如-字符串长度小于1000-，用O(n3)的算法也能够在规定时间内完成。 最长回文子串(-子串是连续的-)的解法 暴力枚举 中心枚举法 动态规划 字符串转数字，用Integer.parseInt() 2021/1/22 java自定义元组数据类型（不可变） 12345678class Tuple&lt;A,B&gt;{ public final A a; public final B b; public Tuple(A a,B b){ this.a=a; this.b=b; }} 2021/1/25 动态规划的思想 如果要解决规模为n的问题的最优解，每一步记录规模为1、2、3…n-1、n的问题的最优解，每一步都利用前面一项或者前面所有项的信息。 如三角形最小路径和一题中，记录三角形中对应每个节点的最小路径和，最终可获得最后一行的最小路径和。 java中截取字符串是消耗性能的，因此一般采取传递索引的方式来表示子串。 java中的== 对于基本数据类型byte,short,int,long,float,double,char,boolean，是比较其值 对于引用数据类型，比较其内存地址 用“==”运算符，该运算符表示指向字符串的引用是否相同，比如: String a=”abc”;String b=”abc”， 那么a==b将返回true。这是因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存 一份，所以a和b指向的是同一个对象；再比如：String a=new String(“abc”); String b=new String(“abc”); 那么a==b将返回false，因为a和b指向不同的对象。 1234567String a=&quot;abc&quot;,b=&quot;abc&quot;;String c=new String(&quot;abc&quot;),d=new String(&quot;abc&quot;);System.out.println(a==b);System.out.println(c==d);//输出结果//true//false java中的StringBuilder的reverse()方法，是原地逆置（在自身上逆置） Java官方推荐使用Deque替代Stack使用,Deque堆栈操作方法：push()、pop()、peek()。 1Deque&lt;String&gt;stack=new ArrayDeque&lt;&gt;(); java中将数组转化为ArrayList的方法,注意不能使用基本数据类型 1234Integer[]arr={1,2,3};List&lt;Integer&gt; lst=new ArrayList&lt;&gt;(Arrays.asList(arr));//或者List&lt;String&gt;l=new ArrayList&lt;&gt;(Arrays.asList(&quot;aaaa&quot;,&quot;aaa&quot;)); 2021/1/26 java中可以直接将List转化为HashSet List&lt;String&gt; wordDict Set&lt;String&gt;wordDictHashSet=new HashSet&lt;&gt;(wordDict) 动态规划不仅仅局限于dp数组的形式，由一个变量或者多个变量，记录变化亦可。 java数组切片用int[]arr_1=Arrays.copyOfRange(arr,0,arr.length-1); 2021/1/27 java中int类型数据有时可能会出现中间结果溢出，用long即可 2021/1/28 如果动态规划中一维或者二维数组的开始点不好处理，可以让其加长一位，遍历时从1开始 int[][]dp=new int[m+1][n+1]; 2021/1/29 DP不仅对求解最优问题有效，对于各种排列组合的个数、概率或者期望之类的计算同样很有用。 2021/2/17 涉及2的多少次方的问题，可以使用移位运算&lt;&lt;和&gt;&gt;，能够大大加快运算 对一个数组进行逆置（或者其他半数的操作），for循环如此for(int i=0;i&lt;len/2;i++)就对了 快速排序的代码 循环条件p&lt;=r的原因是，r下标的元素并未处理，需要p来处理完成后才覆盖所有元素 快速排序核心思想：每次都确定一个（或多个相同）元素的最终位置 注意一定不能写成： int pivot=left; 后续用arr[p] &lt; arr[pivot]；! 因为pivot只记录序号的话，该序号上的数值会发生变化，导致基准不停变化！！ 123456789101112131415161718192021222324252627public void quickSort(int[]arr,int left,int right){ if(left&gt;=right) return; int l=left,r=right; int p=l; int pivot=arr[left]; while(p&lt;=r){ if(arr[p]&gt;pivot){ int temp=arr[p]; arr[p]=arr[r]; arr[r]=temp; r--; } else if(arr[p]&lt;pivot){ int temp=arr[p]; arr[p]=arr[l]; arr[l]=temp; l++; p++; //此处注意需要p++ } else p++; } System.out.println(&quot;l=&quot;+l+&quot;,r=&quot;+r); quickSort(arr,left,l-1); quickSort(arr,r+1,right); } 写法二 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;void swap(int a[], int i, int j){ int t = a[i]; a[i] = a[j]; a[j] = t;}int partition(int a[], int p, int r){ int i = p; int j = r + 1; int x = a[p]; while(1){ while(i&lt;r &amp;&amp; a[++i]&lt;x); //如果i位置元素小于基准，就一直往右，目的是使i位置&gt;=基准 while(a[--j]&gt;x); //如果j的位置大于x，就一直往左，目的是使j的位置&lt;=基准 if(i&gt;=j) break; //如果i&gt;=j，跳出循环 swap(a,i,j); //否则，交换i，j位置上的元素 } swap(a,p,j); return j;}void quicksort(int a[], int p, int r){ if(p&lt;r){ int q = partition(a,p,r); //确定一个元素的最终位置 quicksort(a,p,q-1); quicksort(a,q+1,r); }} 其中标志l左侧的都小于基准，标指r右侧的都大于基准，故递归时使用范围[left,l-1]和[r+1,right] Java中注意，用Scanner先输入一个数字，再输入一行，会报错 因为输入数字后，会产生一个换行符 输入一个sc.nextLine()，把换行符吃掉就行了 Java中，判断对象内容是否相等，只能用equals，否则编程比赛中会扣分 两个数互质指的是两个数只有公因数1 快速求最大公因数：辗转相除 java使用BigInteger来求最大公因数GreatestCommonFactor（GCF） 1234BigInteger two=BigInteger.valueOf(2);BigInteger a=two.pow(20).subtract(BigInteger.ONE);BigInteger b=two.pow(19);BigInteger gcd=a.gcd(b); 快速幂Java实现 123456789101112131415public long quickPower(long base,long power){ long result=1; while(power&gt;0){ if(power%2==0){ power/=2; base*=base; } else{ power/=2; result*=base; //都在这一步乘到结果中了 base*=base; } } return result;} 快速幂java实现，位运算优化版 123456789public static long normalPower(long base,long power){ long result=1; while(power&gt;0){ if((power &amp; 1)==1 ) result*=base; //这里与运算相当于判断二进制形式下最后一位是否是1，即是否是奇数 power&gt;&gt;=1; base*=base; } return result;} java int类型最大值约为21*108 &amp;与运算:二进制形式下，只有相同位置上都为1，才为1，否则为0 2021/2/19 C++中union类型中，赋值时，各成员只能有一个被赋值，即各成分互斥。 union类型只能赋值一个成员，具有互斥性 1234union{ int cls; char position[10];}category; 2021/2/21 对于多个时间区间的任务，要想完成尽量多的任务（不能中断某个任务），每次选取（可选任务中）结束时间最早的即可。即贪心算法。 如果(left+right)/2产生溢出，那么可以写成left+(right-left)/2 二分查找尽量用非递归写法 一般的OJ，其能承受的时间复杂度在每秒**108**以内，所以O(n2)复杂度的问题，当n=105，时间复杂度就变得不可接受 二路归并排序 流程： 先将两个一组进行排序 然后四个一组排序，八个一组排序…直到所有都被排序 其中涉及到两个顺序序列合并的问题，用双指针即可 使用递归实现，倒过来思考 将原始数组分为左边和右边 对左右分别进行归并排序 再将左右两个顺序序列合并为一个顺序序列 时间复杂度O(nlogn) logn是因为每次step*2 n是因为双指针合并两个有序序列，宏观上需要进行O(n)级别次操作 编程时将一些变量视为更容易理解的事物，比如归并排序中将step理解为区间长度远远比步长来的更容易理解。1234567891011121314151617181920212223242526void mergeSort(int arr[],int left,int right){ //递归终止条件 if(left==right) return; //把左边和右边排序好 int mid=(left+right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); //然后将两个顺序序列合并 int temp[right-left+1]; int l=left,r=mid+1; int i=0; while(l&lt;=mid &amp;&amp; r&lt;=right){ if(arr[l]&lt;arr[r]){ temp[i++]=arr[l++]; } else temp[i++]=arr[r++]; } while(l&lt;=mid) temp[i++]=arr[l++]; while(r&lt;=right) temp[i++]=arr[r++]; for(int j=left,i=0;j&lt;=right;j++) arr[j]=temp[i++];} 2021/2/24 处理日期问题时，不仅要注意闰年闰月的问题，在进行函数编写时要注意，传入的月份是1-12，编程中的通常是0-11，传入时要转换为机器友好形式，输出时也要再转回人类阅读友好形式。 2021/3/1 判断一个乘式末尾有多少个0，答案就是min(因子2的个数,因子5的个数)。 即使某个乘子末尾本身就用0也不用考虑，因为10本身就是2和5的积。 丑数（因数只有2，3，5）类似的题，都可以用三指针来做 开始时三个指针都指向dp数组0位置，每次满足条件+1; C++的set和map具有排序功能 注意：在接收字符或字符串后，再接收一行字符，在此之前需要吸收到回车 2021/3/2 对于联通块问题，常采用计数的方法解决 此外，规模较小的可以采用深度优先遍历，规模大的采用宽度优先遍历，否则会栈溢出 int类型大小约为21*108这么大，4字节，32位。 一般来说OJ，1秒能承受的运算次数在107~108 对于多层循环，如何降低时间复杂度 减少层数 减少范围 二分法 空间换时间，提前存储好部分信息以便访问 关于多个数组合成某个数的倍数的问题，考虑用根据余数分组来做。 对于多括号嵌套问题，先处理最小的括号，再递归 2021/3/3 遇到题目说从某种初始状态到达终态最少需要多少步，这种题型，一般都是BFS宽度优先搜索来解决。 定义静态二维数组时，第二维的长度须确定。 所谓回溯就是 执行某种行为 递归 撤销第一步的行为 深刻体会这种DFS的不同剪枝方法 123456789101112131415161718192021222324252627282930313233343536/*a个字母A，b个字母B，c个字母C，能组成多少种不同的长度位固定n的字符串*//* * 这种DFS的题目，其需要求出的是DFS能走要正确终点的路径数*/#include &lt;cstdio&gt;int DFS(int a,int b,int c,int n){ //这是我的思路，有某个字母数量还有才能递归下去 //给出两种终止条件 if(n==0) return 1; int res=0; if(a&gt;0) res+=DFS(a-1,b,c,n-1); if(b&gt;0) res+=DFS(a,b-1,c,n-1); if(c&gt;0) res+=DFS(a,b,c-1,n-1); return res;}int cal(int a, int b, int c, int n) { //这是答案的思路：先递归下来，如果字母数量由0变成-1，那就剪枝return 0 //终止条件 if (a &lt; 0 || b &lt; 0 || c &lt; 0) return 0; if (n == 0) return 1; //递归 return cal(a - 1, b, c, n - 1) + cal(a, b - 1, c, n - 1) + cal(a, b, c - 1, n - 1); //这里的返回值代表的是，选择A作为当前位置字母的话后续共有多少种方案+选择B...+选择C... //cal(a-1...)说明该方案选择A作为当前位置的字母，其返回值代表的是当前位置选择了A这种方案一共有多少种不同方法走到底，若下一步中判断出了a-1是&lt;0的，那么返回值是0，相当于对这个方案做了剪枝 }int main() { printf(&quot;%d\\n&quot;,DFS(1,2,3,3)); printf(&quot;%d&quot;,cal(1,2,3,3)); return 0;} 2021/3/4 互质指的是两个数的最大公约数是1 求最大公因数，就用辗转相除法 12345//递归简约版int gcd(int a,int b){ if(b==0)return a; return gcd(b,a%b);} 互质的两个数x和y,其中ax+by不能凑出的数（a、b&gt;=0，x、y&gt;0)，最大为a*b-(a+b); 意思是对大于a*b-(a+b)的数来说，任意个数的x和y一定能凑出来（a,b有非负解） 计算一个长方形（长宽分别为l、w）能装下多少个边长为e的正方形 (l/e)*(w/e) 注意这里的除是整除 做竞赛题的时候务必注意数据的范围，如果数据比较大，总时间复杂度超过108就很容易执行时长超过1秒 但是对于蓝桥杯这种每个测试用例单独算分的比赛来说，在没有更好的思路情况下，可以用简单的暴力法拿到不少分。 对于顺序枚举的情形来说，可以使用二分法来降低时间复杂度 常常在枚举优化的题目（数据超大）中体现 1234567891011121314//二分法模板int binarySearch(int arr[],int n,int key){ int l=0,r=n-1; while(l&lt;=r){ //注意这里必须是等号 int mid=(l+r)/2; if(arr[mid]==key) return mid; if(arr[mid]&lt;key){ l=mid+1; }else{ r=mid-1; } }} 注意全排列next_permutation(指针1，指针2)注意指针2是开区间 2021/3/5 竞赛时，在时间不够的情况下，优先考虑能多拿分的简单方法解题（如暴力法） 绝对不能使用打点法来记录虚线上的实线，会产生歧义 因为1,2,3,4四个点都被标记了 那么是表示1~4长度为3的实线？ 还是表示12,34长度均为1的两条实线？ 解决方案：用数组记录，0号元素表示01的位置有线，1号元素表示12的位置有线 对于蓝桥杯的递归填空题，搞懂参数的含义和递归的方向，基本就可以写出来（尝试写一下，然后用测试用例跑一下试试） 参加比赛的时候，做题要有取舍，同时对是否暴力求解加以思索 如17年的魔方状态，写几百行代码就为了求一个数，而且无法验证是否正确，不如直接跳过 容斥原理 ∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣A∩C∣−∣B∩C∣+∣A∩B∩C∣ C++中int arr[3]={0};或int arr[3]={-1};不能使用这种方法为数组初始化赋值 也不能bool arr[3]={true}; 这样只会给第一个元素赋值 2021/3/6 快速排序时间复杂度是O(nlogn)的原因是： 每次确定一个元素的最终位置，然后划分两个子区间（递归划分左右子区间需要logn复杂度） 每次确定一个元素的最终位置总共需要O(n)的时间复杂度 &amp;是按位与 如10110&amp;1，其实质是10110&amp;00001 在处理二进制数末尾情况的时候用+1，-1，&amp; 如消除末尾的1，x=0011011，那么x&amp;(x+1)=0011000 10！=3,628,800， 11！=39,916,800 ，超过10的全排列基本都会超时 美国人的习惯是左闭右开，所以函数参数中，基本都是左闭右开 在处理一些数学问题的时候注意，程序中的除法是整除 故采用a/b==c&amp;&amp;a%b==0;避免数学上和程序上的不一致 DFS递归时，递归主体中要对当前层所有情况进行处理 剪枝可以大幅提升递归的效率 全排列代码理解 其中函数参数k，代表的是固定前k个位置的数（或者理解为固定第k个位置的数） 1234567891011121314151617181920212223242526272829//递归实现全排列#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int arr[]={1,1,3};void show(){ for(auto a:arr) printf(&quot;%d &quot;,a); putchar('\\n');}//k代表的是固定第i个位置的数void full_permunation(int k){ if(k==3){ show(); return; } for(int i=k;i&lt;3;i++){ //这个条件加上了，能实现去重的全排列 if(i!=k &amp;&amp; arr[i]==arr[k]) continue; swap(arr[i],arr[k]); full_permunation(k+1); swap(arr[i],arr[k]); }}int main(){ full_permunation(0); return 0;} 使用递归自定义实现全排列，相对于使用next_permutation()的优点在于可以自定义剪枝（剪枝时务忘回溯），优化效率 OJ一般对O(108)时间复杂度，执行时间为1s 如13!=6,227,020,800，执行13个数的全排列大概需要1分钟左右 填空题无需过度在意执行时间，此外还可以使用剪枝、二分等方法来提升执行效率 回溯法中，如果进行了剪枝，要及时回溯 2021/3/7 判断一个数是否能开方，开方后乘方看是否与原来的数相等 sqrt(a)*sqrt(a)==a 如何优化多层for循环的效率 减少for循环层数 减少每层的枚举范围 二分法（对于顺序序列） 缓存+查询 对于某种状态都有后续两种状态的情形，可以理解为一颗二叉树 问：一个字符串s最少补几个字符能把它变成对称字符串 答案=s长度-lcs(s,s逆置)的长度 lcs最长公共子序列 仔细体会其中的奥妙！ 2021/3/8 LCS最长公共子串的dp求解方法，注意核心在于max(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main(){ char s1[100]; char s2[100]; int dp[101][101]; gets(s1); gets(s2); int len1=strlen(s1); int len2=strlen(s2); //初始化 fill(dp[0],dp[0]+101*101,0); for(int i=1;i&lt;len1+1;i++) for(int j=1;j&lt;len2+1;j++){ //计算三个值，取最大值 int t=dp[i-1][j-1]; if(s1[i]==s2[j]) t+=1; dp[i][j]=max(max(t,dp[i][j-1]),dp[i-1][j-1]); } printf(&quot;%d&quot;,dp[len1][len2]); return 0;} 内存优化版本，用一维数组替换矩阵 123456789101112131415161718192021222324252627282930//LCS最长公共子串的dp 一维数组写法#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main(){ char s1[100]; char s2[100]; int dp[101]; int temp[101]; gets(s1); gets(s2); int len1=strlen(s1); int len2=strlen(s2); //初始化dp数组 fill(dp,dp+101,0); fill(temp,temp+101,0); for(int i=0;i&lt;len1;i++) for(int j=0;j&lt;len2;j++){ int t=dp[j]; if(s1[i]==s2[j]) { t+=1; } temp[j+1]=max(max(dp[j+1],t),temp[j]); for(int k=0;k&lt;len2;k++) dp[k+1]=temp[k+1]; } printf(&quot;%d&quot;,dp[len2]); return 0;} Clion无法调试，使用202.2.5的版本就可以 最大公因数用辗转相除法（递归版本简单，上面有代码），最小公倍数用a*b/gcd(a,b)，即a和b的积除以a和b的最大公因数 2021/3/10 做了一道选牌的题目，点数为1~13的牌各4张，问不考虑顺序的情况下取13张，一共有多少种组合 这道题的核心在于理解什么叫不考虑顺序：即顺序不重要，每种牌取出来的张数才是重要的 所以这道题就转换成了一个DFS问题，即每种牌选0~4张，总数限定13张，一共有多少种可能 回溯法 123456789101112131415161718192021222324252627282930313233343536373839//深刻理解什么叫不考虑得到牌的先后顺序//即第一张、第二章拿到A 和 第一张、第三张拿到A是一样的//也就是说，重要的是A的张数#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int cards[13];int ans=0;int chosen=0; //记录已经选的牌的数量//k表示选下标为k的牌的张数void func(int k){ //终止条件 if(chosen==13){ ans++; return; } else if(chosen&gt;13){ //剪枝 return; } if(k==13){ //选完了还没选够13张牌 return; } for(int i=0;i&lt;=4;i++){ chosen+=i; cards[k]-=i; func(k+1); chosen-=i; }}int main(){ fill(cards,cards+13,4); func(0); printf(&quot;%d&quot;,ans); return 0;} 非回溯法 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int cards[13];int ans=0;void f(int k,int c){ //终止条件 if(k&gt;13 || c&gt;13) //这里k不能=13是因为每次都是下一轮判断前面的选牌总数 return; if(c==13){ ans++; return; } //递归主体 for(int i=0;i&lt;=4;i++){ f(k+1,c+i); }}int main(){ fill(cards,cards+13,4); f(0,0); printf(&quot;%d&quot;,ans); return 0;} 有重复元素的圆排列与环排列的计数问题 如何判断手链abc和cab是同一个手链，只是旋转了一下 第一步：abc-&gt;abcabc 第二步：如果cab是abcabc的子串，那么abc和cab是旋转关系 C++中判断子串用s1.find(s2)!=string::npos表示s2是s1的子串 同理：如果加上翻转，那么就判断是否是abcabc和翻转cab的子串关系‘ 2021/3/11 在二维数组的两维之间来回切换 cur=0; for循环中每轮cur=1-cur; 对于结果需要对某个大数取余的题目，中间结果也需要去余，防止溢出 #define MOD 1000000007，注意没有; 生成最小生成树的两个经典算法 克鲁斯卡尔算法Kruskal 将所有边从小到大排序 每一轮选择最小的边加入已选边集，若形成环，则丢弃该边 直到选中n-1条边 Prim普利姆算法 本质是动态规划，使用三个数组 selected[n]：记录顶点是否在已选顶点集中 minDist[n]：记录某顶点距离已选顶点集的最短距离 parent[n]：记录父节点 每一轮实现一个顶点数为1,2,3…n的最小生成树（动态规划） 具体方法 选取0号节点加入已选顶点集，然后更新未选顶点距离已选顶点集的距离 在未选顶点中选取距离已选顶点集最近的点，加入已选顶点集 更新未选顶点与已选顶点集的距离 重复2、3步骤直到加入了所有节点 2021/3/12 并查集可以用于克鲁斯卡尔算法中，提前判断加入当前边是否会形成环 原理是判断边的两个顶点是否在一个集合中，如果已经在一个集合中，再加入该边则会形成环 实现方法：寻找两个节点是否有相同的祖宗节点 同一个集合中的顶点都拥有共同的祖宗节点 解决实际问题的时候，需要将并查集节点和实际问题中的节点映射起来，可以采用数组的形式来映射，创建一个并查集节点数组，根据序号来映射 12345678910111213141516171819202122232425262728293031323334353637//实现一个并查集#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;struct UFNode { UFNode *parent; UFNode() : parent(NULL) {}};/** * 目的是找到p所指向的节点的父节点 * 此外做了优化，将访问路径上的节点全部指向祖宗节点，这样下次查找祖宗节点时更快 * @param p * @return */UFNode *find(UFNode *p) { set&lt;UFNode *&gt; path; while (p-&gt;parent != NULL) { path.insert(p); //这里放入的是p指向的节点的地址，而不是p的地址 p = p-&gt;parent; } //将路径上所有的节点，父指针都指向祖宗节点 for (set&lt;UFNode *&gt;::iterator it = path.begin(); it != path.end(); it++) { (*it)-&gt;parent = p; } return p;}void merge(UFNode *p1, UFNode *p2) { if(find(p1)==find(p2)) return; //将p2的祖宗节点变成p1的祖宗节点的父节点 find(p1)-&gt;parent = find(p2);} 讲一个指针放入vector之中，其实质是将指针所指向的对象的地址放入vector中，而不是指针的地址 同样，指针作为函数参数，其实质是临时复制一个指针，函数体内的操作，并不会改变原来指针的指向 123456int a=1,b=2;int*p=&amp;a;vector&lt;int*&gt;vec;vec.push_back(p);p=&amp;b;printf(&quot;%d&quot;,*vec[0]); //这里的结果是1 2021/3/13 对于枚举过程中的重复问题 存在左1右3，左3右1的情况，砍掉一个 存在左2右2的情况，加上左&lt;右的判断语句 C++ STL中的set和map内部就是用平衡树实现的，因此出现平衡树相关问题，可以直接使用set和map KMP算法： 设主串长度为N，子串长度为M，KMP算法可以将暴力求解最坏情况下O(MN)的时间复杂度降低到O(M+N) 其核心思想是利用子串自身的前后缀信息，来减少暴力求解时的无用回溯 如何利用next数组，见https://www.bilibili.com/video/BV18k4y1m7Ar?from=search&amp;seid=15693083662541831658 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;/** * 如果主串中存在子串，则返回第一次匹配时，第一个字符的下标 * @param s 主串 * @param sub 子串 * @return 如果不存在，则返回-1 */int KMP(char s[],int len1,char sub[],int len2){ //创建next数组 int next[len2]; next[0]=0; int i=0,j=1; while(j&lt;len2){ if(sub[j]==sub[i]){ next[j]=i+1; //i表示，再j位置之前的串中，其从0~i位置和末尾向匹配 i++; //当然我们从最大的可能性开始查找，直至i为0 j++; } else{ if(i==0){ next[j]=0; j++; } else{ i=next[i-1]; } } } i=0,j=0; while(j&lt;len2 &amp;&amp; i&lt;len1){ printf(&quot;i=%d,j=%d\\n&quot;,i,j); if(s[i]==sub[j]){ if(j==len2-1) return i-len2+1; i++; j++; } else{ if(j==0){ i++; } else j=next[j-1]; } } return -1;}int main(){ char s1[]=&quot;abxabcabcaby&quot;; char s2[]=&quot;abcaby&quot;; int ans=KMP(s1,12,s2,6); printf(&quot;%d&quot;,ans); return 0;} 2021/3/14 在可能会超时的双（多）重循环枚举中，我们可以考虑只枚举一重循环，剩下的使用二分查找（前提是有序）或者提前存储好hash表再查找的方法，来降低时间复杂度 滑动窗口可以用双指针来实现 蓝桥杯的规则 12345678910C/C++中怎样使用64位整数？64位整数的类型为：long long使用cin读的操作为：cin &gt;&gt; x;使用cout写的操作为：cout &lt;&lt; x;使用scanf读的操作为：scanf(&quot;%l64d&quot;, &amp;x);使用printf写的操作为：printf(&quot;%l64d&quot;, x); 只求最后四位数字，那么就%10000对一万取余 通常取模运算也叫取余运算，它们返回结果都是余数 .rem 和 mod 唯一的区别在于:当 x 和 y 的正负号一样的时候，两个函数结果是等同的；当 x 和 y 的符号不同时，rem 函数结果的符号和 x 的一样，而 mod 和 y 一样。 &amp;1相当于取二进制最低位数字，一般用于判断奇偶数 2021/3/15 1既不是素数，也不是合数 线性筛（欧拉筛）1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn=1000; //表长int prime[maxn],pNum=0; //记录素数bool p[maxn]={false};int N; //求N以内的素数void f(int n){ for(int i=2;i&lt;=n;i++){ if(!p[i]) //如果没有被筛掉，说明它是素数 prime[pNum++]=i; for(int j=0;j&lt;pNum;j++){ if(i*prime[j]&gt;n) break; p[i*prime[j]]=true; if(i%prime[j]==0) break; } }}int main(){ memset(p,0,sizeof(p)); scanf(&quot;%d&quot;,&amp;N); f(N); for(int i=0;i&lt;pNum;i++){ printf(&quot;%d &quot;,prime[i]); } return 0;} C++中对set进行排序，自定义比较函数cmp(T p1, T p2)，如果按照优先级从低到高，则返回值return 优先级低的&lt;优先级高的，其背后的原理时，sort将调换参数位置分别调用两次cmp函数，如果一次返回true，一次返回false，则认定其一个对象小另一个大，若两次都返回false，则认定两个对象相等。 故这里对vector嵌套pair根据first值从小到大进行排序这样写1234vector&lt;pair&lt;int, int&gt; &gt; time_and_shopID;bool cmp(pair&lt;int, int&gt; p1, pair&lt;int, int&gt; p2) { return p1.first &lt; p2.first;} 2020年2020/12/23 对于递归函数，其空间复杂度与最大递归深度有关 递归的诀窍在于找到形式相同但规模更小的子问题 python函数中可以定义函数，但是参数不能不能写self，调用的时候直接写函数名即可 树的深度优先遍历，一条路径末端不一定是叶节点！ 如：这里的1向右深度优先递归结束了，1不是叶节点 ## 2020/12/24 python判断是否是字母或者数字的函数isalnum 动态规划的精髓在于找到第i项和前i-1项（或第i-1项)的关系 动态规划是由规模较小的问题不断得到较大规模问题解的过程，关键在于状态转移方程 异或^在单个位上相同为0，不同为1的性质使之 任意数字和0异或，等于自身 任意数字和自身异或，等于0 异或满足交换律和结合律 python reduce函数的作用是将序列所有元素以一定的规则累积起来 如recude(lambda x,y:x+y,[1,2,3,4]) 是对序列进行求和 判断链表是否有环，使用快慢指针 2020/12/25 哈希可以降低时间复杂度（以空间换时间） 两条相交链表找交点，使用拼接链表的方式 对于有序序列，可以使用二分查找降低时间复杂度 双指针向中间扫描，可以解决有序数列找两数和的问题 python实现ASCII操作的函数:ord():字符转ASCII，chr():ASCII数字转字符 列表推导式表示字母表[chr(ord('A')+c) for c in range(26)]","link":"/2020/12/25/%E9%9A%8F%E7%AC%94-%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"},{"title":"C++学习笔记","text":"一、基于过程的程序设计1.1 概念及基础 #pragma once //防止头文件重复包含 自定义的头文件用&quot; &quot;，系统的用&lt; &gt; 在标准输入流与输出流中使用控制符需要添加#include iomanip头文件 C++教材p50页 有设置基数10、16、8；填充字符；设置精度；字段宽度；输出左对齐右对齐；输出正数给+ 12cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setiosflags(ios::right)&lt;&lt;setprecision(2);//输出数据右对齐，取两位小数 putchar和getchar 进行字符的输入和输出 c=getchar() 无参数 C++兼容C语言的scanf和printf scanf(“%d %c %f”,&amp;a,&amp;c,&amp;b); printf(“a=%d,b=%f,c=%c\\n”,a,b,c) switch结构 12345678switch(c) //括号中可以是数值类型的数据（包括char类型）{ case 0:###;break; //当c与case后的表达式相同时，执行此句 case 1:###;break; //冒号后可以是好几句代码，break …… default:###; //若所有表达式都不满足，则执行default子句的内嵌语句 //default不需要break；同时也可以没有default} C++提供了两种类型的字符串表示形式 C风格字符串 Index 0 1 2 3 4 5 Variable H e l l o \\0 Address 0x23451 0x23452 0x23453 0x23454 0x23455 0x23456 C++引入的string类类型 定义字符串string str=”Hello”; 复制字符串str1=str2; 连接字符串str=str1+str2; 计算字符串长度str.size() 内置函数（内联函数） 12345678910111213141516#include&lt;iostream&gt;using namespace std;inline int max(int,int,int); //可以在声明和定义函数时写inline，也可以只在函数声明时加int main() //inline，而定义时不加。{ int i=10,j=20.k=30,m; m=max(i,j,k); //编译时直接将max函数体的代码替换此句，同时将实参代替形参 cout&lt;&lt;m; return 0;}inline int max(int a,int b,int c) { if(b&gt;a)a=b; if(c&gt;a)a=c; return a;} 函数的重载：重载函数的参数个数，参数类型，或者参数顺序中必须至少有一种不同 函数模板：建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就是函数模板。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;T max(T a,T b,T c){ if(b&gt;a)a=b; if(c&gt;a)a=c; return a;}int main(){ int a1=1,a2=2,a3=3; double b1=0.1,b2=0.2,b3=0.3; int i;double j; i=max(a1,a2,a3); //调用函数模板，此时T被int取代 j=max(b1,b2,b3); //调用函数模板，此时T被double取代} 函数模板的一般形式为 12345template&lt;typename T&gt;通用函数定义或（二者等价）template&lt;class T&gt;通用函数定义 函数模板只适用于函数体相同、函数的参数个数相同、而类型不同的情况。同时类型参数可以不止一个，可以根据需要确定个数如： 1template&lt;class T1,typename T2&gt; 有默认参数的函数，暂时仅作了解 C++中变量除了有数据类型的属性以外，还有存储类别的属性：自动的auto，静态的static，寄存器的register，外部的extern 自动变量auto：auto可以省略，大多数变量都是自动变量 静态局部变量:对静态局部变量是在编译时赋初值，即只赋值初值一次，以后每次调用函数时不再重新赋初值，而是保留上一次函数调用结束的值 12345678910int f(a){ static int c=1; //c是静态局部变量，只赋一次初值，再次调用时屏蔽此句 c=c+1; return a+c;}int main(){ cout&lt;&lt;f(1)&lt;&lt;' '&lt;&lt;f(1); //输出结果：3，4} 虽然静态局部变量在函数调用结束后仍然存在，但是别的函数不能引用它 寄存器变量：有些变量使用频繁（如在一个函数中执行10000次，每次循环都引用某局部变量），使用寄存器存放大大提高效率(编译器会自动识别高频变量并设置为register variable，无需程序员指定，了解即可) 1register int i=1; 全局变量（外部变量）：作用域从变量的定义处开始到本程序文件的末尾 1234567891011file1.cppextern int a,b; //外部变量声明,两个文件链接后执行file1此句时，编译器先在本文件中找a，bint main() //定义，找不到就去file2中找{cout&lt;&lt;a&lt;&lt;b;}file2.cppint a=3,b=4; 用static声明静态外部变量：如果希望某些外部变量只限于被本文引用，而不能被其他文件引用，此时可以在定义外部变量时加一个static声明，为程序的模块化、通用性提供了方便： 1234567file1.cppstatic int a=3;...file2.cppextern int a; //虽然有此句，但file2仍然无法使用file1中的a... 根据函数是否能被其他源文件调用，将函数区分为内部函数和外部函数 内部函数：只能被本文件中其他函数所调用 1static int func(int a,int b) 外部函数：定义函数时省略extern，默认为外部函数 1extern int func(int a,int b) 控制台停止system(“pause”); 1.1.1生成随机数#include&lt;ctime&gt;srand(time(0));rand()%100 生成0~99区间内的随机数 1.1.2字符数组与字符串 字符数组可以一次性定义，但不可一次赋值，只能分别对每个数组元素赋值 123char C[5];C={'C','h','i','n','a'}; //错误！C[0]='C',C[1]='h'... //正确！ 字符串操作函数(需要#include) 字符串连接函数strcat，是string catenate的缩写 函数原型strcat(char[],const char[]) 12345char str1[30]=&quot;People's Republic of&quot;;char str2[]=&quot;China&quot;;cout&lt;&lt;strcat(str1,str2); //调用strcat函数输出： People's Republic of China 字符串赋值函数strcpy 函数原型strcpy(char[],const char) 123char str1[10],str2[]=&quot;China&quot;;strcpy(str1,str2);//执行后str2中的5个字符和'\\0'被复制到str1中 字符串比较函数strcmp,是string compare的缩写 函数原型strcmp(const char[],const char[]) 1234strcmp(str1,str2);strcmp(&quot;China&quot;,&quot;Beijing&quot;);strcmp(str1,&quot;China&quot;);//以上写法均合法 如果两字符串相等，返回0 字符串1&gt;字符串2，返回正整数 字符传1&lt;字符传2，返回负整数 字符串比较规则是：自左至右逐个字符比ASCII码 字符串长度函数strlen,返回字符串实际长度，不包括’\\0’ 函数原型strlen(const char[]); C++提供全新的数据类型——字符串类型（string类型） 需要#include 字符串赋值直接只用= 字符串连接直接使用+ 字符串比较直接使用关系运算符 String类型的长度固定一般为16字节 指针法表示数组元素 123456int a[10];int *p=a;for(int i=0;i&lt;10;i++) cin&gt;&gt;*(p+i);for(p=a;p&lt;(a+10);p++) cout&lt;&lt;*p; C++有三种方法访问一个字符串 字符数组存放字符串 1char str[]=&quot;I love China&quot;; 用字符串变量存放字符串 1string str=&quot;I love China&quot;; 用字符指针指向一个字符串 1char *str=&quot;I love China&quot;; 1.1.3指针与引用 指针变量也可以指向一个函数。函数再编译时被分配给一个入口地址，这个函数入口地址就成为函数的指针。可以用一个指针变量指向函数，然后通过该指针变量调用此函数。 1234int max(int x,int y); //函数声明int (*p)(int,int); //定义指向函数的指针变量pp=max; //使p指向函数maxint m=p(1,2); //通过p调用函数max 指针数组 1int *p[4]; //由于[]优先级高，p先和[]结合成为数组，然后数组元素的类型是int * 指向指针的指针 123char *(*p);或char **p; 1234char **p; char *arr[]={&quot;BASIC&quot;,&quot;FORTRAN&quot;,&quot;C++&quot;,&quot;Pascal&quot;}; p=arr+2; cout&lt;&lt;*p&lt;&lt;endl&lt;&lt;**p; *arr[2]中存放了字符串”C++”的第一个字符的地址，因此cout&lt;&lt;p就是从第一个字符开始输出字符串”C++”。**p，应该理解为*(*p)，即**p存放的是p所指向内容的地址，即C的地址，故cout&lt;&lt;**p输出的是C； const指针 指向常量的指针变量（经定义后，不允许通过指针变量改变它指向对象的值） 12345int a=12，b=15;const int *p=&amp;a; //定义了p为指向整型变量a的const指针变量*p=13; //试图通过p改变它指向的对象a的值，非法p=&amp;b; //p改为指向b，合法a=15; //直接改变a的值，合法 12const int a=12; //要想绝对保证a的值不变，应该把a定义为常变量//这样p就成为了指向常变量的指针变量，无论直接访问方式还是间接访问方式都无法改变a的值 常变量和常量的区别：变量是再运行时赋值，常量是在编译时赋值。常变量是在程序执行时赋值，只是值不再改变而已。 说明：如果一个变量已经被声明为常变量，则只能用指向常变量的 指针指向它 常指针（指针的指向不能改变） 12char *const p1=&quot;China&quot;; //p1是字符指针变量，其指向不能改变p1=&quot;Canada&quot;; //试图改变p1的指向，非法 指向常量的常指针（结合上面两种，即指针指向一个固定的对象，且不能通过指针改变该对象的值） 12int a=10;const int *const p=&amp;a; 其实上述常指针，和指向常量的指针很简单 12const int *p=&amp;a; //*p左边代表p指向的类型，故p指向常量char *const p=&quot;China&quot;; //const位于*和p之间，代表p是一个常指针，不可以更换指向目标 void指针类型：“指向空类型“或者”不指向确定的类型“ 指针额外知识点 指针可以有空值，即该指针变量不指向任何变量 123p=NULL;//一般情况编译系统中iostream里已经定义了符号常量NULL代表0 #define NULL 0//p=NULL就是使p指向地址为0的单元，即p不指向任何有效的单元 两个指针变量可以相减 如果两个指针变量指向同一个数组的元素，则两个指针的差就是两个指针之间的元素个数 12//假设p1指向a[1],p2指向a[4]p2-p1=3; 两个指针变量比较 若两个指针变量指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量小于指向后面元素的指针变量。 12//假设p1指向a[1],p2指向a[4]p1&lt;p2的值为true; 引用 引用的作用是给变量起别名 声明一个引用时，必须同时使之初始化 1.1.4结构体类型 结构体变量的初始化 可以在定义结构体时指定初始值 也可以在定义变量时进行初始化 指向结构体变量的指针 123Student *p=&amp;stu; cout&lt;&lt;p-&gt;Name; cout&lt;&lt;(*p).score; //注意观察两种输出方式 1.1.5new和delete运算符 new 12345new int; //开辟一个存放整数的存储空间，返回一个指向该 存储空间的地址（即指针）new int(100); //除了上述操作外，指定该整数的初值为100new char[10]; //开辟一个存放字符数组（包含10个元素）的空间，返回字符数组首元素地址new int[5][4]; //开辟一个存放二维数组（大小为5*4）的空间，返回首元素地址float *p=new float(3.14159) //开辟一个存放单精度数的空间，并指定该数初值为3.14159，将该空间的地址赋给指针变量p 注意：用new分配数组空间时不能指定初值，如果由于内存不足无法正常分配空间，new会返回一个空指针NULL delete 123delete p; //撤销上面用new开辟的存放单精度数的空间char *pt=new char[10];delete [] pt; //撤掉该数组空间 1.1.6枚举类型 定义：如果有一个变量只能有几种可能的值，可以定义为枚举（enumeration)类型。 1enum weekday{sun,mon,tue,wed,thu,fri,sat}; weekday为枚举类型。sun,mon,tue…称为枚举元素或枚举常量，它们时用户自定义的标识符 说明 枚举元素按常量处理，故称枚举常量，他们不是变量，不能对他们赋值，即枚举元素的值时固定的 1sun=0; //错误 枚举元素作为常量，它们是有值的，其值是一个整数，编译系统按定义时的顺序对他们赋值为0,1,2… 123weekday workday; //定义枚举变量workdayworkday=mon; //把枚举常量mon的值赋给枚举变量workday,workday的值等于1cout&lt;&lt;workday; //输出结果为1，而不是字符mon 也可以在声明枚举类型的时候自己指定枚举元素的值，如 1enum weekday{sun=7,mon=1,tue,wed,thu,fri,sat}; 枚举值可以用来做判断比较，规则按整数比较进行 不能把一个整数直接赋给一个枚举变量，枚举变量只能接受枚举类型数据，如 12345workday=tue; //正确workday=2； //错误，它们属于不同类型workday=(weekday)2; //正确，C语言的强制转换workday=weekday(2); //正确，C++风格的强制转换 1.1.7typedef typedef的作用相当于取别名 1234typedef int INTEGER;//如此，以下两行等价int i,j;INTEGER i,j; 也可以对一个结构体类型声明一个新的名字 1234567typedef struct{ int month; int day; int year;}DATE;DATE birthday;DATE *p; 还可以进一步用typedef声明一个新的类型名 12345678typedef int NUM[100]; //声明NUM为整型数组类型，包含100个元素NUM n; //定义n为包含100个整形元素的数组typedef char * STRING; //声明STRING为char *类型，即字符指针类型STRING p,s[10];typedef int(*POINTER)(); //声明POINTER为指向函数的指针类型，函数返回整型值POINTER p1,p2; typedef定义的一般用纯大写 定义结构体时同时定义该结构体类型的指针，可以这样写 12345typedef struct Node{ int num; Node *next;}*PNode; 1.1.8基本数据类型占用字节数 1234short takes 2 Bytesint takes 4 Byteslong takes 4 Byteslong long takes 8 Bytes 1.1.9 引用 引用的本质：给变量起别名 注意事项：1.引用必须初始化int &amp;a=b; 2.引用一旦初始化就不可更改 引用作函数参数：1.值传递2.地址传递3.引用传递12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//值传递void swapValue(int a,int b){ int temp=a; a=b; b=temp;}//地址传递void swapAddress(int *a,int *b){ int temp=*a; *a=*b; *b=temp;}//引用传递void swapQuote(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;}int main(){ int a=1,b=2; swapAddress(&amp;a,&amp;b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b;} 引用作为返回值 不要返回局部变量的引用 函数的调用可以作为左值（实质：引用是别名，相当于一个变量名）12345678910111213using namespace std;int&amp;func(){ static int a=10; return a; 注意这里返回的是a不是&amp;a,因为a是名字，返回值是别名类型已经一致}int main(){ 这里的func()相当于是一个变量名,引用的实质是别名 func()=20; cout&lt;&lt;func();} 引用的本质本质：引用的本质在C++内部实现是一个指针常量（指针的指向不能修改）12345678910111213141516void func(int&amp;ref) 系统自动转换为 int*const ref{ ref=30; 系统自动转换为 *ref=30}int main(){ int a=10; int&amp;ref=a; 系统自动转换为int*const ref=&amp;a 将a的地址放在ref中 ref=20; 系统自动转换为 *ref=20; func(a); } 1.1.10 常量引用 *作用**：常量引用主要用来修饰形参，防止误操作 *知识点**： 1.非常量引用的初始值必须为左值2.常量引用则可以直接引用值 123const int&amp; ref = 10; 编译系统自动将代码转换为：int temp=10;const int&amp;ref=temp;cout &lt;&lt; ref; 3.加上const后变成只读状态，不能修改 使用场景：用来修饰形参，防止误操作 123int&amp; ref = 10; 操作非法！const int&amp; ref = 10; 操作合法！加上const后系统自动转换为：int temp=10; const int&amp;ref=temp; 1.1.11指针 指针占用的内存空间32位OS下占4字节,无论什么数据类型的指针（开发一般都是32位环境x86）64位OS下占8字节(x64) 空指针：指针变量指向内存中编号为0的空间用途：初始化指针变量注意：空指针指向的内存是不可访问的（0~255内存是OS占用的不可访问） 野指针：指针变量指向非法的内存空间没有申请就访问一块内存，会产生访问权限冲突。在程序中要避免野指针的出现。1.1.12this指针 this指针指向被调用的成员函数所属的对象*this指针的用途： 1.当形参和成员变量同名时，可用this指针来区分2.在类的非静态成员函数中返回自身，可使用return *this (用于链式调用） 123456789101112131415class Saler {public: Saler(int = 0); Saler&amp; addIncome(int n) { 注意返回值用引用接收 income += n; return *this; 返回的是自身本体 } int income;};Saler::Saler(int a):income(a){}int main(){ Saler Mike; Mike.addIncome(10).addIncome(10).addIncome(20);} Saler addIncome(int n){...}返回的不是引用，则会调用拷贝构造函数，返回一份拷贝而不是本体 空指针访问成员函数12345678910111213class Person {public: void showName() { cout &lt;&lt; &quot;Name=&quot; &lt;&lt; name &lt;&lt; endl; 系统自动添加this.name }private: string name;};int main() { Person* p = NULL; p-&gt;showName(); 代码崩溃,因为this指向当前函数所属对象，但空指针无指向对象} 为了增加程序的健壮性，我们添加if(this==NULL) return;在函数中1.2零碎知识点1.2.1生成随机数12345678#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;int main(){ srand(time(0)); cout&lt;&lt;rand()%10+1&lt;&lt;endl;} 1.2.2 goto跳转语句1.23 函数的分文件编写 swap.h*123#include&lt;iostream&gt;using namespace std;void swap(int&amp;,int&amp;); swap.cpp*(名字不一定要相同）123456#include&quot;swap.h&quot;void swap(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;} main.cpp*1234567#include&quot;swap.h&quot;void swap(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;} 1.2.4 string相关问题直接定义string类型不需要导包用到string相关方法，或用到cout需要导包&lt;string&gt;1.2.5static 静态局部变量*特点： 1.该变量在全局区分配内存2.只能初始化一次，在声明处初始化，如果未初始化系统会自动初始化3.始终驻留全局区，直到程序结束。但是作用域仅为函数内用法：1.在循环中，若赋初值操作只想用一次 123456int count = 0;while (count&lt;5) { static int i = 0; i被声明为static后，这句话只会执行一次 count += i; 后续循环不再赋予初值 i++;} 1.3 函数1.3.1函数默认参数123456void sumNum(int a, int b = 10, int c = 20) { cout &lt;&lt; &quot;sum=&quot; &lt;&lt; a + b + c &lt;&lt; endl;}int main() { sumNum(10);} 注意事项： 1.如果某个位置已经有默认参数，那么从这往右的参数都必须有默认值2.如果函数声明有默认参数，函数实现就不能有默认参数（函数的声明和实现只能有一个有默认参数） 1.3.2 函数重载 函数重载条件：前提：函数作用域相同 1.函数参数类型不同 2.函数参数个数不同 3.函数参数顺序不同 注意：返回值不能作为重载的条件 函数重载两个特殊情形 1.引用作为重载条件const int&amp; 和 int&amp; 视为不同类型 123456789101112131415void func(int&amp;n){ cout&lt;&lt;&quot;int&amp;&quot;&lt;&lt;endl;}void func(const int&amp;n){ cout&lt;&lt;&quot;const int&amp;&quot;&lt;&lt;endl;}int main(){ int a=10; func(a); func(10); 因为int&amp;n=10不合法！ const int&amp;n=10合法! 系统自动转换为int temp=10;const int&amp;n=temp;} 2.尽量避免函数重载和默认参数同时出现 12345678910111213void func(int a,int=10){ cout&lt;&lt;a;}void func(int a){ cout&lt;&lt;a;}int main(){ func(20); 此时编译系统不知道要调用哪个函数，故无法重载 func(10,20); 合法，不产生二义性} 1.3.3指针和函数二、基于对象的程序设计2.0 内存分区模型C++程序在执行时，将内存大方向分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的函数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由OS回收 内存分区的意义： 不同区域存放的数据，赋予不同的生命名周期，给我们更大的灵活编程 2.0.1 程序运行前在程序编译后，生成exe可执行文件前，未执行该程序前分为两个区域代码区： 存放着CPU执行的机器指令 代码区是共享的，目的对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是只读的，防止程序意外地修改它的指令 全局区： 存放全局变量和静态变量 全局区还包括常量区，存放字符串常量和const修饰的变量 该区域的数据在程序结束后由操作系统释放1234567891011using namespace std;int&amp;func(){ static int a=10; return a;}int main(){ func()=20; cout&lt;&lt;func();} 2.0.2 程序运行后 栈区* 存放函数的参数值，局部变量等 由编译器自动分配释放 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放12345678910int*func(){ int a=10; return &amp;a;}int main(){ int *p=func(); cout&lt;&lt;*p;局部变量a存放在栈区，由OS决定该地址的内容是否释放，不能保证输出的一定是10} 堆区*由程序员分配释放，若程序员不释放，程序结束时由操作系统回收C++中主要利用new在堆区开辟内存2.0.3 new操作符 new的基本语法123456789101112#include&lt;iostream&gt;using namespace std;int*func(){ return new int(10);}int main(){ int *p=func(); cout&lt;&lt;*p; system(&quot;pause&quot;);} 在堆区利用new开辟数组123456789101112#include&lt;iostream&gt;using namespace std;int*func(){ return new int(10);}int main(){ int *p=func(); cout&lt;&lt;*p; system(&quot;pause&quot;);} 2.0.4delete操作符释放数组空间需要加上[]:delete [] arr;2.1类和对象2.1.0对象的特性 空对象占用1字节存储（面试可能会），目的是区分不同空对象在内存中的位置，每个空对象也应该有一个独一无二的内存地址 成员变量和成员函数是分开存储的，除了非静态成员变量属于对象，其他都不属于对象（静态成员变量、非静态成员函数、静态成员函数）2.1.1基本概念 面向对象程序设计有4个主要特点：抽象、封装、继承、多态 多态性：由继承而产生的不同派生类，其对象对同一消息会作出不同的相应 如同样是双击操作，windows下，对可执行文件双击就会执行此程序，对文本文件就会启动文本编辑器并打开该文件 类代表了某一批对象的共性和特征。类时对象的抽象，而对象时类的具体实例，也可以说，类是对象的模板。 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 123456789101112class Student{ private: int num; char name[20]; public: void display(){ cout&lt;&lt;&quot;num=&quot;&lt;&lt;num; cout&lt;&lt;&quot;name=&quot;&lt;&lt;name; }};Student stu1,stu2; 如果在类的定义中既不指定private，也不指定public，则系统默认是私有的 私有成员(private),只能被本类中的成员函数引用，类外不能调用（友元类除外） 公用成员（public），既可以被本类中的成员函数所引用也可以被类的作用域内的其他函数引用 受保护的成员(protected),不能被类外访问，但是可以被派生类的成员函数访问 建议先写public部分，因为这样可以使用户将注意力集中在能被外界调用的成员上 当其他类对象作为本类成员，构造的时候先构造类对象，再构造自身。析构时满足先构造的后析构，后构造的先析构原则 2.1.2类的成员函数 工具函数：有的函数不是准备为外界调用的，而是为本类中的成员函数所调用的，就应该将他们指定为private，这种函数的作用是支持其他函数的操作，是类中其他成员的工具函数（utility function),用户不能调用这些私有的工具函数 在类外定义成员函数 12345678class Student{ ...}void Student::display(){ ...} 内置成员函数 使用inline的原因：规模很小的函数，调用的开销比执行的开销更大，因此直接内置更高效 inline函数的作用是在调用该函数时，将函数的代码赋值插入到函数调用点，而若不用inline声明，在调用该函数时 ，流程转去函数代码的入口地址，在执行完该函数的代码段后，流程返回函数调用点 只有在类外定义的成员函数规模很小而调用频率很高时，才指定为内置函数 类内定义的成员函数可以省略inline，因为已被隐含地指定为内置函数 类体外定义的函数，需要用inline显式声明 成员函数的存储方式 不论成员函数是在类内定义还是在类体外定义，成员函数的代码段的存储方式是相同的，都不占用对象的存储空间。（否则要为每个对象存储相同的代码段，对空间极大浪费） inline声明的成员函数，其代码段同样不占用对象的存储空间 2.1.3对象成员的引用 访问对象中的成员有三种方法 通过对象名和成员运算符 通过指向对象的指针 通过对象的引用 123Time t1;Time &amp;t2=ti;cout&lt;&lt;t2.hour; 2.1.4类的封装性和信息隐蔽 公用成员函数是用户使用类的公用接口（public interface），或者说是类对外接口 如同照相机拍照只需要按下快门，并不需要关心其内部的电路和机械结构是如何实现拍照的，这就是接口与实现分离 2.1.5类声明和成员函数定义的分离 实际上，一个C++程序是由3个部分组成的 类声明头文件（后缀为.h)，可以理解为用户使用类库的公用接口 类实现文件（后缀为.cpp)，包括类成员函数的定义 类的使用文件（后缀为.cpp)，即主文件 2.1.6面向对象程序设计中的几个名词 三个术语：对象、方法、消息 1stud.display(); stud是对象，display（）是方法，调用一个对象的方法（如stud.display())就是一个发对对象的消息，要求对象执行一个操作 2.1.7 C++三个文件分离 **#include后面用双引号引起来 “ “ **,不要用&lt; &gt; 主文件（即类的使用文件），后缀为.cpp 123456#include&lt;iostream&gt;#include &quot;time.h&quot;int main(){ ...} 类声明头文件，后缀为.h 12345678910class Time{public: void setTime(); void showTime();private: int hour; int minute; int sec;}; 类的实现文件，包括类成员函数的定义,后缀为.cpp 123456789101112#include&lt;iostream&gt;#include &quot;time.h&quot;using namespace std;void Time::setTime(){ cout&lt;&lt;&quot;Enter hour,minute,sec:&quot;; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;sec;}void Time::showTime(){ cout&lt;&lt;&quot;Time is &quot;&lt;&lt;hour&lt;&lt;'h'&lt;&lt;minute&lt;&lt;&quot;min&quot;&lt;&lt;sec&lt;&lt;'s'&lt;&lt;endl;} 2.1.8struct和class的区别C++中struct和class唯一的区别就在于默认的访问权限不同 1.struct默认访问权限为public2.class默认权限为private 2.2怎样使用类和对象2.2.1利用构造函数对类对象进行初始化 如果一个类中的所有成员都是公用的，则可以在定义对象的时候对数据成员进行初始化 1234567class Time{ public: int hour; int minute;};Time t1={11,23}; C++提供构造函数(Constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。 构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值 可以用一个类对象初始化另一个类对象，此时不调用构造函数，调用拷贝构造函数 12Time t1;Time t2=t1; //建立对象t2，并用t1初始化t2 注意：Person p();不能调用默认构造函数，编译系统会认定其为函数声明；调用默认构造函数直接写Person p; 2.2.2带参数的构造函数 12345678910111213141516171819class Box{public: Box(int,int,int);private: int height; int width; int length;}Box::Box(int h,int w,int len){ height=h; width=w; length=len;}int main(){ Box box1(12,25,30);} 2.2.3用参数初始化表对数据成员进行初始化1Box::Box(int h,int w,int len):height(h),width(w),length(len){} 如果数据成员是数组，则应当在构造函数的函数体中用语句对其赋值，而不能用参数初始化表对其初始化 1234567891011121314class Student{public: Student(int n,char s,char nam[]):num(n),sex(s) { strcpy(name,nam); }private: int num; char sex; char name[20];};Student stu1(10101,'m',&quot;Wang_li&quot;); 2.2.4构造函数的重载 一个类中可以定义多个构造函数，以便为对象提供不同的初始化方法。这些构造函数具有相同的名字，而参数的个数或者参数的类型不相同，创建对象时，据此系统自动选择对应的构造函数 12345678910111213Box();Box(int h,int w,int len):height(h),width(w),length(len){}Box::Box(){ height=10; width=10; length=10;}int main(){ Box box1; Box box2(12,13,14);} 2.2.5使用默认参数的构造函数 带默认参数的构造函数的意思是，如果不输入其某项数据，该项数据将取默认值 应该在声明构造函数时指定默认值，而不能只在定义构造函数时指定默认值 声明构造函数时，形参名可以省略 1Box(int=10,int=10,int=10); 全部参数都指定了默认值的构造函数也属于默认构造函数，一个类只能由一个默认构造函数，也就是说无参数而调用的构造函数，一个类只能由一个 12Box(); //声明了一个无参的构造函数Box(int=10,int=10,int=10); //声明了一个全部都指定了了默认值的构造函数 一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。因为会产生歧义 123456789101112131415161718192021222324class Box{public: Box(int h=10,int w=10.int len=10); //使用默认参数（形参给定值） //或Box(int=10,int=10,int=10);private: int height; int width; int length;};Box::Box(int h,int w,int len){ height=h; width=w; length=len;}//或Box::Box(int h,int w,int len):height(h),width(w),length(len){}int main(){ Box box1; //不指定参数，各参数取默认值 Box box2(15); //只给定一个实参，剩下的取默认值 Box box3(15,30); //只给定两个实参，剩下的取默认值 Box box4(12,30,20); //给定3个实参} 12//上面类体外对构造函数的声明也可以写成参数初始化表的形式Box::Box(int h,int w,int len):height(h),width(w),length(len){} 2.2.6析构函数 析构函数的作用并不是删除对象，而是撤销对象占用的内存空间之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。 析构函数不返回任何值，没有函数类型，也没有函数参数，不能被重载，一个类有多个构造函数，但是只能有一个析构函数 实际上，析构函数的作用并不仅限于释放资源，还可以被用来执行用户希望在最后一次使用对象之后所执行的任何操作，例如输出相关信息。 1234~Student(){ cout&lt;&lt;&quot;Destructor called.&quot;; } 先构造的后析构，后构造的先析构 2.2.6对象数组 如果构造函数只有一个参数,定义数组时可以直接在等号后面的花括号内提供实参 1Student stu[3]={3,2,13}; 如果有多个参数 12345Student stu[3]={ Student(1001,12,39); //调用第一个元素的构造函数，向他提供3个实参 Student(1002,13,23); //调用第二个元素的构造函数，向他提供3个参数 Student(1003,14,78); //调用第三个元素的构造函数，向他提供3个参数}; 2.2.7对象指针 对象空间的起始地址就是对象的指针 123456789Time *pt;Time t1;pt=&amp;t1;//通过指针访问对象的成员(*pt).hourpt-&gt;hour(*pt).get_time()pt-&gt;get_time() 2.2.8指向对象成员的指针 指向对象数据成员的指针 123int *p;p=&amp;t1.hour;cout&lt;&lt;*p; 指向对象成员函数的指针 定义指向对象成员函数的指针变量的方法和定义指向普通函数的指针变量方法有所不同 12345678910//指向普通函数的指针变量void(*p)(); //p是指向void型函数的指针变量p=fun;(*p)(); //调用fun函数//指向对象成员函数的指针变量//需要三步void(Time::*p2)(); //定义p2是一个指向Time类成员函数 返回值为void 的指针p2=&amp;Time::get_time; //注意！此处get_time后不加括号(t1.*p2)(); //调用t1的get_time成员函数 this指针：它是指向本类对象的指针常量（不可修改指向），它的值是当前被调用的成员函数所在对象的起始地址 2.2.9公用数据的保护 常对象 在常对象的生命周期中，t1所有数据成员的值都不能被修改 可以在定义对象时加关键字const，指定对象为常对象。常对象必须有初值。 123Time const t1(12,34,56); 或const Time t1(12,34,56); 常对象只能调用常函数 12const Time t1(12,34,56);t1.get_time(); //非法！试图用调用t1的普通成员函数 声明常成员函数 1void get_time()const; 12345678910class Person {public: void showName()const this指针的本质是Person*const this 指针常量 { 常成员函数相当于把this变成了const Person*const this name = &quot;YUfengxu&quot;; name其实是this-&gt;name }private: string name;}; 常成员函数可以访问常对象中的数据成员，但不允许修改常对象中的数据成员的值 C++考虑到实际编程的需要，将数据成员声明为mutable，这样就可用常成员函数修改它的值 1mutable int count; 1234567public: void showName()const { name = &quot;YUfengxu&quot;; 即使是常成员函数，加了mutable也能修改 }private: mutable string name; 总结一下就两条：1.只有常成员函数能访问常对象，但不能修改数据成员 **2.只有声明为muable的数据成员，才能被常成员函数修改** 常对象成员 可以将对象的成员声明为const，包括常数据成员和常成员函数 常数据成员 只能通过构造函数的参数初始化表对常数据成员进行初始化，任何其他函数都不能对常数据成员赋值 123456const int hour;//不能采用在构造函数中队常数据成员赋初值Time::Time(int h){ hour=h; //非法，不能对之赋值} 12//应当写成Time::Time(int h):hour(h){} 常成员函数 1void get_time()const; 调用时不必加const 常成员函数可有引用const数据成员，也可以引用非const数据成员 数据成员 普通成员函数 const成员函数 非const的普通数据成员 可以引用，也可以改变值 可以引用，但不可以改变值 const数据成员 可以引用，但不可以改变值 可以引用，但不可以改变值 const对象 不允许 可以引用，但不可以改变值 总结一下就是：const成员函数只能引用，不能改变值；普通成员函数要看情况 指向对象的常指针 将指针声明为const型，这样指针变量始终保持为初值，不能改变，即其指向不变 1234Time t1(10,12,15),t2;Time *const p;p=&amp;t1;p=&amp;t2; //错误，p不能改变指向 指向常对象的指针变量 与前面所说的指针和其所指向变量的关系，是一致的。指向常变量的指针可以指向const和非const型的变量，而指向非const型变量的指针只能指向非const的变量 只需将“变量”替换为“对象”即为对象与指针的规则 如果一个对象已经被声明为常对象，则只能用指向常对象的指针指向它。 如果定义了一个指向常对象的指针，并使它指向一个非const对象，则其指向的对象不能通过该指针变量来改变 总之，常指针不能改变方向，指向常变量/常对象的指针不能通过指针修改目标值（除非将涉及到的成员函数都设置为const，涉及到的数据成员都设置为mutable） 1234Time t1(10,12,15);const Time *p=&amp;t1;t1.hour=12; //合法(*p).hour=15; //非法，不能通过指针变量改变t1的值 12//如果希望任何情况下t1的值都不能被改变，应该把他定义为const型const Time t1(10,12,15); 注意区别 常指针和指向常对象的指针，不同的定义方法 12Time *const p; //指向对象的常指针const Time *p; //指向常对象的指针变量 对象的常引用 如果不希望在函数中修改实参t1的值，可以吧fun函数的形参t声明为const（常引用） 1void fun(const Time &amp;t); 在C++面向对象程序设计中，经常用到常指针和常引用作为函数参数。这样既能保证数据安全，使数据不能被随意修改，在调用函数时又不必建立实参的拷贝，常指针和常饮用作函数参数，可以提高程序效率 const型数据小结 形式 含义 Time const t t是常对象，其值任何情况下都不能改变 void Time::fun()const fun是Time类的常成员函数，可以引用，但是不能修改本类中的数据成员 Time *const p p是指向Time类对象的常指针，p的指向不能改变 const Time*p p是指向Time类常对象的指针，不能通过p改变目标值 const Time&amp;t1=t t1是Time类对象t的常引用，二者指向同一存储空间，t的值不能改变 2.2.10对象的动态建立和释放12345Box *pt;pt=new Box;cout&lt;&lt;pt-&gt;height;cout&lt;&lt;pt-&gt;volume(); 1Box *pt=new Box(12,15,16); //可以在执行new时，对新建立的对象进行初始化 在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成相关善后清理工作 1delete pt; //释放pt所指向的内存空间 2.2.11对象的赋值和复制(拷贝构造函数） 对象的赋值 123Student stu1,stu2;...stu2=stu1; 注意，用此方式赋值，类的数据成员中不能包括动态分配的数据，否则在赋值时会出现严重后果 对象的复制 1Box box2(box1); //用已有的对象box1去复制出一个新的对象box2 编译系统自动调用复制构造函数，而不会去调用其他构造函数 如果用户未定义复制构造函数，则编译系统会自动提供一个默认的复制构造函数，其作用是简单地复制类中的每个数据成员 C++还提供另一种方便用户的复制形式，但作用都是调用复制构造函数 1Box box2=box1,box3=box2; 123456Student(const Student&amp;stu){ cout&lt;&lt;&quot;Copy-Constructor running!&quot;&lt;&lt;endl; age=stu.age; sex=stu.sex;} 2.2.12静态成员 静态数据成员（即类的各对象共享的数据，只要修改，因为所有对象都引用这一值，故都改变） 静态数据成员不是说数据保持不变，而是说静态数据成员属于类，不是对象，但类的对象可以引用它,如果改变它的值，则在各对象中这个数据成员的值都同时改变了。 123456789class Box{public: int volume();private: static int height; //将height定义为静态的数据成员 int width; int length;};int Box::height=10; //只能在类体外初始化 静态数据成员可以初始化，但只能在类体外进行初始化 在编译阶段（程序还未运行）分配内存（全局区） 不能用参数初始化表对静态数据成员进行初始化 静态数据成员既可以通过对象名引用，也可以通过类名来引用 12cout&lt;&lt;a.height;cout&lt;&lt;Box::height; 静态成员函数 静态成员函数属于类的一部分而不是对象的一部分，如果要在类外调用公用的静态成员函数，要用类名和域运算符:: 123static int volume();Box::volume();a.volume(); 静态成员函数与非静态成员函数的根本区别：非静态成员函数有this指针，而静态成员函数由于属于类而没有this指针,由此决定了静态成员函数不能访问本类中的非静态成员 静态成员函数可以直接引用本类中的静态成员，因为静态成员同样属于类。 C++中，静态成员函数主要用来访问静态数据成员，而不访问非静态成员，假如在一个静态成员函数中有以下语句 12cout&lt;&lt;height&lt;&lt;endl; //height已声明为satic，合法cout&lt;&lt;width&lt;&lt;endl; //width非静态成员，错误 如果一定要用静态成员函数访问本类的非静态成员，只是不能进行默认访问，因为无法知道去找哪个对象 1cout&lt;&lt;a.width; //用静态成员函数访问本类中非静态成员 C++程序员应该养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员 2.2.13友元 将普通函数声明为友元函数 1234567891011class Time{public: Time(int,int,int); friend void display(Time &amp;); //声明display函数为Time类的友元函数}void display(Time &amp;t){ cout&lt;&lt;t.hour;} 友元成员函数 注意在调用非本类中的成员时，必须加上对象名，如display()是另一个函数的友元函数，调用其内容时必须加上其对象名 1234567891011121314151617181920212223242526272829303132333435class Date; //对Date类的提前引用声明class Time{public: Time(int,int,int); void display(Date &amp;); //display是成员函数，形参是Date类对象的引用private: int hour; int minute; int sec;};class Date{public: Date(int,int,int); friend void Time::display(Date &amp;); //声明Time中的display函数为本类的友元成员函数private: int month; int day; int year;};void Time::display(Date &amp;d){ cout&lt;&lt;d.month; //注意在输出Date类的对象中成员时，必须加上对象名d.month}... int main(){ Time t1(10,13,26); Date d1(12,25,2004); t1.display(d1); //调用t1中的display函数，实参是Date类对象d1} 友元类 不仅可以将一个函数声明为一个类的“朋友”,还可以将一个类B声明为另一个类A的“朋友”，这时B类就是A类的友元类，B中的所有函数都时A类的友元函数，可以访问A类中的所有成员 友元类的关系时单向的 友元类的关系不能传递 2.2.14类模板/参数化的类 类模板是类的抽象，类是类模板的实例 类模板可以有一个或多个虚拟的参数类型 12345678910111213template &lt;class numtype&gt;class Compare{public: Compare(numtype a,numtype b); {x=a;y=b;} numtype max() {return(x&gt;y)?x:y;} numtype min() {return(x&lt;y)?x:y;}private: numtype x,y;}; 其中numtype只是表示“数据类型”的意思而已，这个名字可以任意取，只要是合法的标识符即可 如何使用类模板 1Compare &lt;int&gt; cmp(4,7)； 可以这样声明和使用类模板 首先，写出一个实际的类，由于其语义明确，不容易出错 然后，将此类中准备改变的类型名，改用一个自己指定的虚拟类型名（如numtype) 最后，在类声明前加上一行template &lt;class 虚拟类型参数&gt; 在类模板外声明成员函数，前提是声明和类模板必须放在同一文件中 12template&lt;class T1,class T2&gt; //T1 Compare&lt;T1,T2&gt;::max(){...}; 2.2.15仿函数&amp;匿名对象123456789101112131415class myPrint{public: void operator()(string str) { cout &lt;&lt; str; }};int main(){ myPrint obj; obj(&quot;第一个字符串&quot;); cout &lt;&lt; endl; myPrint()(&quot;第二个字符串&quot;); 使用了匿名对象} 2.3运算符重载本章知识点最全最正确的案例Tips:前置运算符返回引用（引用传递），后置运算符返回值（值传递） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;class Complex {public: //默认构造函数 Complex() { real = 0; imag = 0; } //带参构造函数 Complex(double r,double i) :real(r),imag(i){} //重载运算符+ Complex operator+(Complex c) { return Complex(real + c.real, imag + c.imag); } //运算符函数也可以重载 Complex operator+(double num) { return Complex(real + num, imag); } //重载运算符&lt;&lt; friend ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex c); //重载运算符&gt;&gt; friend istream&amp; operator&gt;&gt;(istream&amp; input, Complex &amp;c); //重载运算符前置++ Complex&amp; operator++() { real++; return *this; } //重载运算符后置++ 返回的是值不是引用，即后置++不能链式使用 Complex operator++(int) { Complex c(*this); //或Complex c=*this; 两种方式都可以调用拷贝构造函数 real++; return c; //值传递 }private: double real; double imag;};ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex c){ if (c.imag &gt;= 0) output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; else output &lt;&lt; c.real &lt;&lt; c.imag&lt;&lt;'i'; return output;}istream&amp; operator&gt;&gt;(istream&amp; input, Complex &amp;c){ input &gt;&gt; c.real &gt;&gt; c.imag; return input;} &lt;&lt;运算符重载参数写成引用的话，须这样写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;class Complex {public: //默认构造函数 Complex() { real = 0; imag = 0; } //带参构造函数 Complex(double r,double i):real(r),imag(i){} //重载运算符+ Complex&amp; operator+(Complex &amp;c) { //不能返回局部变量的引用，new在堆区创建对象在函数执行后才不会被销毁 return *(new Complex(real + c.real, imag + c.imag)); //new返回的是地址，要解引用 } //运算符函数也可以重载 Complex&amp; operator+(int num) { Complex*p=new Complex(real + num, imag); return *p; //解引用 } //重载运算符&lt;&lt; friend ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex&amp;c); //重载运算符&gt;&gt; friend istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c); //重载运算符前置++ Complex&amp; operator++() { real++; return *this; } //重载运算符后置++ Complex&amp; operator++(int) { real++; return *this; }private: int real; int imag;};ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex&amp; c){ if (c.imag &gt;= 0) output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; else output &lt;&lt; c.real &lt;&lt; c.imag&lt;&lt;'i'; return output;}istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c){ input &gt;&gt; c.real &gt;&gt; c.imag; return input;} 2.3.1运算符重载的方法 运算符重载的实质是函数的重载 函数类型 operator 运算符名称(形参表){对运算符的重载处理} c1+c2，编译系统将它解释为c1. operator+ （c2） ，即通过对象c1调用运算符重载函数”operator+”，并以表达式中的第2个参数（运算符右侧的类对象c2）作为函数参数 1234567891011121314151617class Complex //定义复数类{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 void display();private: double real; double imag;};Complex&amp; Complex::operator+(Complex &amp;c2){ Complex *c=new Complex(real+c2.real,imag+c2.imag); return *c;} 2.3.2 重载运算符的规则 C++不允许用户自定义新的运算符，只能对已有的C++运算符进行重载 C++允许重载的运算符，见红C++书p302 不能重载的运算符只有5个 成员访问运算符 . 成员指针访问运算符 * 域运算符 :: 长度运算符 sizeof 条件运算符 ?: 重载不改变运算符的优先级别 重载不能改变运算符的结合性 重载不能改变操作数的个数 重载运算符的函数不能由默认的参数，否则就改变了运算符参数的个数，与上面一点矛盾 重载的运算符必须和用户自定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象（或类对象的引用）。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质 12int operator+(int a,int b){return a-b;} //错误！ 用于类对象的运算符一般必须重载，但有两个例外，运算符“=”和“&amp;”不必用户重载 2.3.3运算符重载函数作为类成员函数和友元函数 对运算符重载的函数有两种处理方式 作为类的成员函数 普通函数，声明为友元函数 123456789101112131415161718class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} friend Complex operator+(Complex &amp;c1,Complex &amp;c2); //重载函数作为友元函数 void display();private: double real; double imag;};Complex&amp; operator+(Complex&amp;c1,Complex&amp;c2){ Complex* c=new Complex(c1.real+c2.real,c1.imag+c2.imag); return *c;} 有的C++编译系统如Visual C++ 6.0没有完全实现C++标准，不支持把运算符重载函数作为友元函数，但是VisualC++6.0提供的老版本的带后缀.h的头文件可以支持 此功能，因此可以把程序头两行改为以下一行 1#include&lt;iostream.h&gt; 由于编译器是将c1+c2解释为c1. operator+ （c2） ，operator+整体作为前者对象的成员函数来调用，如果第一个参数是int型，则运算符重载函数不能作为成员函数，如果函数需要访问私有成员，则必须声明为友元函数 1234567//在Complex类中声明：friend Complex operator+(int &amp;i,Complex &amp;c); //第一个参数可以不是类对象//在类外定义友元函数Complex&amp; operator+(int &amp;i,Complex &amp;c) //运算符重载函数不是成员函数{ Complex *c1=new Complex(i+c.real,c.imag); return *c1;} 将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参列表中必须有两个参数，不能省略，形参的顺序任意。但是在使用运算符的表达式中，要求运算符左侧的操作数与函数第一个参数对应，右侧操作数与第二个参数对应： 12c3=i+c2; //正确c3=c2+i; //错误 如果想使用交换律，必须再重载一次运算符 究竟是把运算符重载函数作为类的成员函数好，还是友元函数好？由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符函数作为成员函数，但还应考虑到各方面的因素和程序员的习惯，以下可供参考 C++规定，=,[],(),-&gt;必须作为成员函数重载 流插入&lt;&lt;和流提取运算符&gt;&gt;，类型转换运算符函数不能定义为类的成员函数，只能作为友元函数 一般将单目运算符和复合运算符+=,-=,/=,*=,&amp;=,!=,^=,%=,&gt;&gt;=,&lt;&lt;=重载为成员函数 一般将双目运算符重载为友元函数 2.3.4重载双目运算符 注意！在其他普通函数中使用重载运算符时，只能以调用重载运算符函数的形式使用 12345void Compare(String &amp;st1,String &amp;str2){ if(operator&gt;(string1,string2)==1) //在别的函数中，只能以operatir&gt;( )的形式使用重载运 算符 ...} 1234567891011struct Tuple { LL a, b, c; Tuple() {} Tuple(LL t1, LL t2, LL t3) : a(t1), b(t2), c(t3) {} bool operator&lt;(const Tuple &amp;t) const { //注意这两个const必须要加 return a &lt; t.a || a == t.a &amp;&amp; b &lt; t.b || a == t.a &amp;&amp; b == t.b &amp;&amp; c &lt; t.c; }}; 2.3.5重载单目运算符12345678Time Time::operator++(){ if(++sec&gt;=60){ sec-=60; ++minute; } return *this;} 后置++，增加一个int形参就可以实现 12345678910Time Time::operator++(int){ Time temp(*this); //将当前对象的内容复制给新建的对象temp sec++; if(sec&gt;=60){ sec-=60; ++minute; } return temp;} 注意二者区别，前者是先自加然后返回修改后的自身；而后者返回的是自加前的对象，然后对象自加（说白了就是返回一个还没改变的临时镜像，然后原来的对象自增） 2.3.6重载流插入运算符&lt;&lt;和流提取运算符&gt;&gt; 重载的函数形式如下 12istream &amp; operator&gt;&gt;(istream &amp;,用户自定义类&amp;);ostream &amp; operator&lt;&lt;(ostream &amp;,用户自定义类&amp;); 重载运算符&gt;&gt;的函数的第一个参数和函数的类型都必须是istream&amp;类型，第二个参数是要进行输入操作的类。重载&lt;&lt;的函数的第一个参数和函数的类型都必须是ostream&amp;类型，函数第二个参数是要进行输入操作的类。因此只能将重载&lt;&lt; &gt;&gt;的函数作为友元函数，而不能将它们定义为成员函数。(因为运算符重载为成员函数后，如果出现表达式c1+c2,编译系统会把它解释为c1.operator+(c2) ) 为什么重载&lt;&lt;和&gt;&gt;不能用成员函数？因为无法实现cout在左侧!使用成员函数重载运算符后，对象在左边 p&lt;&lt;cout。因此必须用全局函数重载它们。operator&lt;&lt;(cout,p)的简化形式是cout&lt;&lt;p 重载流插入运算符&lt;&lt; 在程序中，人们希望能用插入运算符&lt;&lt;来输出用户自己声明的类的对象的信息，这就需要重载&lt;&lt; 1234567891011121314151617181920212223242526class Complex //定义复数类{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,Complex&amp;); //运算符&lt;&lt;重载为友元函数private: double real; double imag;};... ostream&amp;operator&lt;&lt;(ostream&amp;output,Complex&amp;c){ output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;'+'&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; return output;}int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+c2; cout&lt;&lt;c3;} cout&lt;&lt;c3 cout是头文件iostream中声明的ostream类对象，c3是Complex类对象，由于已将运算符&lt;&lt;的重载函数声明为Complex类的友元函数，编译系统把cout&lt;&lt;c3解释为：operator&lt;&lt;(cout,c3),即以cout和c3作为实参，调用上面的operator&lt;&lt;函数。调用函数时形参output成为实参cout的引用，形参c成为c3的引用。 return output的作用：output是cout的引用即别名，相当于return cout，将输出流cout的现状返回，即保留输出流的现状，目的是连续向输出流插入信息 123cout&lt;&lt;c3&lt;&lt;c2;//即(cout&lt;&lt;c3)&lt;&lt;c2; 执行(cout&lt;&lt;c3)的结果就是具有新内容的流对象cout，因此(cout&lt;&lt;c3)&lt;&lt;c2相当于cout(新值)&lt;&lt;c2,现在理解为什么C++规定运算符&lt;&lt;重载函数的第一次参数和函数的类型必须是ostream类型的引用了吧！就是为了返回cout当前值以便连续输出 重载流提取符&gt;&gt; C++预定义的运算符&gt;&gt;的作用是从一个输入流中提取数据，如cin&gt;&gt;i,表示从输入流中提取一个整数赋给变量i。重载流提取符的目的是希望将&gt;&gt;用于输入自定义类型的对象的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,Complex&amp;); //运算符&lt;&lt;重载为友元函数 friend istream&amp;operator&gt;&gt;(istream&amp;,Complex&amp;); //运算符&gt;&gt;重载为友元函数private: double real; double imag;};Complex Complex::operator+(Complex &amp;c2){ return Complex(real+c2.real,imag+c2.imag);}ostream&amp;operator&lt;&lt;(ostream&amp;output,Complex&amp;c){ if(c.imag&gt;=0) output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;'+'&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; else output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; return output;}istream&amp;operator&gt;&gt;(istream&amp;input,Complex&amp;c){ cout&lt;&lt;&quot;Input real part and imaginary part of complex number:&quot;; input&gt;&gt;c.real&gt;&gt;c.imag; return input;}int main(){ Complex c1,c2; cin&gt;&gt;c1&gt;&gt;c2; cout&lt;&lt;&quot;c1=&quot;&lt;&lt;c1; cout&lt;&lt;&quot;c2=&quot;&lt;&lt;c2;} 2.3.7赋值运算符重载 C++至少给一个类添加四个函数： 1.默认构造函数2.默认析构函数3.默认拷贝构造函数4.赋值运算符operator=,对属性值进行拷贝 如果不对赋值运算符进行重载，在堆区开辟内存了的类，如果进行p1=p2赋值运算，在销毁时可能会发生堆区内存重复释放12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class Person{public: Person(int a) { //new在堆区开辟内存存放数字，返回地址 agePointer = new int(a); } //在堆区开辟的内存，需要程序员自行销毁 ~Person() { //需要先判断是否指向空，因为如果指向空，不能对该指针进行detele操作 //增强程序健壮性 if (agePointer!= NULL) { delete agePointer; agePointer= NULL; } } int*agePointer;};void func(){ Person p1(10), p2(20); p1 = p2; 函数执行完后p1，p2均会调用析构函数对堆区中同一块内存 进行delete操作（重复释放），导致程序出错！}int main(){ func();} 对赋值运算符operator=进行重载12345678Person&amp; operator=(Person &amp;p) 返回引用以实现 p1=p2=p3{ 先将自己占用的内存释放干净 if (agePointer != NULL) delete agePointer; agePointer = new int(*p.agePointer); return *this;} 2.3.8 ==和!=运算符重载12345678910111213141516171819202122232425262728293031class Car{public: Car(string b, string l) { brand = b; licenseNum = new string(l); } ~Car() { if (licenseNum != NULL) { delete licenseNum; licenseNum = NULL; } } bool operator==(Car &amp;c) { if (this == &amp;c) return true; if (brand == c.brand &amp;&amp; *licenseNum == *c.licenseNum) return true; return false; } bool operator!=(Car c) { return !(*this == c); }private: string brand; string* licenseNum;}; 2.3.9 函数调用运算符（）重载由于重载后使用的方式非常像函数的调用，因此被成为仿函数仿函数没有固定的写法，非常灵活2.4不同类型数据间的转换 2.4.1标准数据类型间的转换 C++保留了C语言的强制转换方式(int)89.5,提倡C++提供的方法int(89.5) 2.4.2用构造函数进行不同类型数据的转换 转换构造函数的作用是将一个其他类型的数据转换成一个类的对象 回顾以前学过的几种构造函数： 默认构造函数 1Complex(); //没有参数 用于初始化的构造函数 1Complex(double r,double i); 用于复制对象的复制构造函数 1Complex(Complex &amp;c); //形参是本类对象的引用 现在要介绍一种新的构造函数——转换构造函数，转换构造函数只有一个形参，如 123Complex(double r){real=r;imag=0;}//这样就可以将一个double类型的数据 强制转换 为一个Complex类对象c=c1+Complex(2.5); //运算符+已重载 其作用是将double型的参数r转换成Complex类的对象，将r作为复数的实部，虚部为0。用户可以根据需要定义转换构造函数，在函数体中告诉编译系统怎样去进行转换 转换构造函数只能有一个参数，如果有多个参数的，它就不是转换构造函数!原因是显然的，如果有多个参数，那么究竟将哪个转换为Complex对象呢？ 不仅可以将一个标准数据类型转换为类对象，还可以将另一个类对象转换为 转换构造函数所在的类对象。如果，可以将一个学生类对象转换为教师类对象（学生毕业后当了老师），要求把某学生的编号、姓名、性别复制到一个教师类对象中，可以在Teacher类中写出如下的转换构造函数 1Teacher(Student&amp;s){num=s.num;strcpy(name,s.name);sex=s.sex;} 同时应注意，对象s中的num，name，sex必须是共用成员，否则不能被类外引用 2.4.3类型转换函数 类型转换函数的作用是将一个类的对象转换成另一个类型的数据。如果已声明了一个Complex类，可以在Complex类中这样定义类型转换函数： 12operator double(){return real;}x` 123456789101112131415161718class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i):real(r),imag(i){} operator double(){return real;} //定义类型转换函数private: double real; double imag;};int main(){ Complex c1(3,4),c2(5,-10),c3; double d; d=2.5+c1; //隐式地调用类型转换函数 cout&lt;&lt;d&lt;&lt;endl;} 注意，函数名是operator double,函数没有参数,其返回值的类型是由函数名中指定的类型名来确定的。类型转换函数只能作为成员函数，因为转换的主体是本类的对象。不能作为友元函数或普通函数。 double类型经过重载后，除了原有的含义外，还获得新的含义（将一个Complex类对象转换为double类型数据，并指定了转换方法）。这样，编译系统不仅能识别原有的double型数据，而且还会把Complex类对象作为double型数据处理。Complex类对象只有在需要的时候才进行转换，要根据表达式的上下文来确定 ！！！注意，重载运算符+的友元函数时，参数不能使用引用，否则会导致类型转换出错 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class Complex{public: Complex(){real=0;imag=0;} //默认构造函数，无形参 Complex(double r){real=r;imag=0;} //转换构造函数，一个形参 Complex(double r,double i){real=r;imag=i;} //实现初始化的构造函数，两个形参 friend Complex operator+(Complex c1,Complex c2); //重载运算符+的友元函数 //注意此处没有使用引用，如果使用引用会导致无法类型转换 void display();private: double real; double imag;};Complex operator+(Complex c1,Complex c2){ return Complex(c1.real+c2.real,c1.imag+c2.imag);}void Complex::display(){ cout&lt;&lt;'('&lt;&lt;real&lt;&lt;','&lt;&lt;imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl;}int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+2.5; //复数与double数据相加 c3.display();} 程序分析 如果没有定义转换构造函数，则此程序出错，因为没有重载运算符能使之将Complex类对象与double数据相加，由于c3是Complex类对象，必须设法将2.5转换为Complex类对象，然后与c1相加，再赋值给c3 现在，再类Complex中定义了转换构造函数，并具体规定了怎样构成一个复数。由于已经重载了运算符+，再处理表达式c1+2.5时，编译系统把他解释为 1operator+(c1,2.5); 由于2.5不是Complex类对象，系统先调用转换构造函数Complex(2.5),建立一个临时的Complex类对象，其值是(2.5+0i)。相当于 1operator+(c1,Complex(2,5)); 如果把c3=c1+2.5改为c3=2.5+c1，同样可以运行！ 结论 在已经定义了相应转换构造函数的情况下，将运算符+函数重载为友元函数，在进行两个复数相加时，可以用交换律 如果运算符函数重载为成员函数，它的第一个参数必须是本类的对象。交换律不适用！ 因此，一般情况下将双目运算符函数重载为友元函数，单目运算符则多重载为成员函数 1234567891011121314151617181920class Complex{public: Complex(){real=0;imag=0;} //默认构造函数，无形参 Complex(double r){real=r;imag=0;} //转换构造函数，一个形参 Complex(double r,double i){real=r;imag=i;} //实现初始化的构造函数，两个形参 operator double(){return real;} //类型转换函数，无形参 friend Complex operator+(Complex c1,Complex c2); //重载运算符+的友元函数 void display();private: double real; double imag;};...int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+2.5; //复数与double数据相加 c3.display();} 编译报错，原因是出现二义性，在处理c1+2.5时，一种理解是调用转换构造函数将2.5变成Complex类对象，然后调用运算符+重载函数，与复数c1进行相加。另一种理解是，调用类型转换函数，把c1转换为double型数，然后与2.5进行相加。系统无法判定，这二者是矛盾的。如果要使用类型转换函数，就应删去运算符+重载函数。 2.4 对象的初始化和清理2.4.1 构造函数的分类及调用三类：构造函数、拷贝构造函数、析构函数调用：1.括号法 123Person p1; 默认构造函数（注意不要加括号，否则会被认为是函数声明）Person p2(10); 有参构造函数Person p3(p2); 拷贝构造函数 2.显示法 1234Person p1;Person p2=Person(10); 有参构造Person p3=Person(p2); 拷贝构造注意事项：不要用拷贝构造函数初始化匿名对象：Person(p2); 3.隐式转换法 1Person p1=10; 系统会自动转换为Person p1=Person(10); 2.4.2 拷贝构造函数的调用时机1.使用一个已经创建完毕的对象来初始化一个新对象Person p2(p1);2.值传递的方式给函数参数传值 123void func(Student stu) {}函数体为空，参数为类对象，函数参数值传递相当于拷贝一份临时的数据，会调用拷贝构造函数 3.值方式返回局部对象 123456789101112Student returnValue() { Student stu; return stu; 此时并不是返回上面的stu本身，而是返回一份拷贝数据}int main() { Student stu = returnValue();}运行结果：默认构造函数调用拷贝构造函数调用析构函数调用析构函数调用 2.4.3构造函数调用规则默认情况下，C++编译器至少会给一个类添加三个函数1.默认构造函数（无参，类体为空）2.默认析构函数（无参，类体为空）3.默认拷贝构造函数，对属性值进行拷贝 构造函数调用规则如下：1.如果用户定义了有参构造函数，C++不再提供默认无参构造函数，但是会提供拷贝构造函数2.如果用户定义了拷贝构造函数，C++不再提供其他构造函数 2.4.4深拷贝与浅拷贝问题（面试常考）浅拷贝：简单的赋值拷贝操作(编译系统赠送的拷贝构造函数）深拷贝：在堆区重新申请空间，进行拷贝操作 浅拷贝存在的问题：可能造成堆区内存的重复释放 12345678910111213141516171819202122232425262728在此情况下，如果使用了浅拷贝的拷贝构造函数，将造成同一块内存区域的重复释放原因：浅拷贝简单地把在堆区开辟的内存的地址复制到新的对象中class Student{public: Student(int a,int h) { age=a; height=new int(h); 堆区开辟内存，使指针height指向该内存 } ~Student() { if(height!=NULL) { delete height; height=NULL: } }private: int age; int*height;};int main(){ Student stu1(22, 170); Student stu2(stu1); } 解决方法：自己实现拷贝构造函数 1234Student(const Student&amp; stu) { age = stu.age; height = new int(*stu.height);} 三、面向对象的程序设计 3.1继承与派生C++提供了类的继承机制，解决了软件重用问题 3.1.1继承与派生的概念 单继承：一个派生类只从一个基类派生 多重继承：一个派生类有两个或多个基类 派生类是基类的具体化，而基类则是派生类的抽象 3.1.2派生类的声明方式123class Student1:public Student{派生类新增加的成员}; 构造函数和析构函数不能从基类继承，因此应当自己定义派生类的构造函数和析构函数 只能覆盖，不能舍弃基类成员，可以在派生类中声明一个与基类成员同名的成员以覆盖（注意覆盖成员函数需要保持函数类型，参数个数，参数类型相同 3.1.3派生类成员的访问属性 公用继承：基类私有不可访问（即没有继承下来，要访问还得用基类的成员函数），其他保持原有不变 私有继承：基类私有不可访问，剩下的变为派生类的私有成员 基类的公用成员函数变成了派生类的私有成员函数，不能直接调用 123456789101112131415161718192021222324252627282930313233343536373839404142using namespace std;class Student{public: void get_value(){ cin&gt;&gt;num&gt;&gt;name&gt;&gt;sex;} void display() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;&quot;sex:&quot;&lt;&lt;sex&lt;&lt;endl; }private: int num; string name; char sex;};class Student2:private Student //私有继承{public: void get_value_1() { get_value(); //基类的公用函数被私有继承为私有函数，故只能通过基类函数调用它 cin&gt;&gt;age&gt;&gt;addr; } void display_1() { display(); cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl&lt;&lt;&quot;address:&quot;&lt;&lt;addr&lt;&lt;endl; }private: int age; string addr;};int main(){ Student2 stu; stu.get_value(); //错误！基类的公用函数已被私有继承为私有函数，不能直接调用 stu.get_value_1(); //正确，这是派生类的函数，通过其调用基类的共有成员函数} 受保护的继承：基类私有成员不可访问，剩下的变成派生类的受保护的成员（外界不可访问，如用xx.num) 保护继承的特点：保护基类的公有成员和保护成员都在派生类中成了保护成员，其私有成员仍未基类私有，也就是把基类原有的公有成员也保护了起来，不让类外任意访问 总之，基类私有不可被派生类访问，只能通过基类的成员函数来引用 实际中，公用继承用的最多，私有继承和保护继承方式用的很少，只需了解以便阅读别人写的程序时能理解 3.1.4派生类的构造函数 简单的派生类的构造函数 12345678910111213141516171819202122232425262728class Student{public: Student(int n,string nam,char s):num(n),name(nam),sex(s){} ~Student(){}protected: int num; string name; char sex;};class Student1:public Student{public: Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } void show() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;address:&quot;&lt;&lt;addr&lt;&lt;endl; } ~Student1(){}private: int age; string addr;}; 注意派生类的构造函数，Student(n,nam,s)不需要写类型，因为相当于把前面传进来的参数摘给后边 12345Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } 如果在类内声明，类体外定义则不需写Student(n,nam,s) 12345678//类内Student1(int n,string nam,char s,int a,string ad);//类外定义Student1::Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } 还可以直接使用常量或全局变量 1Student1(int n,string nam,char s,int a,string ad):Student(10010,nam,s) 也可以用参数初始化表 1Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s),age(a),addr(ad){} 执行构造函数和析构函数的顺序： 派生类构造函数先调用基类构造函数 再执行派生类构造函数本身（即派生类构造函数的函数体），上述例中：先初始化num,name,sex再初始化age,addr 在派生类对象释放时，先执行派生类析构函数，再执行基类析构函数 有子对象的派生类的构造函数 指的是成员中含有对象的对象 123456789101112131415//基类中Student(int n,string nam):num(n),name(nam){}//派生类中public: Student1(int n,string nam,int n1,string nam1,int a,string ad) :Student(n,nam),monitor(n1,nam1)//派生类构造函数 { age=a; addr=ad; }...private: Student monitor; //私有成员中含有类对象 int age; string addr; 派生类构造函数的任务包括三个部分 对基类数据成员的初始化 对子对象数据成员的初始化 对派生类数据成员初始化 3.1.5多层派生时的构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student{public: Student(int n,string nam):num(n),name(nam){} void display() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; }protected: int num; string name;};class Student1:public Student{public: Student1(int n,string nam,int a):Student(n,nam) { age=a; } void show() { display(); cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl; }private: int age;};class Student2:public Student1{public: Student2(int n,string nam,int a,int s):Student1(n,nam,a) { score=s; } void show_all() { show(); cout&lt;&lt;&quot;score:&quot;&lt;&lt;score&lt;&lt;endl; }private: int score;}; 3.1.6派生类构造函数的特殊形式 不需要对派生类新增的成员进行任何初始操作时，派生类构造函数的函数体可以为空 1Student2(int n,string nam,int a,int s):Student1(n,nam,a){} 另一种怪麻烦的，请查谭浩强C++第三版P356页 3.1.7继承后子类是否保留父类数据 子类中所有非静态成员变量都会保留到子类中* 123456789101112131415161718192021class Father{public: int a;protected: int b;private: int c;};class Son :public Father{public: int d;};int main(){ cout &lt;&lt; &quot;Son的大小是&quot; &lt;&lt; sizeof(Son) &lt;&lt;&quot;字节&quot;&lt;&lt; endl; 输出结果是16字节，说明子类完全地保留了父类的数据} 使用VS自带的工具开发者命令提示工具可以查看类的结构 1.找到文件路径，输入如下命令D:\\Codes\\VisualStudioProjects\\Project01\\继承后的父类数据是否拷贝&gt;cl /d1 reportSingleClassLayoutSon 源.cpp 123456789class Son size(16): +--- 0 | +--- (base class Father) 0 | | a 4 | | b 8 | | c | +---12 | d +--- 3.1.8继承中的构造和析构顺序创建一个子类对象，其中构造函数和析构函数的顺序如下：1.父类构造函数2.子类构造函数3.子类析构函数4.父类析构函数面试题：创建一个子类对象会不会有父类对象的创建？答：有！ 3.1.9继承中的同名成员处理加上作用域::即可。注意一下情形：子类中的同名函数会隐藏掉父类中所有同名函数（包括所有重载形式）需要加作用域才能调用 继承同名静态成员的处理方式：1.同名静态数据成员（编译阶段分配内存，类内声明，类外初始化）2.同名静态成员函数处理方式仍然是加上父类作用域以访问父类静态成员有两种方式:1.Father::num2.Son::Father::num 3.2多重继承(multiple inheritance)实际开发中不建议使用多继承 3.2.1多重继承的声明12class D:public A,private B,protected C{类D新增加的成员} 3.2.2多重继承派生类的构造函数12Graduate(string nam,int a,char s,string t,float sco,float w): Teacher(nam,a,t),Student(nam,s,sco),wage(w){} 3.2.3多重继承引起的二义性问题 第一种情况：两基类有同名成员 加上限定符即可，如c1.A::display(); 若在派生类C中的成员函数访问基类A的display,则A::display(); 第二种情况：两个基类和派生类三者都有同名成员，即有3个display函数 答案时：会产生覆盖，基类的同名函数（注意要保持函数类型、参数个数、参数类型相同，否则就是重载）被派生类函数覆盖 如果类A和类B是从同一个基类N派生的 应该加上限定符A::或B::,如c1.A::a=3;c1.A::display();//要访问的是类N的派生类A中的基类成员 3.3解决菱形继承问题——虚基类菱形继承：子类继承两份相同的数据，导致资源浪费以及含义的冲突（如年龄） 3.3.1虚基类的作用C++提供虚基类virtual base class的方法，使得在继承简介共同基类时只保留一份成员 12345graph LRA[A] -- 派生 --&gt; B[B]A --派生--&gt; C[C]B --派生--&gt; D[D]C --派生--&gt; D 现在将类A声明为虚基类，虚基类是在声明派生类时，指定继承方式时声明的！ 123456class A{...};class B:virtual public A{...};class C:virtual public A{...}; 3.3.2虚基类的初始化如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类（包括直接派生类和间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类进行初始化，因为只有一份数据，如果由B和C分别初始化，会造成数据不一致发生矛盾 123456789101112class A{A(int i){} //基类构造函数，有一个参数..}class B:virtual public A{B(int n):A(n){}...};class C:virtual public A{C(int n):A(n){}...};class D:public B,public C{D(int n):A(n),B(n),C(n){} //D类构造函数，在初始化表中对所有基类初始化...} C++编译器只执行最后的派生类对虚基类的构造函数的调用，忽略其他的，保证虚基类的数据成员不会被多次初始化多重继承容易产生二义性问题，如果能用单一继承解决得问题不要使用多重继承 3.3.3基类与派生类的转换 派生类对象可以向基类对象赋值，相反则不可以 派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化 12345假设已定义Point类，和派生类CircleCircle c(1,2,3);//输出的是半径为3的圆Point&amp;p=c; //p和c共享 基类Point那一段存储空间此时p是c的部分引用，注意是部分！p共享c的基类那一部分存储空间，故cout&lt;&lt;p; //输出的是(1,2)点信息 如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象 12345如有一函数funvoid fun(A&amp;r) //形参是A类对象的引用{cout&lt;&lt;r.num&lt;&lt;endl;} //输出该引用中的数据成员num//在调用fun函数时可以用派生类B的对象b1作实参fun(b1); 指向基类对象的指针变量也可以指向派生类对象，但通过指向基类对象的指针只能访问派生类中的基类成员，而不能访问派生类增加的成员 3.4继承与组合123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;class Teacher{public: Teacher(int n,string nam,char s):num(n),name(nam),sex(s){} void display() { cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name=&quot;&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;&quot;sex=&quot;&lt;&lt;sex&lt;&lt;endl; }private: int num; string name; char sex;};class BirthDate{public: BirthDate(int y,int m,int d):year(y),month(m),day(d){} void display() { cout&lt;&lt;year&lt;&lt;'/'&lt;&lt;month&lt;&lt;'/'&lt;&lt;day&lt;&lt;endl; }private: int year; int month; int day;};class Professor:public Teacher{public: Professor(int n,string nam,char s,int y,int m,int d) :Teacher(n,nam,s),birthday(y,m,d){} void show() { Teacher::display(); //对同名函数加上限定符 birthday.display(); }private: BirthDate birthday;}; 3.5多态性与虚函数3.5.1多态性的概念多态的实质：父类引用指向子类对象多态性：向不同的对象发送同一消息，不同的对象在接收时会产生不同的行为（即方法），分为静态多态性和动态多态性。 静态多态性的应用即函数的重载和运算符重载,编译阶段确定函数地址 动态多态性的特点是：在程序运行过程中动态地确定操作所针对的对象，又称运行时的多态性，是通过虚函数来实现的。运行阶段确定函数地址3.5.2静态多态性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104using namespace std;class Point //点类{public: Point(float x=0,float y=0); void setPoint(float,float); float getX()const{return x;} //读x坐标，getX函数为常成员函数 float getY()const{return y;} //读y坐标，getY函数为常成员函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Point&amp;);//友元重载运算符&lt;&lt;protected: float x,y;};Point::Point(float a,float b){ x=a;y=b;}void Point::setPoint(float a,float b){ x=a;y=b;}ostream&amp;operator&lt;&lt;(ostream&amp;output,const Point&amp;p) //重载运算符&lt;&lt;，使之能输出点的坐标{ output&lt;&lt;'['&lt;&lt;p.x&lt;&lt;','&lt;&lt;p.y&lt;&lt;']'&lt;&lt;endl; return output;}//派生类Circleclass Circle:public Point{public: Circle(float x=0,float=0,float=0);//带默认参数的构造函数 void setRadius(float); //设置半径值 float getRadius()const; //读取半径值 常成员函数不能修改数据 float area()const; //计算圆面积 设置为常成员函数不能修改数据 friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Circle &amp;); //重载运算符&quot;&lt;&lt;&quot;,使之能输出Circle类对象protected: float radius;};//定义构造函数，对圆心坐标和半径初始化Circle::Circle(float a,float b,float r):Point(a,b),radius(r){}//设置半径void Circle::setRadius(float r){ radius=r;}//读取半径值float Circle::getRadius()const{ return radius;}//计算面积float Circle::area()const{ return 3.14159*radius*radius;}//重载运算符“&lt;&lt;&quot;，使之能按规定的形式输出圆的信息ostream&amp;operator&lt;&lt;(ostream&amp;output,const Circle&amp;c){ output&lt;&lt;&quot;Center=[&quot;&lt;&lt;c.x&lt;&lt;','&lt;&lt;c.y&lt;&lt;&quot;],r=&quot;&lt;&lt;c.radius&lt;&lt;&quot;,area=&quot;&lt;&lt;c.area()&lt;&lt;endl; return output;}//Cylinder是Circle的公用派生类（圆柱体）class Cylinder:public Circle{public: //带默认参数的构造函数，若对应数据项不输入则取默认值 Cylinder(float=0,float=0,float=0,float=0); //构造函数初始化 /*Cylinder(float a,float b,float r,float h) :Circle(a,b,r),height(h){} 定义了全部都是默认参数的构造函数后不能再重载构造函数，否则会发生矛盾*/ void setHeight(float h){height=h;} float getHeight()const{return height;} float volume()const; friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Cylinder&amp;); //运算符重载只能声明为友元函数，申明为成员函数默认参数为本类对象private: float height;};Cylinder::Cylinder(float a,float b,float r,float h):Circle(a,b,r){height=h;}ostream&amp;operator&lt;&lt;(ostream&amp;output,const Cylinder&amp;c){ output&lt;&lt;'['&lt;&lt;c.x&lt;&lt;','&lt;&lt;c.y&lt;&lt;&quot;],r=&quot;&lt;&lt;c.radius&lt;&lt;&quot;,height=&quot;&lt;&lt;c.height&lt;&lt;&quot;,volume=&quot;&lt;&lt;c.volume()&lt;&lt;endl;}float Cylinder::volume()const{ return area()*height;}int main(){ Cylinder c; cout&lt;&lt;c; Circle&amp;cir=c; //此时cir部分引用Cylinder类对象c， cout&lt;&lt;cir; //输出的是c的Circle基类部分 Point&amp;po=c; cout&lt;&lt;po;} 3.5.3利用虚函数实现动态多态性所谓虚函数就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。在程序运行期间，用指针指向某一派生类对象，这样就能调用指针指向的派生类对象中的函数，而不会调用其他派生类中的函数。注意：虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。虚函数的使用方法是： 在基类中用virtual声明成员函数为虚函数。在类外定义虚函数时不必再加virtual 在派生类中重新定义此函数，函数名、函数类型、参数个数和类型必须与基类的虚函数相同，根据派生类的需要重新定义函数体。当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时可以加virtual，也可以不加。但是习惯上一般在每一层声明该函数时都加virtual，使程序更清晰。 定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。 通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数 123456Student stud1(1001,&quot;Li&quot;,99); Graduate grad1(2001,&quot;Wang&quot;,98,1200); Student*pt=&amp;stud1; pt-&gt;display(); pt=&amp;grad1; //指向基类对象类型的指针，直接修改指向 pt-&gt;display(); 未定义虚函数时，结果是： 1234567num:1001name:Liscore:99num:2001name:Wangscore:98 //调用了基类对象的display()函数 定义虚函数后，结果是： 12345678num:1001name:Liscore:99num:2001name:Wangscore:98wage=1200 //调用了子类对象的display()函数 3.5.4在什么情况下应当声明虚函数 使用虚函数需要注意以下两点 不能将类外的普通函数声明为虚函数 一个成员函数被声明为虚函数后，在同一类族中的类就不能再定义一个非virtual得但与该虚函数具有相同得参数和函数返回值类型得同名函数 根据什么考虑把一个成员函数声明为虚函数 首先看成员函数所在的类是否会作为基类。然后看成员函数再类的继承后有无可能被更改功能，如果希望其更改功能的，一般应声明为虚函数 如果成员函数在类被继承后功能无需修改，或在派生类中用不到该函数，则不要把他声明为虚函数。 应考虑对成员函数的调用是通过对象名还是通过基类指针或引用去访问，如果是通过基类指针或引用去访问，则应当声明为虚函数。‘ 有时，在定义虚函数时，并不定义其函数体，即函数体是空的。它的作用只是定义了一个虚函数名，具体功能留给派生类去添加。 需要说明的是：使用虚函数，系统有一定的时空开销。当一个类带有虚函数时，编译系统会为该类构造一个虚函数表(virtual function table，简称vtable)，它是一个指针数组，存放每个虚函数的入口地址，系统在进行动态关联时的时间开销是很小的，因此，多态性是高效的。 3.5.5虚析构函数析构函数的作用是在对象撤销之前做必要的“清理现场”的工作。当派生类的对象从内存中撤销时，一般先调用派生类的析构函数，然后调用基类的析构函数。但是如果用new运算符建立了临时对象，若基类中有析构函数，并且定义了一个指向该基类的指针变量。在程序中用delete运算符撤销对象时，会发生一个情况：系统只会执行基类的析构函数，而不执行派生类的析构函数。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Point{public: Point(){} ~Point(){cout&lt;&lt;&quot;Executing Point destructor&quot;&lt;&lt;endl;}};class Circle:public Point{public: Circle(){} ~Circle(){cout&lt;&lt;&quot;executing Circle destuctor&quot;&lt;&lt;endl;}private: int radius;};int main(){ Point*p=new Circle; delete p;} 此时，执行结果是：Executing Point destructor只调用了基类的析构函数。如果希望能执行派生类circle的析构函数，可以将基类中的析构函数声明为虚函数 1virtual~Point(){cout&lt;&lt;&quot;Executing Point destructor&quot;&lt;&lt;endl;} 此时执行结果便是executing Circle destructorExecuting Point destructor 虚构函数的概念和用法很简单，但它在面向对象程序设计中是很重要的技巧。专业人员一般都习惯声明虚析构函数，即使基类并不需要析构函数，也显式地定义一个函数体为空的虚析构函数，以保证在撤销动态分配空间时能得到正确的处理。 构造函数不能声明为虚函数。因为在执行构造函数时类对象还未完成建立过程，当然谈不上把函数与类对象的绑定。3.5.6多态的原理剖析多态的原理：用虚函数表来实现的声明了虚函数的类中，会添加一个vfptr虚函数表指针，指向自己的虚函数表vftable我们使用vs开发人员命令提示符查看该类的结构,结果如下：类的代码1234567class Animal{public: virtual void sound() { cout &lt;&lt; &quot;动物叫~&quot; &lt;&lt; endl; }}; 查看结果1234567891011class Animal size(4): +--- 0 | {vfptr} +---Animal::$vftable@: | &amp;Animal_meta | 0 0 | &amp;Animal::sound //记录下虚函数入口地址Animal::sound this adjustor: 0 如果子类没有重写父类方法，子类结构：1234567891011class Cat size(4): +--- 0 | +--- (base class Animal) 0 | | {vfptr} | +--- +---Cat::$vftable@: | &amp;Cat_meta | 0 0 | &amp;Animal::sound //存放的是父类sound函数的入口地址 重写父类方法后，子类结构：1234567891011class Cat size(4): +--- 0 | +--- (base class Animal) 0 | | {vfptr} | +--- +---Cat::$vftable@: | &amp;Cat_meta | 0 0 | &amp;Cat::sound 3.6纯虚函数与抽象类3.6.1纯虚函数 声明纯虚函数pure virtual function 1virtual float area(参数列表)const=0;//只需在虚函数声明后再加=0，const不是必要 纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：我在这里声明了一个虚函数，留待派生类中定义。3.6.2抽象类不用来定义对象，而只作为一种基本类型用作继承的类，成为抽象类abstract class)，由于它常用作基类，通常称为抽象基类abstract base class。凡是包含纯虚函数的类都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类无法建立对象，抽象类的作用是作为一个类族的共同基类，或者说为一个类族提供一个公共接口。 *继承抽象类的子类如果不对所有的纯虚函数进行重写，那么它也是一个抽象类，不能实例化。好多的面向对象的系统，其层次结构的顶部是一个抽象基类，甚至顶部有好几层都是抽象类。如果在抽象类所派生出的新类中对基类的所有纯虚函数进行了定义，那么这些函数就被赋予了功能，可以被调用。这个派生类就成为了具体类**concrete class。虽然抽象类不能定义对象（或者说抽象类不能实例化），但是可以定义指向抽象类数据的指针类型。当派生类成为具体类后，就可以用这种指针指向派生类对象，然后通过调用虚函数，实现多态性的操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;class AbstractMakeDrink{public: virtual void spoilWater() = 0; virtual void putIn() = 0; virtual void addThings() = 0;};class makeTea :public AbstractMakeDrink{public: void spoilWater() { cout &lt;&lt; &quot;正在为茶烧开水&quot; &lt;&lt; endl; } void putIn() { cout &lt;&lt; &quot;将茶放入开水中&quot; &lt;&lt; endl; } void addThings() { cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl; }};class makeCoffee :public AbstractMakeDrink{public: void spoilWater() { cout &lt;&lt; &quot;正在为咖啡烧开水&quot; &lt;&lt; endl; } void putIn() { cout &lt;&lt; &quot;将咖啡放入开水中&quot; &lt;&lt; endl; } void addThings() { cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl; } };void makeDrinks(AbstractMakeDrink* ptr){ ptr-&gt;spoilWater(); ptr-&gt;putIn(); ptr-&gt;addThings(); delete ptr;}void test(){ makeDrinks(new makeCoffee); cout &lt;&lt; &quot;=======================&quot; &lt;&lt; endl; makeDrinks(new makeTea);}int main(){ test();} 3.6.3虚析构与纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码解决方式：将父类中的析构函数改为虚析构函数或纯虚析构函数二者共性： 1.可以解决父类指针释放子类对象2.都需要有具体的函数来实现 虚析构和纯虚析构的区别：如果是纯虚析构，那么该类属于抽象类，无法实例化 虚析构语法:virtual ~类名(){}纯虚析构语法:virtual~类名()=0;类名::~类名(){}同时需要具体实现！否则报错 说白了虚析构的作用，就是弥补多态不能调用子类析构函数的的缺陷（父类中如果不写虚析构或纯虚析构，那么多态下是不会执行子类析构代码的） 总结：1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构3.拥有虚析构的类是抽象类，不饿能实例化 四、文件操作C++中对文件进行操作需要包含头文件&lt;fstream&gt; 文件分为两种类型：1.文本文件：文件以文本的ASCII码形式存储在计算机中2.二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂 操作文件的三大类：1.ofstream:写操作2.ifstream:读操作3.fstream：读写操作 4.1文本文件4.1.1写文件写文件步骤：1.包含头文件#include&lt;fstream&gt;2.创建流对象ofstream ofs;3.打开文件ofs.open(&quot;文件路径&quot;,打开方式);4.写数据ofs&lt;&lt;&quot;写入的数据&quot;&lt;&lt;endl;5.关闭文件ofs.close(); 文件打开方式| 打开方式 | 解释 || ————————————————- | —————————- || ios::in | 读文件 || ios::out | 写文件 || ios::ate | 初始位置：文件尾 || ios::app | 追加方式写文件 || ios::trunc | 如果文件存在，先删除，再创建 || ios::binary | 二进制方式 || 注意：文件打开方式可以配合使用，利用操作符| | | 4.1.2读文件常用于比赛的文件读入：重定向cin 123456789101112#include&lt;iostream&gt;using namespace std;int main() { freopen(&quot;d:\\\\test.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;d:\\\\test2.txt&quot;, &quot;wa&quot;, stdout); char c; while(cin&gt;&gt;c){ cout&lt;&lt;c; } return 0;} 下面是正常的方法 读文件步骤：1.包含头文件#include&lt;fstream&gt;2.创建流对象ifstream ifs;3.打开文件ifs.open(&quot;文件路径&quot;,打开方式);4读数据：四种方式读取5.关闭文件ofs.close(); 四种方式案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;void test01(){ ofstream ofs; ofs.open(&quot;ForMyBaby.txt&quot;, ios::out); ofs &lt;&lt; &quot;亲爱的宝宝&quot;&lt;&lt;endl&lt;&lt;&quot;我想你啦&quot;; ofs.close();}void readFileWay1(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; } char buf[1024] = { 0 }; while (ifs &gt;&gt; buf) //一次读一行，读到整个文件末尾返回false { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay2(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } char buf[1024] = { 0 }; while (ifs.getline(buf, sizeof(buf))) { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay3(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } string buf; while (getline(ifs, buf)) { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay4(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } char c; while ((c = ifs.get()) != EOF)//end of file { cout &lt;&lt; c; } ifs.close();} 4.2二进制文件的读写123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class Phone{public: char brand[64]; int price;};void writeBinary(){ ofstream fs(&quot;BinaryFile.txt&quot;, ios::out|ios::binary); Phone apple = { &quot;Apple&quot;,5888 }; fs.write((const char*)&amp;apple, sizeof(apple)); fs.close();}void readBinary(){ ifstream fs(&quot;BinaryFile.txt&quot;, ios::out | ios::binary); if (!fs.is_open()) { cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl; return; } Phone p; fs.read((char*)&amp;p, sizeof(Phone)); cout &lt;&lt; &quot;手机品牌:&quot; &lt;&lt; p.brand &lt;&lt; &quot;,手机价格:&quot; &lt;&lt; p.price &lt;&lt; endl; fs.close();}int main(){ writeBinary(); readBinary();} 五、泛型编程C++另一种编程思想成为泛型编程，主要利用的技术就是模板C++提供两种模板机制：函数模板和类模板 5.1函数模板函数模板语法 12template&lt;typename T&gt; 其中typename可以用class代替函数声明或定义","link":"/2020/01/05/C-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java高级","text":"1.多线程1.1 基本概念：程序、进程、线程程序：一段静态的代码进程：正在运行的程序，是资源分配的基本单位。线程：是CPU执行和调度的最小单位，每个线程拥有独立的运行栈和程序计数器pc，线程切换的开销比较小。多个线程共享一个进程的资源（共享进程的方法区和堆，但存在安全隐患）。 在Java的内存区域中，栈区（虚拟机栈）和程序计数器是每个线程一份，方法区和堆区，是每个进程一份，各个线程共享。 使用多线程的优点1.资源利用率提升，程序处理效率提高2.改善程序结构，代码会相对简单3.软件运行速度提升，提升应用程序的响应速度 何时需要多线程1.程序需要同时执行两个或多个任务2.程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等3.需要一些后台运行的程序时 Java程序至少有3个线程1.主线程2.垃圾回收线程3.异常处理线程（会影响主线程） 1.2 线程的创建和使用Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 Thread类的特性1.每个线程都是通过特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run()3.Thread类实现了Runnable接口 start方法作用1.启动当前线程2.调用当前线程的run方法 注意1.不能通过调用run方法来启动线程（仍然在主线程中执行）2.额外再启动一个线程，需要重新创建一个线程的对象 两种创建线程的方法1.继承Thread类，重写run方法2.实现Runnable接口，实现run方法，在Thread构造器中传入一个Runnable接口实现对象 两种创建线程方法的比较开发中，优先选择Runnable接口的方法1.实现的方式没有类单继承性的限制2.实现的方式更适合来处理多个线程共享数据的情况 注意，这里ticket没有加static，就实现了三个线程共享ticket 1234567891011121314151617181920212223242526class Sell implements Runnable { private int ticket = 100; @Override public void run() { while (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖&quot; + ticket + &quot;号票&quot;); ticket--; } }}/* * 死锁的四个必要条件 * 1.互斥访问：共享资源互斥访问 * 2.请求并保持：已经持有资源的情况下，申请别的资源未果，也不释放自己持有的资源（站在自己角度） * 3.不可剥夺：进程申请的资源除了完成任务释放，别人无法将其释放（站在别人角度） * 4.循环等待：系统中存在资源循环等待的链条*/public class Demo { public static void main(String[] args) { Sell sell = new Sell(); new Thread(sell).start(); new Thread(sell).start(); new Thread(sell).start(); } Thread类常用方法1.void start()：启动当前线程；调用当前线程的run()2.run()：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中3.String getName()4.void setName()5.static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。6.yield()：释放cpu的执行权（有可能紧接着又获取了cpu的执行权）7.h.join()：在线程a中执行h.join()，会阻塞当前线程a，直到h线程执行完，线程a才结束阻塞状态8.stop()：强制线程生命周期结束，deprecated 不推荐使用，因为不安全，过时的api9.static void sleep(long millis)：睡眠(阻塞)若干毫秒；静态方法，可以直接调用。注意：如果是在run方法中使用sleep，则处理sleep的异常只能try-catch，无法throws；因为是重写Thread的run方法，其并无异常抛出，故子类重写也无法抛出异常。10.bool isAlive()：判断当前线程是否存活（是否执行完了），阻塞状态下返回值也是true。 获取线程名称Thread.currentThread().getName(); 更改线程名称1.通过Thread.currentThread().setName();2.通过构造器 123456789class MyThread extends Thread{ public MyThread(String name){ super(name); } public static void main(String[] args) { Thread t1=new MyThread(&quot;一号线程&quot;); }} 使用匿名对象执行开启线程 12345678new Thread(){ private int count=0; @Override public void run(){ while(true) System.out.println(count++); } }.start(); 1.3 线程的调度 Java的调度方法 1.同优先级线程组成先进先出队列（先到先服务），使用时间片策略2.对于高优先级，使用优先调度的抢占式策略 线程的优先级 1.线程的优先级等级：MAX_PRIORITY:10,MIN_PRIORITY:1,NORM_PRIORITY:52.获取和设置当前线程的优先级：getPriority(),setPriority(int p) 注意：并不是优先级高的执行完再执行优先级低的，而是优先级高的获取CPU的概率更高 1.4 线程的分类在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆： 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。下面的方法就是用来设置守护线程的。 1234567Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 1.5 线程的生命周期 1.6 线程的同步线程同步，主要用来解决线程的安全问题。 例：创建三个线程卖票，总共100张1.问题：卖票过程中，出现了重票、错票（0，-1号票）–&gt;出现了线程的安全问题2.问题出现的原因：某线程操作车票时，别的线程也参与进来3.如何解决：某线程操作车票时，即使出现阻塞（例如sleep(100);)，别人也不能参与进来。4.在Java中，我们通过同步机制，来解决线程的安全问题 解决方式 同步代码块a.同步监视器（又叫锁）：任何一个对象都可以作为锁；要求多个线程必须要共用同一把锁。b.同步原理：当一个线程执行代码碰到一个锁时，如果已经有别的线程使用了锁并且没有归还，那么本线程就阻塞在这里。 继承Thread方式 1234567891011121314151617181920212223242526public class p1 { public static void main(String[] args) { Sell s1 = new Sell(); Sell s2 = new Sell(); Sell s3 = new Sell(); s1.start(); s2.start(); s3.start(); }}class Sell extends Thread { public static int ticket = 10000; @Override public void run() { while (true) { synchronized(Sell.class) { if (ticket &gt; 0) { System.out.println(getName() + &quot;出售第&quot; + ticket + &quot;张票&quot;); ticket--; } else break; } } }} 这里的Sell.class充分说明了，在Java中类也是对象 实现Runnable接口方式 1234567891011121314151617181920212223242526public class p2 { public static void main(String[] args) { Sell2 sell=new Sell2(); Thread t1=new Thread(sell); Thread t2=new Thread(sell); Thread t3=new Thread(sell); t1.start(); t2.start(); t3.start(); }}class Sell2 implements Runnable { private int ticket=10000; @Override public void run() { while(true){ synchronized(this){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); else break; } } }} 同步方法如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。 实现Runnable接口方式 1234567891011121314151617181920212223242526272829public class p3 { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; @Override public void run() { while (ticket &gt; 0) { sell(); } } private synchronized void sell() { if (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); } }} 继承Thread方式，注意这里的sell方法必须要加static，否则会出现安全问题（不加static，同步方法所用的锁，不是同一个） 同步方法不加static，使用的是this作为锁。加了static，使用的是类名.class作为锁 1234567891011121314151617181920212223242526public class p4 { public static void main(String[] args) { Window4 w1=new Window4(); Window4 w2=new Window4(); Window4 w3=new Window4(); w1.start(); w2.start(); w3.start(); }}class Window4 extends Thread{ private static int ticket=10000; @Override public void run(){ while(ticket&gt;0) //这里可能会出现卖第0张票的情况 sell(); } private static synchronized void sell(){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); }} 使用同步锁1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t3.setName(&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); if (ticket &gt; 0) System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); else break; } finally { /*保证无论发生什么特殊情况，一定能够释放锁*/ lock.unlock(); } } }} 可重入锁 ReentrantLock 1一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；如果有两个不同的方法用到同一个锁，其中方法A里面又调用了方法B，那就不会死锁了 面试题：synchronized和Lock的区别？synchronized在执行完同步代码以后，自动释放同步监视器Lock方式手动加锁和释放锁，更加灵活。 1.7 改造懒汉单例模式使之线程安全**注意，写了两次判断instance==null**，这样效率最高。只在首次访问的时候进行同步，后续已经有instance的情况下无需同步，直接返回instance，最大化效率。 1234567891011121314151617181920//单例模式之懒汉式class Tool { private static Tool instance = null; //私有化构造方法 private Tool() { } public static Tool getInstance() { if (instance == null) { synchronized (Tool.class) { if (instance == null) instance = new Tool(); } } return instance; }} 1.8 线程的死锁问题死锁：1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续（操作系统中学到的定义：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，这些永远都在互相等待的进程，称为死锁进程） 解决方法1.专门的算法、原则2.尽量减少同步资源的定义3.尽量避免嵌套同步 死锁发生的四个必要条件1.互斥：共享资源互斥访问2.请求并保持：进程请求资源未果，不会释放自身已经占有的资源3.不可剥夺：只有进程自身使用完资源后才会释放，别人无法将其释放4.循环等待：多个进程之间存在资源请求的环路 预防死锁1.破坏请求并保持条件：一次性请求所有需要的资源，否则就不申请2.破坏不可剥夺条件：请求资源未果，释放自身占有的资源3.破坏循环等待条件：可用资源线性排序，只能从低到高申请资源 避免死锁银行家算法：已分配资源表、可用资源表、所需资源表；每次分配给一个能够满足其需求的进程，该进程执行完后返还所有的资源，不断循环。 1在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 预防死锁和避免死锁的区别预防死锁是通过破坏死锁发生的必要条件中的一个，限制条件比较严格，可能造成系统资源利用率和系统吞吐率的下降。避免死锁施加的条件比较宽松，在资源的动态分配中，避免系统出现不安全状态。 1.9 线程的通信例题：使用两个线程打印1~100。线程1，线程2交替打印 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r = new Count(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; @Override public void run() { while (true) { synchronized (this) { notify(); //或者this.notify, 如果用的是某个obj，则obj.notify if (num &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;数&quot; + num--); } else break; try { wait(); /*自我阻塞，wait会自动释放锁（与sleep的区别）*/ } catch (InterruptedException e) { e.printStackTrace(); } } } }} 涉及到的三个方法1.wait()：一旦执行此方法，当前线程就进入阻塞状态， 并释放同步监视器2.notify()：一旦执行此方法。就会唤醒被wait的一个线程。如果有多个，则唤醒优先级最高的3.notifyAll()：唤醒所有wait的线程 123补充：this.notify();//唤醒同步监视器等待池中的一个线程（放入锁池中，开始竞争锁）this.wait(); //当前线程停止执行，并释放锁，进入同步监视器的等待池中（不竞争锁） 说明1.wait(), notify(), notifyAll() 三个方法必须使用在同步代码块或者同步方法中2.三者的调用者必须是同步代码块或同步方法中的同步监视器，否则会报异常，不加调用者默认是this.3.三者是定义在java.lang.Object类中的 上述例题也可以使用公平锁来实现（存在一个等待队列，先进先出）,注意要使用finally来保证unlock的执行 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r=new Count(); Thread t1=new Thread(r); Thread t2=new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; ReentrantLock lock = new ReentrantLock(true);/*fair lock*/ @Override public void run() { while(true){ try{ lock.lock(); if(num&gt;0) System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num--); else break; } finally { lock.unlock(); } } }} 生产者消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Main { public static void main(String[] args) { Clerk clerk = new Clerk(); new Thread(new Consumer(clerk)).start(); new Thread(new Consumer(clerk)).start(); new Thread(new Producer(clerk)).start(); }}class Clerk { private int products = 0; public synchronized void produce() { //notity(); 也可以写这里 if (products &lt; 20) { System.out.println(&quot;生产者生产第&quot; + (++products) + &quot;个商品&quot;); this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void consume() { if (products &gt; 0) { System.out.println(&quot;消费者消费第&quot; + products-- + &quot;个商品&quot;); if (products &lt; 20) this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produce(); } }}class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consume(); } }} 这里有个疑问：如果把sleep写在两个同步方法中，while中只有调用，则会出现每次生产者生产满20个消费者才去消费，每次消费者消费完了生产者才开始生产。即每轮while循环结束同步方法都不释放锁。（在while中随意加入一个语句如print，则此现象消失，正常交替执行） 1.10 JDK5.0新增线程创建方式新增方式一：实现Callable接口与Runnable相比，Callable功能更强大1.相比run()方法，可以有返回值2.方法可以抛出异常（重写Runnable中的run不能抛出异常，因为Runnable接口中的run没有抛 ）3.支持泛型的返回值4.需要借助FutureTask类，比如获取返回值 123456789101112131415161718192021222324252627282930import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask futureTask = new FutureTask(count); new Thread(futureTask).start(); Object ans = null; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 使用泛型 12345678910111213141516171819202122232425public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(count); new Thread(futureTask).start(); int ans = 0; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable&lt;Integer&gt; { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 新增方式二：使用线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中的线程，不需要每次都创建）3.便于线程管理：corePoolSize核心池的大小maximumPoolSize最大线程数keepAliveTime 线程没有任务时最多保持多长时间后会终止 线程池相关API1.JDK5.0起提供了线程池相关API：ExecutorService和Executors2.ExecutorService 真正的线程池接口.常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令,没有返回值,一般用来执行Runnable &lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):执行任务,有返回值,一般用来执行Callable void shutdown():关闭连接池 3.Executors:工具类、线程池的工厂类,用于创建并返回不同类型的线程池 Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n):创建一个线程池,它可以安排在给定延迟后运行命令或者定期地执行 1234567891011121314151617181920212223242526272829303132333435363738public class Main { public static void main(String[] args) { /*Executors是线程池的工厂类*/ ExecutorService server= Executors.newFixedThreadPool(10); server.execute(new Count()); server.submit(new Calculate()); /*或者使用FutureTask包装Calculate()以获取线程返回值*/ FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Calculate()); server.submit(task); try { System.out.println(task.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }}class Count implements Runnable{ @Override public void run() { int i=0; while(i++&lt;100) System.out.print(i+&quot; &quot;); }}class Calculate implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;100;i++) sum+=i; return sum; }} 练习题 谈谈你对程序、进程、线程的理解 程序：一段静态代码进程：关于进程我想谈两点，一个是为什么需要进程这个概念，另一个是进程的作用。首先，现代操作系统的一大特点就是多道程序设计，那么在此之前是单道程序设计，一个程序运行时占有所有的资源，那么就无需资源的分配和调度，也就无需进程这个概念。到了多道程序设计中，多个程序并发执行，这就涉及到了系统资源的分配和调度，诸如CPU资源、存储资源、IO资源、文件资源，那么进程这个概念就应运而生。因此进程的作用有两大点，第一，它是资源分配和调度的基本单位。第二，它是程序独立运行的载体，保障程序正常执行。线程：线程是CPU调度的基本单位，多个线程之间共享进程的资源；线程包含在进程之中，是进程中实际运行工作的单位。 操作系统四大特性：虚拟、异步、共享、并发。2. 对比两种线程的创建方式3. sleep和wait方法的异同？相同点：都能使当前线程阻塞不同点：1.sleep声明在Thread类中，wait声明在Object类中 2.sleep()可以在任何地方使用，wait()需要在同步方法或者同步代码块中调用 3.如果都使用在同步代码块或者同步方法中，sleep方法不会释放锁，wait会释放锁 2.常用类2.1 字符串相关的类String类String特性1.String类:代表字符串.Java程序中,所有字符串的字面值(如”abc”)都是String类的实例2.String是一个final类,不可以继承3.字符串是常量,值在创建之后不可改变,字符内容是存储在一个字符数组value[]中的4.通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中5.字符串常量池(位于方法区中,后来改叫meta space)中是不会存储相同内容的字符串的String对象的创建1.字面量的方式,String str=&quot;abc&quot;;2.String s=new String()3.String s=new String(String s2)4.String s=new String(char[] arr)5.String s=new String(char[] arr,int startIndex, int count) 字符串常量池存储在字符串常量池,目的是共享; 字符串非常量的对象存储在堆中 面试题1:下面的p1.name==p2.name? 123456789101112131415public class Main { public static void main(String[] args) { Person p1 = new Person(&quot;yfx&quot;); Person p2 = new Person(&quot;yfx&quot;); System.out.println(p1.name == p2.name); //true 地址相同 }}class Person { String name; Person(String name) { this.name = name; }} 面试题2:String s=new String(&quot;abc&quot;); 在内存中创建了几个对象? 答:如果常量池中没有abc,则创建了两个,有的话则创建一个(现在常量池创建”abc”,然后在堆中创建一个String对象,内容fianl char[]value指向常量池的”abc”) 面试题3:下面几种字符串连接后,在内存中实际是怎么样的? 123456789101112131415161718192021public static void main(String[] args) { String s1 = &quot;java&quot;, s2 = &quot;docker&quot;; String s3=&quot;javadocker&quot;; String s4=&quot;java&quot;+&quot;docker&quot;; //编译阶段会直接合成&quot;javadocker&quot; String s5=s1+&quot;docker&quot;; String s6=&quot;java&quot;+s2; System.out.println(s3==s4); //true System.out.println(s3==s5); //false System.out.println(s3==s6); //false System.out.println(s5==s6); //false String s7=s5.intern(); //intern():如果常量池中没有s5的字符串值,那么就在常量池中创建该字符串常量,并返回其引用;如果常量池中已经有,则直接返回引用 System.out.println(s3==s7); //true final String s8=&quot;java&quot;; //final修饰的变成常量 String s9=s8+&quot;docker&quot;; System.out.println(s3==s9); //true} 涉及到对象的连接,则都在堆中产生新的String对象; 面试题4:java的值传递 123456789101112131415161718public class Main { String str = new String(&quot;good&quot;); char[] ch = {'t', 'e', 's', 't'}; public void change(String str, char ch[]) { str = &quot;test ok&quot;; //将常量池中&quot;test ok&quot;的地址赋值给str ch[0] = 'b'; } @Test public void test() { Main obj = new Main(); obj.change(obj.str, obj.ch); System.out.println(obj.str); //good System.out.println(obj.ch); //best }} String类常用方法1.int length()2.char charAt(int index)3.boolean isEmpty()4.String toLowerCase()5.String toUpperCase()6.String trim():返回字符串的副本,忽略前导空白和尾部空白7.boolean equalsIgnoreCase(String s)8.String concat(String str):将指定字符串连接到此字符串的结尾,等价于+9.int compareTo(String s):比较两个字符串字典序10.String substring(int beginIndex):11.String substring(int beginIndex, int endIndex):按照下标截取字符串,左闭右开12.boolean endsWith(String suffix):是否以指定的后缀结束13.boolean startsWith(String prefix):是否以指定的前缀开始14.boolean startsWith(String prefix,int offset):测试此字符串从指定索引开始的子串是否以指定前缀开始 15.boolean contains(CharSequence s):当且仅当此字符串包含指定的char值序列时,返回true16.int indexOf(String str):返回子串第一次出现的索引,未找到返回-117.int indexOf(String s,int fromIndex):返回子串从偏移下标开始首次出现的索引18.int lastIndexOf(String s):反向搜索19.int lastIndexOf(String s,int fromIndex),从指定偏移量开始反向搜索 20.String replace(char oldChar,char newChar):替换所有指定字符21.String replace(CharSequence target, CharSequence replacement):替换所有指定子串22.String replaceAll(String regex, String replacement):使用给定的子串替换所有匹配正则表达式的子串23.String replaceFirst(String regex, String replacement): 24.boolean matches(String regex):告知此字符串是否匹配给定的正则表达式 25.String[] split(String regex):根据给定正则表达式的匹配拆分此字符串26.String[] split(String regex, int limit):根据给定正则表达式来拆分此字符串,最多不超过limit个,如果超过了,剩下的全部放到最后一个元素中 String与基本数据类型转换1.String转基本数据类型、包装类: 调用包装类的静态方法:parseXXX(str)2.基本数据类型、包装类转Stirng:String.valueOf(xxx)3.String转char[]:str.toCharArray()4.char[]转String:new String(char[] arr)5.String转byte[]:str.getBytes()6.byte[]转String:new String(bytes[] arr) 重载函数new String(bytes[]arr,字符集) 123456789101112131415161718public class Main { public static void main(String[] args) throws UnsupportedEncodingException { String s=&quot;abc123中国&quot;; byte[] bytes = s.getBytes();//使用默认的字符集 System.out.println(Arrays.toString(bytes)); //[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67] utf-8编码一个汉字3个字节 byte[] gbks = s.getBytes(&quot;gbk&quot;); System.out.println(Arrays.toString(gbks)); //[97, 98, 99, 49, 50, 51, -42, -48, -71, -6] gbk编码一个汉字2个字节 System.out.println(new String(bytes)); //abc123中国 System.out.println(new String(gbks)); //abc123�й� 字符集指定错误,出现乱码 System.out.println(new String(gbks,&quot;gbk&quot;)); //abc123中国 }} StringBuffer,StringBuilderString:1.不可变字符序列 StringBuffer:1.可变字符序列2.线程安全,效率低 (除了构造方法,所有方法都加了synchronized) StringBuilder:1.可变字符序列2.线程不安全,效率高 三者底层都是用char[]存储 StringBuffer和StringBuilder的扩容默认情况下,扩容为原来的2倍+2,同时将原有数组中的元素复制到新的数组中指导意义: 如果需要对字符串进行频繁的添加, 建议使用此构造器StringBuffer(int capacity) 或 StringBuilder(int capacity),提前指定容量,以免频繁扩容,降低效率 三者效率对比 123456789101112131415161718192021@Testpublic void testTimeConsume() { String s = &quot;&quot;; StringBuffer buffer = new StringBuffer(); StringBuilder builder = new StringBuilder(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) { buffer.append(i); } System.out.println(&quot;StringBuffer use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { builder.append(i); } System.out.println(&quot;StringBuilder use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { s += i; } System.out.println(&quot;String use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;);} 2.2 JDK8之前的时间APISystem静态方法System.currentTimeMillis(): 返回1970年1月1日0点到现在经历了多少毫秒,返回值是long类型 Date类有两个Date类java.util.Date和java.sql.Date(继承前边的类) java.util.Date1.构造器一:Date() 创建了一个对应当前时间的Date对象 2.构造器二Date(long time) 创建指定毫秒数的Date类 java.sql.Date对应着数据库中的日期 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Date date=new Date(); System.out.println(date); //Wed Aug 25 10:49:42 CST 2021 System.out.println(date.getTime()); //1629859782884 Date date2=new Date(1629859782884L); System.out.println(date2); //Wed Aug 25 10:49:42 CST 2021 Date date3=new java.sql.Date(2131243242334L); System.out.println(date3); //2037-07-15 /*java.util.Date转换为java.sql.Date*/ //情形一 多态,对象本身就是sql下的Date Date date4=new java.sql.Date(2315432424345L); java.sql.Date date5= (java.sql.Date) date4; //情形二 对象本身就是util下的Date,无法直接强制转换.但是他们拥有一个共同的东西,就是毫秒数 Date date6=new Date(); java.sql.Date date7=new java.sql.Date(date6.getTime()); }} Calendar类Calendar是一个抽象基类,主要用于完成日期字段之间相互操作的功能 获取Calendar实例的方法1.使用Calendar.getInstance()方法 (抽象类无法实例化,这里返回的是子类GregorianCalendar的对象,多态,用Calendar接收)2.调用它的子类GregorianCalendar的构造器 一个Canlendar的实例是系统时间的抽象表示,通过get(int field)方法来取得想要的时间信息.比如YEAR, MONTH, DAY_OF_WEEK, HOUR_OF_DAY,MINUTE, SECOND1.public void set(int field, int value)2.public void add(int field, int amount)3.public final Date getTime()4.public final void setTime(Date date) 注意1.获取月份时:一月是0, 二月是1, 以此类推, 12月是112.获取星期时,周日是1,周二是2,…,周六是7 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); //多态 System.out.println(calendar.getClass()); //java.util.GregorianCalendar //get() System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //add() calendar.add(Calendar.DAY_OF_MONTH, -10); //往前倒10个月 //getTime() Date date=calendar.getTime(); //setTime() calendar.setTime(date); //用date来设置calendar calendar.setTimeInMillis(23214325798L); //用毫秒数设置calendar }} SimpleDateFormat类用于对Date类的格式化和解析 Date类的API不易于国际化,大部分都被废弃了,java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化: 日期-&gt;文本, 解析: 文本-&gt;日期 1.格式化SimpleDateFormat(): 默认的模式和语言环境创建对象public SimpleDateFormat(String pattern) 该构造方法可以用参数pattern指定的格式创建一个对象,该对象调用public String format(Date date): 方法格式化时间对象date 2.解析public Date parse(String source): 从给定字符串的开始解析文本,以生成一个日期 1234567891011public class Main { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); /*格式化:date转String*/ String format = sdf.format(new Date()); System.out.println(format); //2021-08-25 04:00:54 /*解析*:String转Date*/ Date date = sdf.parse(&quot;2021-08-25 16:30:20&quot;); System.out.println(date); //Wed Aug 25 16:30:20 CST 2021 }} 如果用SimpleDateFormat类解析字符串成java.sql.Date,就先解析为java.util.Date,在用毫秒数转换为java.util.Date 例题1990-01-01开始,三天打鱼两天晒网,请问给定日期在做什么事情?答:用SimpleDateFomart类解析两个日期,算出毫秒值之差,然后向上整除1000*3600*24(这里用向上除法$(m+n-1)/n$), 然后结果+1(代表一共有多少天), 然后对5取模. 0~2在打渔,3~4在晒网 2.3 JDK8中新日期的APIJDK1.0包含了一个java.util.Date类,但是它的大多数方法已经在JDK1.1引入Calendar类后被弃用了.而Calendar类并不比Date好多少.它们面临的问题是:1.可变性:像日期和事件这样的类,应该是不可变得2.偏移性:Date中的年份是从1900开始的,而月份是从0开始的3.格式化:格式化只对Date有用,Calendar则不行此外,它们也不是线程安全的; 不能处理润秒等 总结:对日期和时间的操作一直是Java程序员最痛苦的地方之一 第三次引入的API是成功的,并且Java8中引入的java.timeAPI已经纠正了过去的缺陷,将在很长一段时间内它都会为我们服务 LocalDate,LocalTime,LocalDateTime其中LocalDateTime最常用 1.now(): 当前的日期、时间2.of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便3.getXxx(): 获取某项时间信息4.with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象5.plus()/minus(): 增减日期 1234567891011121314151617181920212223242526272829303132333435public void test(){ /*now(): 当前的日期、时间*/ LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); //LocalDateTime用的最频繁 System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); /*of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便*/ LocalDateTime time1 = LocalDateTime.of(2021, 8, 25, 20, 34); System.out.println(time1); /*getXxx()*/ System.out.println(localDateTime.getYear()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getDayOfYear()); System.out.println(localDateTime.getMinute()); /*with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象*/ LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(1); //不修改原来的日期,重新返回一个修改后的日期 System.out.println(localDateTime1); System.out.println(localDateTime1); LocalDateTime localDateTime2 = localDateTime1.withHour(4); System.out.println(localDateTime2); /*plus()/minus(): 增减日期*/ LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusYears(2); System.out.println(localDateTime4);} Instant类似于java.util.Date类 方法 描述 now() 静态方法,返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳 1234567891011121314151617public void test2(){ /*now(): 获取本初子午线对应的时间标准*/ Instant time1 = Instant.now();//默认是 本初子午线 的时区 /*atOffset()结合即时的偏移来创建一个OffsetDateTime量*/ OffsetDateTime time2 = time1.atOffset(ZoneOffset.ofHours(8));//改成东八区 System.out.println(time1); System.out.println(time2); /*toEpochSecond():返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳*/ long l = time2.toEpochSecond(); System.out.println(l); /*ofEpochMilli()静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象*/ Instant instant = Instant.ofEpochMilli(1532324124325L); System.out.println(instant);} DateTimeFormatter1.方式一:预定义的标准格式2.本地化相关的格式 3.自定义的格式(一般都用这个) 12345678910public void test3(){ //自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format = formatter.format(LocalDateTime.now()); System.out.println(format); //解析 TemporalAccessor parse = formatter.parse(&quot;2021-08-25 09:34:46&quot;); //LocalDateTime,LocalDate,LocalTime都实现了TemporalAccessor接口 System.out.println(parse);} 其他类 2.4 Java比较器Comparable接口 String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方法 重写comparaTo()的规则：如果当前对象this大于形参对象obj，则返回正整数；当前对象this小于形参对象obj，则返回负数；相等返回0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Student implements Comparable{ String name; int id; public Student() { } public Student(String name, int id) { this.name = name; this.id = id; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, id=&quot; + id + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public int compareTo(Object o) { if(o instanceof Student){ Student s=(Student)o; return Integer.compare(this.id,s.id); } throw new RuntimeException(&quot;比较的数据类型不是Student&quot;); }}public class p1 { @Test public void test(){ Student[] arr=new Student[3]; arr[0]=new Student(&quot;小小余&quot;,1); arr[1]=new Student(&quot;余丰旭&quot;,3); arr[2]=new Student(&quot;陈香玉&quot;,2); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); }} Comparator接口1.当元素的类型没有实现java.lang.Comparable接口又不方便修改代码，或者实现饿了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序，强行对多个对象进行整体排序的比较。 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2来；如果返回0，则表示相等；返回负数，表示o1小于o2 3.可以将Comparator传递给sort方法（如Collections.sort或Arrays.sort)，从而允许在排序上实现精确控制。 4.还可以使用Comparator来控制某些数据结构（如有序set或者有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序 1234567891011121314151617public class p1 { @Test public void test(){ Student[] arr=new Student[3]; arr[0]=new Student(&quot;小小余&quot;,1); arr[1]=new Student(&quot;余丰旭&quot;,3); arr[2]=new Student(&quot;陈香玉&quot;,2); //Arrays.sort(arr); Arrays.sort(arr, new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return -Double.compare(o1.id,o2.id); } }); System.out.println(Arrays.toString(arr)); }} 两种比较器对比 Comparable具有永久性，Comparator是临时使用的 Comparable接口一旦指定，保证其实现类对象在任何位置都可以比较大小；Comparator接口属于临时性的比较 2.5 System类 2.6 Math类 2.7 BigInteger和BigDecimal类 BigInteger对应的是整型，BigDecimal对应的是浮点型 3.枚举类1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类。 2.当需要定义一组常量时，强烈建议使用枚举类。 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式 如何定义枚举类 1.JDK5.0前，自定义枚举类 2.JDK5.0开始，可以使用enum关键字自定义枚举类 12345678910111213141516171819202122232425262728293031323334353637class Season{ //私有化构造器 private Season(String seasonName,String seasonDesc){ this.seasonName=seasonName; this.seasonDesc=seasonDesc; } //常量内容（带final的需要赋值） private final String seasonName; private final String seasonDesc; //静态对象 public static final Season SPRING=new Season(&quot;春天&quot;,&quot;春天开花&quot;); public static final Season SUMMER=new Season(&quot;夏天&quot;,&quot;夏天下雨&quot;); public static final Season AUTUMN=new Season(&quot;秋天&quot;,&quot;秋天收麦子&quot;); public static final Season WINTER=new Season(&quot;冬天&quot;,&quot;冬天堆雪人&quot;); public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return &quot;Season{&quot; + &quot;seasonName='&quot; + seasonName + '\\'' + &quot;, seasonDesc='&quot; + seasonDesc + '\\'' + '}'; }}public class p6 { public static void main(String[] args) { Season s1=Season.AUTUMN; System.out.println(s1); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class p7 { public static void main(String[] args) { Family father = Family.Father; Family mother=Family.Mather; System.out.println(father); //打印当前对象的名字 System.out.println(mother); Family[] values = Family.values(); System.out.println(Arrays.toString(values)); //看看Family的父类是什么 System.out.println(Family.class.getSuperclass()); System.out.println(Family.class.getSuperclass().getSuperclass()); System.out.println(Object.class); } @Test public void f1(){ Country[] values = Country.values(); System.out.println(Arrays.toString(values)); Country china = Country.valueOf(&quot;China&quot;); System.out.println(china.name()); System.out.println(china); //toString方法默认返回name }}/*如果没有属性，则连小括号也不需要*/enum Country{ China,USA,Canada,India;}enum Family{ Father(&quot;男生&quot;,&quot;挣钱养家&quot;), //注意这里是逗号 Mather(&quot;女生&quot;,&quot;貌美如花&quot;); private final String name,duty; Family(String mem,String duty){ //默认是private的 this.name=mem; this.duty=duty; } public String getName() { return name; } public String getDuty() { return duty; }}public class p7 { public static void main(String[] args) { Family father = Family.Father; Family mother=Family.Mather; System.out.println(father); //打印当前对象的名字 System.out.println(mother); //看看Family的父类是什么 System.out.println(Family.class.getSuperclass()); System.out.println(Family.class.getSuperclass().getSuperclass()); System.out.println(Object.class); }}enum Family{ Father(&quot;男生&quot;,&quot;挣钱养家&quot;), //注意这里是逗号 Mather(&quot;女生&quot;,&quot;貌美如花&quot;); private final String name,duty; Family(String mem,String duty){ //默认是private的 this.name=mem; this.duty=duty; } public String getName() { return name; } public String getDuty() { return duty; }} enum类的主要方法 重点关注values()（返回常量对象数组） ,valueOf(String str), toString()方法 枚举类实现接口 1.在enum类中实现抽象方法 2.让枚举类的对象分别实现接口中的抽象方法 12345678910111213141516171819202122232425262728293031interface Info{ void show(); //默认是public abstract的}//由枚举类来实现抽象方法enum Planet implements Info{ Earth,Mars,Sun,Moon; @Override public void show(){ //必须是public，因为抽象方法是public，重写权限必须大于等于原来的权限 System.out.println(&quot;这颗星球是&quot;+this.name()); }}//每个对象分别实现接口的抽象方法enum Lanuage implements Info{ Chinese{ @Override public void show(){ System.out.println(&quot;中文&quot;); } },English{ @Override public void show() { System.out.println(&quot;英文&quot;); } },French { @Override public void show() { System.out.println(&quot;法语&quot;); } };} 4.注解4.1概述 从JDK5开始，java增加了对元数据（MetaData）的支持，也就是Annotation（注解） Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的“name=value”对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA（Java Persistence API持久层API）是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.X以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架=注解+反射+设计模式 4.2常见的Annotation示例常见的三种用法： 生成文档相关注释 在编译时进行格式检查（JDK内置的三个基本的注解） 跟踪代码依赖性，实现替代配置文件功能 4.3自定义Annotation 注解声明为@interface 内部定义成员，通常使用value标识 可以指定成员的默认值，使用default定义 如果自定义注解没有成员，表明是一个标识作用 如果注解有成员，在使用注解时，需要指明成员的值（除非有默认值） 4.4JDK中的元注解jdk提供了四种元注解，元Annotation用于修饰其他Annotation定义。 Retention：指定所修饰的Annotation的生命周期：SOURCE\\CLASS（默认行为）\\RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取 Target：用于修饰Annotation定义，用于指定被修饰Annatation能用于哪些程序元素。@Target也包含了一个名为value的成员变量 Documented：用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为Runtime。 Interited：被它修饰的Annotation将具有继承性。如果某个类使用了被Inherited修饰的Annotation，则其子类自动具有该注解。 实际应用中，使用较少 ```java@Inherited@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation{ String values() default &quot;aaa&quot;; } @MyAnnotation(values = “hello”)public class p1 { @Test public void test() { for(Annotation a:p2.class.getAnnotations()) System.out.println(a); } } class p2 extends p1{ } //执行结果：@October.day04.MyAnnotation(values=”hello”) 12345678910111213141516171819202122232425262728&gt; 自定义注解一般都会指明Retention，Target## 4.5利用反射获取注解信息## 4.6JDK8中的新注解## 可重复注解1.在`OneAnnotation`上声明`@Repeatable`，成员值为`OneAnnotations.class`2.`OneAnnotation`的Target和Retention，必须和`OneAnnotations`相同```java@Repeatable(OneAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})@interface OneAnnotation {}@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})@interface OneAnnotations { OneAnnotation[] value();} 类型注解 JDK1.8以后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE 在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方 123456789101112public class P4&lt;@SecondAnnotation T&gt; { public void show() throws @SecondAnnotation RuntimeException{ ArrayList&lt;@SecondAnnotation String&gt;list=new ArrayList&lt;&gt;(); int num=(@SecondAnnotation int)10L; }}@Target({ElementType.TYPE_PARAMETER,ElementType.TYPE_USE})@interface SecondAnnotation{} 5.Java集合Java集合框架概述Java集合可以分为Collection和Map两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Map接口：双列数据，保存具有映射关系key-value对的集合 Collection接口中存储自定义类的对象，除了TreeSet(自然排序重写compareTo，定制排序重写compare)，其他基本都需要重写equals，Set中需要重写hashCode和equals自不用说， List中要重写equals，主要是后续用于remove，contents等方法。 Collection接口继承树 Map接口继承树 Collection接口方法 注意 contains(target)内部比较调用的是equals方法，不需要target和内部对应元素拥有相同的引用。 A.retainAll(B)求交集，结果存放在A col1.equals(col2)，要求两者元素相同，并且顺序相同 hashcode()，根据内容返回哈希值；内容不同，哈希值也不同。 将数组元素全部读入ArrayList中 List&lt;Integer&gt; col = new ArrayList&lt;&gt;(Arrays.asList(123,456)); 注意Arrays.asList返回的不是ArrayList类型，而是java.util.Arrays$ArrayList类型，实现了List接口。 而ArrayList的构造函数可以传入一个Collection类型的数据。 Iterator迭代器接口1.Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。 2.GOF给迭代器模式的定义为：提供一种方法访问一个容器（Collection）对象中各个元素，而又无需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于公交车上的售票员，火车上的乘务员。 3.Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象。 4.Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。 5.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 1234567891011@Testpublic void test1(){ Collection col=new ArrayList&lt;&gt;(Arrays.asList(&quot;abc&quot;,&quot;def&quot;,&quot;...&quot;)); Iterator it= col.iterator(); while(it.hasNext()) System.out.println(it.next());} default void remove()方法的使用 注：default方法指的是接口中可以写方法体的方法，实现类直接继承，无需重写 12345678910111213public void test2(){ Collection&lt;String&gt;col=new ArrayList&lt;&gt;(Arrays.asList(&quot;abc&quot;,&quot;yfx&quot;,&quot;cxy&quot;)); Iterator&lt;String&gt;it=col.iterator(); while(it.hasNext()){ Object obj=it.next(); if(&quot;abc&quot;.equals(obj)) it.remove(); } //col.removeIf(&quot;abc&quot;::equals); //等价写法 it=col.iterator(); //需要从头获取 while(it.hasNext()) System.out.println(it.next());} 注意： 1.Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法 2.如果还未调用next()或者在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException Iterator的执行原理： iterator首先指向第一个对象之前的位置。 注：Iterator不可用于Map集合 增强for循环，内部也是使用了Iterator来实现的。 12for(String s:arr) //将arr中的元素赋值给s s=&quot;abc&quot;; //无法改变原有的内容 Collection子接口一：ListList集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List三个实现类的不同点： ArrayList：作为List接口的主要实现类；线程不安全，效率高；底层使用Object[] elementData存数组储 LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储； Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData数组存储 相同点： 都实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 ArrayList源码分析（jdk7和jdk8中有所不同） IDEA ctrl+f12 查看类的所有方法 结论：建议开发中使用带参的构造器：new ArrayList(int capacity);，如果使用空参构造器，可能会发生频繁扩容（复制数组），降低效率 LinkedList略 Vector略 作为List接口的古老实现类；线程安全；效率低；底层使用object[] List接口中的常用测试方法List中除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法 void add(int index,Object ele) Object get(int index) Object remove(int index) Object set(int index,Object ele) Collection子接口二：SetSet：存储无序的、不可重复的数据 以HashSet为例（TreeSet底层不是数组，是二叉树了） 无序性：不等于随机性，存储的数据在底层数组（TreeSet底层不是数组）中并非按照数据索引的顺序添加，而是根据数据的hash值 不可重复性：hash值不同，或者hash值相同，但equals不同 底层是用数组+链表/二叉树，来实现存储的。 向HashSet中添加元素a，先调用a的HashCode()方法，计算a的hash值，然后通过某种算法计算出a在底层数组中的存放位置（索引位置），判断数组在此位置上是否已经有元素，如果没有则添加成功，如果有则跟此位置挂载的链表/红黑树，上的元素进行比较（调用equals），如果均不相同则插入，否则产生重复不插入。 HashSet底层用的是HashMap 特点： 线程不安全 可以存储null值 LinkedHashSet是HashSet的子类，可以按照添加顺序遍历元素。 底层是hash表+双向链表（leetcode有一题LRU算法就是用这个数据结构来实现的） TreeSet特点： 只能放同一类的对象 两种排序方式：自然排序（Comparable）、定制排序(Comparator) 自然排序，自定义类型必须实现Comparable接口 可以按照添加对象的指定属性，进行排序 TreeSet中判断是否相同，使用的是CompareTo（自然排序）/compare（定制排序），而非equals TreeSet底层用的是TreeMap Map接口Map中的key：无序、不可重复，使用Set存储所有key（key的类要重写equals和hashCode方法，TreeMap则需要自然排序或定制排序） Map中的value：无序、可重复，使用Collection存储所有的value key-value键值对：构成了一个Entry对象 Map中的entry：无序、不可重复，使用Set存储所有的entry 注意，Map没有Iterator，不可直接迭代，需要使用元视图keySet()、entrySet()、values()的结果才能迭代 注意，Hashtable的t是小写 Map接口常用方法 增删改 Object put(Object key,Object value) void putAll(Map m) Object remove(Object key) void clear（） 查询操作 Object get(Object key) boolean containsKey(Object key) boolean containsValue(Object value) int size() boolean isEmpty() boolean equals(Object obj) 元视图操作 Set keySet()：返回所有key构成的set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet：返回所有key-value构成的Set集合 HashMapHashMap是Map接口的主要实现类 HashMap特点： 线程不安全 效率高 可以存储null的key和value 和ArrayList一样，即使涉及线程安全问题，也可以用Collections来改造使之线程安全 HashMap存储数据的过程： 读源码注释的收获： 扩容会将原有的hash表结构破坏，所有key的位置需要重新计算，因此代价非常高。如果HashMap需要存储的数据量很大，则最好预先制定好capacity。 capacity大小需要合适，如果太大占用空间且迭代效率低（迭代时间复杂度O(N+capacity)，N是key的数量），如果太小需要经常扩容，扩容需要全部重新计算hash，即重新计算key的位置，代价非常大。 状态因子，如果大了，空间利用率高，但是容易产生冲突；如果小了，空间利用率低，但不容易产生冲突；一般用0.75比较合适 threshold阈值=capacity*loadfactor，hash表上元素个数（不包括链表/红黑树上的元素）超过此阈值要扩容（两倍） HashtableHashtable是古老实现类。 其子类Properties常用来处理配置文件。 LinkedHashMap 保证在遍历map元素时，可以按照添加的顺序实现遍历。 原理：hash表+双向链表 对频繁的遍历操作，此类执行效率高于HashMap（支持LRU算法） HashMap的底层： 数组+链表（jdk7及之前） 数字+链表/红黑树（jdk8） TreeMap按照key-value中的key进行排序（要求key是同一个类的对象），需要实现自然排序/定制排序 ConcurrentHashMap使用分段锁（数据分段加lock），在多线程使用时安全且高效 其他常用类PriorityQueue默认是小根堆 如果要生成大根堆，则传入比较器，重写compare方法 123456A=new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; }}); 或者用lamdba表达式 12B=new PriorityQueue&lt;&gt;((x,y) -&gt; (y-x));//注意，lambda表达式内部不用写逗号 Collections工具类Collections是操作Set,List,Map等集合的工具类 排序操作（均为static方法） reverse(List) shuffle(List) sort(List) sort(List,Comparator) swap(List,int,int) 查找、替换 Object max(Collection) Object max(Collection, Comparator) Object min(Collection) Object min(Collection, Comparator) int frequency(Collection, Object) ：返回指定集合中指定元素出现的次数 void copy(List dest, List src)：将src中的内容复制到dest中 boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值 同步控制（将对应类型扔进参数即可），底层仅仅用synchronized包装了原有的方法 synchronizedCollection synchronizedList synchronizedMap synchronizedSet synchronizedSortedMap synchronizedSortedSet 6.泛型 泛型类可能有多个参数，此时应该将多个参数一起放在尖括号内，如E1,E2,E3 泛型类的构造器如下：public GenericClass(){} 这种写法是错误的：public GenericClass&lt;E&gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致 泛型不同的引用不能相互赋值 尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是在运行时都只会被当做ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object 即泛型要用，就一路都用；要不用，就都不用 如果泛型类是一个接口或抽象类，则不可创建泛型类的对象 泛型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中，不能使用类的泛型（本质原因：泛型是在生成对象的时候指定的，静态结构早于对象创建） 泛型方法可以是静态方法，因为泛型参数是在调用方法时确定的，并非在实例化类的时候确定。 异常类，不能是泛型的 不能使用new E[]，但是可以E[]elements=(E[])new Object[capacity] 参考：ArrayList源码中生命：Object[] elementData，而非泛型参数类型数组 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型 子类不保留父类的泛型，按需实现 没有类型 擦除 具体类型 子类保留父类的泛型，泛型子类 全部保留 部分保留 1234567891011class Father&lt;T1,T2&gt;{}//1. 没有类型，擦除class Son1 extends Father{}//2. 具体类型class Son2 extends Father&lt;Integer,String&gt;{}//3. 子类保留父类的泛型//3.1 全部保留class Son3&lt;T1,T2&gt;extends Father&lt;T1,T2&gt;{}//3.2 部分保留class Son4&lt;T2&gt;extends Father&lt;Integer,T2&gt;{} 为何需要泛型 解决元素存储的安全性问题 解决获取数据元素时，需要强制类型转换的问题 在集合中使用泛型如果没有使用泛型，默认是java.lang.Object类型 自定义泛型结构泛型类、泛型接口、泛型方法 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系！ 换句话说，类中指明了&lt;E&gt;，而方法中用到了&lt;T&gt;，才能叫泛型方法。泛型方法所属的类是不是泛型类都没有关系 12public &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr){...}//最前面需要声明泛型E，否则编译器认为E是一个类名，会报错 泛型方法可以是静态的！泛型方法可以是静态方法，因为泛型参数是在调用方法时确定的，并非在实例化类的时候确定。 泛型在继承上的体现子类在继承泛型时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 1234567public class SubOrder extends Order&lt;Integer&gt;{ ...} //SubOrder:不是泛型类public class SubOrder2&lt;T&gt; extends Order&lt;T&gt;{ ...} //SubOrder&lt;T&gt;仍然是泛型类 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;二者不具备子父类关系，二者是并列关系 下面这个是可以的 通配符的使用 需要泛型通配符的根本原因在于，泛型之间都平行关系（即使两个泛型类型自身存在父子关系），因此如果没有泛型的话，要兼容同一子类下的所有所有类型，必须要重载很多函数。 有限制条件的通配z符 &lt;?&gt;允许所有泛型的引用调用 通配符指定上限，上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 通配符指定下限，下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例 &lt;? extends Number&gt; &lt;? super Number&gt; &lt;? externds Comparable&gt; 只允许泛型为实现了Comparable接口的实现类的引用调用 7.IO流File类的使用基本知识 绝对路径与相对路径 File中的相对路径（IDEA）： 如果在main方法中写，则是相对于工程的根目录（一个工程下可以有多个module） 如果是使用Junit单元测试测试方法，相对路径即为当前module下 Eclipse中，均是相对于Project根目录下 路径分隔符 windows和DOS系统采用\\来标识 UNIX和URL使用/来标识 为了解决这个隐患，File类提供一个常量public static final String separator，根据操作系统，动态地提供分隔符 注：在windows下写成/也能识别 三种构造器 直接写地址 parent地址+child地址 File+child地址 创建File时，若硬盘中有对应文件，则File对象的各属性会显式赋值；否则，除了指定目录和路径外，其余属性都取默认值。 常用方法 File类的获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath()：获取路径 public String getName()：获取名称 public String getParent()：获取上层文件目录路径，若无，返回null 如果用相对路径创建File，路径名只有一级的话，返回null public long length()：获取文件长度（字节数）不能获取目录的长度 public long lastModified：获取最后一次的修改时间，毫秒值 public String[]list()：获取指定目录下的所有文件或文件目录的名称数组 public File[]listFiles()：获取指定目录下的所有文件或文件目录的File数组 File类的重命名功能 public boolean renameTo(File des)：把文件重命名为指定的文件路径 底层是native方法，跟平台相关 linux下des只能在同一文件夹下，我的理解：其目的是重命名，所以只能在同一目录下进行。 File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile()：判断是否是文件 public boolean exists()是否存在 public boolean canRead()是否可读 public boolean canWrite()是否可写 public boolean isHidden()是否隐藏 IO流原理及流的分类 按操作数据单位不同分为：字节流，字符流 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java的IO流共40多个类，实际上非常规则，都是以上四个抽象基类派生的 由这四个类派生出来的子类名称都是以其父类名作为后缀 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件/节点流 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputstream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 字符流一次读几个字节？ 我的理解：看到FileReader源码中提到字符集的问题，应该是根据字符集来的 为什么不能用字符流处理图片（如复制图片后会损坏打不开）？ 我的理解：字符流在读取文件后，会根据指定的（或默认）字符集转换原有的编码，因此二进制文件已经被改变，所以图片损坏。（如utf-32是4字节一个字符，utf-8是可变长编码字符） 文本文件：.txt .java .c 使用字符流进行处理 非文本文件：.jpg .mp3 .doc .ppt 使用字节流进行处理 节点流（又叫文件流）FileReader如果要一个一个读，直接用read()方法，不加参数，返回的是int类型，如果值是-1代表文件末尾，如果不是-1则转化为char类型即可 12345678910111213141516171819202122public void test1() { File file = new File(&quot;demo&quot;); FileReader reader = null; try { reader = new FileReader(file); int data; while ((data = reader.read()) != -1) System.out.print((char) data); } catch (IOException e) { e.printStackTrace(); } finally { try { if(reader!=null) reader.close(); } catch (IOException e) { e.printStackTrace(); } }} 为什么不推荐使用throws IOException? 因为一共有三个地方抛异常，如果中间抛异常，会导致流没有close java垃圾回收机制，只能回收JVM堆内存里的对象空间；对于其他物理连接，比如数据库连接、输入输出流、Socket连接无能为力。 12345678910111213141516171819202122232425public void test2() { File file = new File(&quot;demo&quot;); FileReader fr = null; try { fr = new FileReader(file); char[] buff = new char[3]; int len;//需要len的原因是，结尾处可能读不满buff while ((len = fr.read(buff)) != -1) { //每次按照buff的长度来读取字符，返回读取的字符的数量 //for (int i = 0; i &lt; len; i++) //System.out.print(buff[i]); //方式二 System.out.print(new String(buff, 0, len)); } ; } catch (IOException e) { e.printStackTrace(); } finally { try { if (fr != null) fr.close(); } catch (IOException e) { e.printStackTrace(); } }} 为什么流需要关闭？ 123因为当我们用了虚拟机以外的资源，比如端口、显存、文件的时候（访问本地资源），超出了虚拟机能够释放资源的界限，这时候虚拟机并不能通过垃圾回收机制对你占用的资源进行释放，如果在没有关闭的情况下第一次运行程序是不会发生问题的，但是随着资源占有量逐渐增多而你又不自己进行close释放资源的话，垃圾只会越积越多，导致系统无法存储其他的资源，甚至会导致系统崩溃。如果你再次对未关闭流的文件进行读写，编译就会报错，告诉你这个文件被占用。举例说明：如果你再堆区new一个对象的时候，如果等号左边是对端口、显存、文件进行操作的时候，虚拟机就无法利用垃圾回收机制对堆区占用的资源进行释放。 12345678910虽然都是 InputStream，但不同的物理实现，close() 的物理作用也有所不同，所以忘记了 close() 的后果也不一样。比如 ByteArrayInputStream 这种输入流，close() 与否就没什么关系。楼主的例子中，实际的输入流是一个网络连接。如果忘记 close() 的话，它会一直占用着，直到 timeout 后系统自动关闭这个网络连接。也就是说，如果你忘记了关闭这个资源，到了一定的时候，系统会替你关闭。但如果类似这样的程序被执行很多次，就会有大量资源被长时间无效占用，极端情况下可能导致后续程序资源不足而失败。也不是所有的资源都能自动回收，比如 FileInputStream，你要是忘记关闭了，它就一直占用着，直到 JVM 退出。所以，回过来说，好的编程习惯是：主动用程序严格控制对资源的释放，而不必区分其具体的物理实现，不要指望系统级的回收机制。这样能保证程序的可读性和可靠性。 总结一下，针对内存的流可以不关闭，但是使用了JVM外界的资源的流如文件、端口、数据库连接等，JVM无法在垃圾回收时进行关闭并清理对应的内存对象，因此需要手动close（可以使用try-with-resources方式进行关闭）。如果一直不关，会导致外界资源一直被占用，对应的内存对象无法回收。 123456789101112131415161718public void test1() { File file = new File(&quot;demo&quot;); FileWriter fw = null; try { fw = new FileWriter(file,true); //第二个参数表示是否追加写入 fw.write(&quot;\\n你在赣神魔！&quot;); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fw != null) fw.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(&quot;成功！&quot;);} 为什么close要放在finally中？ 如果不写在finally中，如写在try或catch或try-catch代码块后面，try或者catch中可能会出现跳过close的代码，如thow、return、continue、break(如下代码所示) 不放在catch中，是因为可能有多个具体的异常（多个catch），需要写很多close，不如统一写在finally中 注意：try-catch的目的就是为了处理异常，使得后续代码可以继续运行。因此try-catch中出现了异常，程序不会直接退出，后续代码会继续执行 123456789for(int i=0;i&lt;100;i++){ try{ if(..) continue; }catch(){ } close(); //如果continue执行，则无法close} 使用filereader和filewriter进行文件的复制 1234567891011121314151617181920212223242526272829303132/*复制文件*/@Testpublic void test2() { File f1 = new File(&quot;src.txt&quot;); File f2 = new File(&quot;target.txt&quot;); FileReader fr = null; FileWriter fw = null; try { fr = new FileReader(f1); fw = new FileWriter(f2,true); //true:追加写入，false：清空文件重新写入 char[]buf=new char[10]; int len; while((len=fr.read(buf))!=-1){ fw.write(buf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fr != null) fr.close(); }catch (IOException e){ e.printStackTrace(); } try { if (fw != null) fw.close(); }catch (IOException e){ e.printStackTrace(); } }} 使用字节流复制图片 12345678910111213141516171819202122232425262728293031323334/*使用字节流复制图片*/@Testpublic void test3() { File f1 = new File(&quot;皮卡丘.jfif&quot;); File f2 = new File(&quot;皮卡丘副本.png&quot;); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(f1); fos = new FileOutputStream(f2); byte[]buf=new byte[1000]; int len; while((len=fis.read(buf))!=-1){ fos.write(buf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fis != null) fis.close(); } catch (IOException e) { e.printStackTrace(); } try { if (fos != null) fos.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(&quot;复制完成！&quot;);} 缓冲流处理流的一种 缓冲流是为了提高文件的读写效率 我认为其效果就如同中断方式的IO和DMA方式的IO 没有缓冲意味着：包工头指着一块砖头对着工人说你给我从A搬到B地，然后再发出命令你把下一块砖头从A搬到B，重复直至搬完；有了缓冲，包工头可以说你把这100块砖头从A搬到B，然后等工人搬完再下达命令，直到所有砖头搬完（方法二节省了很多无效时间） 12345678910111213141516171819202122232425262728293031323334public static void copyFileByBuf(String url) { File file = new File(url); File copy = new File(&quot;副本&quot; + file.getName()); FileInputStream fis = null; FileOutputStream fos = null; BufferedInputStream bis = null; BufferedOutputStream bos = null; try { fis = new FileInputStream(file); fos = new FileOutputStream(copy); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); int len; byte[]buf=new byte[1024]; //buf的大小影响文件读写效率 while((len=bis.read(buf))!=-1){ bos.write(buf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (bis != null) bis.close(); } catch (IOException e) { e.printStackTrace(); } try { if (bos != null) bos.close(); } catch (IOException e) { e.printStackTrace(); } }} 注意，将外层处理流关闭后，内层的节点流会自动关闭 转换流处理流的一种 转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流 InputStreamReader：将InputStream转换为Reader OutputStreamWriter：将Writer转换为OutputStream 字节流中的数据都是字符时，转换成字符流操作更高效（为什么？没查到原因） 很多时候我们使用转换流来处理文件乱码的问题，实现编码和解码的功能 字符集 ASCII：美国标准信息交换码 ISO8895-1：拉丁码表：欧洲码表。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK:中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。 Unicode：国际标准码，融合了目前人类使用的所有字符。为每一个字符分配唯一的字符码。 Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。 UTF-8:变长的编码方法，可用1-4个字节来表示一个字符。 123456789101112131415161718192021222324252627282930public void test1() { InputStreamReader isr = null; OutputStreamWriter osw=null; try { isr = new InputStreamReader(new FileInputStream(&quot;src.txt&quot;), StandardCharsets.UTF_8); osw=new OutputStreamWriter(new FileOutputStream(&quot;gbk_src.txt&quot;),&quot;gbk&quot;); int len; char[] buf = new char[1024]; while ((len = isr.read(buf)) != -1) { // System.out.println(new String(buf, 0, len)); osw.write(buf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(isr!=null) isr.close(); } catch (IOException e) { e.printStackTrace(); } try { if(osw!=null) osw.close(); } catch (IOException e) { e.printStackTrace(); } }} 标准输入输出流1234567891011121314151617181920212223242526272829/*从键盘输入字符串，要求将读取到的整行字符串转换成大写输出。然后继续进行输入操作 * 直至输入e和exit时，退出程序*//*方法1：使用Scanner实现 * 方法2：使用System.in实现。 System.in --&gt; 转换流 --&gt; BufferedReader的readline()*/public void test2() { BufferedReader br = null; try { InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8); br = new BufferedReader(reader); while (true) { String t = br.readLine(); if (&quot;e&quot;.equalsIgnoreCase(t) || &quot;exit&quot;.equals(t.toLowerCase())) { System.out.println(&quot;程序结束...&quot;); return; } System.out.println(t.toUpperCase()); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } }} 模拟实现Scanner效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static void main(String[] args) throws IOException { MyInput myInput = new MyInput(System.in); while (true) { // int a= myInput.readInt(); // System.out.println(a); // System.out.println(myInput.readString()); System.out.println(myInput.readFloat()); }}class MyInput { private BufferedReader reader = null; public MyInput(InputStream input) { reader = new BufferedReader(new InputStreamReader(input)); } /*输出字符，直到遇到空格或回车停止*/ public int readInt() throws IOException { StringBuilder sb = new StringBuilder(); while (true) { char c = (char) reader.read(); if (c &gt;= '0' &amp;&amp; c &lt;= '9') { sb.append(c); } else { if (sb.length() == 0) //防止返回空的数字 continue; return Integer.parseInt(sb.toString()); } } } public String readString() throws IOException { StringBuilder sb = new StringBuilder(); while (true) { char c = (char) reader.read(); if (c == ' ' || c == '\\t' || c == '\\n') { if (sb.length() == 0) continue; return sb.toString(); } else sb.append(c); } } public float readFloat()throws IOException{ StringBuilder sb=new StringBuilder(); while(true){ char c=(char)reader.read(); if(c&gt;='0' &amp;&amp; c&lt;='9' || c=='.'){ sb.append(c); }else{ if(sb.length()==0) continue; /*输入的浮点数格式不正确*/ try{ return Float.parseFloat(sb.toString()); }catch (NumberFormatException e){ e.printStackTrace(); } } } }} 打印流了解即可 Sytem.out就是一个打印流 将System.out的打印流从控制台重定向到自定义的输出流中，然后写入文件 123456789FileOutputStream fos=new FileOutputStream(&quot;testSystemOutRedirect.txt&quot;,true); //追加写入PrintStream ps=new PrintStream(fos); System.setOut(ps); //重定向System输出，到自定义的ps打印流InputStreamReader reader=new InputStreamReader(System.in);int t;while((t=reader.read())!=-1){ char c=(char)t; System.out.print(c);} 数据流了解即可 作用：为了方便操作Java语言的基本数据类型和String的数据，可以使用数据流（可以理解为专门为Java基本数据类型和String类型持久化和读取的流，其生成的文件可以理解为一种特殊文件，用于持久化存储java基本数据类型和String） 读取不同类型的数据的顺序，要与当初写入文件时的顺序一致！ 数据流有两个类：用于读取和写出基本数据类型、String类的数据 DataInputStream和DataOutputStream 分别“套接”在InputStream和OutputStream子类的流上 DataInputStream中的方法 boolean readBoolean() char readChar() double readDouble … String readUTF() void readFully(byte[] b) DataOutputStream中的方法 将上述的方法中的read改为相应的write即可 123456789101112131415161718192021//数据流进行java基本数据类型和String的持久化@Testpublic void test3()throws IOException{ DataOutputStream dos=new DataOutputStream(new FileOutputStream(&quot;dataflow&quot;)); dos.writeBoolean(false); dos.writeUTF(&quot;张三丰&quot;); dos.writeInt(12345); dos.flush(); //将内存中的数据写入文件 dos.close();}//数据流进行java基本数据类型和String的持久化文件的读取@Testpublic void test4()throws IOException{ DataInputStream dis=new DataInputStream(new FileInputStream(&quot;dataflow&quot;)); boolean b=dis.readBoolean(); String s=dis.readUTF(); int i=dis.readInt(); System.out.println(b); System.out.println(s); System.out.println(i);} 对象流对象的序列化 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于：可将任何实现了Serializable接口的对象转换成字节数据，使其在保存和传输时可以被还原。 序列化是RMI（Remote Method Invoke 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则会抛出NotSerializableException异常。 Serializable Externalizable 对象序列化需要满足两个要求 实现接口Serializable（仅仅是个标识接口，无具体内容） 当前类提供一个全局常量：serialVersionUID serialVersionUID用来表示类的不同版本之间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成。若类的实例变量做了修改，serialVersionUID可能发生变化。所以，建议使用显式声明。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本的一致性的。在进行反序列化时，JVM会把传过来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常（InvalidCastException） 必须保证内部所有属性可序列化（默认情况下，基本数据类型可序列化） 对象流 ObjectInputStream, ObjectOutputStream 用于存储和读取基本数据类型数据或对象的处理流。可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本数据类型或对象的机制 反序列化：用ObjectInputStream类读取基本数据类型或对象的机制 不能序列化static和transient修饰的成员变量 123456789101112131415161718//java对象序列化@Testpublic void test5()throws IOException{ ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;serializationObjects&quot;)); oos.writeObject(&quot;你是什么念&quot;); oos.writeObject(new Date()); oos.flush(); oos.close();}//java对象反序列化@Testpublic void test6() throws IOException, ClassNotFoundException { ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;serializationObjects&quot;)); Object o1=ois.readObject(); Object o2=ois.readObject(); System.out.println(o1); System.out.println(o2);} 随机存取文件流RandomAccessFile类 声明在java.io包下，但直接继承于java.lang.Object类。（而非继承于流的四个基类）并且它实现了DataInput、DataOutput这两个接口，意味着既可以读也可以写（但是要造两个对象） RandomAccessFile类支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile对象包含一个记录指针，可以标示当前读写处的位置。该对象可以自由移动记录指针 long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到pos位置 创建对象需要指定一个mode参数，该参数指定RandomAccessFIle对象的访问模式 r：以只读方式打开 rw：打开以便读取和写入 rwd：打开以便读取和写入；同步文件的内容的更新 rws：打开以便进行读取和写入；同步文件内容和元数据的更新 注：如果模式为r，则不会创建文件，而是会读取一个已存在的文件，如果读取的文件不存在则会抛出异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建，而是覆盖。 NIO.2中Path、Paths、Files类的使用 Java NIO(Non-Blocking IO)是从java1.4开始引入的一套新的IO API，可以替代标准Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作。NIO将以更高效的方式进行文件的读写操作。 Java API中提供了两套NIO，一套是针对标准输入输出的NIO，另一套是网络编程NIO java.nio.channels.Channel： FileChannel：处理本地文件 SocketChannel：TCP网络编程的客户端Channel ServerSocketChannel：TCP网络编程的服务器端的Channel DatagramChannel：UDP网络编程中发送端和接收端的Channel 随着JDK7的发布，Java对NIo进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2，因为NIO提供的一些功能，NIO已经成为文件处理中越来越重要的部分。 补充一般实际工作中，会导入第三方jar包，如Apache的commons-io中的FileUitls来实现文件的操作。 8.网络编程网络通信要素概述如何实现网络中的主机相互通信 通信双方地址 IP 端口号 一定的规则（网络通信协议） OSI参考模型：模型过于理想化，未在因特网上进行广泛推广 TCP/IP参考模型（TCP/IP协议）：事实上的国际标准 通信要素1：IP和端口号在Java中使用InetAddress类代表IP 端口号标识正在计算机上运行的进程 不同的进程有不同的端口号 被规定为一个16位的整数0~65535 端口分类 公认端口：0~1023。被预先定义的服务通信占用（如HTTP80，FTP21，Telnet23） 注册端口：1024~49151.分配给用户进程或应用程序。（如Tomcat8080，MySQL3306，Oracle1521） 动态/私有端口：49152~65535 端口号和IP地址的组合得出一个网络套接字：Socket 通信要素2：网络协议TCP和UDP TCP协议： 使用前须建立TCP连接，形成传输通道 传输前，采用三次握手方式，点对点通信，可靠的 TCP协议进行通信的两个应用进程：客户端、服务端 在连接中可进行大量数据的传输 传输完毕，需释放已建立的连接，效率低 UDP协议： 将数据、源、目的封装成数据包，无需建立连接 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方也收不到确认，故不可靠 可以广播发送 发送结束后无需释放资源，开销小，速度快 为什么TCP需要三次握手、四次挥手? B站掌知识：https://www.bilibili.com/video/BV1kV411j7hA?from=search&amp;seid=5623693464798890863&amp;spm_id_from=333.337.0.0 TCP网络编程注：用教研室电脑作为服务器端进行测试，由于ISP会动态给路由器分配IP地址，需要临时查看路由器IP；此外需要固定路由器给本机MAC分配的IP地址，然后固定NAT内外端口映射。 注：为何使用节点流、缓冲流，有时接收方的read无法结束，持续阻塞？而使用DataOutputStream和DataInputStream则没问题？ 答：因为如果不关闭流，接收方read无法得知何时结束接收（貌似关闭流，接收方read就会返回-1，结束while）。因此如果发送方的发送文件代码下方没有别的代码阻塞，则函数结束，自动关闭流；如果下方有别的代码在阻塞，则不会自动关闭流，此时需要手动关闭流。 答：DataOutputStream的writeUTF和DataInputStream的readUTF，每次传输后会自动关闭流。 客户端/服务器聊天案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//服务器端：监听指定端口号，一旦有socket请求，则创建两个持续执行的线程，一个用来接收消息，一个用来发送消息package MyChat;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class ChatServer { public static void main(String[] args) { ServerSocket serverSocket = null; //服务端socket Socket clientSocket = null; //客户端socket final int port = 12345; try { serverSocket = new ServerSocket(port); while (true) { //监听端口，一旦收到新的scoket，则建立两个线程用于接收和发送消息 clientSocket = serverSocket.accept(); new Thread(new SendMessageToClient(clientSocket)).start(); new Thread(new ReceiveClientMessage(clientSocket)).start(); } } catch (IOException e) { e.printStackTrace(); } finally { if(clientSocket!=null) { try { clientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!=null) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } }}class SendMessageToClient implements Runnable { DataOutputStream dataOutputStream=null; private Scanner sc=new Scanner(System.in); public SendMessageToClient(Socket s) { try { dataOutputStream=new DataOutputStream(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message=null; try{ while(true){ message=sc.nextLine(); dataOutputStream.writeUTF(message); } }catch (IOException e){ e.printStackTrace(); } }}class ReceiveClientMessage implements Runnable { private DataInputStream dataInputStream = null; public ReceiveClientMessage(Socket s) { try { dataInputStream = new DataInputStream(s.getInputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message=null; try{ while(true){ //一直运行，一旦接收到消息，就打印 message=dataInputStream.readUTF(); System.out.println(&quot;收到客户端消息：&quot;+message); } }catch (IOException e){ e.printStackTrace(); } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//客户端：向指定ip和端口发起socket请求，创建两个线程，一个用于发送消息，一个用于接收消息package MyChat;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.Scanner;public class ChatClient { private static final String ip = &quot;219.230.70.7&quot;; private static final int port=12345; public static void main(String[] args) { Socket serverSocket = null; try { serverSocket = new Socket(ip, port); new Thread(new MessageToServer(serverSocket)).start(); new Thread(new MessageFromServer(serverSocket)).start(); } catch (IOException e) { e.printStackTrace(); } }}class MessageToServer implements Runnable { private DataOutputStream dataOutputStream = null; private Scanner sc = new Scanner(System.in); public MessageToServer(Socket s) { try { dataOutputStream = new DataOutputStream(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String message = null; while (true) { message=sc.nextLine(); try { dataOutputStream.writeUTF(message); } catch (IOException e) { e.printStackTrace(); } } }}class MessageFromServer implements Runnable { private DataInputStream dataInputStream = null; public MessageFromServer(Socket s) { try { dataInputStream = new DataInputStream(s.getInputStream()); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { String info=null; while(true){ try { info=dataInputStream.readUTF(); System.out.println(&quot;收到服务端消息：&quot;+info); } catch (IOException e) { e.printStackTrace(); } } }} 客户端/服务器文件传输案例 注： 只有发送端关闭outputstream，接收端的read才能返回-1 失败经验：我采用在发送数据的前4个字节添加数据长度，接收方根据长度来判断何时终止while循环，来解决read阻塞的问题（不阻塞，则接受完文件可以继续向发送方反馈信息）。但是失败了，文件没接受完就一直阻塞。 我思考可能的原因是：底层tcp协议有个缓冲区，每次缓冲区接收满，或者收到FIN包，才会将缓冲区中内容复制到用户程序缓冲区。（这样做的原因是，数据包不是按顺序接收的，要保证这一段数据全部完整接收才会交给应用程序）。因此我的程序依然会阻塞在read处。 ```javawhile((len=bufferedInputStream.read(buf))!=-1){ bufferedOutputStream.write(buf,0,len); fileLength-=len; System.out.println(&quot;本轮传输&quot;+len+&quot;B，剩余&quot;+fileLength+&quot;B&quot;); if(fileLength&lt;=0) break; } //控制台消息文件长度为12850B本轮传输1024B，剩余11826B本轮传输1024B，剩余10802B本轮传输1024B，剩余9778B本轮传输1024B，剩余8754B本轮传输1024B，剩余7730B本轮传输1024B，剩余6706B本轮传输1024B，剩余5682B//卡在这里不动了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 - 解决办法：使用NIO。```java//服务器端：监听指定端口，一旦有socket请求，则创建一个线程发送文件package day05;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class TransferFileServer { public static void main(String[] args) { //持续监测端口，一旦发现socket连接，则启动发送文件的线程 int port=12345; ServerSocket serverSocket=null; Socket socket=null; try { serverSocket=new ServerSocket(port); while(true){ socket= serverSocket.accept(); //阻塞线程 new Thread(new SendFileThread(socket)).start(); } } catch (IOException e) { e.printStackTrace(); }finally { if(serverSocket!=null) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } }}class SendFileThread implements Runnable { private final Socket socket; private final String filename=&quot;副本曼达洛人.The.Mandalorian.S01E01.中英字幕.WEB.1080p-人人影视.V4.mp4&quot;; public SendFileThread(Socket s) { this.socket = s; } @Override public void run() { BufferedOutputStream output=null; BufferedInputStream input=null; try { output=new BufferedOutputStream(socket.getOutputStream()); input=new BufferedInputStream(new FileInputStream(filename)); byte[]buf=new byte[1024]; int len; while((len=input.read(buf))!=-1){ output.write(buf,0,len);// System.out.println(&quot;len=&quot;+len); } System.out.println(&quot;本次传输完成！&quot;); } catch (IOException e) { e.printStackTrace(); }finally { if(input!=null) { try { input.close(); } catch (IOException e) { e.printStackTrace(); } } if(output!=null) { try { output.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//客户端：向指定ip地址和端口发起socket请求，接收文件package day05;import java.io.*;import java.net.Socket;public class TransferFileClient { public static void main(String[] args) { String ip=&quot;219.230.74.51&quot;; int port=12345; int count=2; while(count&gt;0){ new Thread(new ReceiveFileThread(ip,port)).start(); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } count--; } }}/*接收文件*/class ReceiveFileThread implements Runnable { private final String ip; private final int port; private static int count=0; public ReceiveFileThread(String ip, int port) { this.port = port; this.ip = ip; } @Override public void run() { Socket socket=null; BufferedInputStream bufferedInputStream=null; BufferedOutputStream bufferedOutputStream=null; try { socket = new Socket(ip, port); bufferedInputStream=new BufferedInputStream(socket.getInputStream()); int tmp=count; bufferedOutputStream=new BufferedOutputStream(new FileOutputStream(&quot;File_&quot;+tmp+&quot;.mp4&quot;)); count++; byte[]buf=new byte[1024]; int len; while((len=bufferedInputStream.read(buf))!=-1){ bufferedOutputStream.write(buf,0,len); } System.out.println(&quot;客户端接收文件&quot;+tmp+&quot;结束！&quot;); } catch (IOException e) { e.printStackTrace(); }finally { if(bufferedOutputStream!=null) { try { bufferedOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if(bufferedInputStream!=null) { try { bufferedInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } }} UDP网络编程URL编程9.反射反射概述反射：通过对象得知其类的信息 为什么需要反射:有些类无法在编译时确定,需要在运行时动态确定,比如Spring管理各种Bean,不可能预知. 反射相关的主要API java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造器 获取Class的实例的四种方式方式1:调用运行时类的属性:.class 1Class&lt;Student&gt; clazz=Student.class; //泛型可加可不加 方式2:通过运行时类的对象 12Student stu=new Student();Class clazz=stu.getClass(); 运行时类: .java文件被编译成.class文件之后,加载进内存中,生成Class类的对象的类(任何类都是Class类的对象). 加载到内存中的运行时类,会缓存一定的时间.在此时间之内,我们可以通过不同的方式来获取此运行时类. 方式3:调用Class的静态方法(用的最多) 1Class clazz=Class.forName(&quot;com.njust.java.Student&quot;); //有异常要处理ClassNotFoundException 方式4:使用类的加载器:ClassLoader(了解) 12ClassLoader classLoader=Studetn.class.getClassLoader();Class clazz=classLoader.loadClass(&quot;com.njust.java.Student&quot;); 注:四种方式获取的运行时类,地址值相同. 即:Class的实例就对应着一个运行时类 哪些些类型可以有Class对象 class 外部类,成员(成员内部类,静态内部类),局部内部类,匿名内部类 interface:接口 [] 数组 (只要数组元素类型和维度相同,就是同一个Class) enum:枚举 annotation:注解@interface primitive type:基本数据类型 void 类的加载过程 使用ClassLoader加载配置文件 创建运行时类的对象12Class&lt;Student&gt; clazz=Student.class;Student stu=clazz.newInstance(); 还可以通过获取构造器来创建实例 10.Java8新特性11.Java9 &amp; 10 &amp; 11 新特性","link":"/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"},{"title":"队列操作","text":"牛客网-腾讯-队列操作 几个注意事项 tail必须和head空一个位置,否则全满和全空无法区分 插入的时候记得是插在tail的前一个位置 各种移动tail和head的操作都要进行取余! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t&gt;0){ t--; int q=sc.nextInt(); Que que=new Que(); while(q&gt;0){ q--; String op=sc.next(); if(&quot;TOP&quot;.equals(op)){ que.top(); }else if(&quot;PUSH&quot;.equals(op)){ que.push(sc.nextInt()); }else if(&quot;POP&quot;.equals(op)){ que.pop(); }else if(&quot;SIZE&quot;.equals(op)){ que.SIZE(); }else if(&quot;CLEAR&quot;.equals(op)){ que.clear(); } } } }}class Que{ final int MAX=1000; int[]nums=new int[MAX]; int head=0,tail=1; //tail指向的位置不存数字 Que(){ } void top(){ if(size()==0) System.out.println(-1); else{ System.out.println(nums[head]); } } void push(int x){ nums[(tail-1+MAX)%MAX]=x; tail++; tail%=MAX; } private int size(){ return (tail+MAX-head-1)%MAX; } void SIZE(){ System.out.println(size()); } void pop(){ if(size()==0) System.out.println(-1); else{ head++; head%=MAX; } } void clear(){ tail=(head+1)%MAX; } }","link":"/2022/06/30/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E8%85%BE%E8%AE%AF-%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C/"},{"title":"完美对","text":"牛客-阿里-完美对 这一题的收获 对于$O(n^2)$复杂度要优化至$O(nlogn)$的,常规的三种方法1.hash2.二分3.dp前缀和 都用不了的话,那么要换一个角度思考问题: 对于$O(n^2)$的问题,通常都是固定一个变量,然后去寻找另一个合适的变量;如果寻找这个过程一定无法用二分和dp来减少时间复杂度 那么就不去找,而是发掘元素自身的特点,把我要找的另一半应该是什么样计算出来,然后在hash表中找是否有这样的元素. 涉及hash表的计算,这题用第二种方法更优(两数之和的经典方法) 一种思路,全部装进去,然后计算 另一种思路,边装边计算,可以避免重复问题 数组互相比较不能直接用equals,必须用Arrays.equals 如果用数组作为hash表的键,最好替换成List;否则需要自己包装数组,然后重写equals和hashCode 注意,重写equals,其参数必须是Object类型 对数组hash用Arrays.hashCode();对对象用Objects.hashCode() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//减少时间复杂度的方法 1.hash空间换时间 2.二分 3.前缀和dpimport java.util.*;class Arr{ int[]arr; Arr(int k){ arr=new int[k]; } Arr(int[]t){ arr=t; } @Override public int hashCode() { return Arrays.hashCode(arr); } @Override public String toString(){ return Arrays.toString(arr); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Arr arr1 = (Arr) o; return Arrays.equals(arr, arr1.arr); }}public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int m=sc.nextInt(); Map&lt;Arr,Integer&gt;hash=new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++){ int[]t=new int[m-1]; int s=sc.nextInt(); for(int j=0;j&lt;m-1;j++){ int s2=sc.nextInt(); t[j]=s2-s; s=s2; } Arr arr=new Arr(t); if(hash.containsKey(arr)) hash.put(arr,hash.get(arr)+1); else hash.put(arr,1); } long ans=0; for(Map.Entry&lt;Arr,Integer&gt;en:hash.entrySet()){ int[]dir=en.getKey().arr; int val=en.getValue(); int[]other=new int[m-1]; for(int i=0;i&lt;m-1;i++){ other[i]=-dir[i]; } Arr otherArr=new Arr(other); if(Arrays.equals(dir,other)){ ans+=(long)val*(val-1); //这里要/2再乘2,因为最后ans/2 }else{ if(hash.containsKey(otherArr)) ans+=(long)val*hash.get(otherArr); } } System.out.println(ans/2); }}","link":"/2022/06/30/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%AE%8C%E7%BE%8E%E5%AF%B9/"},{"title":"做题方法总结","text":"如何降低$O(n^2)$算法的时间复杂度这一类的题目,一般n的值在$10^5$左右 固定一边,去搜索另一边 二分 dp / 前缀和 空间换时间 滑动窗口 不去搜索,而是看元素自身有什么特征,所需要配对的另一半的特征是什么,然后直接在hash表中找其数量 例如这题牛客-阿里-完美对 存在多种关系,尤其是链式关系的题首先,遇到这种存在多种联系,存在链式关系的题目,要条件反射般地考虑到图或者树. 其次,进一步地,还要能想到用图和树中的常用方法来解决题目中的问题. 例题: 牛客网-阿里-蚂蚁森林之王","link":"/2022/07/02/%E7%AE%97%E6%B3%95-%E5%81%9A%E9%A2%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"比例问题","text":"牛客-阿里-比例问题 思路 首先,根据比例公式得到,x和y是正比例关系,因此y或者x越大,xy的乘积越大 其次,本能地想到要用最大公因数来约分比例 脱离编程来思考这个问题 例如 1000 500 3 2 固定左边的数,即在1000以内找一个数x,使得$3x&lt;=1000$并且满足$2x&lt;=500$ 那么1000以内三的倍数有很多个,并且值是递增的(顺序-&gt;立即推-&gt;二分!) 聪明反被聪明误! 我想用递归来保证a&gt;=b,却没想到最后结果要按照原来的顺序打印! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//bx=ay//xyimport java.util.*;public class Main{ public static void main(String[]args){ new Main().solve(); } void solve(){ Scanner sc=new Scanner(System.in); int A=sc.nextInt(); int B=sc.nextInt(); int a=sc.nextInt(); int b=sc.nextInt(); f(A,B,a,b); } //最大公因数 int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); } void f(int A,int B,int a,int b){ if(a==b){ int t=Math.min(A,B); System.out.println(t+&quot; &quot;+t); return; } int gcd=gcd(a,b); a/=gcd; b/=gcd; //二分搜索 int l=1,r=A/a; int ans=-1; while(l&lt;=r){ int m=l+(r-l)/2; if(m*b&lt;=B){ ans=m; l=m+1; }else{ r=m-1; } } if(ans==-1) System.out.println(0+&quot; &quot;+0); else System.out.println(ans*a+&quot; &quot;+ans*b); }} 看了题解之后,发现他的写法更牛 要求x和y的乘积最大其实就是要x尽可能大（或y尽可能大），因为比例a/b已经固定了，y=x*b/a并没有什么操作空间。 先求取a和b的最大公约数将a/b化为最简分式，我们可以认为存在一个单元unit，使得x=a*unit，y=b*unit，因此可以得到unit1=x/a，unit2=y/b。 由x/y=a/b可知x/a=y/b，而x/a&lt;=A/a，因此unit1&lt;=A/a，同理unit2&lt;=B/b，因此unit只需要同时满足不大于A/a和不大于B/b即可。又因为x要尽可能大，所以unit就要尽可能大，于是得到unit=min(A/a,B/b) 123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.IOException;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] params = br.readLine().trim().split(&quot; &quot;); int A = Integer.parseInt(params[0]), B = Integer.parseInt(params[1]), a = Integer.parseInt(params[2]), b = Integer.parseInt(params[3]); int greatestCommonDivisor = gcd(a, b); // 先约分 a /= greatestCommonDivisor; b /= greatestCommonDivisor; // 然后计算unit int unit = Math.min(A / a, B / b); //选一个更小的单元! // x占a份unit，y占b份unit System.out.println(unit * a + &quot; &quot; + unit * b); } private static int gcd(int a, int b){ if(a &lt; b){ int temp = a; a = b; b = temp; } while(b &gt; 0){ int temp = a % b; a = b; b = temp; } return a; }}","link":"/2022/07/01/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E6%AF%94%E4%BE%8B%E9%97%AE%E9%A2%98/"},{"title":"蚂蚁森林之王","text":"牛客网-阿里-蚂蚁森林之王 首先,遇到这种存在多种联系,存在链式关系的题目,要条件反射般地考虑到图或者树. 其次,进一步地,还要能想到用图和树中的常用方法来解决题目中的问题. 这一题中存在链式崇拜关系,显然是一个森林,其中每棵树是一个多叉树,进一步思考则用二叉树的递归算法求子树的节点数即可. 一开始我想用的是dp,用二维数组记录每个人向上崇拜链条中的所有人.但是显然空间会爆.$210^5210^54/2=8*10^{10}字节=80G$ 仔细想想这其中存在大量冗余. 所以树的自下而上的算法可以节省这些冗余存储和计算. 其实仔细想想,出题人一定是根据二叉树递归计算节点个数为原型,然后设计出的这个题目.所以都是套路.以后看到这种存在多种关系和链式联系的,一定要想到图和树,想到图和树的常用算法. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;public class Main{ public static void main(String[]args){ new Main().solve(); } int n; int[]worship; List&lt;List&lt;Integer&gt;&gt;tree; long[]ans; void solve(){ Scanner sc=new Scanner(System.in); n=sc.nextInt(); worship=new int[n+1]; for(int i=0;i&lt;n;i++){ worship[i+1]=sc.nextInt(); } tree=new ArrayList&lt;&gt;(n+1); tree.add(null); for(int i=1;i&lt;=n;i++){ tree.add(new ArrayList&lt;&gt;()); } for(int i=2;i&lt;=n;i++){ if(worship[i]!=0) tree.get(worship[i]).add(i); //i是worship[i]的孩子 } ans=new long[n+1]; Arrays.fill(ans,-1); for(int i=1;i&lt;=n;i++) dfs(i); for(int i=1;i&lt;=n;i++) System.out.println(ans[i]); } //递归计算子树所含的节点个数 long dfs(int k){ if(ans[k]!=-1) //避免重复计算 return ans[k]; List&lt;Integer&gt;children=tree.get(k); long sum=1; for(int i=0;i&lt;children.size();i++){ sum+=dfs(children.get(i)); } ans[k]=sum; return sum; }}","link":"/2022/07/02/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E4%B9%8B%E7%8E%8B/"},{"title":"组合数的更优秀的实现","text":"效率更高的算法 效率高的原因在于: dfs(int x,int k)的含义是从下标x开始搜索k个数字,过程中可以直接调到下一步要选的数字,而不用像我之前的写法一样,一个一个查看 1234567891011121314151617181920212223242526272829class Solution { List&lt;List&lt;Integer&gt;&gt;ans=new ArrayList&lt;&gt;(); List&lt;Integer&gt;path=new ArrayList&lt;&gt;(); int n; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { this.n=n; dfs(1,k); return ans; } //从i~n中选k个数字 void dfs(int i,int k){ if(k==0){ //已经选了k个数字 ans.add(new ArrayList&lt;&gt;(path)); return; } if(i==n+1) //已经结束了还没选到k个数字 return; for(int x=i;x&lt;=n;x++){ //下一个数字选哪个 可以直接跳过多个放弃的数字! path.add(x); dfs(x+1,k-1); path.remove(path.size()-1); } }} 我之前的经典写法 1234567891011121314151617181920212223class Solution { List&lt;List&lt;Integer&gt;&gt;ans=new ArrayList&lt;&gt;(); List&lt;Integer&gt;tmp=new ArrayList&lt;&gt;(); int n; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { this.n=n; dfs(1,k); return ans; } void dfs(int x,int k){ if(k==0){ ans.add(new ArrayList&lt;&gt;(tmp)); return; } if(x==n+1) return; dfs(x+1,k); tmp.add(x); dfs(x+1,k-1); tmp.remove(tmp.size()-1); }}","link":"/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0/"},{"title":"用户喜好","text":"牛客-字节-用户喜好 如何快速统计某一区间内的指定数字个数?逆向思维!不是去区间中扫描指定数字有多少个,而是统计该数字出现在哪些下标,然后用二分快速查找. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); Map&lt;Integer,List&lt;Integer&gt;&gt;mp=new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++){ int t=sc.nextInt(); if(mp.containsKey(t)){ mp.get(t).add(i); } else{ List&lt;Integer&gt;tmp=new ArrayList&lt;&gt;(); tmp.add(i); mp.put(t,tmp); } } int q=sc.nextInt(); for(int i=0;i&lt;q;i++){ int ll=sc.nextInt()-1,rr=sc.nextInt()-1,k=sc.nextInt(); List&lt;Integer&gt;index=mp.get(k); if(index==null){ System.out.println(0); continue; } //找第一个大于等于l的 int left=-1; int l=0,r=index.size()-1; while(l&lt;=r){ int mid=l+(r-l)/2; if(index.get(mid)&gt;=ll){ r=mid-1; left=mid; }else{ l=mid+1; } } if(left==-1){ System.out.println(0); continue; } int right=-1; //找最后一个小于等于r的 l=0; r=index.size()-1; while(l&lt;=r){ int mid=l+(r-l)/2; if(index.get(mid)&lt;=rr){ right=mid; l=mid+1; }else{ r=mid-1; } } System.out.println(right-left+1); } }}","link":"/2022/07/17/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E5%AD%97%E8%8A%82-%E7%94%A8%E6%88%B7%E5%96%9C%E5%A5%BD/"},{"title":"小美的代金券要过期啦","text":"牛客-美团-小美的代金券要过期啦 这题是codeforces 1312e原题,用dp来写的话,时间复杂度$O(N^3)$ 定义dp[i][j]表示下标i~j范围合并后的最小长度 定义lastNum[i][j]表示ij合并成最小长度后的最后一个数字(或者是若合并后长度为1,其数字是多少) 一个重要的结论是: 只有合并后长度为1的区间有资格进一步合并 那么$dp[i][j]=min(dp[i][k]+dp[k+1][j]) ,k \\in [i,j)$ 其中若$dp[i][k]==dp[k+1][j]==1$ 则可以合并$dp[i][j]=1, lastNum[i][j]=lastNum[i][k]+1$ 开始我把初始化i==j的情况写在双重for循环中了,但是由于k的范围导致其并不执行; 另外一开始也没有对lastNum进行复制 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main{ public static void main(String[]args){ Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int[]num=new int[n]; for(int i=0;i&lt;n;i++) num[i]=sc.nextInt(); int[][]dp=new int[n][n]; //dp[i][j]表示i~j合并后的最小长度 int[][]lastNum=new int[n][n];//lastNum[i][j]表示ij合并成最小长度后的最后一个数字 for(int i=0;i&lt;n;i++){ Arrays.fill(dp[i],0x3fffffff); dp[i][i]=1; } for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) lastNum[i][j]=num[j]; for(int j=0;j&lt;n;j++) //右边界 for(int i=j;i&gt;=0;i--){ //左边界 for(int k=i;k&lt;j;k++){ //[i,k] [k+1,j] int l=dp[i][k]; int r=dp[k+1][j]; if(l==1 &amp;&amp; r==1 &amp;&amp; lastNum[i][k]==lastNum[k+1][j]){ dp[i][j]=1; lastNum[i][j]=lastNum[i][k]+1; }else{ if(l+r&lt;dp[i][j]){ dp[i][j]=l+r; lastNum[i][j]=lastNum[k+1][j]; } } } } System.out.println(n-dp[0][n-1]); }}","link":"/2022/07/06/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BE%8E%E5%9B%A2-%E4%BB%A3%E9%87%91%E5%88%B8/"},{"title":"删除字符","text":"牛客-阿里-删除字符 如何实现字符串的字典序最小? 答:越小的字母越放前面. 对于这一组用例来说 1210 4lkqijxsnny 需要保留6个字符,那么也就意味着需要从lkqij中选出第一个字符(因为剩下的xsnny只有5个字符,如果从其中选的话,总数就不够6个了),显然需要选i,因为字典序的比较是从左到右一个一个比较,如果第一个就小的话,那么后边就不用比了;这里如果用其他字符做第一个字母,那么已经输给i开头的字符串了. lkqijxsnny 首先从lkqij中选出第一个字符,此时选中i jxsnny 然后需要从jx中选出第二个字符,此时选中j xsnny 然后需要从xs中选择第三个字符,此时选中s nny 然后需要从n中选择第四个字符,此时选中n ny 然后需要从n中选择第五个字符,此时选中n y 然后需要从y中选择第六个字符,此时选中y 最后的结果是ijsnny 这个过程可以用单调队列来处理(凡是在我左边还比我小的字符,通通出队) 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main{ String str; void solve(){ Scanner sc=new Scanner(System.in); int t=sc.nextInt(); while(t&gt;0){ t--; int n=sc.nextInt(); int m=n-sc.nextInt(); //保留多少个数字 str=sc.next(); //单调队列-用双端队列来实现 Deque&lt;Character&gt;incQue=new ArrayDeque&lt;&gt;(); for(int i=0;i&lt;=n-m-1;i++){ while(!incQue.isEmpty() &amp;&amp; str.charAt(i)&lt;incQue.peekLast()) incQue.pollLast(); incQue.offer(str.charAt(i)); } List&lt;Character&gt;ans=new ArrayList&lt;&gt;(); for(int i=n-m;i&lt;n;i++){ while(!incQue.isEmpty() &amp;&amp; str.charAt(i)&lt;incQue.peekLast()) incQue.pollLast(); incQue.offer(str.charAt(i)); ans.add(incQue.poll()); } for(int i=0;i&lt;ans.size();i++) System.out.print(ans.get(i)); System.out.println(); } } public static void main(String[]args){ new Main().solve(); }}","link":"/2022/07/02/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AF%95%E9%A2%98-%E9%98%BF%E9%87%8C-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6/"}],"tags":[{"name":"web","slug":"web","link":"/tags/web/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"优先级队列","slug":"优先级队列","link":"/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"最短路径","slug":"最短路径","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"转化等价问题","slug":"转化等价问题","link":"/tags/%E8%BD%AC%E5%8C%96%E7%AD%89%E4%BB%B7%E9%97%AE%E9%A2%98/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"美团","slug":"美团","link":"/tags/%E7%BE%8E%E5%9B%A2/"},{"name":"阿里","slug":"阿里","link":"/tags/%E9%98%BF%E9%87%8C/"},{"name":"笔试题","slug":"笔试题","link":"/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"},{"name":"腾讯","slug":"腾讯","link":"/tags/%E8%85%BE%E8%AE%AF/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"B树","slug":"B树","link":"/tags/B%E6%A0%91/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"区间dp","slug":"区间dp","link":"/tags/%E5%8C%BA%E9%97%B4dp/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"我的项目","slug":"我的项目","link":"/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"论文","slug":"论文","link":"/categories/%E8%AE%BA%E6%96%87/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}