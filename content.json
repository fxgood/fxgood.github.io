{"pages":[],"posts":[{"title":"算法题之戳气球","text":"leetcode312 戳气球 这一题可以用动态规划来解决,但是dp含义的设置和状态转移方程的设计很有意思。 首先,一维dp难以实现的，应该考虑二维dp，尤其在一个数组中，要考虑到双指针移动来解决复杂问题。 如果将dp[i][j]的含义设置为戳爆下标[i,j]之间所有的气球能获得的最大钱币,会发现由于涉及到与i左边和j右边数字相乘,难以书写状态转移方程。 将dp[i][j]的含义设置为:戳爆下标i和j之间（开区间）的所有气球能获得的最大钱币。此时，如果将状态转移方程写为$dp[i][j]=max(先戳气球k,再戳剩下所有气球,获得的最大钱币) i&lt;k&lt;j$,会造成子问题之间相互牵连,不具有独立性,也就无法完成动态规划的设计。 因此将状态转移方程方程写成dp[i][j]=max(先戳剩下所有气球,再戳气球k,获得的最大钱币) i&lt;k&lt;j,这样每次左右两边的计算互不干扰,即可完成动态规划的设计。 （本质是由于，如果先戳爆气球k，则气球k-1右侧的气球改变，气球k+1左侧的气球也改变，造成钱币获取公式的改变,而最后戳爆气球k,则不会出现这个问题,即固定了dp[i][j]中i和j这两个气球) 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt;nums; int stab(int t){ if(t==0 || t==nums.size()+1) return 1; return nums[t-1]; } //一维dp不行,就整二维 int maxCoins(vector&lt;int&gt;&amp; nums) { this-&gt;nums=nums; int n=nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n+2,vector&lt;int&gt;(n+2,-1)); for(int i=0;i&lt;=n+1;i++) for(int j=i;j&gt;=0;j--){ if(i==j || i==j+1){ dp[j][i]=0; } else{ int m=0; //最后戳爆气球k for(int k=j+1;k&lt;i;k++){ m=max(m,dp[j][k]+dp[k][i]+stab(i)*stab(k)*stab(j)); } dp[j][i]=m; } } return dp[0][n+1]; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%88%B3%E6%B0%94%E7%90%83/"},{"title":"操作系统知识巩固","text":"概述 操作系统基本功能 统一管理所有计算机资源 处理器资源 存储资源 IO资源 文件资源 实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统四大特性 并发 并行：多个事件同一时刻发生 并发： 多个事件同一时间间隔内交替发生（多道程序交替执行） 共享 共享性：操作系统中的资源可以供多个并发的程序共同使用 分类： 互斥共享 同时共享 虚拟 虚拟性：把一个物理实体转变为若干个逻辑实体 虚拟技术又分为：时分复用和空分复用。 时分复用技术：资源在时间上进行复用，不同程序并发使用；多道程序分时使用计算机硬件资源 虚拟处理器技术 借助多道程序设计技术，为每个程序建立进程，多个程序（进程）分时复用处理器 虚拟设备技术 物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问 空分复用技术：用来实现虚拟磁盘、虚拟内存等，提高资源的利用率，提升编程效率。 虚拟磁盘技术 物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 异步 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）进程管理 为什么需要进程 没有配置OS之前，资源属于当前运行的程序（单道程序设计） 配置OS之后，引入多道程序设计的概念 合理地隔离资源、运行环境，提升资源利用率 进程的作用 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体，保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升1234面试官：请你谈一谈你对进程的认识。答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。 进程的实体 主存中的进程形态： 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据） IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器事件、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。 进程控制块(PCB)中记录的数据，可以分为四类 进程标识符 处理机状态 进程调度信息 进程控制信息进程与线程一个进程(Process)可以有一个或多个线程(Thread) 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位 线程包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程资源 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 开销大 开销小 通信 进程IPC 读写同一进程数据通信 五状态模型进程的五状态模型包括：创建，就绪，执行，阻塞，中止 就绪状态 定义：其他资源都准备好，只差CPU资源的状态称为就绪状态 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行 多个处于就绪状态的进程通常排列成一个队列，称为就绪队列 执行状态 定义：进程获得CPU，其程序正在执行，称为执行状态 在单处理机中，在某个时刻只能有一个进程是处于执行状态 阻塞状态 定义：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 阻塞进程会组成一个队列，称为阻塞队列 创建状态 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态 操作系统提供fork函数接口创建进程 终止状态 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态 ## 进程同步 为什么需要进程间同步 需要进行进程同步的两个经典问题生产者消费者问题 哲学家就餐问题 上述两个模型发生问题的根源：彼此之间没有通信 进程之间同步所解决的问题 1.对竞争资源在多进程之间进行次序的协调 2.使得并发执行的多个进程之间可以有效使用资源和相互合作 临界资源指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。 进程间同步的原则 1.空闲让进：资源无占用，允许使用2.忙着等待：资源有占用，请求进程等待3.有限等待：保证有限等待时间能够使用资源3.让权等待：等待时，进程需要让出CPU 线程与线程的同步方法 进程同步方法 1.消息队列 2.共享存储 3.信号量 线程同步方法 1.互斥量 2.读写锁 3.自旋锁 4.条件变量 Linux的进程管理Linux进程的相关概念 进程的类型： 前台进程： 1.前台进程就是具有中断，可以与用户交互的进程 后台进程： 1.与前台进程相对，没有占用终端的就是后台进程； 2.后台程序基本上不和用户交互，优先级比前台进程低 3.将需要执行的命令以&amp;符号结束 守护进程： 1.守护(daemon)进程是特殊的后台进程； 2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭； 3.linux有很多典型的守护进程； 4.进程名字以d结尾的一般都是守护进程，如crond,sshd,httpd,mysqld 操作系统提供fork函数接口创建进程 进程的标记 进程ID 1.唯一性 2.负整数，最大值由操作系统限定 3.ID为0的进程为idle进程，是系统创建的第一个进程 4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 5.Init进程是所有用户进程的祖先进程 状态符号 ### 操作Linux进程的相关命令 ps命令 1.ps是process status的缩写2.可以添加-ef或者-aux展示详细进程详细信息3.搜索某个进程的详细信息ps -ef | grep python34.查询进程树ps -ef --forest5.查询某个用户的进程ps -u yfx6.按照cpu的使用频率进行排序ps -aux --sort=-pcpu7.按照内存使用的状况进行排序ps - aux --sort=-pmem top命令 1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态 kill命令 1.kill -9 进程号 无条件终止进程 作业管理作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。 进程调度进程调度概述 进程调度：计算机通过决策决定哪个就绪进程可以获得CPU的使用权（多道程序设计） 进程调度的步骤 1.保留旧进程的运行信息，请出旧进程2.选择新进程，准备运行环境并分配cpu 新老进程的上下文切换机制进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 ### 进程调度算法 两种调度的方式 1.非抢占式的调度2.抢占式的调度 进程调度算法 1.先来先服务2.短进程优先3.高优先权优先4.时间片轮转 死锁死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。 死锁的产生 死锁产生的原因 1.竞争资源2.进程调度顺序不当 死锁的四个必要条件（如果出现死锁，必然存在下边四个条件） 互斥条件资源同一时间只能允许一个进程访问 请求保持条件进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源 不可剥夺条件只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。 循环等待条件多个进程之间存在资源请求的环路死锁的处理 预防死锁 破坏请求保持条件 1.进程运行之前，一次性申请所有需要的资源 2.并且在运行期间不会提出新的资源请求 破坏不可剥夺条件 1.当一个进程请求新的资源得不到满足时，必须释放占有的资源 2.进程运行时占用的资源可以被释放 破坏环路等待条件 1.可用资源线性排序，申请必须按照需要递增申请 假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。 但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。 避免死锁 避免死锁和预防死锁的区别二者都是通过施加某些限制条件，来预防死锁发生。 差别： 1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个） 2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态） 银行家算法 是一个可操作的著名的避免死锁的算法 以银行借贷系统分配策略为基础的算法 存储管理内存分配单一连续分配只能在单用户、单进程的操作系统中使用 固定分区分配1.内存空间被划分为若干固定大小的区域2.每个分区只提供给一个程序使用，互不干扰 动态内存分配根据进程实际需要，动态分配内存空间 动态分区空闲表数据结构 动态分区空闲链数据结构 内存分配过程 首次适应算法（First Fit)： 算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件缺点：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。(2)每次都是从低址部分查找，使得查找空闲分区的开销增大2. 循环首次适应算法(Next Fit) ：算法思想：配内存时不是从链首进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；优点：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存3. 最佳适应算法（Best Fist）算法思想：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的缺点：产生大量难以利用的外部碎片。4. 快速适应算法（Quick Fit）算法思想：快速适应算法要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区 内存回收一共有四中情况，如下图1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去 页式存储管理管理方式1.将进程逻辑空间等分为若干大小的页面2.相应地把物理内存空间分成与页面大小相同的物理块3.以页面为单位把进程空间装进物理内存中分散的物理块 页面大小1.过大难以分配，过小内存碎片过多2.通常是512B~8K 页表1.页表记录进程逻辑空间与物理空间的映射2.某个页表项的地址=页表起始地址+页表项大小x页号3.实际物理地址=字块大小x字块号+块内偏移地址 多级页表页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。 缺陷有一段连续的逻辑分布在多个页面中，将大大降低执行效率 段式存储管理管理方式1.将进程逻辑空间划分成若干段（非等分）2.段的长度由连续逻辑的长度决定3.主函数MAIN，子程序段X，子函数Y等 段式和页式对比1.二者都离散地管理了进程的逻辑空间2.页是物理单位，段式逻辑单位3.分页是为了合理利用空间，分段是满足用户要求4.页大小由硬件固定，段长度可动态变化5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度） 段页式存储管理为何需要段页式存储管理1.分页可以有效提高内存利用率2.分段可以更好地满足用户需求3.二者结合，形成段页式存储管理 如何管理1.先将逻辑空间按按段式管理分成若干段2.再把段内空间按页式管理分成若干页 虚拟内存问题一个游戏十几G，物理内存只有8G，游戏如何运行起来的？ 虚拟内存概述有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。程序局部性原理指CPU访问存储器，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。 虚拟内存的置换算法1.先进先出算法FIFO2.最不经常使用算法LFU3.最近最少使用算法LRU 与高速缓存的替换区别1.替换策略发生在Cache-主存层次、主存-辅存层次2.Cache-主存层次的替换策略主要是为了解决速度问题3.主存-辅存层次主要是为了解决容量问题 Linux存储管理Buddy内存管理算法概述1.Buddy算法（伙伴算法）是经典的内存管理算法2.基于计算机处理二进制的优势，效率极高3.主要是为了解决内存外碎片的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB） Buddy管理算法的目的努力让内存分配与相邻内存合并能够快速进行 内存分配原则向上取整为2的幂大小（外碎片转化为内碎片）(1)申请70k -&gt; 分配128k(2)申请129k -&gt; 分配256k(3)申请666k -&gt; 分配1024k 伙伴系统伙伴指的是内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存 内存分配过程1.创建一系列空闲块链表，每一种都是2的幂大小2.假设存储空间有1M大小3.分配100k内存(1)100k向上取2的幂=128k(2)查询是否有128k的空闲内存块？(3)没有！查询是否有256k空闲内存块？(4)没有！查询是否有512k空闲内存块？(5)没有！查询是否有1M空闲块内存？(6)有，摘下1M空闲内存块，分配出去(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去(8)拆下256K放在空闲链上，其余分配出去(9)拆下128K放在空闲链上，其余分配出去(10)分配完毕 4.回收内存过程(1)判断刚才分配的内存伙伴在空闲链表上吗？(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴…?(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴…?(4)在！移出伙伴，合并为1M空闲内存(5)插入1M空闲链表，回收完成 Linux交换空间概述1.交换空间（Swap）是磁盘的一个分区2.Linux物理内存满时，会把一些内存交换到Swap空间 作用1.冷启动内存依赖许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。2.系统睡眠依赖Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。3.大进程空间依赖有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。 Swap空间和虚拟内存的对比Swap空间(1)存在于磁盘(2)与主存发生置换(3)是操作系统概念(4)解决系统物理内存不足问题 虚拟内存(1)存在于磁盘(2)与主存发生置换(3)是进程概念(4)解决进程物理内存不足问题 文件管理文件的逻辑结构 逻辑结构的文件类型有结构文件1.文件内容由定长记录和可变长记录组成2.定长记录存储文件格式、文件描述等结构化数据项3.可变长记录存储文件的具体内容 无结构文件也成为流式文件，文件内容长度以字节为单位。如exe文件、dll文件、so文件 linux静态链接库文件.a 动态链接库文件.sowindows静态链接库文件.lib 动态链接库文件.dll 顺序文件1.顺序文件是指按照顺序存放在存储介质中的文件2.磁带的存储特性使得磁带文件只能存储顺序文件3.顺序文件是所有逻辑文件当中存储效率最高的4.顺序文件的增删查改是比较困难的 索引文件1.可变长的文件不适合用顺序文件格式存储2.索引文件是为了解决可变长文件存储而发明的一种文件格式3.索引文件需要配合索引表完成存储 辅存的存储空间分配 连续分配 1.顺序读取文件非常容易，速度很快 2.对存储要求高，要求满足容量的连续存储空间 链接分配1.链接分配可以将文件存储在离散的盘块中2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中-&gt;隐式链接，记录在FAT中-&gt;显示分配） 隐式链接分配显式链接分配缺点：1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块） 索引分配1.每个文件拥有一个索引块，记录所有盘块信息2.索引分配方式支持直接访问盘块3.文件较大时，索引分配方式具有明显优势4.现在主流文件系统都是使用索引分配 (空闲块)存储空间管理三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。 空闲表 空闲链表1.把所有空闲盘区组成一个空闲链表2.每个链表节点存储空闲盘块和空闲的数目 位示图1.位示图维护成本低2.非常容易找到空闲盘块3.使用0/1比特，占用空间小 目录管理任何文件或目录都只有唯一路径 Linux文件的基本操作Linux目录|目录|描述 ||–|–||/bin |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里 ||/etc |存放系统管理和配置文件 ||/home |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user ||/usr |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：unix software resources ||/opt |额外安装的可选应用程序宝所放置的位置 ||/proc |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息 ||root |超级用户（系统管理员）的主目录 ||/sbin |存放二进制可执行文件，只有root才能访问 ||/dev |用于存放设备文件 ||/mnt |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。 ||/boot |存放用于系统引导时使用的各种文件 ||/lib |存放文件系统中的程序运行所需要的共享库及内核模块 ||/var |用于存放运行时需要改变数据的文件 | Linux文件常用操作 命令 操作 touch 创建文件 mkdir 创建文件夹 rm 删除文件 cat 查看文件 gedit 使用gedit编辑文件 Linux文件类型 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信 使用ls -al命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型 Linux文件系统设备管理","link":"/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%B7%A9%E5%9B%BA/"},{"title":"自建博客记录与心得","text":"本博客采用hexo+gitee page+阿里云图床(阿里云对象存储oss)来建立的，主题选用的是基于hexo的icarus主题。一开始用的是hexo+githubpage，存在两个问题：1.博客部署在github部署和访问不稳定2.图片的使用和访问不方便。 建站过程 下载node.js、git等工具。进入在windows命令行 配置npm的国内源 12npm config set registry https://registry.npm.taobao.org #配置国内的镜像源npm info hexo # 测试查看hexo的安装信息，是否是taobao.org的源 安装hexo 12npm install -g hexo # 通过npm安装hexo# -g 指定全局安装，可以使用hexo命令 在自选的路径下，进行以下操作 123hexo init test # 初始化创建，会再桌面创建test文件夹cd test # 进入test目录npm install # 进一步安装hexo所需文件 hexo安装完成，启动hexo 123hexo clean # 清除所有记录hexo generate # 生成静态网页hexo server -p 80 # 在80端口启动服务，如果写-p xx 则在默认端口 浏览器访问localhost:端口号，可以查看博客当前的样子 主题配置：将下载的hexo主题（可以去github或者百度知乎上搜喜欢的）放在themes文件夹下，然后修改_config.yml配置文件 1theme: xxx # 这里与theme下主题文件夹的名称相同 在gitee中创建和用户名相同的仓库，然后修改_config.yml中的仓库url 123deploy: type: git repo: https://gitee.com/fxgood/fxgood # gitee的仓库地址 cd到博客根目录下，输入命令hexo generate &amp;&amp; hexo deploy 或者hexo g &amp;&amp;hexo d ，即可将博客部署到gitee page 阿里云购买域名，进行域名绑定 Typora绑定阿里云图床过程参考 https://zhuanlan.zhihu.com/p/138878534 注意事项 通过gitee page来建博客，仓库名一定要与gitee用户名一致，这样可以采用https://用户名.gitee.io/的方式来访问博客。 每次更新博客内容需要手动在gitee page上进行刷新（氪金会员据说可以自动刷新） hexo配置和主题配置，分别在_config.yml和_config.xxx主题名xx.yml中 写文章，就在source/_posts/下，可以再创建文件夹进行分类存放 生成文章摘要有两种方法 在文章中某一行添加&lt;-- more --&gt;，则该行以上的内容会作为摘要 在md文件开头添加属性excerpt:xxx内容填写摘要即可 hexo常用命令 注：首先要用cmd或者git来到本地博客根目录 hexo init初始化博客 hexo clean 刷新部署 hexo generate 更新博客内容后，需要重新生成 hexo deploy 部署到远程服务器上 hexo c &amp;&amp;hexo g &amp;&amp;hexo d 可以一键完成上述三个功能 文章常用yaml front matter title: xxx标题 category: 分类 tag: 标签 excerpt: 文章摘要 updated: 2020-04-01 00:00:00 更新时间，（注意在_config.icarus.yml中article中可以设置update_time以实现控制) date: 2020-1-1 00:00:00 创建时间","link":"/2021/09/09/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}