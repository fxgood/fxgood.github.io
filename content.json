{"pages":[],"posts":[{"title":"Java相关的思考","text":"看到一个知乎的回答讲jvm、jre、jdk，讲的很好，将其主要观点记录下来，来自知乎用户圆胖肿： 现在java现在已经不再强调jvm概念了 以前，jvm是跨平台所需要部分的最小子集，也就是主要用来封装OS差异用的，每一种操作系统，都弄一个jvm，这样提供给上层的接口就统一了。 在jvm的基础上，再加上一些常见的类库，工具，就做成了jre，也就是java的运行时runtime 然后再在jre的基础之上，添加一些编译器等工具，这就是java的sdk（软件开发工具包）了，简称jdk。因此jdk是jre的超集，jre是jvm的超集，反过来，jvm是jre的子集，jre是jdk的子集。 以前java提供jre和jdk两个下载，如果只是运行java的字节码，jar那些的话，只下载安装jre就行，无需安装jdk，只有开发者才需要jdk。 java在9的jsgsaw之后，就不再使用jvm的概念，因为jre可以被定制了，jvm和jre被拆成了一个又一个模块，可以根据需要，删减或者加入自己编写的模块。","link":"/2021/04/26/Java-java%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"O(1)时间插入、删除和获取随机元素的数据结构","text":"今天做到了这一题O(1) 时间插入、删除和获取随机元素，其利用了哈希的O(1)查找，和数组O(1)的随机访问特点来实现题目所要求的数据结构。 并且，做这道题目，纠正了我一个很大的误区，数组的删除，只有在要求顺序不变的情况下，其最坏时间复杂度才是O(N)，否则可以通过交换当前数和数组尾部的数字，然后pop_back()，来实现O(1)时间复杂度的删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*利用哈希的O(1)查找和数组的随机访问*/class RandomizedSet {private: map&lt;int,int&gt;mp; vector&lt;int&gt;nums; //O(1)时间复杂度删除一个数字 void deleteNum(int n){ int index=mp[n]; nums[index]=nums[nums.size()-1]; mp[nums[index]]=index; //删除 mp.erase(n); nums.pop_back(); }public: /** Initialize your data structure here. */ RandomizedSet() { srand((unsigned)time(NULL)); } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(mp.find(val)==mp.end()){ mp[val]=nums.size(); nums.emplace_back(val); return true; } return false; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(mp.find(val)!=mp.end()){ deleteNum(val); return true; } return false; } /** Get a random element from the set. */ int getRandom() { return nums[rand()%nums.size()]; }};/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"单调队列解决滑动窗口最大值问题","text":"今天遇到一道滑动窗口最大值问题239滑动窗口最大值，发现单调队列是解决这类问题的高效方法，遂加以记录。 单调队列：即保持单调有序的队列。底层数据结构使用双端队列比较好，C++需要添加&lt;deque&gt;头文件。 滑动窗口最大值问题中，我们关心的是滑动窗口内的最大值，当滑动窗口向右移动一位时，需要删除一个元素和添加一个元素。对于添加元素来说比较好办，如果添加的元素大于当前最大值则替换其为最大值。而删除元素，如果删除的是最大值，则需要重新遍历滑动窗口内容，造成效率的低下。 研究此问题发现，如下图，当添加的元素是4,时，前面的所有小于4的元素均变成无效数据（如果删除5，则4是最大值，轮不到123当最大值；如果删除了5又删除了4，因为123在4之前进入滑动窗口，所以删除4之前123已经被删除，所以也轮不到123当最大值）。 因此滑动窗口右移，一：删除窗口左端元素，如果和队首元素相同，则队首元素出队，否则什么也不做；二：添加窗口右边元素，新元素入队时，都将前面所有比自己小的元素删除再入队 1234567891011121314151617181920212223242526272829303132333435//单调队列struct MonotonicQue{ deque&lt;int&gt;que; void push(int n){ while(!que.empty() &amp;&amp; que.back()&lt;n){ que.pop_back(); } que.push_back(n); } void pop(int n){ if(n==que.front()) que.pop_front(); } int top(){ return que.front(); }};class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MonotonicQue monQue; //添加前k个元素到单调队列 for(int i=0;i&lt;k;i++) monQue.push(nums[i]); vector&lt;int&gt;ans; ans.push_back(monQue.top()); for(int i=k;i&lt;nums.size();i++){ monQue.pop(nums[i-k]); monQue.push(nums[i]); ans.push_back(monQue.top()); } return ans; }};","link":"/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"},{"title":"双栈模拟队列","text":"使用第一个栈存储push的元素，只有当需要pop时，才将第二个栈中的元素全部倒入到第二个栈中。n次操作总复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyQueue {private: stack&lt;int&gt; st1,st2; int popSt2(){ int ans=st2.top(); st2.pop(); return ans; } void transfer(){ while(!st1.empty()){ st2.push(st1.top()); st1.pop(); } }public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { st1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if(!st2.empty()){ return popSt2(); } transfer(); return popSt2(); } /** Get the front element. */ int peek() { if(!st2.empty()){ return st2.top(); } transfer(); return st2.top(); } /** Returns whether the queue is empty. */ bool empty() { return st1.empty() &amp;&amp; st2.empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"title":"单调栈的应用案例","text":"单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序。 单调栈模板单调栈一般用来解决一类问题：Next Greater Number。比如说，输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。即找到每个元素之后，第一个大于它的元素，如果没有则设置为-1。 解决方式：使用一个栈st，然后逆序来看nums数组，先将所有栈中比当前元素小的全部弹出（比当前元素矮的元素都是后续无法利用的无效信息,如图，矮个子会被高个子挡住，因此丢弃），然后如果此时栈空，则结果是-1；如果不为空，为结果是栈顶元素。最后将当前元素入栈；循环执行，最后得出结果数组。 例题1496下一个更大元素I 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int,int&gt;mp; stack&lt;int&gt;st; for(int i=nums2.size()-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; st.top()&lt;nums2[i]){ st.pop(); } if(st.empty()){ mp[nums2[i]]=-1; }else{ mp[nums2[i]]=st.top(); } st.push(nums2[i]); } vector&lt;int&gt;ans; for(auto&amp;n:nums1){ ans.push_back(mp[n]); } return ans; }}; 例题2739每日温度 12345678910111213141516171819class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt;st; vector&lt;int&gt;ans(temperatures.size()); //如果不预先申请长度，则会因为频繁扩容和复制数组，导致超时 for(int i=temperatures.size()-1;i&gt;=0;i--){ int n=temperatures[i]; while(!st.empty() &amp;&amp; n&gt;=temperatures[st.top()]){ st.pop(); } if(st.empty()) ans[i]=0; else ans[i]=st.top()-i; st.push(i); } return ans; }}; 例题3503下一个更大元素II 解决循环数组问题的常用解决方法就是数组翻倍。这里并没有直接构建一个双倍数组，而是通过下标小技巧实现的，形成逻辑上的二倍数组。 1234567891011121314151617class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int len=nums.size(); vector&lt;int&gt;ans(len,-1); stack&lt;int&gt;st; for(int i=2*len-1;i&gt;=0;i--){ while(!st.empty() &amp;&amp; nums[i%len]&gt;=st.top()) st.pop(); if(i&lt;len &amp;&amp; !st.empty()){ ans[i]=st.top(); } st.push(nums[i%len]); } return ans; }};","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"实现一个优先级队列(堆)","text":"手动实现一个优先级队列，拥有插入、弹出、判空功能。核心代码是对维护堆结构的代码：从完全二叉树逆序第一个有子节点的节点开始调整。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//手动实现一个二叉堆（优先级队列）#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class PriorityQueue{public: //插入 void push(int n){ arr.push_back(n); makeHeap(); } //弹出队首元素 int pop(){ int ans=arr[0]; swap(arr[0],arr[arr.size()-1]); arr.pop_back(); makeHeap(); return ans; } //判断队空 bool empty(){ return arr.size()==0; }private: //底层数组 vector&lt;int&gt;arr; //调整堆结构 void makeHeap(){ int len=arr.size(); int first=len/2-1; //固定是此位置 for(int i=first;i&gt;=0;i--){ //如果存在右子节点 if(2*i+2&lt;len){ if(arr[2*i+2]&lt;arr[2*i+1] &amp;&amp; arr[2*i+2]&lt;arr[i]) swap(arr[2*i+2],arr[i]); else if(arr[2*i+1]&lt;arr[2*i+2] &amp;&amp; arr[2*i+1]&lt;arr[i]) swap(arr[2*i+1],arr[i]); } //只有左子节点 else{ if(arr[2*i+1]&lt;arr[i]){ swap(arr[2*i+1],arr[i]); } } } }};int main(){ PriorityQueue que; que.push(1); que.push(1); que.push(4); que.push(3); que.push(2); while(!que.empty()){ cout&lt;&lt;que.pop()&lt;&lt;&quot; &quot;; }}","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%E5%8F%89%E5%A0%86%EF%BC%89/"},{"title":"队列模拟栈","text":"栈模拟队列需要两个，而队列模拟栈最少只需要一个。即每次需要出栈时，把队尾元素返回即可（其他元素出队再入队）。 下面给出用双队列模拟栈的代码，其中now标记的使用，比较巧妙 12345678910111213141516171819202122232425262728293031323334353637class MyStack {private: queue&lt;int&gt; qArr[2]; int now=0;public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { qArr[1-now].push(x); while(!qArr[now].empty()){ qArr[1-now].push(qArr[now].front()); qArr[now].pop(); } now=1-now; } /** Removes the element on top of the stack and returns that element. */ int pop() { int ans=qArr[now].front(); qArr[now].pop(); return ans; } /** Get the top element. */ int top() { return qArr[now].front(); } /** Returns whether the stack is empty. */ bool empty() { return qArr[now].empty(); }};","link":"/2021/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E6%A0%88/"},{"title":"非递归实现树的三种遍历","text":"三种非递归遍历都使用一种框架,代码如下 123456789101112131415void traversal(TreeNode* root) { TreeNode*p=root; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜入栈 while(p!=NULL){ st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } } 中序遍历其核心思想在于：每次把一棵树的根节点、根节点的左孩子、左孩子的左孩子…一直到最左下角，这一条斜线上的所有节点入栈。每次取出并打印栈顶节点的值，然后对其右子树进行上述入栈操作。 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt;st; while(root){ st.push(root); root=root-&gt;left; } vector&lt;int&gt;ans; while(!st.empty()){ //取出栈顶元素 TreeNode*t=st.top(); st.pop(); ans.emplace_back(t-&gt;val); //将栈顶元素右孩子一直到其最下角的左孩子全部入栈 TreeNode*p=t-&gt;right; while(p){ st.push(p); p=p-&gt;left; } } return ans; }}; 前序遍历1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { TreeNode*p=root; vector&lt;int&gt;ans; stack&lt;TreeNode*&gt;st; while(!st.empty() || p!=NULL){ //将p及其左边一溜先打印，再入栈 while(p!=NULL){ //打印 ans.push_back(p-&gt;val); //cout&lt;&lt;st.top()-&gt;val //入栈 st.push(p); p=p-&gt;left; } //p指向栈顶元素的右孩子，即使它为空 p=st.top()-&gt;right; //栈顶元素出栈 st.pop(); } return ans; }}; 后序遍历后序遍历非递归的关键在于，栈顶元素何时打印，何时不打印。 当栈顶元素右子树全部访问完了（pre==top()-&gt;right)或为空时，根据后序遍历的定义，此时可以打印栈顶元素；这里的pre指向上次打印的节点，由于后序遍历根最后打印，所以当pre==top()-&gt;right时，能够判断出栈顶元素的右子树所有节点已经访问完毕。 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt;st; TreeNode*pre=NULL; vector&lt;int&gt;ans; TreeNode*p=root; while(p || !st.empty()){ while(p){ st.push(p); p=p-&gt;left; } //如果栈顶元素的右子树为空 或者 右子树存在且已经全部访问过了，则直接打印 if(st.top()-&gt;right==NULL || st.top()-&gt;right==pre){ ans.push_back(st.top()-&gt;val); pre=st.top(); st.pop(); p=NULL; //让下一轮直接访问栈顶元素 }else p=st.top()-&gt;right; } return ans; }};","link":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"},{"title":"算法题之戳气球","text":"leetcode312 戳气球 这一题可以用动态规划来解决,但是dp含义的设置和状态转移方程的设计很有意思。 首先,一维dp难以实现的，应该考虑二维dp，尤其在一个数组中，要考虑到双指针移动来解决复杂问题。 如果将dp[i][j]的含义设置为戳爆下标[i,j]之间所有的气球能获得的最大钱币,会发现由于涉及到与i左边和j右边数字相乘,难以书写状态转移方程。 将dp[i][j]的含义设置为:戳爆下标i和j之间（开区间）的所有气球能获得的最大钱币。此时，如果将状态转移方程写为$dp[i][j]=max(先戳气球k,再戳剩下所有气球,获得的最大钱币) i&lt;k&lt;j$,会造成子问题之间相互牵连,不具有独立性,也就无法完成动态规划的设计。 因此将状态转移方程方程写成dp[i][j]=max(先戳剩下所有气球,再戳气球k,获得的最大钱币) i&lt;k&lt;j,这样每次左右两边的计算互不干扰,即可完成动态规划的设计。 （本质是由于，如果先戳爆气球k，则气球k-1右侧的气球改变，气球k+1左侧的气球也改变，造成钱币获取公式的改变,而最后戳爆气球k,则不会出现这个问题,即固定了dp[i][j]中i和j这两个气球) 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt;nums; int stab(int t){ if(t==0 || t==nums.size()+1) return 1; return nums[t-1]; } //一维dp不行,就整二维 int maxCoins(vector&lt;int&gt;&amp; nums) { this-&gt;nums=nums; int n=nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n+2,vector&lt;int&gt;(n+2,-1)); for(int i=0;i&lt;=n+1;i++) for(int j=i;j&gt;=0;j--){ if(i==j || i==j+1){ dp[j][i]=0; } else{ int m=0; //最后戳爆气球k for(int k=j+1;k&lt;i;k++){ m=max(m,dp[j][k]+dp[k][i]+stab(i)*stab(k)*stab(j)); } dp[j][i]=m; } } return dp[0][n+1]; }};","link":"/2021/08/02/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%88%B3%E6%B0%94%E7%90%83/"},{"title":"JDBC学习笔记","text":"JDBC基本概念 Java DataBase Connectivity Java数据库连接，Java语言操作数据库 JDBC本质：是Sun公司定义的一套操作关系型数据库的接口，各个数据库厂商去实现了这套接口，提供数据库驱动jar包。我们可以使用这套接口编程 快速入门 步骤 导入驱动jar包 复制文件到libs目录下(记得把数据库驱动也复制过去) 右键add as library 注册驱动 获取数据库的连接对象Connection（java与数据库的连接桥梁） 定义sql 获取执行sql语句的对象Statement 执行sql，接收返回结果 处理结果 释放资源 如果自定义JDBCUtils，则须在src下创建jdbc.properties 1234url=jdbc:mysql:///db1user=rootpassword=rootdriver=com.mysql.jdbc.Driver 代码实现 12345678910111213141516//1.导入jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db1&quot;, &quot;root&quot;, &quot;123&quot;); //4.定义sql语句 String sql =&quot;update user set name='goodboy' where id=1&quot;; //5.获取执行sql的对象 Statement statement = connection.createStatement(); //6.执行sql int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); connection.close(); 详解各个对象 DriverManager：驱动管理对象 功能： 注册驱动：告诉程序该使用哪个数据库驱动jar（！mysql5以后自动注册） static void registerDriver(Driver driver)：注册与给定的驱动程序DriverManager 写代码使用：Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在存在静态代码块 获取数据库连接 ： 方法：getConnection(String url,String user,String password) 参数 url:指定连接的路径 mysql语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称 例子：jdbc:mysql:..localhost(127.0.0.1):3306/bd1 细节：如果连接的是本机的mysql服务器，并且mysql服务默认端口是3306，则url可以简写为jdbc:mysql:///数据库名称 user：数据库用户名 password：数据库密码 Connection：数据库连接对象 功能 获取执行sql的对象 createStatement() prepareStatement(String sql) 管理事务 开启事务： setAutoCommit(boolean autoCommit)：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql)：可以执行任意sql，了解即可不常用 int excuteUpdate(String sql)：执行DML（增删改insert，update，delete）语句，（DDL不常用）DDL（create,alter,drop) 返回值：影响的行数。&gt;0执行成功 （最常用）ResultSet excuteQuery(String sql)：执行DQL（Select）语句 ResultSet：结果集对象,封装查询结果 boolean next()：游标向下移动衣阿华那个 getXxx(参数)：获取数据 Xxx：代表数据类型 如getInt() getString() 参数： int：代表列的编号，从1开始 String：代表列名称。如getString(“name”); 使用步骤 游标向下移动一行 判断是否有数据(看next的返回结果，如果为false则该行没数据 ) 获取数据 练习 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回（注意double类型接收数据库的小数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 查询emp表然后将结果封装成一个对象，然后放入集合，返回*/public class JDBC_demo05 { /*查询emp所有对象*/ public static List&lt;User&gt; findAll(){ Connection connection=null; Statement statement=null; ResultSet resultSet=null; ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取连接 connection= DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //3.创建sql String sql=&quot;select*from user&quot;; //4.执行sql statement=connection.createStatement(); resultSet = statement.executeQuery(sql); //5.处理结果 while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(statement!=null) statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } return list; } public static void main(String[] args) { List&lt;User&gt; all = JDBC_demo05.findAll(); for(User user:all){ System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getGender()); } }} PreparedStatement：执行sql的对象（是Statement的子接口） SQL注入问题：在拼接sql时，有一些sql的特殊关键词参与字符串的拼接。会造成安全性问题 用户名随便，密码输入 a’ or ‘a’=’a’ sql: select*from user where username=xxx and password=’a’ or ‘a’=’a’,查询条件变成了恒等式 解决：使用PreparedStatement对象来解决 预编译的SQL：参数？作为占位符 步骤： 导入驱动jar包 注册驱动 获取数据库连接对象COnnection 定义sql 注意：sql的参数使用？作为占位符 获取PreparedStatement对象：Connection.getPreparedStatement(String sql) 给？赋值 方法：setXxx（参数1，参数2） 参数1：？的位置编号，从1开始 参数2：？的值 注意：后期都会使用PreparedStatement来完成增删改查的所有工作 可以防止SQL注入 效率更高 代码实现 1234567891011121314151617181920212223242526272829303132333435public class JDBC_demo03_标准 { public static void main(String[] args) { Connection connection=null; Statement statement=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;insert into user values(3,'小小余','男')&quot;; //5.执行 statement = connection.createStatement(); int result = statement.executeUpdate(sql); //6.打印结果 if(result&gt;0) System.out.println(&quot;执行成功！&quot;); else System.out.println(&quot;执行失败！&quot;); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041public class JDBC_demo04_excuteQuery { public static void main(String[] args) { Connection connection=null; Statement statement=null; ResultSet resultSet=null; //1.导驱动jar包 try { //2.设置驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取连接数据库对象 connection = DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,&quot;root&quot;,&quot;&quot;); //4.定义sql语句 String sql=&quot;select*from user&quot;; //5.执行 statement = connection.createStatement(); resultSet=statement.executeQuery(sql); //6.打印结果 while(resultSet.next()){ int id=resultSet.getInt(&quot;id&quot;); String name=resultSet.getString(&quot;name&quot;); String gender=resultSet.getString(&quot;gender&quot;); System.out.println(id+&quot;/&quot;+name+&quot;/&quot;+gender); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { try { if(resultSet!=null) resultSet.close(); if(statement!=null) statement.close(); if(connection!=null) connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 抽取JDBC工具类：JDBCUtils 目的：简化书写 案例： User: 封装了数据库表的JavaBean 1234567891011121314151617181920212223242526272829303132333435363738394041public class User { private int id; private String name; private String gender; @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, gender='&quot; + gender + '\\'' + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public User() { }} JDBCUtils工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; //静态代码块加载配置文件,**静态代码块随着类的加载而加载，只执行一次** static { Properties properties=new Properties(); //获取src路径下的文件的方式——&gt;ClassLoader类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL propertiesURL = classLoader.getResource(&quot;jdbc.properties&quot;); try { properties.load(new FileReader(propertiesURL.getPath())); } catch (IOException e) { e.printStackTrace(); } url=properties.getProperty(&quot;url&quot;); user=properties.getProperty(&quot;user&quot;); password=properties.getProperty(&quot;password&quot;); driver=properties.getProperty(&quot;driver&quot;); //注册驱动 try { Class.forName(driver); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //获取Connection对象 public static Connection getConnection(){ Connection connection=null; try { connection= DriverManager.getConnection(url, user, password); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //执行sql语句,实现增删改 public static void update(String sql){ Connection connection=getConnection(); Statement statement=null; int result=-1; try { statement = connection.createStatement(); result = statement.executeUpdate(sql); if(result&gt;0) System.out.println(&quot;执行成功！&quot;); } catch (SQLException throwables) { throwables.printStackTrace(); }finally { closeUpdate(connection,statement); } } //update后关闭资源 public static void closeQuery(Connection connection, ResultSet resultSet, Statement statement){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } } //query后关闭资源 public static void closeUpdate(Connection connection,Statement statement){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } }} 实现增删改 1234567public class JDBC_demo06 { public static void main(String[] args) { Connection connection= JDBCUtils.getConnection(); String sql=&quot;insert into user values(4,'小小余','女')&quot;; JDBCUtils.update(sql); }} 实现查询 12345678910111213141516171819202122232425262728public class JDBC_demo07 { public static void main(String[] args) { Statement statement=null; ResultSet resultSet=null; String sql=&quot;select*from user&quot;; Connection connection= JDBCUtils.getConnection(); ArrayList&lt;User&gt;list=new ArrayList&lt;&gt;(); try { statement=connection.createStatement(); resultSet=statement.executeQuery(sql); while(resultSet.next()){ User user=new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setGender(resultSet.getString(&quot;gender&quot;)); list.add(user); } } catch (SQLException throwables) { throwables.printStackTrace(); } JDBCUtils.closeQuery(connection,resultSet,statement); for(User user:list){ System.out.println(user); } }} JDBC控制事务 事务：一个包含多个步骤的业务操作 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 setAutoCommit(boolean autoCommit（）：调用该方法，设置参数为false，即开启事务 在执行sql之前开启事务 commit()：提交事务 当所有sql都执行完提交事务 rollback()：回滚事务 在catch中回滚事务 数据库连接池 概念：其实就是一个容器（集合）：存放数据库连接的容。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户访问数据库时，从容器中获取连接对象，用户访问完后，会将对象归还给容器 好处 节约资源 高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：如果连接对象COnnection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接，而是归还到连接池中 一般我们不去实现它，由数据库厂商来实现 C3P0：数据库连接池技术（老） Druid（德鲁伊）：由阿里巴巴来实现的 C3P0 略 Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂类来获取DruidDataSourceFactory 获取连接：getConnection() 代码实现 1234567891011//1.导入jar包，放入libs，右键add as library//2.定义配置文件，赋值，放在src下(记得修改一下url）//3.加载配置文件Properties properties=new Properties();InputStream inputStream = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);properties.load(inputStream);//4.获取连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//5.获取连接Connection connection=dataSource.getConnection();System.out.println(connection); 定义工具类 定义一个类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源： 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*Druid连接池的工具类*/public class JDBCUtils_Druid { //1.定义成员变量DataSource private static DataSource dataSource; static{ //1.加载配置文件 Properties properties=new Properties(); InputStream inputStream = JDBCUtils_Druid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); try { properties.load(inputStream); dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } //2.获取连接的方法 public static Connection getConnection(){ Connection connection=null; try { connection=dataSource.getConnection(); } catch (SQLException throwables) { throwables.printStackTrace(); } return connection; } //3.释放资源 public static void close(Statement statement,Connection connection){ if(statement!=null) { try { statement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if(connection!=null) { try { connection.close(); //归还连接 } catch (SQLException throwables) { throwables.printStackTrace(); } } } public static void close(ResultSet resultSet,Statement statement, Connection connection){ if(resultSet!=null) { try { resultSet.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } close(statement,connection); } //4.获取连接池的方法 public static DataSource getDataSource(){ return dataSource; }} Spring JDBC Spring框架提供的JDBC简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 (记得还导入mysql驱动) 创建JdbcTemplate对象。依赖于数据源DataSource（数据库连接池） JdbcTemplate template=new JdbcTemplate(ds); 调用方法来完成crud操作 update()：执行DML语句 （增删改） queryForMap（）：查询结果将结果集封装为Map集合，只能查询结果为1个的语句 queryForList（）：查询结果将结果集封装为List集合 query()：查询结果，将结果封装为JavaBean对象 query的参数：RowMapper接口 一般我们使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装 例：new BeanPropertyRowMapper(Person.class) queryForObject（）：查询结果，将结果封装为对象（一般用于聚合函数的查询） ```java //1.导入jar包，加入library //2.创建JdbcTemplate对象，参数是数据库连接池 JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); //3.调用方法 String sql=&quot;update account set balance =100 where id=?&quot;; int result = jdbcTemplate.update(sql, 2); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* 练习： * **注意！JavaBean在封装时成员变量最好写成封装类型Integer Double等，否则在调用template进行封装时会出现，如果某个值为null就会报错** * 需求 1. 修改数据 2. 增加记录 3. 删除记录 4. 查询一定条件的结果，封装为map集合 5. 查询所有记录，分装为list 6. 查询所有记录，封装为emp对象的list集合 7. 查询总记录数（count聚合函数） ```java public class demo04_test { @Test public void test01(){ //查询结果以map的方式返回,**查询结果只能为1个** JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(&quot;select*from account where id=1&quot;); System.out.println(stringObjectMap); } @Test public void test02(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select*from account&quot;); System.out.println(list); } @Test public void test03(){ //遍历所有，将每行的结果封装为一个JavaBean JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new RowMapper&lt;Person&gt;() { @Override public Person mapRow(ResultSet resultSet, int i) throws SQLException { Person p = new Person(); p.setId(resultSet.getInt(&quot;id&quot;)); p.setBalance(resultSet.getInt(&quot;balance&quot;)); p.setName(resultSet.getString(&quot;name&quot;)); return p; } }); System.out.println(personList); } //简化版封装JavaBean @Test public void test04(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); List&lt;Person&gt; personList = jdbcTemplate.query(&quot;select*from account&quot;, new BeanPropertyRowMapper&lt;Person&gt;(Person.class)); System.out.println(personList); } //查询记录条数 @Test public void test05(){ JdbcTemplate jdbcTemplate=new JdbcTemplate(JDBCUtils_Druid.getDataSource()); Integer integer = jdbcTemplate.queryForObject(&quot;select count(*)from account&quot;, Integer.class); System.out.println(integer); } }","link":"/2020/05/12/Java-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java基础","text":"1. 概述 冯诺依曼体系结构 组成：运算器，控制器，存储器，输入设备，输出设备 SUN公司1995年推出的一门高级编程语言 JDK：Java Development Kit （java开发工具包） 包括jre 其他开发工具：编译工具javac.exe，打包工具jar.exe JRE：Java Runtime Environmen（java运行时环境 ） 包括Java虚拟机（Java Virtual Machine）和Java程序所需要的核心类库等。 如果想运行一个开发好的java程序，计算机中只需要安装JRE即可。 Java内存模型 2. 基本语法2.1 关键字和标识符关键字 关键字的定义和特点 定义：被Java语言赋予了特殊含义的字符串 特点：都是小写 用于定义数据类型的关键字byte,short,int,long,float,double,boolean,void,class,interface,enum 用于流程控制的关键字if,else,switch,for,while,case,default,do,break,continue,return 用于定义访问权限修饰符的关键字public,protected,private 定义类，函数，变量修饰符的关键字abstract,final,static,synchronized 用于定义类与类之u见关系的关键字extends,implements 用于定义简历实例及引用实例，判断实例的关键字new,this,super,instanceof 用于异常处理的关键词try,catch,finally,throw,throws 用于包的关键字package,import 其他修饰符关键字native,strictfp,transient,volatile,assert 保留字现有Java版本尚未使用，但以后版本可能会作为关键字使用，如goto，const 标识符命名规范 包名：全部小写,xxxyyyzzz 类名、接口名：大驼峰 变量名、方法名：小驼峰 常量名：全部大写，多个单词用下划线连接 2.2 变量基本数据类型 Java语言数据类型的长度和表示范围不受OS影响 基本数据类型(primitive type) 数值型 整数类型 byte:1字节，范围：-128-127 short:2字节，范围:$-2^{15}$ ~ $2^{15}+1$ int:4字节，范围$-2^{31}$ ~ $2^{31}-1$（约21亿） long:8字节，范围$-2^{63}$ ~ $2^{63}-1$声明long类型常量须加小写l或者大写L 浮点类型 单精度float，占4字节，尾数可以精确到7位有效数字 float类型表示范围比long还大！ 因为float类型底层存储方式不同，$2^E*M$ 浮点数关注的是精度，整数类型关心的是范围，。 双精度double，占8字节，精度是float的两倍。通常采用此类型 java的浮点型常量默认为double类型，声明float类型，须后加小写f或者大写F 两种表示形式 十进制数形式：2.12, 512.0f, .34 科学计数法形式：5.12e2, 512E2, 100E-2 字符型 char，占2个字节 三种表示方式 单引号 转义字符\\r回车符，\\n换行符 Unicode值直接表示，\\uXXXX，XXXX代表一个十六进制整数 char类型可以运算，因为有对应的Unicode码 UTF-8是使用最广的一种Unicode的实现方式 布尔型 boolean 引用数据类型(reference type) 类(包括String） 接口 数组 基本数据类型之间的转换除了boolean类型，其他7种基本数据类型之间的转换自动类型提升 当容量（表示数的范围）小的数据类型的变量与容量大的数据类型的变量之间做运算时，结果自动提升为容量大的数据类型。 如果用int=int+long则会报错 容量（表示数的范围）从小到大是：byte（1字节）-&gt; char、short （2字节）-&gt; int -&gt; long -&gt; float -&gt; double (注意，float虽然是4个字节，但是比8个字节的long，能表示的数据范围要更大） 特别地，byte、char、short三种类型的变量之间做运算时（包括自己和自己，如byte+byte），结果为int类型 书上：java在做运算地时候，如果操作数均在int范围内，那么一律在int的空间内运算强制类型转换 需要使用强转符号() 可能造成精度损失 不加l或者L的整数，默认是int型 比如 long a=213214332143254324; 会报错，整数超过int类型 不加f或者F，默认是double类型 比如float b=12.3; 会报错 因为12.3默认是double类型，不能直接赋值给精度小的float类型常量 整型常量，默认类型为int型 浮点型常量，默认类型为double型String 声明String时，用双引号即可 不是基本数据类型，属于引用数据类型 字符串可以拼接其他字符串，也可以拼接其他数据类型的数据 可以与基本数据类型，直接做+运算 进制转换 对于整数，有四种表示方式 二进制binary，以0b或者0B开头 十进制decimal 八进制octal，以数字0开头 十六进制hex，以0x或者0X开头 二进制的整数有如下三种形式 原码：直接将一个数值转换成二进制。最高位是符号位 反码： 正数：和原码一样 负数：除符号位外，其他位对原码按位取反 补码： 正数：和原码一样 负数：反码+1 -127补码是1000 0001，-128补码是1000 0000，用-127减一即可 2.3 运算符Java中的运算符有 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 位运算符&gt;&gt;&gt;无符号右移 移位运算符和位运算符优先级如下~，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，^，| 2.4 数组对char型数组，System.out.println()打印的结果是内容的字符串形式对于其他类型的数组，打印的结果是类型@地址值，如[I@ed9d034 3. 封装面向对象的三大特征 封装 继承 多态3.1 java内存模型 堆Heap唯一目的是存放对象实例， 几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈Stack通常所说的栈Stack，指的是虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型(byte,short,char,int,long,boolean,float,double)、对象引用(reference类型，是对象在堆内存的首地址）。方法执行完，自动释放。 Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）， Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。对于我们来说，主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。 方法区Method Area用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(JDK8以后改成了元数据空间metaspace） 程序计数器1234程序计数器是一个记录着当前线程所执行的 字节码的行号指示器。JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。 首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，**每个线程工作时都有属于自己的独立计数器。** 运行时数据区包括：方法区、虚拟机栈、本地方法栈、堆、程序计数器 3.2 对象 对象的内存解析 对象数组的内存解析 注意： 此处的字符串“Tom”，是字符串常量，实际上是在方法区 引用类型的变量，只可能存储两类值：null 或 地址值（包含变量的类型）3.3 方法 方法重载概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数 或 参数类型不同即可。特点：与返回值类型无关，只看参数列表。 可变形参的方法允许直接定义能和多个实参相匹配的形参。从而，可以使用一种更简单的方式，来传递个数可变(任意个，包括0个）的参数。具体使用 格式：数据类型 ... 变量名 传入参数个数可以是：0个，1个，2个… 可以与形参不同的方法之间形成重载 与形参类型相同的数组，不能共存 在形参列表中，必须声明在末尾 形参列表中，最多只能声明一个可变形参定义123456public void show(String ... strs){ //可以像使用数组一样使用参数strs for(int i=0;i&lt;str.length();i++){ System.out.println(strs[i]); }} 方法参数的值传递机制Java里的方法的参数传递方式只有一种：值传递。即将实际参数值的副本传入方法内，而参数本身不受影响。 形参是基本数据类型：将其数据值传递给形参 形参是引用数据类型：将其地址值传递给形参 关于字符串作为形参的情况 123456789101112public class p1 { static void change(String s2) { s2 = &quot;bbb&quot;; } public static void main(String[] args) { String s1 = &quot;aaa&quot;; change(s1); System.out.println(s1); }}//打印结果：aaa Java中的String对象具有不可改变性，这里java在常量池中开辟了一块区域给aaa，s1指向aaa。change函数的形参仍然是地址传递（String是引用数据类型），s2也指向aaa，然后s2=&quot;bbb&quot;即将s2指向bbb，s1的指向并未改变。因此最终打印的结果仍然是aaa 3.4 四种权限修饰符封装性的体现： 我们将类的属性xxx私有化，同时，提供公共方法来获取和设置它。 不对外暴露的私有的方法 单例模式 … 我们设计程序追求“高内聚、低耦合” 高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅对外暴露少量的方法用于使用 Java规定了4种权限：private, (default), protected, public| 修饰符 | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 || ——— | —— | ——– | ———— | ———- || private | Yes | | | || (default) | Yes | Yes | | || protected | Yes | Yes | Yes | || public | Yes | Yes | Yes | Yes | 四种权限可以用来修饰类以及类的内部结构：属性、方法、构造器、内部类 对于class的权限修饰，只可以用public和default（缺省） public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 3.5 构造方法说明 如果没有显示地定义类的构造器的话，系统默认会提供一个空参的构造器；一旦我们显示定义了类的构造器之后，系统就不再提供默认的空参构造器。 定义构造器的格式：权限修饰符 类名(形参列表){...} 构造器可以重载 3.6 JavaBean说明 JavaBean是一种Java语言写成的可重用组件 所谓JavaBean，是指符合以下标准的Java类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get和set方法3.7 UML类图3.8 this说明 它在方法内部使用，即这个方法所属对象的引用 它在构造器内部使用，表示该构造器正在初始化的对象 用于构造器调用其他构造器（必须声明在当前构造器的首行，且最多只能使用一次）1234567891011public Person{ public Person(){...} public Person(int age){ this(); ... } public Person(int age,string name){ this(age); ... } } 3.9 JDK中主要的包介绍 java.lang：包含Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能 java.net：包含执行与网络相关操作的类和接口 java.io：包含能提供多种输入/输出功能的类 java.util：包含一些实用的工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数 java.text：包含了一些java格式化相关的类 java.sql：包含了java进行JDBC数据库编程的相关类/接口 java.awt：包含了构成抽象窗口工具及(abstract window toolkits）的多个类，用于构建和管理应用程序的GUI，现在不常用了。3.10 MVC设计模式MVC是常用的设计模式之一，将整个程序分为三个层次：视图、控制器、数据模型。3.11 import关键字说明 可以使用xxx.*方式，导入xxx包下的所有结构（子包除外，需要再显示声明） java.lang包或本宝下定义的类和接口，可以省略import 如果在源文件中，使用了两个不同包下的同名的类，则至少有一个要以全类名的方式书写（xxx.xxx.类名) import static ：导入指定类或接口中的静态结构（落脚点不是类，而是某个结构，属性或方法，或者写*），用的少。12345import static java.lang.System.*;import static java.Math.*;//这样可以省略System、Mathout.println(&quot;abc&quot;);long a=round(1.23); 4. 继承Java对继承的规定 单继承：一个子类只能有一个父类 直接继承的是直接父类，间接继承的是间接父类 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法，但是能否访问还得看权限修饰符。 4.1 Object类 如果我们没有显示地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除了java.lang.Object类）都直接或间接继承于java.lang.Object类4.2 方法重写 定义：在子类中可以根据需要对从父类继承来的方法进行改造。在程序执行时，子类的方法将覆盖父类的方法 要求： 重写的方法必须与父类具有相同的方法名和参数列表 重写的方法的返回值类型不能大于父类被重写的方法的返回值；如果父类返回的是基本数据类型，那么子类也必须是。 子类重写的方法使用的访问权限不能小于父类被重写的方法的权限 子类不能重写父类中声明为private权限的方法 子类方法跑出的异常不能大于父类被重写的方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static（不是重写）。因为static方法属于类，子类无法覆盖父类的static方法。 4.3 super关键字 说明 可以在子类的方法或构造其中，使用super.属性或者super.方法的方式，显示地调用父类中声明的方法或属性。通常情况下， 省略super 特殊情况下，当子类和父类方法名或属性名重名时，显示调用super super调用构造器 可以在子类的构造器中显示地使用super(形参列表)的方式，调用父类中声明的指定的构造器 必须在子类构造器的首行 类的构造器中，this(形参列表)和super(形参列表)只能二选一，不能同时出现 在构造器的首行，如果没有显示地声明 this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器；注意，子类构造器必须直接或间接地调用父类构造器，如果没有声明，则调用父类的默认空参构造器（如果父类没有，则报错）。4.4 子类对象实例化过程 从结果上看子类继承父类之后，就获取了父类中声明的属性和方法；创建子类的对象，在堆空间中，就会加载所有父类中声明的属性 从过程上看当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 4.5 抽象类与抽象方法4.6 接口5. 多态5.1 概述 理解多态性：是面向对象中最重要的概念，在Java中的体现就是父类的引用指向子类的对象。可以直接应用在抽象类和借口上。 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际给该变量赋值的对象决定。简而言之：编译时看左，运行时看右。 若编译时和运行时类型不一致，就出现了对象的多态性（Polymorphism） 多态情况下： 看左边：看的是父类的引用（父类中不具备子类特有的方法） 看右边：看的是子类的对象（实际运行的是子类重写父类的方法） 多态使用的前提 类的继承关系 方法的重写 多态性不适用于属性（编译和运行时都看左边） 多态的意义：多态是面向对象中最重要的概念，没有多态性，就没有后面的抽象类、接口等概念。 虚拟方法调用：子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。 如何证明多态是运行时行为？（编译时无法确定类型，动态绑定） 12345678910111213141516171819202122232425262728293031323334353637383940414243package July.demo01;import java.util.Random;public class Animal { void speak(){ } static Animal getInstance(int key){ switch(key){ case 0: return new Dog(); case 1: return new Cat(); default: return new Rabbit(); } } public static void main(String[] args) { int key= new Random().nextInt(3); Animal animal=getInstance(key); animal.speak(); }}class Dog extends Animal{ void speak(){ System.out.println(&quot;Dog!&quot;); }}class Cat extends Animal{ void speak(){ System.out.println(&quot;Cat!&quot;); }}class Rabbit extends Animal{ void speak(){ System.out.println(&quot;Rabbit!&quot;); }} 5.2 重载和重写 5.3 instanceof 操作符与向下转型如何才能调用子类特有的方法和属性？向下转型，使用强制类型转换符。使用强转的时候，可能出现ClassCastException异常。a instanceof A：如果a是A的实例，或者是A的子类的实例，则返回true 对于引用数据类型来说，强制类型转换的前提是，堆内存中存在转换后类型（或子类）的对象，否则不能转换。 123456//Man是Person的子类Person p=new Person();Man m=(Man)p; //错误！堆内存中是Person类型对象Object obj=new Man();Person p=(Person)obj; //可以执行！内存中有Man类型对象，也是Person子类的实例。 6. 补充内容6.1 Object类 Object类是所有Java的根父类 如果定义一个类没有声明父类，则默认继承java.lang.Object Object类只声明了一个空参的构造器 Object类方法（所有类的通用方法） equals toString getClass hashCode clone finalize6.2 ==和equals ==运算符 1.比较基本数据类型：比较值。注意可以类型不同，如int a=1; float b=1.0，a和b==运算的结果是true。（boolean不能参与运算） 2.比较引用数据类型：比较在内存中的地址值。 为何有些情况下，直接定义String的时候，可以直接用==判断两个String值相等？因为String存在字符串常量池的问题（但不是所有String都在里边，也有可能两个相同的String不指向同一个引用）。 equals方法 1.只能用于引用数据类型2.Object中的equals是用==实现的3.IDE自动生成的equals方法 6.2 包装类 基本数据类型、包装类和String之间的转换 自动装箱与自动拆箱包装类和基本数据类型之间可以直接进行互相赋值 123int a=1;Integer b=a;a=b; 基本数据类型、包装类–&gt;String方式一：使用&quot;&quot;+连接方式二：String.valueOf() String–&gt;基本数据类型、包装类 包装类的一些问题 6.3 关键字：static 修饰属性 修饰方法 单例设计模式 饿汉式： 优点：线程安全 缺点：资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类，那么这个实例仍然初始化 懒汉式： 优点：延迟加载，需要用到实例的时候再加载 缺点：线程不安全（有改进的方法） 12345678910111213141516171819202122//单例之饿汉式public class House { private static House house=new House(); public static House getInstance(){return house;} private House(){}}//单例之懒汉式class Country{ private Country(){} private static Country count=null; public static Country getInstance(){ if(count==null) count=new Country(); return count; }} 单例模式应用场景6.4 类的成员：代码块 代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 可以定义多个，按照声明的先后顺序执行 分类： 静态代码块：随着类的加载而加载，并执行；随着类的加载而执行，而且只执行一次 非静态代码块：随着对象的创建而加载，并执行；每创建一个对象，就执行一次6.5 关键字：final 修饰类：不能被继承 修饰方法：不能被重写 修饰变量：此时的变量变为了一个常量。 基本数据类型：变量一旦赋值后，不能被重新赋值。 引用数据类型：引用指向不能发生改变。6.6 抽象类与抽象方法abstract可以用来修饰类、方法，不能修饰私有方法、静态方法、final的类、方法 修饰类：抽象类 此类不能实例化 仍然提供构造器（子类要调用），类中一定有构造器。 修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之不然。 子类重写父类中的所有抽象方法后，此子类方可实例化 抽象类的匿名子对象模板方法设计模式 抽象类和接口的区别 1抽象类是一种对事物的抽象，而接口是一种对行为的抽象； 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 抽象类是一种模板式设计，而接口是一种行为规范，是一种辐射式设计。 6.7 接口 Java不支持多继承，但是有了接口，就可以实现多重继承的效果。接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。 说明： interface接口不能定义构造器，意味着接口不能实例化。 类implements接口 如果类没有实现接口中的所有抽象方法，则此类仍然是一个抽象类 接口和接口之间可以继承，而且可以多继承 JDK8之后，除了定义全局常量public static final和抽象方法以外，还可以定义静态方法、默认方法。 接口中的所有属性（全局静态常量）和方法，都是public的，即使不加，系统也自动声明为public。 接口匿名实现类6.8 接口应用：代理模式（Proxy） 概述：代理模式是Java开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制这个对象的访问。如明星（被代理类）和经纪人（代理类），租房者（被代理类）和中介（代理类）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class proxyPatternDemo { public static void main(String[] args) { Proxy proxy=new Proxy(new Server()); while(true){ proxy.browse(); System.out.println(); } }}//浏览网页的接口interface NetWork { void browse();}//被代理类class Server implements NetWork{ @Override public void browse() { System.out.println(&quot;正在访问该网站&quot;); }}//代理类class Proxy implements NetWork{ private NetWork netWork; public Proxy(NetWork netWork){ this.netWork=netWork; } private boolean check() throws InterruptedException { System.out.println(&quot;正在做访问网络前的检查...&quot;); Thread.sleep(1000); return new Random().nextInt(100)%2==0; } @Override public void browse(){ try { boolean res=check(); if(res){ System.out.println(&quot;校验通过，允许访问！&quot;); netWork.browse(); }else{ System.out.println(&quot;校验不通过，不允许访问！&quot;); } } catch (InterruptedException e) { e.printStackTrace(); } }} 应用场景 分类 静态代理（静态定义代理类） 动态代理 （动态生成代理类） JDK自带的动态代理，需要反射等知识。 6.9 接口的应用：工厂设计模式 工厂模式概念：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 核心本质：实例化对象，用工厂方法代替new操作；将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 工厂模式的分类 简单工厂模式：用来生产同一等级结构中的任意产品。（对于新增加的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） //简单工厂模式 123456789101112131415161718192021222324252627282930313233343536public interface Car { public void run();}class BMW implements Car{ @Override public void run(){ System.out.println(&quot;BMW is running~&quot;); }}class Mercedes_Benz implements Car{ @Override public void run(){ System.out.println(&quot;Benz is running~&quot;); }}//Car工厂类class carFactory{ public static BMW getBMW(){ return new BMW(); } public static Mercedes_Benz getBenz(){ return new Mercedes_Benz(); }}class Test{ public static void main(String[] args) { Car car1=carFactory.getBenz(); Car car2=carFactory.getBMW(); car1.run(); car2.run(); }} //工厂方法模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Car { void run();}class Benz implements Car{ @Override public void run() { System.out.println(&quot;Benz is running...&quot;); }}class Audi implements Car{ @Override public void run() { System.out.println(&quot;Audi is running...&quot;); }}//工厂接口interface carFactory{ Car getCar();}//宝马工厂class BenzFactory implements carFactory{ @Override public Benz getCar() { return new Benz(); }}//奥迪工厂class AudiFactory implements carFactory{ @Override public Car getCar() { return new Audi(); }}class Test{ public static void main(String[] args) { Car car1=new AudiFactory().getCar(); Car car2=new BenzFactory().getCar(); car1.run(); car2.run(); }} 6.10 JDK8接口静态方法、默认方法 静态方法：接口中定义的静态方法，只能通过接口来调用（不能用实现类来调用） 默认方法：类似让接口拥有类的功能，让实现类拥有该方法。通过实现类对象来调用（可以重写）。 public即使不加，系统也会自动加上1234567891011121314151617public interface Test { public static void method1(){ //... } static void method2(){ //... } public default void method3(){ //... } default void method4(){ //... }} 6.11 内部类 概念：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 Inner class 一般用在定义它的类或者语句块之内，在外部引用它时必须给出完整的名称。 分类 成员内部类：static成员内部类和非static成员内部类 局部内部类（不谈修饰符）：匿名内部类 1234567891011public class Person { //静态成员内部类 static class Cat{} //非静态成员内部类 class Dog{} void f(){ //局部内部类 class Fish{} } } 7. 异常处理7.1 异常概述与异常体系结构 为什么需要异常处理因为有很多问题不是靠代码能够避免的，比如：用户输入数据的格式，读取文件是否存在，网络是否始终保持畅通等等 异常：在程序执行过程中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常） 分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。如：StackOverflowError和OOM。一般不编写针对性的代码进行处理 Excepetion：其他因编程错误或者偶然的外在因素导致的一般性稳提，可以使用针对性的代码进行处理，例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组访问越界 Exception又分为：编译时异常(checked受检异常）和运行时异常 7.2 常见异常编译时异常 IOException —-FileNotFoundException ClassNotFoundException 运行时异常（编程实践中，一般对运行时异常不做处理） NuLLPointerException12345678//试图堆一个空对象调用方法时，就会产生空指针异常public class Main { @Test public void test(){ Date date=null; date.getTime(); }} ArrayIndexOutOfBoundsException ClassCastException1234567public class Main { @Test public void test(){ Object obj=new String(&quot;abc&quot;); Main main=(Main)obj; }} NumberFormatException123456public class Main { @Test public void test(){ int num=Integer.parseInt(&quot;abc&quot;); }} InputMismatchExceptionScanner输入int，结果用户输入abc，会报此异常 ArithmeticException123456public class Main { @Test public void test(){ int a=10/0; }} 7.3 异常处理机制一：try-catch-finally使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于把一个编译时可能出现的异常，延时到运行时出现（转变为运行时异常）。所以，对于运行时异常，一般不做处理。使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的类，并且终止try中代码的执行，根据此异常的类型去catch中进行匹配。try-catch-finally执行完了，继续执行下面的其他代码。 常用的异常对象处理的方式1.String getMessage()2.void printStackTrace() try-catch-finally结构可以嵌套 注意：如果catch多个异常存在父子关系的话，子类要放在上边 7.4 异常处理机制二：throws1.使用throws向上抛出异常，出现异常时，异常后序的代码将不再执行2.throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 注意：子类重写方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（或者不抛）（原因：多态时，父类引用指向子类对象，调用同名方法，并且进行异常处理时，如果子类方法异常类型大于父类类型，则无法处理） 1234567891011121314151617181920212223242526public class Main { @Test public void test() { f(new Son()); } public void f(Father person){ try { person.method(); } catch (IOException e) { e.printStackTrace(); } }}class Father{ void method()throws IOException{ }}class Son extends Father{ void method()throws FileNotFoundException{ }} 7.5 两种异常处理方式的选择1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理2.执行的方法A中，先后又调用了另外几个方法bcd，这几个方法是递进关系的（需要利用上一个方法的返回值）。建议这几个方法使用throws进行处理。而执行的方法A考虑使用try-catch-finally方式进行处理。（如果在b直接进行try-catch处理，cd会正常执行，但是利用的返回值是无效的） 7.6 手动抛出异常：throw关于异常对象的产生：1.系统自动生成的异常对象2.手动的生成一个异常对象，并throw 123456789101112131415public class ThrowTest { public static void main(String[] args) { new Student(-100); }}class Student{ private int id; Student(int id){ if(id&gt;0) this.id=id; else throw new RuntimeException(&quot;输入的id非法&quot;); }} 运行结果 12345678910111213141516171819public class ThrowTest { public static void main(String[] args) { try { new Student(-100); } catch (Exception e) { System.out.println(e.getMessage()); } }}class Student{ private int id; Student(int id) throws Exception{ if(id&gt;0) this.id=id; else throw new Exception(&quot;输入的id非法&quot;); }} 运行结果 7.7 用户自定义异常类如何自定义异常类?1.继承于现有的异常结构：RuntimeException, Exception2.提供全局常量序列号: serialVersionUID (类的唯一标识）3.提供重载的构造器 12345678910class MyException extends RuntimeException { static final long serialVersionUID = 123L; public MyException() { } public MyException(String msg) { super(msg); }}","link":"/2020/07/11/Java-java%E5%9F%BA%E7%A1%80/"},{"title":"Java高级","text":"1.多线程1.1 基本概念：程序、进程、线程程序：一段静态的代码进程：正在运行的程序，是资源分配的基本单位。线程：是CPU执行和调度的最小单位，每个线程拥有独立的运行栈和程序计数器pc，线程切换的开销比较小。多个线程共享一个进程的资源（共享进程的方法区和堆，但存在安全隐患）。 在Java的内存区域中，栈区（虚拟机栈）和程序计数器是每个线程一份，方法区和堆区，是每个进程一份，各个线程共享。 使用多线程的优点1.资源利用率提升，程序处理效率提高2.改善程序结构，代码会相对简单3.软件运行速度提升，提升应用程序的响应速度 何时需要多线程1.程序需要同时执行两个或多个任务2.程序需要实现一些需要等待的任务，如用户输入、文件读写操作、网络操作、搜索等3.需要一些后台运行的程序时 Java程序至少有3个线程1.主线程2.垃圾回收线程3.异常处理线程（会影响主线程） 1.2 线程的创建和使用Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 Thread类的特性1.每个线程都是通过特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run()3.Thread类实现了Runnable接口 start方法作用1.启动当前线程2.调用当前线程的run方法 注意1.不能通过调用run方法来启动线程（仍然在主线程中执行）2.额外再启动一个线程，需要重新创建一个线程的对象 两种创建线程的方法1.继承Thread类，重写run方法2.实现Runnable接口，实现run方法，在Thread构造器中传入一个Runnable接口实现对象 两种创建线程方法的比较开发中，优先选择Runnable接口的方法1.实现的方式没有类单继承性的限制2.实现的方式更适合来处理多个线程共享数据的情况 注意，这里ticket没有加static，就实现了三个线程共享ticket 1234567891011121314151617181920212223242526class Sell implements Runnable { private int ticket = 100; @Override public void run() { while (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;卖&quot; + ticket + &quot;号票&quot;); ticket--; } }}/* * 死锁的四个必要条件 * 1.互斥访问：共享资源互斥访问 * 2.请求并保持：已经持有资源的情况下，申请别的资源未果，也不释放自己持有的资源 * 3.不可剥夺：进程申请的资源除了完成任务释放，别人无法将其释放 * 4.循环等待：系统中存在资源循环等待的链条*/public class Demo { public static void main(String[] args) { Sell sell = new Sell(); new Thread(sell).start(); new Thread(sell).start(); new Thread(sell).start(); } Thread类常用方法1.void start()：启动当前线程；调用当前线程的run()2.run()：通常需要重写Thread类中的此方法，将创建的线程需要执行的操作声明在此方法中3.String getName()4.void setName()5.static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。6.yield()：释放cpu的执行权（有可能紧接着又获取了cpu的执行权）7.h.join()：在线程a中执行h.join()，会阻塞当前线程a，直到h线程执行完，线程a才结束阻塞状态8.stop()：强制线程生命周期结束，deprecated 不推荐使用，因为不安全，过时的api9.static void sleep(long millis)：睡眠(阻塞)若干毫秒；静态方法，可以直接调用。注意：如果是在run方法中使用sleep，则处理sleep的异常只能try-catch，无法throws；因为是重写Thread的run方法，其并无异常抛出，故子类重写也无法抛出异常。10.bool isAlive()：判断当前线程是否存活（是否执行完了），阻塞状态下返回值也是true。 获取线程名称Thread.currentThread().getName(); 更改线程名称1.通过Thread.currentThread().setName();2.通过构造器 123456789class MyThread extends Thread{ public MyThread(String name){ super(name); } public static void main(String[] args) { Thread t1=new MyThread(&quot;一号线程&quot;); }} 使用匿名对象执行开启线程 12345678new Thread(){ private int count=0; @Override public void run(){ while(true) System.out.println(count++); } }.start(); 1.3 线程的调度 Java的调度方法 1.同优先级线程组成先进先出队列（先到先服务），使用时间片策略2.对于高优先级，使用优先调度的抢占式策略 线程的优先级 1.线程的优先级等级：MAX_PRIORITY:10,MIN_PRIORITY:1,NORM_PRIORITY:52.获取和设置当前线程的优先级：getPriority(),setPriority(int p) 注意：并不是优先级高的执行完再执行优先级低的，而是优先级高的获取CPU的概率更高 1.4 线程的分类在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆： 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。 值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。下面的方法就是用来设置守护线程的。 1234567Thread daemonTread = new Thread(); // 设定 daemonThread 为 守护线程，default false(非守护线程) daemonThread.setDaemon(true); // 验证当前线程是否为守护线程，返回 true 则为守护线程 daemonThread.isDaemon(); 1.5 线程的生命周期 1.6 线程的同步线程同步，主要用来解决线程的安全问题。 例：创建三个线程卖票，总共100张1.问题：卖票过程中，出现了重票、错票（0，-1号票）–&gt;出现了线程的安全问题2.问题出现的原因：某线程操作车票时，别的线程也参与进来3.如何解决：某线程操作车票时，即使出现阻塞（例如sleep(100);)，别人也不能参与进来。4.在Java中，我们通过同步机制，来解决线程的安全问题 解决方式 同步代码块a.同步监视器（又叫锁）：任何一个对象都可以作为锁；要求多个线程必须要共用同一把锁。b.同步原理：当一个线程执行代码碰到一个锁时，如果已经有别的线程使用了锁并且没有归还，那么本线程就阻塞在这里。 继承Thread方式 1234567891011121314151617181920212223242526public class p1 { public static void main(String[] args) { Sell s1 = new Sell(); Sell s2 = new Sell(); Sell s3 = new Sell(); s1.start(); s2.start(); s3.start(); }}class Sell extends Thread { public static int ticket = 10000; @Override public void run() { while (true) { synchronized(Sell.class) { if (ticket &gt; 0) { System.out.println(getName() + &quot;出售第&quot; + ticket + &quot;张票&quot;); ticket--; } else break; } } }} 这里的Sell.class充分说明了，在Java中类也是对象 实现Runnable接口方式 1234567891011121314151617181920212223242526public class p2 { public static void main(String[] args) { Sell2 sell=new Sell2(); Thread t1=new Thread(sell); Thread t2=new Thread(sell); Thread t3=new Thread(sell); t1.start(); t2.start(); t3.start(); }}class Sell2 implements Runnable { private int ticket=10000; @Override public void run() { while(true){ synchronized(this){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); else break; } } }} 同步方法如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。 实现Runnable接口方式 1234567891011121314151617181920212223242526272829public class p3 { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; @Override public void run() { while (ticket &gt; 0) { sell(); } } private synchronized void sell() { if (ticket &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); } }} 继承Thread方式，注意这里的sell方法必须要加static，否则会出现安全问题（不加static，同步方法所用的锁，不是同一个） 同步方法不加static，使用的是this作为锁。加了static，使用的是类名.class作为锁 1234567891011121314151617181920212223242526public class p4 { public static void main(String[] args) { Window4 w1=new Window4(); Window4 w2=new Window4(); Window4 w3=new Window4(); w1.start(); w2.start(); w3.start(); }}class Window4 extends Thread{ private static int ticket=10000; @Override public void run(){ while(ticket&gt;0) sell(); } private static synchronized void sell(){ if(ticket&gt;0) System.out.println(Thread.currentThread().getName()+&quot;出售&quot;+ticket--+&quot;号票&quot;); }} 使用同步锁1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args) { Runnable r = new Window(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t3.setName(&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); }}class Window implements Runnable { private int ticket = 10000; ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); if (ticket &gt; 0) System.out.println(Thread.currentThread().getName() + &quot;出售&quot; + ticket-- + &quot;号票&quot;); else break; } finally { /*保证无论发生什么特殊情况，一定能够释放锁*/ lock.unlock(); } } }} 可重入锁 ReentrantLock 1一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；如果有两个不同的方法用到同一个锁，其中方法A里面又调用了方法B，那就不会死锁了 面试题：synchronized和Lock的区别？synchronized在执行完同步代码以后，自动释放同步监视器Lock方式手动加锁和释放锁，更加灵活。 1.7 改造懒汉单例模式使之线程安全**注意，写了两次判断instance==null**，这样效率最高。只在首次访问的时候进行同步，后续已经有instance的情况下无需同步，直接返回instance，最大化效率。 1234567891011121314151617181920//单例模式之懒汉式class Tool { private static Tool instance = null; //私有化构造方法 private Tool() { } public static Tool getInstance() { if (instance == null) { synchronized (Tool.class) { if (instance == null) instance = new Tool(); } } return instance; }} 1.8 线程的死锁问题死锁：1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续（操作系统中学到的定义：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，这些永远都在互相等待的进程，称为死锁进程） 解决方法1.专门的算法、原则2.尽量减少同步资源的定义3.尽量避免嵌套同步 死锁发生的四个必要条件1.互斥：共享资源互斥访问2.请求并保持：进程请求资源未果，不会释放自身已经占有的资源3.不可剥夺：只有进程自身使用完资源后才会释放，别人无法将其释放4.循环等待：多个进程之间存在资源请求的环路 预防死锁1.破坏请求并保持条件：一次性请求所有需要的资源，否则就不申请2.破坏不可剥夺条件：请求资源未果，释放自身占有的资源3.破坏循环等待条件：可用资源线性排序，只能从低到高申请资源 避免死锁银行家算法：已分配资源表、可用资源表、所需资源表；每次分配给一个能够满足其需求的进程，该进程执行完后返还所有的资源，不断循环。 1在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 预防死锁和避免死锁的区别预防死锁是通过破坏死锁发生的必要条件中的一个，限制条件比较严格，可能造成系统资源利用率和系统吞吐率的下降。避免死锁施加的条件比较宽松，在资源的动态分配中，避免系统出现不安全状态。 1.9 线程的通信例题：使用两个线程打印1~100。线程1，线程2交替打印 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r = new Count(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; @Override public void run() { while (true) { synchronized (this) { notify(); //或者this.notify, 如果用的是某个obj，则obj.notify if (num &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;数&quot; + num--); } else break; try { wait(); /*自我阻塞，wait会自动释放锁（与sleep的区别）*/ } catch (InterruptedException e) { e.printStackTrace(); } } } }} 涉及到的三个方法1.wait()：一旦执行此方法，当前线程就进入阻塞状态， 并释放同步监视器2.notify()：一旦执行此方法。就会唤醒被wait的一个线程。如果有多个，则唤醒优先级最高的3.notifyAll()：唤醒所有wait的线程 说明1.wait(), notify(), notifyAll() 三个方法必须使用在同步代码块或者同步方法中2.三者的调用者必须是同步代码块或同步方法中的同步监视器，否则会报异常，不加调用者默认是this.3.三者是定义在java.lang.Object类中的 上述例题也可以使用公平锁来实现（存在一个等待队列，先进先出）,注意要使用finally来保证unlock的执行 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Runnable r=new Count(); Thread t1=new Thread(r); Thread t2=new Thread(r); t1.start(); t2.start(); }}class Count implements Runnable { private int num = 100; ReentrantLock lock = new ReentrantLock(true);/*fair lock*/ @Override public void run() { while(true){ try{ lock.lock(); if(num&gt;0) System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num--); else break; } finally { lock.unlock(); } } }} 生产者消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Main { public static void main(String[] args) { Clerk clerk = new Clerk(); new Thread(new Consumer(clerk)).start(); new Thread(new Consumer(clerk)).start(); new Thread(new Producer(clerk)).start(); }}class Clerk { private int products = 0; public synchronized void produce() { //notity(); 也可以写这里 if (products &lt; 20) { System.out.println(&quot;生产者生产第&quot; + (++products) + &quot;个商品&quot;); this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void consume() { if (products &gt; 0) { System.out.println(&quot;消费者消费第&quot; + products-- + &quot;个商品&quot;); if (products &lt; 20) this.notify(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produce(); } }}class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consume(); } }} 这里有个疑问：如果把sleep写在两个同步方法中，while中只有调用，则会出现每次生产者生产满20个消费者才去消费，每次消费者消费完了生产者才开始生产。即每轮while循环结束同步方法都不释放锁。（在while中随意加入一个语句如print，则此现象消失，正常交替执行） 1.10 JDK5.0新增线程创建方式新增方式一：实现Callable接口与Runnable相比，Callable功能更强大1.相比run()方法，可以有返回值2.方法可以抛出异常（重写Runnable中的run不能抛出异常，因为Runnable接口中的run没有抛 ）3.支持泛型的返回值4.需要借助FutureTask类，比如获取返回值 123456789101112131415161718192021222324252627282930import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask futureTask = new FutureTask(count); new Thread(futureTask).start(); Object ans = null; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 使用泛型 12345678910111213141516171819202122232425public class Demo { public static void main(String[] args) { Count count = new Count(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(count); new Thread(futureTask).start(); int ans = 0; try { ans = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(ans); }}class Count implements Callable&lt;Integer&gt; { @Override public Integer call() { int i = 100000000; int sum = 0; while (i-- &gt; 0) sum += i; return sum; }} 新增方式二：使用线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中的线程，不需要每次都创建）3.便于线程管理：corePoolSize核心池的大小maximumPoolSize最大线程数keepAliveTime 线程没有任务时最多保持多长时间后会终止 线程池相关API1.JDK5.0起提供了线程池相关API：ExecutorService和Executors2.ExecutorService 真正的线程池接口.常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令,没有返回值,一般用来执行Runnable &lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):执行任务,有返回值,一般用来执行Callable void shutdown():关闭连接池 3.Executors:工具类、线程池的工厂类,用于创建并返回不同类型的线程池 Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n):创建一个线程池,它可以安排在给定延迟后运行命令或者定期地执行 1234567891011121314151617181920212223242526272829303132333435363738public class Main { public static void main(String[] args) { /*Executors是线程池的工厂类*/ ExecutorService server= Executors.newFixedThreadPool(10); server.execute(new Count()); server.submit(new Calculate()); /*或者使用FutureTask包装Calculate()以获取线程返回值*/ FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Calculate()); server.submit(task); try { System.out.println(task.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }}class Count implements Runnable{ @Override public void run() { int i=0; while(i++&lt;100) System.out.print(i+&quot; &quot;); }}class Calculate implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum=0; for(int i=0;i&lt;100;i++) sum+=i; return sum; }} 练习题 谈谈你对程序、进程、线程的理解 程序：一段静态代码进程：关于进程我想谈两点，一个是为什么需要进程这个概念，另一个是进程的作用。首先，现代操作系统的一大特点就是多道程序设计，那么在此之前是单道程序设计，一个程序运行时占有所有的资源，那么就无需资源的分配和调度，也就无需进程这个概念。到了多道程序设计中，多个程序并发执行，这就涉及到了系统资源的分配和调度，诸如CPU资源、存储资源、IO资源、文件资源，那么进程这个概念就应运而生。因此进程的作用有两大点，第一，它是资源分配和调度的基本单位。第二，它是程序独立运行的载体，保障程序正常执行。线程：线程是CPU调度的基本单位，多个线程之间共享进程的资源；线程包含在进程之中，是进程中实际运行工作的单位。 操作系统四大特性：虚拟、异步、共享、并发。2. 对比两种线程的创建方式3. sleep和wait方法的异同？相同点：都能使当前线程阻塞不同点：1.sleep声明在Thread类中，wait声明在Object类中 2.sleep()可以在任何地方使用，wait()需要在同步方法或者同步代码块中调用 3.如果都使用在同步代码块或者同步方法中，sleep方法不会释放锁，wait会释放锁 2.常用类2.1 字符串相关的类String类String特性1.String类:代表字符串.Java程序中,所有字符串的字面值(如”abc”)都是String类的实例2.String是一个final类,不可以继承3.字符串是常量,值在创建之后不可改变,字符内容是存储在一个字符数组value[]中的4.通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中5.字符串常量池(位于方法区中,后来改叫meta space)中是不会存储相同内容的字符串的String对象的创建1.字面量的方式,String str=&quot;abc&quot;;2.String s=new String()3.String s=new String(String s2)4.String s=new String(char[] arr)5.String s=new String(char[] arr,int startIndex, int count) 字符串常量池存储在字符串常量池,目的是共享; 字符串非常量的对象存储在堆中 面试题1:下面的p1.name==p2.name? 123456789101112131415public class Main { public static void main(String[] args) { Person p1 = new Person(&quot;yfx&quot;); Person p2 = new Person(&quot;yfx&quot;); System.out.println(p1.name == p2.name); //true 地址相同 }}class Person { String name; Person(String name) { this.name = name; }} 面试题2:String s=new String(&quot;abc&quot;); 在内存中创建了几个对象? 答:如果常量池中没有abc,则创建了两个,有的话则创建一个(现在常量池创建”abc”,然后在堆中创建一个String对象,内容fianl char[]value指向常量池的”abc”) 面试题3:下面几种字符串连接后,在内存中实际是怎么样的? 123456789101112131415161718192021public static void main(String[] args) { String s1 = &quot;java&quot;, s2 = &quot;docker&quot;; String s3=&quot;javadocker&quot;; String s4=&quot;java&quot;+&quot;docker&quot;; //编译阶段会直接合成&quot;javadocker&quot; String s5=s1+&quot;docker&quot;; String s6=&quot;java&quot;+s2; System.out.println(s3==s4); //true System.out.println(s3==s5); //false System.out.println(s3==s6); //false System.out.println(s5==s6); //false String s7=s5.intern(); //intern():如果常量池中没有s5的字符串值,那么就在常量池中创建该字符串常量,并返回其引用;如果常量池中已经有,则直接返回引用 System.out.println(s3==s7); //true final String s8=&quot;java&quot;; //final修饰的变成常量 String s9=s8+&quot;docker&quot;; System.out.println(s3==s9); //true} 涉及到对象的连接,则都在堆中产生新的String对象; 面试题4:java的值传递 123456789101112131415161718public class Main { String str = new String(&quot;good&quot;); char[] ch = {'t', 'e', 's', 't'}; public void change(String str, char ch[]) { str = &quot;test ok&quot;; //将常量池中&quot;test ok&quot;的地址赋值给str ch[0] = 'b'; } @Test public void test() { Main obj = new Main(); obj.change(obj.str, obj.ch); System.out.println(obj.str); //good System.out.println(obj.ch); //best }} String类常用方法1.int length()2.char charAt(int index)3.boolean isEmpty()4.String toLowerCase()5.String toUpperCase()6.String trim():返回字符串的副本,忽略前导空白和尾部空白7.boolean equalsIgnoreCase(String s)8.String concat(String str):将指定字符串连接到此字符串的结尾,等价于+9.int compareTo(String s):比较两个字符串字典序10.String substring(int beginIndex):11.String substring(int beginIndex, int endIndex):按照下标截取字符串,左闭右开12.boolean endsWith(String suffix):是否以指定的后缀结束13.boolean startsWith(String prefix):是否以指定的前缀开始14.boolean startsWith(String prefix,int offset):测试此字符串从指定索引开始的子串是否以指定前缀开始 15.boolean contains(CharSequence s):当且仅当此字符串包含指定的char值序列时,返回true16.int indexOf(String str):返回子串第一次出现的索引,未找到返回-117.int indexOf(String s,int fromIndex):返回子串从偏移下标开始首次出现的索引18.int lastIndexOf(String s):反向搜索19.int lastIndexOf(String s,int fromIndex),从指定偏移量开始反向搜索 20.String replace(char oldChar,char newChar):替换所有指定字符21.String replace(CharSequence target, CharSequence replacement):替换所有指定子串22.String replaceAll(String regex, String replacement):使用给定的子串替换所有匹配正则表达式的子串23.String replaceFirst(String regex, String replacement): 24.boolean matches(String regex):告知此字符串是否匹配给定的正则表达式 25.String[] split(String regex):根据给定正则表达式的匹配拆分此字符串26.String[] split(String regex, int limit):根据给定正则表达式来拆分此字符串,最多不超过limit个,如果超过了,剩下的全部放到最后一个元素中 String与基本数据类型转换1.String转基本数据类型、包装类: 调用包装类的静态方法:parseXXX(str)2.基本数据类型、包装类转Stirng:String.valueOf(xxx)3.String转char[]:str.toCharArray()4.char[]转String:new String(char[] arr)5.String转byte[]:str.getBytes()6.byte[]转String:new String(bytes[] arr) 重载函数new String(bytes[]arr,字符集) 123456789101112131415161718public class Main { public static void main(String[] args) throws UnsupportedEncodingException { String s=&quot;abc123中国&quot;; byte[] bytes = s.getBytes();//使用默认的字符集 System.out.println(Arrays.toString(bytes)); //[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67] utf-8编码一个汉字3个字节 byte[] gbks = s.getBytes(&quot;gbk&quot;); System.out.println(Arrays.toString(gbks)); //[97, 98, 99, 49, 50, 51, -42, -48, -71, -6] gbk编码一个汉字2个字节 System.out.println(new String(bytes)); //abc123中国 System.out.println(new String(gbks)); //abc123�й� 字符集指定错误,出现乱码 System.out.println(new String(gbks,&quot;gbk&quot;)); //abc123中国 }} StringBuffer,StringBuilderString:1.不可变字符序列 StringBuffer:1.可变字符序列2.线程安全,效率低 (除了构造方法,所有方法都加了synchronized) StringBuilder:1.可变字符序列2.线程不安全,效率高 三者底层都是用char[]存储 StringBuffer和StringBuilder的扩容默认情况下,扩容为原来的2倍+2,同时将原有数组中的元素复制到新的数组中指导意义: 如果需要对字符串进行频繁的添加, 建议使用此构造器StringBuffer(int capacity) 或 StringBuilder(int capacity),提前指定容量,以免频繁扩容,降低效率 三者效率对比 123456789101112131415161718192021@Testpublic void testTimeConsume() { String s = &quot;&quot;; StringBuffer buffer = new StringBuffer(); StringBuilder builder = new StringBuilder(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) { buffer.append(i); } System.out.println(&quot;StringBuffer use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { builder.append(i); } System.out.println(&quot;StringBuilder use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); for (int i = 0; i &lt; 100000; i++) { s += i; } System.out.println(&quot;String use &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;);} 2.2 JDK8之前的时间APISystem静态方法System.currentTimeMillis(): 返回1970年1月1日0点到现在经历了多少毫秒,返回值是long类型 Date类有两个Date类java.util.Date和java.sql.Date(继承前边的类) java.util.Date1.构造器一:Date() 创建了一个对应当前时间的Date对象 2.构造器二Date(long time) 创建指定毫秒数的Date类 java.sql.Date对应着数据库中的日期 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Date date=new Date(); System.out.println(date); //Wed Aug 25 10:49:42 CST 2021 System.out.println(date.getTime()); //1629859782884 Date date2=new Date(1629859782884L); System.out.println(date2); //Wed Aug 25 10:49:42 CST 2021 Date date3=new java.sql.Date(2131243242334L); System.out.println(date3); //2037-07-15 /*java.util.Date转换为java.sql.Date*/ //情形一 多态,对象本身就是sql下的Date Date date4=new java.sql.Date(2315432424345L); java.sql.Date date5= (java.sql.Date) date4; //情形二 对象本身就是util下的Date,无法直接强制转换.但是他们拥有一个共同的东西,就是毫秒数 Date date6=new Date(); java.sql.Date date7=new java.sql.Date(date6.getTime()); }} Calendar类Calendar是一个抽象基类,主要用于完成日期字段之间相互操作的功能 获取Calendar实例的方法1.使用Calendar.getInstance()方法 (抽象类无法实例化,这里返回的是子类GregorianCalendar的对象,多态,用Calendar接收)2.调用它的子类GregorianCalendar的构造器 一个Canlendar的实例是系统时间的抽象表示,通过get(int field)方法来取得想要的时间信息.比如YEAR, MONTH, DAY_OF_WEEK, HOUR_OF_DAY,MINUTE, SECOND1.public void set(int field, int value)2.public void add(int field, int amount)3.public final Date getTime()4.public final void setTime(Date date) 注意1.获取月份时:一月是0, 二月是1, 以此类推, 12月是112.获取星期时,周日是1,周二是2,…,周六是7 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); //多态 System.out.println(calendar.getClass()); //java.util.GregorianCalendar //get() System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //add() calendar.add(Calendar.DAY_OF_MONTH, -10); //往前倒10个月 //getTime() Date date=calendar.getTime(); //setTime() calendar.setTime(date); //用date来设置calendar calendar.setTimeInMillis(23214325798L); //用毫秒数设置calendar }} SimpleDateFormat类用于对Date类的格式化和解析 Date类的API不易于国际化,大部分都被废弃了,java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化: 日期-&gt;文本, 解析: 文本-&gt;日期 1.格式化SimpleDateFormat(): 默认的模式和语言环境创建对象public SimpleDateFormat(String pattern) 该构造方法可以用参数pattern指定的格式创建一个对象,该对象调用public String format(Date date): 方法格式化时间对象date 2.解析public Date parse(String source): 从给定字符串的开始解析文本,以生成一个日期 1234567891011public class Main { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); /*格式化:date转String*/ String format = sdf.format(new Date()); System.out.println(format); //2021-08-25 04:00:54 /*解析*:String转Date*/ Date date = sdf.parse(&quot;2021-08-25 16:30:20&quot;); System.out.println(date); //Wed Aug 25 16:30:20 CST 2021 }} 如果用SimpleDateFormat类解析字符串成java.sql.Date,就先解析为java.util.Date,在用毫秒数转换为java.util.Date 例题1990-01-01开始,三天打鱼两天晒网,请问给定日期在做什么事情?答:用SimpleDateFomart类解析两个日期,算出毫秒值之差,然后向上整除1000*3600*24(这里用向上除法$(m+n-1)/n$), 然后结果+1(代表一共有多少天), 然后对5取模. 0~2在打渔,3~4在晒网 2.3 JDK8中新日期的APIJDK1.0包含了一个java.util.Date类,但是它的大多数方法已经在JDK1.1引入Calendar类后被弃用了.而Calendar类并不比Date号多少.它们面临的问题是:1.可变性:像日期和事件这样的类,应该是不可变得2.偏移性:Date中的年份是从1900开始的,而月份是从0开始的3.格式化:格式化只对Date有用,Calendar则不行此外,它们也不是线程安全的; 不能处理润秒等 总结:对日期和时间的操作一直是Java程序员最痛苦的地方之一 第三次引入的API是成功的,并且Java8中引入的java.timeAPI已经纠正了过去的缺陷,将在很长一段时间内它都会为我们服务 LocalDate,LocalTime,LocalDateTime其中LocalDateTime最常用 1.now(): 当前的日期、时间2.of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便3.getXxx(): 获取某项时间信息4.with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象5.plus()/minus(): 增减日期 1234567891011121314151617181920212223242526272829303132333435public void test(){ /*now(): 当前的日期、时间*/ LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); //LocalDateTime用的最频繁 System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); /*of(): 设置指定的年、月、日、时、分、秒 无偏移量，方便*/ LocalDateTime time1 = LocalDateTime.of(2021, 8, 25, 20, 34); System.out.println(time1); /*getXxx()*/ System.out.println(localDateTime.getYear()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getDayOfYear()); System.out.println(localDateTime.getMinute()); /*with(): 修改日期,返回修改后的时间对象,不修改原来的时间对象*/ LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(1); //不修改原来的日期,重新返回一个修改后的日期 System.out.println(localDateTime1); System.out.println(localDateTime1); LocalDateTime localDateTime2 = localDateTime1.withHour(4); System.out.println(localDateTime2); /*plus()/minus(): 增减日期*/ LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusYears(2); System.out.println(localDateTime4);} Instant类似于java.util.Date类 方法 描述 now() 静态方法,返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳 1234567891011121314151617public void test2(){ /*now(): 获取本初子午线对应的时间标准*/ Instant time1 = Instant.now();//默认是 本初子午线 的时区 /*atOffset()结合即时的偏移来创建一个OffsetDateTime量*/ OffsetDateTime time2 = time1.atOffset(ZoneOffset.ofHours(8));//改成东八区 System.out.println(time1); System.out.println(time2); /*toEpochSecond():返回1970年1月1日0时0分0秒(UTC)开始的毫秒数 即时间戳*/ long l = time2.toEpochSecond(); System.out.println(l); /*ofEpochMilli()静态方法,返回在1970年1月1日0时0分0秒基础上指定毫秒数后的Instant类对象*/ Instant instant = Instant.ofEpochMilli(1532324124325L); System.out.println(instant);} DateTimeFormatter1.方式一:预定义的标准格式2.本地化相关的格式 3.自定义的格式(一般都用这个) 12345678910public void test3(){ //自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format = formatter.format(LocalDateTime.now()); System.out.println(format); //解析 TemporalAccessor parse = formatter.parse(&quot;2021-08-25 09:34:46&quot;); //LocalDateTime,LocalDate,LocalTime都实现了TemporalAccessor接口 System.out.println(parse);} 其他类 2.4 Java比较器Comparable接口Comparator接口2.5 System类2.6 Math类2.7 BigInteger和BigDecimal类3.枚举类 &amp; 注解4.Java集合5.泛型6.IO流7.网络编程8.反射9.Java8新特性10.Java9 &amp; 10 &amp; 11 新特性","link":"/2020/07/30/Java-java%E9%AB%98%E7%BA%A7/"},{"title":"操作系统知识巩固","text":"概述 操作系统基本功能 统一管理所有计算机资源 处理器资源 存储资源 IO资源 文件资源 实现了对计算机资源的抽象 用户无需面向硬件接口编程 IO设备管理软件，提供读写接口 文件管理软件，提供操作文件接口 提供了用户与计算机之间的接口 图像窗口形式 命令形式 系统调用形式 操作系统四大特性 并发 并行：多个事件同一时刻发生 并发： 多个事件同一时间间隔内交替发生（多道程序交替执行） 共享 共享性：操作系统中的资源可以供多个并发的程序共同使用 分类： 互斥共享 同时共享 虚拟 虚拟性：把一个物理实体转变为若干个逻辑实体 虚拟技术又分为：时分复用和空分复用。 时分复用技术：资源在时间上进行复用，不同程序并发使用；多道程序分时使用计算机硬件资源 虚拟处理器技术 借助多道程序设计技术，为每个程序建立进程，多个程序（进程）分时复用处理器 虚拟设备技术 物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问 空分复用技术：用来实现虚拟磁盘、虚拟内存等，提高资源的利用率，提升编程效率。 虚拟磁盘技术 物理磁盘虚拟为逻辑磁盘C、D、E等逻辑盘，使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率 异步 在多道程序环境下，允许多个进程并发执行 进程在使用资源时可能需要等待或放弃 进程的执行并不是一气呵成，而是以走走停停的形式推进（进程以不可预知的速度向前推进）进程管理 为什么需要进程 没有配置OS之前，资源属于当前运行的程序（单道程序设计） 配置OS之后，引入多道程序设计的概念 合理地隔离资源、运行环境，提升资源利用率 进程的作用 进程是系统进行资源分配和调度的基本单位 进程作为程序独立运行的载体，保障程序正常执行 进程的存在使得操作系统资源的利用率大幅提升1234面试官：请你谈一谈你对进程的认识。答：关于进程我想谈两点，第一是为什么需要进程，第二是进程的作用。首先，现代操作系统一个重要的设计就是**多道程序设计**，那么在此之前是单道程序设计，在单道程序设计之下，当前运行的程序占有所有的资源，无需进行资源的分配和调度，也就无需进程这个概念。但是到了多道程序设计下，程序之间并发执行，这就涉及到了系统资源的分配和调度，比如CPU资源、存储资源、文件资源、IO资源，所以进程的概念应运而生。那么进程的作用就应该有一下几点：1. 他是系统资源分配和调度的基本单位 2. 它作为程序独立运行的载体，保障程序正常执行。此外我想，包括进程这个概念，还有操作系统的并发、共享、虚拟、异步这些设计，都是为了一个目标，就是提高系统资源的利用率，所以，第3点，进程的设计也是为了提高系统资源的利用率。 进程的实体 主存中的进程形态： 标识符：唯一标记一个进程，用于区别其他进程 状态：标记进程的进程状态，如：运行态 程序计数器：进程即将被执行的下一条指令的地址 内存指针：程序代码、进程数据相关指针 上下文数据：进程执行时处理器存储的数据（cpu执行时，寄存器和高速缓存中存储的数据就是进程的上下文数据） IO状态信息：被进程IO操作所占用的文件列表 记账信息：使用处理器事件、时钟数总和等 进程控制块(PCB) 用于描述和控制进程运行的通用数据结构 记录进程当前状态和控制进程运行的全部信息 PCB是使得进程能够独立运行的基本单位（每个进程，都依赖PCB来被操作系统调度或者被控制） PCB是OS进行调度进程会被读取的信息，因此PCB是常驻内存的，存放在系统专门开辟的PCB区域内。 进程控制块(PCB)中记录的数据，可以分为四类 进程标识符 处理机状态 进程调度信息 进程控制信息进程与线程一个进程(Process)可以有一个或多个线程(Thread) 进程是系统进行资源分配和调度的基本单位；而线程是系统进行运行调度的基本单位 线程包含在进程之中，是进程中实际运行工作的单位 一个进程可以并发多个线程，每个线程执行不同的任务 线程共享进程资源 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 开销大 开销小 通信 进程IPC 读写同一进程数据通信 五状态模型进程的五状态模型包括：创建，就绪，执行，阻塞，中止 就绪状态 定义：其他资源都准备好，只差CPU资源的状态称为就绪状态 当进程被分配到除了CPU以外的所有资源后，只要获得CPU的使用权，就可以立即运行 多个处于就绪状态的进程通常排列成一个队列，称为就绪队列 执行状态 定义：进程获得CPU，其程序正在执行，称为执行状态 在单处理机中，在某个时刻只能有一个进程是处于执行状态 阻塞状态 定义：进程由于某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态，称为阻塞状态 阻塞进程会组成一个队列，称为阻塞队列 创建状态 创建进程时，拥有PCB但其他资源尚未就绪的状态，称为创建状态 操作系统提供fork函数接口创建进程 终止状态 定义：进程结束，由系统清理或归还PCB的状态称之为终止状态 ## 进程同步 为什么需要进程间同步 需要进行进程同步的两个经典问题生产者消费者问题 哲学家就餐问题 上述两个模型发生问题的根源：彼此之间没有通信 进程之间同步所解决的问题 1.对竞争资源在多进程之间进行次序的协调 2.使得并发执行的多个进程之间可以有效使用资源和相互合作 临界资源指的是一些虽然作为共享资源，却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制，等待占用进程释放该共享资源才可重新竞争使用共享资源。 进程间同步的原则 1.空闲让进：资源无占用，允许使用2.忙着等待：资源有占用，请求进程等待3.有限等待：保证有限等待时间能够使用资源3.让权等待：等待时，进程需要让出CPU 线程与线程的同步方法 进程同步方法 1.消息队列 2.共享存储 3.信号量 线程同步方法 1.互斥量 2.读写锁 3.自旋锁 4.条件变量 Linux的进程管理Linux进程的相关概念 进程的类型： 前台进程： 1.前台进程就是具有中断，可以与用户交互的进程 后台进程： 1.与前台进程相对，没有占用终端的就是后台进程； 2.后台程序基本上不和用户交互，优先级比前台进程低 3.将需要执行的命令以&amp;符号结束 守护进程： 1.守护(daemon)进程是特殊的后台进程； 2.很多守护进程在系统引导的时候启动，一直运行直到系统关闭； 3.linux有很多典型的守护进程； 4.进程名字以d结尾的一般都是守护进程，如crond,sshd,httpd,mysqld 操作系统提供fork函数接口创建进程 进程的标记 进程ID 1.唯一性 2.负整数，最大值由操作系统限定 3.ID为0的进程为idle进程，是系统创建的第一个进程 4.ID为1的进程为init进程，是0号进程的子进程，完成系统初始化 5.Init进程是所有用户进程的祖先进程 状态符号 ### 操作Linux进程的相关命令 ps命令 1.ps是process status的缩写2.可以添加-ef或者-aux展示详细进程详细信息3.搜索某个进程的详细信息ps -ef | grep python34.查询进程树ps -ef --forest5.查询某个用户的进程ps -u yfx6.按照cpu的使用频率进行排序ps -aux --sort=-pcpu7.按照内存使用的状况进行排序ps - aux --sort=-pmem top命令 1.与ps的区别是，ps是进程状态的静态快照，而top命令是动态监测进程状态 kill命令 1.kill -9 进程号 无条件终止进程 作业管理作业管理和进程管理的区别：作业是一项任务，需要至少一个进程来实现。 进程调度进程调度概述 进程调度：计算机通过决策决定哪个就绪进程可以获得CPU的使用权（多道程序设计） 进程调度的步骤 1.保留旧进程的运行信息，请出旧进程2.选择新进程，准备运行环境并分配cpu 新老进程的上下文切换机制进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 ### 进程调度算法 两种调度的方式 1.非抢占式的调度2.抢占式的调度 进程调度算法 1.先来先服务2.短进程优先3.高优先权优先4.时间片轮转 死锁死锁：多个进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或者系统产生了死锁。这些永远都在互相等待的进程，称为死锁进程。 死锁的产生 死锁产生的原因 1.竞争资源2.进程调度顺序不当 死锁的四个必要条件（如果出现死锁，必然存在下边四个条件） 互斥条件资源同一时间只能允许一个进程访问 请求保持条件进程拥有至少一个资源，在请求别的资源未果发生阻塞时，不释放自身拥有的资源 不可剥夺条件只有进程完成对自身资源的使用后，才会释放资源。别人无法使之释放。 循环等待条件多个进程之间存在资源请求的环路死锁的处理 预防死锁 破坏请求保持条件 1.进程运行之前，一次性申请所有需要的资源 2.并且在运行期间不会提出新的资源请求 破坏不可剥夺条件 1.当一个进程请求新的资源得不到满足时，必须释放占有的资源 2.进程运行时占用的资源可以被释放 破坏环路等待条件 1.可用资源线性排序，申请必须按照需要递增申请 假如进程1和2都需要B和D两种资源，如果要发生死锁的话，1先申请B，2申请D，然后1申请D，2申请B。 但是按照递增顺序申请，只能先申请B再申请D，就预防了死锁。 避免死锁 避免死锁和预防死锁的区别二者都是通过施加某些限制条件，来预防死锁发生。 差别： 1.预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个） 2.避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态） 银行家算法 是一个可操作的著名的避免死锁的算法 以银行借贷系统分配策略为基础的算法 存储管理内存分配单一连续分配只能在单用户、单进程的操作系统中使用 固定分区分配1.内存空间被划分为若干固定大小的区域2.每个分区只提供给一个程序使用，互不干扰 动态内存分配根据进程实际需要，动态分配内存空间 动态分区空闲表数据结构 动态分区空闲链数据结构 内存分配过程 首次适应算法（First Fit)： 算法思想：将空闲分区链以地址递增的顺序连接；在进行内存分配时，从链首开始顺序查找，直到找到一块分区的大小可以满足需求时，按照该作业的大小，从该分区中分配出内存，将剩下的空闲分区仍然链在空闲分区链中。优点：高址部分的大的空闲分区得到保留，为大作业的内存分配创造了条件缺点：(1)每次都是优先利用低址部分的空闲分区，造成低址部分产生大量的外碎片。(2)每次都是从低址部分查找，使得查找空闲分区的开销增大2. 循环首次适应算法(Next Fit) ：算法思想：配内存时不是从链首进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；优点：（1）使得空闲分区分布更加均匀（2）空闲分区的查找开销小缺点：高址部分的大空闲分区被分小，使得大作业进入无法分配内存3. 最佳适应算法（Best Fist）算法思想：将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，所谓“最佳”优点：第一次找到的空闲分区是大小最接近待分配内存作业大小的缺点：产生大量难以利用的外部碎片。4. 快速适应算法（Quick Fit）算法思想：快速适应算法要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区 内存回收一共有四中情况，如下图1.第一种情形：（1）无需新建空闲链表节点（2）只需要把空闲区1的容量增大即可2.第二种情况：（1）将回收区与空闲区合并（2）新的空闲区使用回收区的地址3.第三种情况：（1）将三个区合并（2）新的空闲区使用空闲区1的地址4.第四种情况：（1）为回收区创建新的空闲节点 （2）插入到相应的空闲区链表中去 页式存储管理管理方式1.将进程逻辑空间等分为若干大小的页面2.相应地把物理内存空间分成与页面大小相同的物理块3.以页面为单位把进程空间装进物理内存中分散的物理块 页面大小1.过大难以分配，过小内存碎片过多2.通常是512B~8K 页表1.页表记录进程逻辑空间与物理空间的映射2.某个页表项的地址=页表起始地址+页表项大小x页号3.实际物理地址=字块大小x字块号+块内偏移地址 多级页表页表的作用就是使得进程连续的逻辑地址空间，可以映射到内存中离散的物理地址上，这样进程的地址空间就不必占用一大块连续的物理地址。但是页表本身有可能占用较大的连续地址空间，既然如此，就用相同的办法，把页表的连续物理地址空间离散，即使用多级页表。 缺陷有一段连续的逻辑分布在多个页面中，将大大降低执行效率 段式存储管理管理方式1.将进程逻辑空间划分成若干段（非等分）2.段的长度由连续逻辑的长度决定3.主函数MAIN，子程序段X，子函数Y等 段式和页式对比1.二者都离散地管理了进程的逻辑空间2.页是物理单位，段式逻辑单位3.分页是为了合理利用空间，分段是满足用户要求4.页大小由硬件固定，段长度可动态变化5.页表信息是一维的，段表信息是二维的（因为段长度不固定，需要补充一栏来交代段长度） 段页式存储管理为何需要段页式存储管理1.分页可以有效提高内存利用率2.分段可以更好地满足用户需求3.二者结合，形成段页式存储管理 如何管理1.先将逻辑空间按按段式管理分成若干段2.再把段内空间按页式管理分成若干页 虚拟内存问题一个游戏十几G，物理内存只有8G，游戏如何运行起来的？ 虚拟内存概述有些进程实际需要的内存很大，超过物理内存的容量；多道程序设计，使得每个进程可用物理内存更加稀缺；不可能无线增加物理内存，物理内存总有不够用的时候。虚拟内存是操作系统内存管理的关键技术；使得多道程序运行和大程序运行成为现实；把程序使用内存划分，将部分暂时不实用的内存放置在辅存。程序局部性原理指CPU访问存储器，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。那么程序在运行时，无需全部装入内存，装备部分即可。如果访问页不在内存中，则发出缺页中断，发起页面置换。从用户层面看，程序拥有很大的空间，即是虚拟内存。虚拟内存实际上是对物理内存的补充，速度接近于内存，成本接近于辅存。 虚拟内存的置换算法1.先进先出算法FIFO2.最不经常使用算法LFU3.最近最少使用算法LRU 与高速缓存的替换区别1.替换策略发生在Cache-主存层次、主存-辅存层次2.Cache-主存层次的替换策略主要是为了解决速度问题3.主存-辅存层次主要是为了解决容量问题 Linux存储管理Buddy内存管理算法概述1.Buddy算法（伙伴算法）是经典的内存管理算法2.基于计算机处理二进制的优势，效率极高3.主要是为了解决内存外碎片的问题（其实是把外碎片转换为内碎片，比如本来要用120KB，实际分配128KB） Buddy管理算法的目的努力让内存分配与相邻内存合并能够快速进行 内存分配原则向上取整为2的幂大小（外碎片转化为内碎片）(1)申请70k -&gt; 分配128k(2)申请129k -&gt; 分配256k(3)申请666k -&gt; 分配1024k 伙伴系统伙伴指的是内存的伙伴，一片连续内存的伙伴是相邻的另一片大小一样的连续内存 内存分配过程1.创建一系列空闲块链表，每一种都是2的幂大小2.假设存储空间有1M大小3.分配100k内存(1)100k向上取2的幂=128k(2)查询是否有128k的空闲内存块？(3)没有！查询是否有256k空闲内存块？(4)没有！查询是否有512k空闲内存块？(5)没有！查询是否有1M空闲块内存？(6)有，摘下1M空闲内存块，分配出去(7)拆下1M的一半512K放在512K的空闲链上，其余的分配出去(8)拆下256K放在空闲链上，其余分配出去(9)拆下128K放在空闲链上，其余分配出去(10)分配完毕 4.回收内存过程(1)判断刚才分配的内存伙伴在空闲链表上吗？(2)在！移出伙伴，合并为256K空闲内存，再判断伙伴…?(3)在！移出伙伴，合并为512k空闲内存，再判断伙伴…?(4)在！移出伙伴，合并为1M空闲内存(5)插入1M空闲链表，回收完成 Linux交换空间概述1.交换空间（Swap）是磁盘的一个分区2.Linux物理内存满时，会把一些内存交换到Swap空间 作用1.冷启动内存依赖许多大型程序在启动的时候需要使用大量的内存，但是许多内存只是在启动的时候用一下，后续很少使用。那么系统就可以将这些运行时不怎么使用的内存内容，存在放Swap空间中，从而提供更多的物理空间给系统使用。2.系统睡眠依赖Linux系统睡眠时，会将系统运行的数据存放在Swap空间中，下次启动时重新将其加载到内存中，从而加快系统的启动速度。3.大进程空间依赖有些进程需要大量内存空间，物理内存不够使用，将部分内存保存在Swap中。 Swap空间和虚拟内存的对比Swap空间(1)存在于磁盘(2)与主存发生置换(3)是操作系统概念(4)解决系统物理内存不足问题 虚拟内存(1)存在于磁盘(2)与主存发生置换(3)是进程概念(4)解决进程物理内存不足问题 文件管理文件的逻辑结构 逻辑结构的文件类型有结构文件1.文件内容由定长记录和可变长记录组成2.定长记录存储文件格式、文件描述等结构化数据项3.可变长记录存储文件的具体内容 无结构文件也成为流式文件，文件内容长度以字节为单位。如exe文件、dll文件、so文件 linux静态链接库文件.a 动态链接库文件.sowindows静态链接库文件.lib 动态链接库文件.dll 顺序文件1.顺序文件是指按照顺序存放在存储介质中的文件2.磁带的存储特性使得磁带文件只能存储顺序文件3.顺序文件是所有逻辑文件当中存储效率最高的4.顺序文件的增删查改是比较困难的 索引文件1.可变长的文件不适合用顺序文件格式存储2.索引文件是为了解决可变长文件存储而发明的一种文件格式3.索引文件需要配合索引表完成存储 辅存的存储空间分配 连续分配 1.顺序读取文件非常容易，速度很快 2.对存储要求高，要求满足容量的连续存储空间 链接分配1.链接分配可以将文件存储在离散的盘块中2.需要额外的存储空间存储文件的盘块链接顺序（记录在盘块中-&gt;隐式链接，记录在FAT中-&gt;显示分配） 隐式链接分配显式链接分配缺点：1.FAT表占用较大的存储空间，需要将整个FAT加载到内存中，且磁盘越大，FAT越大（记录整个磁盘的存储信息）。2.不支持高效的直接存储（需要先从FAT表中寻找离散的空闲的块） 索引分配1.每个文件拥有一个索引块，记录所有盘块信息2.索引分配方式支持直接访问盘块3.文件较大时，索引分配方式具有明显优势4.现在主流文件系统都是使用索引分配 (空闲块)存储空间管理三种（空闲块）管理方式：空闲表、空闲链表、位示图。其中前两种和内存管理方式类似。 空闲表 空闲链表1.把所有空闲盘区组成一个空闲链表2.每个链表节点存储空闲盘块和空闲的数目 位示图1.位示图维护成本低2.非常容易找到空闲盘块3.使用0/1比特，占用空间小 目录管理任何文件或目录都只有唯一路径 Linux文件的基本操作Linux目录|目录|描述 ||–|–||/bin |存放二进制可执行文件(ls,cat,mkdir等命令)，常用命令一般都在这里 ||/etc |存放系统管理和配置文件 ||/home |存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user ||/usr |用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录。usr全称：unix software resources ||/opt |额外安装的可选应用程序宝所放置的位置 ||/proc |虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息 ||root |超级用户（系统管理员）的主目录 ||/sbin |存放二进制可执行文件，只有root才能访问 ||/dev |用于存放设备文件 ||/mnt |系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统。 ||/boot |存放用于系统引导时使用的各种文件 ||/lib |存放文件系统中的程序运行所需要的共享库及内核模块 ||/var |用于存放运行时需要改变数据的文件 | Linux文件常用操作 命令 操作 touch 创建文件 mkdir 创建文件夹 rm 删除文件 cat 查看文件 gedit 使用gedit编辑文件 Linux文件类型 注：这里的FIFO即先入先出，是pipe管道类型的文件，用于通信 使用ls -al命令（展示所有文件的详细信息），此时每一行第一个字符，就代表这个文件的类型 Linux文件系统设备管理","link":"/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%B7%A9%E5%9B%BA/"},{"title":"Java入门","text":"第一章 IDEA基本配置和快捷键IDEA快捷键 快捷键 功能 shift+F6 选中目标内容后，更改所有用到它的内容 ctrl+Y 删除当前行 ctrl+D 复制当前行 Alt+Enter 导入包自动修正代码 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消 ctrl+shift+/ 选中代码注释，再按取消 Alt+Ins 自动生成代码：如toString,set,get等方法 Alt+Shift+上下箭头 移动当前行 Shift+F6 更改类文件名称 ctrl+alt+t 包括代码块，添加try-catch等信息 ## 操作技巧 5.fori 可以快速输入循环体 for(int i=0;i&lt;5;i++) arryA.fori可以快速输入循环体for(int i=0;i&lt;arr.length;i++) Alt+Enter 快速为对象.方法 创建一个接收者 IDEA注释最好看的颜色#088D52 第二章 JAVA基本知识基础知识 所有的引用类型都可以赋值为null，代表其中什么都没有 获取数组长度 数组名称.length方法使用方法的注意事项 1.方法应该定义在类中，不能在方法中定义方法 2.方法定义的前后顺序无所谓方法重载 1.要求具有不同的参数列表（参数个数不同，参数数据类型不同，参数的数据类型排列顺序不同，满足其一即可） 修饰符如public,static等无关数组数组的初始化 动态初始化（指定长度） 1234int[]arr=new int[10];//或者拆分成两个步骤int[]arr;arr=new int[10]; 静态初始化（指定内容） 1234int[]arr=new int[]{1,2,3};//或者分为两步int[]arr;arr=new int[]{1,2,3}; 数组省略格式(无法拆分成两个步骤） 1int[]arr={1,2,3}; 数组的访问 使用动态初始化时，其中的元素会自动拥有一个默认值，规则如下: 如果是整数类型，默认为0 如果是浮点类型，默认为0.0 如果是字符类型，默认为’\\u0000’ （是一个不可见字符） 如果是布尔类型，默认为false 如果是引用类型，那么默认为null(空常量）利用数组实现多个返回值 JAVA内存 java的内存需要划分为5个部分： 栈(Stack):存放的都是方法中的局部变量，方法的运行一定要在栈中 局部变量：方法的参数，或者是方法内部的变量 作用域：一旦超出作用域，立刻从栈内存当中消失 堆(Heap):凡是new出来的东西，都在堆当中 堆内存里面的东西都有一个地址值：16进制 堆内存里面的数据，都有默认值，规则在上 面。 方法区(Method Area):存储.class(.java编译之后用来运行的字节码文件)是相关信息，包含方法的信息 本地方法栈(Native Method Stack):与操作系统相关 寄存器(pc Register):与CPU相关数组在内存中的存储 内存中的两个不同数组 两个引用指向同一个数组对象在内存中的存储 当一个对象作为参数传递到方法中时，实际上传递进去的是地址值 当一个对象类型作为方法的返回值时，返回值其实就是对象的地址值 一个对象在内存中的存储 两个引用指向同一个对象final关键字概念和四种用法 常见四种用法：1.修饰一个类 2.修饰一个方法3.修饰一个局部变量4.修饰一个成员变量 注意事项：对于类和方法来说，abstract和final不能同时使用，因为矛盾 final修饰一个类时public final class...含义：当前类不能有任何子类 final修饰一个方法时修饰符 final 返回值类型‘含义：该方法不能被覆盖重写 final修饰变量，一次赋值，终身不变含义：1.对于基本数据类型来说，不可改变的是数值 2.对于引用数据类型来说，不可改变的是地址值 final修饰成员变量，这个变量也是不可变的 1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值2.对于final成员变量，要么直接赋值，要么通过构造方法赋值（必须保证所有重载的构造都对final成员变量赋值） 四种权限修饰符public &gt; protected &gt; (default) &gt; private 同一个类中 同一个包中 不同包子类（父子关系） 不同包非子类（无关系） public protected (default) private 同一个类 √ √ √ √ 同一个包 √ √ √ × 不同包子类 √ √ × × 不同包非子类 √ × × × ## 内部类 分类：1.成员内部类 2.局部内部类（包含匿名内部类） ### 成员内部类 格式：直接定义在类体内就行 注意：内用外，随意访问；外用内，需要内部类对象 如何使用内部类？有两种方式： 1.间接方式：在外部类的方法中使用内部类，然后main方法中调用外部类的方法 2.直接方法，公式：外部类名称.内部类名称 对象名=new 外部类名称().new 内部类名称(); 内部类的同名变量访问1234567891011public class Outer { int num=10; public class Inner{ int num=20; public void method(){ int num=30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); } } 局部内部类如果一个类是定义在方法内部的，那么这就是一个局部内部类 *局部的含义**：只有当前的方法能使用它，出了这个方法就不能使用格式:123456修饰符 class 外部类名称{ 修饰符 返回值 外部类方法名称(参数列表){ class 局部内部类名称{ ... }} 局部内部类使用方法在成员方法中new局部内部类对象，然后调用成员方法即可 小结：类的权限修饰符1.外部类：public / (default)2.成员内部类:public / protected / (default) / private3.局部内部类：什么都不能写 局部内部类的final问题局部内部类中，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的.备注：从JAVA8+开始，只要局部变量事实不变，那么final关键字可以省略原因：1.new出来的对象是在堆当中的2.局部变量是跟着方法走的，在栈内存中3.方法运行结束后，立刻出栈，局部变量就会立刻消失4.但是new出来的对象会一直存在于栈内存中，直到垃圾回收消失。因此该对象会copy一份使用到的变量，方法消失后保证数据依旧存在。故该方法的局部变量不能改变。 匿名内部类（重点）如果接口的实现类（或父类的子类）只需要使用唯一的一次，那么就可以省略掉该类的定义，而改为使用匿名内部类匿名内部类的使用格式：其中，obj是匿名内部类的对象，匿名内部类省略了繁琐地完整创建一个.class文件 1234567891011public class Temp { public static void main(String[] args) { MyInterface obj=new MyInterface() { @Override public void method() { System.out.println(&quot;使用了匿名内部类！&quot;); } }; obj.method(); }} 使用匿名内部类的注意事项对格式*new 接口名称(){…}*进行解析 1.new代表创建对象的动作2.接口名称就是匿名内部类需要实现的接口3.*{…}*这才是匿名内部类的内容 还需注意 1.匿名内部类，在创建对象时，只能使用一次（但不是匿名对象，创建出来的对象可以一直使用）2.匿名内部类和匿名对象不是一回事3.匿名内部类和匿名对象同时使用 123456789public static void main(String[] args) { new MyInterface(){ @Override public void method() { System.out.println(&quot;使用了匿名内部类和匿名对象&quot;); } }.method(); } 第三章 面向对象程序设计 面向对象技术三大特性：继承性、封装性、多态性基础知识 成员变量是直接定义在类中的，在方法体外边 成员方法不要写static关键词 通常情况下，需要根据类创建一个对象才能使用 使用一个类的步骤 导包 import 包名称.类名称; import cn.hhu.day06.demo01.Student; 若位于同一包下无需导入 创建 Student stu=new Student(); 使用 如果成员变量没有赋值，那么将会有一个默认值，规则和数组一样 成员变量和局部变量的区别 定义的位置不同 局部变量：在方法的内部 成员变量：在方法的外部，直接写在类当中 作用域不同 局部变量：只有方法当中才可以使用 成员变量：整个类全都可以用 默认值不同 局部变量：没有默认值，必须手动赋值 成员变量：有默认值，规则和数组相同 内存的位置不同（了解） 局部变量：位于栈内存 成员变量：位于堆内存（new出来的都放在堆里，赋初值） 生命周期不同 局部变量：随着方法进栈诞生，随着方法出栈消失 成员变量：随着对象创建诞生，随着对象被垃圾回收而消失 匿名对象的说明匿名对象就是只有右边的对象，没有左边的名字和赋值运算符 12new Person().name=&quot;赵丽颖&quot;; //只能使用这一次 抽象 抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束 抽象类：抽象方法所在的类必须是抽象类。在class之间写上abstract即可 如何使用抽象类和抽象方法 不能直接new抽象类对象，必须用一个子类继承抽象父类 子类必须覆盖重写（也叫实现）父类中的所有抽象方法 注意事项 抽象类中，可以有构造方法，供子类创建对象时，初始化父类成员时使用 抽象类中不一定包含抽象方法，但是包含抽象方法的必须是抽象类 除非子类也是抽象类，否则必须重写抽象父类中的所有抽象方法 抽象类不能创建对象，无论是否含有抽象方法继承性 JAVA语言是单继承的（一个类只能有一个直接父类），但是可以多级继承 如果类的定义中不含选项extends父类名，则java虚拟机一般会自动给当定义的类添加默认的选项extends java.lang.Object。故除了类java.lang.Object之外，任何类都有父类，而且类java.lang.Object是除它自身之外的所有类的父类。 当前定义的类的构造方法必须调用其父类的构造方法，而且该调用语句必须是当前定义的类的构造方法的第一句语句，其调用格式是 如果发生重名，成员方法属于谁，就优先用谁的成员变量12super(调用参数列表)//其中super是关键字，表示直接父类的构造方法。 java.lang.Object类是所有类的 公共最高父类三种重名 成员变量重名父类成员变量使用super.子类成员变量使用this.局部变量直接写 1234567891011121314151617//Father.javapublic class Father { int num=30;}//Son.javapublic class Son extends Father { int num = 20; public void method() { int num = 10; System.out.println(&quot;Father:&quot; + super.num); System.out.println(&quot;Son:&quot; + this.num); System.out.println(&quot;Temp:&quot; + num); }} 成员方法重名 方法覆盖 必须保证父子类之间方法的名称相同，参数列表也相同 子类方法的返回值必须小于等于父类方法的返回值范围 @Override:这叫做注解，写在方法前面，用来检测是否有效地正确覆盖。（如果报错说明未发生覆盖） 子类方法的权限必须大于等于父类方法的权限修饰符。 public&gt;protected&gt;留空(default)&gt;private继承中构造方法的访问特点 子类构造方法当中，有一个默认隐含的super()调用，所以一定是先调用父类构造方法，后执行子类构造方法 可以通过super关键字在子类中调用父类重载构造函数 super的父类构造调用，必须是子类构造方法的第一个语句。不能多次调用super构造。super关键字的三种用法this关键字的三种用法 在本类的成员方法中，访问本类的成员变量（成员方法中含有重名的局部变量，也生效） 在本类的成员方法中，访问本类的另一个成员方法 在本类的构造方法中，访问本类的另一个重载构造方法 1234567public Temp01(){ System.out.println(&quot;调用无参构造函数&quot;);}public Temp01(int n){ this(); System.out.println(&quot;调用重载构造函数&quot;);} 第三种方法中注意：this()构造方法也必须是语句的第一句注意：this和super两种构造调用不能同时使用，因为构造方法必须放在第一句，也就必须要保证唯一性 子类与父类之间的类型转换 隐式类型转换：无需强制类型转换符，将子类型的数据转换成父类型数据 12Teacher tom=new Teacher();Employee a=tom; 显式类型转换：需要强制类型转换符()，将父类型数据转换为子类型数据 123Teacher tom=new Teacher();Employee a=tom;Teacher b=(Teacher)a; 如果两个类型不存在子类型与父类型之间的关系，则一般不能进行类型转换。可以使用引用类型表达式instanceof引用类型来判断一个引用表达式所指向的实例对象是否是某种引用类型的实例对象 123Teacher a=new Teacher();Employee b=new Employee();Employee c=a; 则表达式a instanceof Teacher返回true表达式a instanceof Employee返回true表达式b instanceof Teacher返回false表达式c instanceof Employee返回true表达式c instanceof Teacher返回true instanceof运算符可以用再引用类型转换中，即先判断一个引用表达式所指向的实例对象是否是目标类型的实例对象，可以避免错误如 123if(a instanceof Teacher) b=(Teacher)a;else b=new Teacher(); 多态性 多态性指的是：在类定义中出现多个构造方法或者出现多个同名的成员方法。对于同名的成员方法，多态性还包括在当前定义的类型中出现与其父类型的成员方法同名的成员方法。多态性包括：静态多态性和动态多态性。 静态多态性 静态多态性指的是在同一个类中同名方法在功能上的重载overload，这也包括一个类对其父类同名方法在功能上的重载，而且在方法声明的形式上要求同名的方法具有不同的参数列表。这里的方法，可以是成员方法，也可以是构造方法。一般建议，重载的方法应当具有相似的功能。 动态多态性 动态多态性指的是在子类和父类的类体中均定义了具有基本相同声明的非静态成员方法。所谓非静态成员方法指的是在成员方法定义中成员方法的声明不包含方法修饰词static，这时也称为子类的成员方法对其父类进本相同声明的成员方法的覆盖override。（基本相同声明的成员方法要求具有相同的方法名，相同的参数个数，对应参数的类型也相同，而且子类的成员方法应当比其父类对应的成员方法有更广的访问控制方式） 利用动态多态性使得可以通过父类型的引用调用子类型的成员方法。这里要求父类型的引用 所指向的实例对象实际上是其子类型的实例对象，而且调用的子类型的成员方法是对父类型同名成员方法的覆盖。 由于动态多态性使得子类型的成员方法屏蔽了父类型的被覆盖的成员方法，因此通过关键字super可以解决在子类型的成员方法中调用父类型的被覆盖的成员方法的问题。 在子类型的非静态成员方法中访问其父类型的成员与，格式： super.父类型的成员域 在子类型的非静态成员方法中调用其父类型的成员方法，其格式： super.父类型的成员方法(调用参数列表) 在子类的构造方法的第一条语句处调用其父类的构造方法，其格式： super(父类构造方法的调用参数列表); 与super对应的关键字是this，其调用的是同一个类的成员域或成员方法。 需要注意的是，动态多态性只针对非静态的成员方法。 封装性 封装性在JAVA中的体现 方法是一种封装 关键字private也是一种封装 一旦使用private进行修饰，在本类中可以随意访问，但是超出本类范围就不能再直接访问了。 间接访问private成员变量，就是定义一对儿get/set方法，必须叫getXXX/setXXX。对于基本数据类型中的boolean类型，get方法必须写成isXXX。 当方法的局部变量（如参数）和类的成员变量重名的时候，根据就近原则，优先使用局部变量。如果需要访问本类当中的成员变量，需要使用this.成员变量名 **通过谁调用的方法，谁就是this ** 构造方法 构造方法注意事项 构造方法的名称必须和所在的类名完全一样 构造方法无返回值 如果没有编写任何构造方法，那么编译器会默认一个构造方法，没有参数，方法体什么事都不做 构造方法可以进行重载一个标准的类 一个标准的类要拥有下面四个部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对get/set方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做 Java Bean. 可以使用快捷键Alt+Insert或菜单中Code-Generate Static关键字 Static修饰成员field只在类中保存一份，所有本类对象共享一份。属于类而不是属于单独某一个对象。可以利用这一点，自动给对象顺序赋id 123456789private String name;private int id;static String teacher=&quot;胡景月&quot;;private static int idCount=0; //给成员变量赋初值public Student(String name) { this.name = name; id=++idCount;} Static修饰方法 静态方法属于类，不属于对象 如果没有static，必须创建对象才能使用方法 如果有static，对于静态方法来说，可以通过对象调用方法（不推荐），也可以通过类名调用方法。 本类当中的静态方法可以省略类名 静态不能直接访问非静态（原因：内存中先有的静态内容，后有的非静态内容） 静态方法中不能用this，因为this指的是当前对象，而静态内容属于类而不属于对象 静态Static的内存图静态内容与对象无关，即使写成对象.静态内容,也会被编译成为类.静态内容 静态代码块特点：1. 第一次用到本类时，静态代码块执行唯一的一次 静态内容总是优于非静态，所以静态代码块比构造方法先执行 静态代码块的典型用途 一次性地对静态成员进行赋值 第四章 APIAPI概念API全程Application Programming Interface,应用程序编程接口。API使用步骤 打开帮助文档 点击显示，找到索引，看到输入框 输入框里输入想找的类 看包。java.lang下的类不需要导包，其他需要 看类的解释和说明 学习构造方法 使用成员方法Scanner类——键盘输入类 基本功能：可以实现键盘输入数据到程序当中 引用类型的一般使用步骤： 导包 如果需要使用的目标类和当前类位于同一包下，则可以省略导包语句；只有java.lang包下的内容(如java.lang.String)不需要导包，其它的包都需要import语句。 创建 Scanner sc=new Scanner(System.in); //代表从键盘输入 使用 获取键盘输入的一个int数字：int num=sc.nextInt(); 其实键盘输入的都是字符串， nextInt是将输入的字符串里的数字转换成int型数 获取键盘输入的一个字符串：String str=sc.next();如果只需使用一次，可以使用匿名对象 12345678910111213141516int num=new Scanner(System.in).nextInt();//还可以使用匿名对象作为参数public class Demo04Anonymous { public static void printInt(Scanner sc){ int temp=sc.nextInt(); System.out.println(&quot;Num is &quot;+temp); } public static void main(String[] args) { printInt(new Scanner(System.in)); }}//匿名对象还可以作为返回值public static Scanner methodReturn() { return new Scanner(System.in); } Random类——产生随机数字 random类的使用 12Random r=new Random(); int a=r.nextInt(); //范围-21亿到+21亿 Random生成指定范围的随机数12345678910Random r=new Random(); for (int i = 0; i &lt; 10; i++) { int temp = r.nextInt(10); //范围是[0,10) 左闭右开 System.out.print(temp); System.out.print(&quot; &quot;); }//若想1~10就 r.nextInt(10)+1; 对象数组 1234567Person[]arr=new Person[3]; Person one=new Person(&quot;余丰旭&quot;,22); Person two=new Person(&quot;陈香玉&quot;,24); Person three=new Person(&quot;小小余&quot;,1); arr[0]=one; arr[1]=two; arr[2]=three; ArrayList 数组的长度不能改变，但是ArrayList集合的长度是可以随意变化的 对于ArrayList来说，有一个尖括号代表泛型，也就是装在集合当中的所有元素，全都是的什么类型。 注意：泛型只能是引用类型，不能是基本类型。原因是：ArrayList中存储的都是引用类型对象的地址，而基本数据类型没有地址。解决方案：使用基本类型对应的包装类。包装类：都位于java.lang包下（无需导包）从JDK1.5+开始，支持自动装箱、自动拆箱。自动装箱：基本类型–&gt;包装类型自动拆箱：包装类型–&gt;基本类型 基本类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 对于ArrayList集合来说，直接打印的到的不是地址值，而是内容 12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;余丰旭&quot;); list.add(&quot;陈香玉&quot;); list.add(&quot;小小余&quot;); System.out.println(list); ArrayList常用方法 public boolean add(E e):向集合当中添加元素，类型与泛型一致 public E get(int index):从集合中获取元素，参数是索引编号 public E remove(int index):从集合中删除元素 public int size():获取集合的尺寸长度（集合中的元素个数） 注意，ArrayList作为方法参数时，不要忘了&lt;E(泛型)&gt;String一.String类基本知识 java中只要是” “中的内容，都是String实例，无论new否 字符串特点 字符串的内容永不可变 正是因为字符串不可改变，所以字符串是可以共享使用的 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[ ]字节数组 字符串的构造方法和直接创建，常见3+1种方式三种构造方法： public String():创建一个空白字符串，不含有任何内容 public String(char[ ]array):根据字符数组的内容，来创建对应的字符串 public String(byte[ ] array):根据字节数组的内容，来创建对应的字符串1234567891011121314public static void main(String[] args) { String str = new String(); System.out.println(&quot;First String is &quot; + str); char[] arr = {'a', 'b', 'c'}; String str2 = new String(arr); System.out.println(&quot;Second String is &quot; + str2); byte[] arr_byte = {97, 98, 99}; String str3 = new String(arr_byte); System.out.println(&quot;Third String is &quot; + str3); String str4=&quot;abc&quot;; System.out.println(&quot;Forth String is &quot;+str4); 二.字符串的常量池 字符串常量池：程序中直接写上的双引号字符串，就在字符串常量池中对于基本类型来说，==是进行数值的比较；对于引用类型来说，==是进行地址值的比较。 1234567String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);System.out.println(str1==str2); //tureSystem.out.println(str1==str3); //falseSystem.out.println(str2==str3); //false 双引号直接写的字符串在常量池中，new的不在池当中 三.字符串的比较相关方法 ==是进行对象的地址值的比较，如果确实需要字符串的内容比较，可以使用两个方法public boolean equals(Object obj):参数可以是任何对象public boolean equalsIgnoreCase(String str):忽略大小写，进行内容比较 123456789101112String str1=&quot;abc&quot;;String str2=&quot;abc&quot;;char[]arr={'a','b','c'};String str3=new String(arr);if(str1.equals(str2)) System.out.println(&quot;str1=str2&quot;);if(str1.equals(str3)) System.out.println(&quot;str1=str3&quot;);if(str1.equals(&quot;abc&quot;)) System.out.println(&quot;str1=abc&quot;);if(&quot;abc&quot;.equals(str1)) System.out.println(&quot;abc=str1&quot;); ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200122191346564.png) 字符串的获取相关方法String当中与获取相关的常用方法有： public int Length():获取字符串中含有的字符个数 public String concat(String str):将当前字符串和参数字符串拼接成为返回值新的字符串 public char charAt(int index):获取指定索引位置的单个字符 public int indexOf(String str):查找参数字符串在本字符串中首次出现的索引位置，如果没有返回-1字符串的截取方法 public String substring(int index):从参数位置一直到末尾，返回新字符串 public String substring(int begin,int end):从begin开始，一直到end结束，中间的字符串，左闭右开字符串的转换方法 public char[ ] toCharArray():将当前字符串拆分成为字符数组作为返回值 public byte[ ] getBytes():获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString):将所有出现的老字符串替换成为新的字符串，返回替换后的结果新字符串备注：CharSequence就是说可以接受字符串类型字符串的分割方法分割字符串的方法;public String[ ] split(String regex):根据参数的规则，将字符串切分为若干部分 12String str=&quot;Yu,Feng,XU&quot;;String[]strString=str.split(&quot;,&quot;); 注意事项:split方法的参数其实是一个正则表达式，今后学习，今天要注意，如果按照英文句点.进行切分，必须写\\\\.两个反斜杠 ArraysArrays是一个与数组相关的工具类，里面提供了大量静态方法，来实现数组的常见操作（方便，静态方法不用new）常用方法 public static String toString(数组) 功能：将参数数组变成字符串（按照默认格式，即[xx,xx,xx..]） public static void sort(数组) 功能：按照默认升序对数组元素进行排序 备注：1. 如果是数值，sort默认按升序从小到大 2. 如果是字符串，sort默认按字母升序 3. 如果是自定义类型，**那么这个自定义类需要有Comparable或Comparator接口的支持 数学工具类Math常用方法： public static double abc(double num) abc是absolute的缩写，计算绝对值 public static double ceil(double num) 向上取整 public static double floor(double num) 向下取整4.public static long round(double num) 四舍五入 Math.PI 代表近似的圆周率值Object类重写equals方法(可以使用快捷键Alt+Insert)因为java中==对于基本数据类型比较的是数值，对于引用数据类型比较的是地址值，所以对于自己创建的对象，继承了Object类的equals方法，需要对equals方法进行重写1234567891011121314151617@Overridepublic boolean equals(Object obj) { //如果传递进来的是自身，直接返回true,提高程序效率 if(obj==this) return true; //如果传空，直接返回false，提高程序效率 if(obj==null) return false; //如果不是Student对象，直接返回false if (!(obj instanceof Student)) return false; //向下转型，并进行比较 Student stu = (Student) obj; if (this.age == stu.age &amp;&amp; this.name == stu.name) return true; return false;} Objects类有一个equals方法，可以容忍空指针（注意不是Object类，是Objects类）123456public static void main(String[] args) { Student stu=new Student(&quot;余丰旭&quot;,22); Student stu2=null; boolean b=Objects.equals(stu,stu2); System.out.println(b);} 因为其Objects.equals(再次注意不是Object类是Objects类）方法如下123public static boolean equals(Object a,Object b){ return (a==b)||(a!=null&amp;&amp;a.equals(b)); } 重写toString方法（也可以快捷键）1234@Overridepublic String toString() { return name+&quot;:&quot;+age+&quot;岁&quot;;} Object类位于java.util.objects JDK7中添加了Objects工具类，它有一些静态方法，这些方法是null-save(空指针安全的）或null-tolerant(容忍空指针的），用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象 在比较两个对象时，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题 源码如下12public static boolean equals(Object a,Object b){return (a==b)||(a!=null&amp;&amp;a.equals(b)); Date类 System.currentTimeMillis()获取当前系统时间到1970年1月1日00：00：00（英国格林威治时间）经历了多少毫秒（long类型）构造方法 1.无参构造 1234Date date=new Date();System.out.println(date);输出结果Mon Jan 27 19:47:17 CST 2020 2.带参构造（long类型）即毫秒值 1234Date date2=new Date(1580125811479L);System.out.println(date2);输出结果Mon Jan 27 19:50:11 CST 2020 常用方法 long getTime()把日期转换为毫秒值DateFormat类DateFormat类是抽象类，不能直接使用。所以需要常用子类java.text.SimpleDateFormat，这个类需要一个模式来指定格式化或解析的标准，构造方法为： public SimpleDateFormat(String pattern):用给定的模式和默认语言环境的日期符号构造SimpleDateFormat 格式规则| 标识字母（区分大小写） | 含义 || ———————- | —- || y | 年 || M | 月 || d | 日 || H | 时 || m | 分 || s | 秒 | 备注：更详细的格式规则，请见API文档 写对应的模式，会把模式替换为对应的日期和时间：yyyy-MM-dd HH:mm:ss或yyyy年MM月dd日 HH时mm分ss秒其中连接符可以任意写 format方法传入date类型的参数，按照SimpleDateFormat中指定的模式输出字符串 12345Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);System.out.println(sdf.format(today));输出结果2020年02月04日 11时55分41秒 parse方法把符合模式的字符串解析为Date日期public Date parse(String source)throws ParseExceptionparse方法声明了一个异常叫ParseException解析异常，如果字符串和构造方法中的模式不一样，那么程序就会抛出异常，调用一个抛出了异常的方法，就必须处理这个异常，那么throws继续声明抛出这一个异常，要么try..catch自己处理这个异常（暂时用Alt+enter 让虚拟机自己处理） 12345678Date today=new Date();SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);Date day=sdf.parse(&quot;2020年02月04日 11时55分41秒&quot;);System.out.println(&quot;parse方法将符合指定模式的字符串转换为Date类型数据:\\n&quot;+day);输出结果：parse方法将符合指定模式的字符串转换为Date类型数据:Tue Feb 04 11:55:41 CST 2020 小练习：计算距出生多少天12345678910111213public class demo02 { public static void main(String[] args) throws ParseException { System.out.println(&quot;请按照格式输入出生日期: yyyy-MM-dd&quot;); Scanner sc=new Scanner(System.in); String birthString=sc.next(); SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date birthday=sdf.parse(birthString); long birthdayMS=birthday.getTime(); long nowMS=new Date().getTime(); long distance=nowMS-birthdayMS; System.out.println(&quot;此人距出生已经历&quot;+distance/1000/60/60/24+&quot;天&quot;); }} Calendar抽象类很多Date类的方法已被Calendar类替代，java.util.Calendar类是一个抽象类，提供了很多操作日历字段的方法（YEAR,MONTH,DAY_OF_MONTH,HOUR)Calendar类无法直接创建对象使用，其含有静态方法getInstance(),该方法返回一个Calendar类的子类对象static Calendar getInstance()使用默认时区和语言环境获得一个日历 12使用了多态，用父类型接收子类对象Calendar c=Calendar.getInstance(); Calendar类常用方法public int get(int field)：返回给定日历字段的值public void set(int field,int value)：将给定日历字段设置为给定值public abstract void add(int field,int amout)：根据日历的规则，为给定的日历字段添加或减去指定的时间量public Date getTime()：转换为Date类对象 System类常用方法 public static long currentTimeMillis()：返回以毫秒值为单位的当前时间 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)：将数组中指定的数据拷贝到另一个数组中。参数含义：src-源数组、srcPos-源数组中的起始位置、dest-目标数组、destPos-目标数组中的起始位置、length-复制的元素数量StringBuilder类 字符串是常量，它们的值在创建之后不能改变。字符串的底层是一个被final修饰的数组，不能改变，是一个常量。因此会导致一个问题：拼接多个字符串时会产生大量字符串占用内存（如拼接a+b+c,内存中会产生a,b,c,ab,abc五个字符串 为了提高效率，可以使用字符串缓冲区（可以看成长度可以变化的字符串），底层也是数组，但是没有被final修饰，可以改变长度。 StringBuilder在内存中始终是一个数组，占用空间少，效率高；如果超出StringBuilder的容量，会自动扩容*构造方法 public StringBuilder()：构造一个空的StringBuilder容器 public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去常用成员方法 public StringBuilder append(...)：添加任意类型数据，并返回当前对象自身（可以链式编程） public String toString()：将当前StringBuilder对象转换为String对象第五章 包装类基本数据类型使用方便，效率高，但是缺少对应的方法来操作这些数据，故有时采用包装类。（除了char-Character和int-Integer,其他包装类都是首字母大写）装箱与拆箱 装箱：基本类型转换为对应包装类对象 通过构造方法(已过时）：Integer(int i)Integer(String s)：其中s必须时基本类型字符串，否则抛出异常 静态方法：static Integer valueOf(int i)：返回一个Integer实例static Integer valueOf(String s) 拆箱：包装类对象转换为基本类型成员方法：int intValue()自动装箱与拆箱从JDK1.5开始，基本类型和包装类的装箱与拆箱可以自动完成如ArrayList&lt;Integer&gt;中只能存储Integer包装类，但是可以直接写123ArrayList&lt;Integer&gt;list;list.add(999); //自动装箱int a=list[0]; //自动拆箱 基本数据类型与字符串之间的转换基本类型转字符串总共三种方式 基本数据类型+””即可 使用包装类中的静态方法toString（参数) 重载了Object的toString方法 使用String类中的静态方法valueOf(参数)String转基本数据类型除了Character类以外，所有包装类都具有parseXxx静态方法，可以将字符串参数转换为对应的基本类型 第六章 接口基础知识 接口就是一种公共的规范标准，如全中国的插座都一样。只要符合标准就可以大家通用 代码中，接口就是多个类的公共规范 接口是一种引用数据类型，其中最重要的内容就是抽象方法 接口的格式 123public interface 接口名称{接口内容} 备注：换成了关键字interface后，编译生成的字节码文件仍然是.java-&gt;.class 如果是JAVA7，则接口中可以包含的内容有：1.常量 2.抽象方法 如果是JAVA8，则：3.默认方法 4.静态方法 如果是JAVA9，则：5.私有方法接口使用步骤 注意事项： 1.接口中的抽象方法，修饰符必须是两个固定的关键词：public abstract2.这两个关键字可以选择性地省略，忽略任意一个或者两个一起省略都可以 接口使用步骤 接口不能直接使用，必须有一个实现类(类似子类）来实现该接口public class 实现类名称 implements 接口名称{...} 接口的实现类必须覆盖重写（实现）接口中的所有抽象方法 创建实现类的对象，进行使用接口的默认方法定义 接口中的默认方法可以解决接口升级的问题（已经实现了原有接口的类，在接口添加了新的抽象类后，由于实现类必须实现接口所有的抽象方法，而不能再使用）使用带方法体的默认方法即可解决这个问题 格式 1public default 返回值类型 方法名称（参数列表）{方法体} 注意事项 1.接口的默认方法，可以通过接口实现类对象直接调用2.接口的默认方法，也可以被接口实现类进行覆盖重写 接口中的Static方法 从JAVA8开始，接口中允许定义Static方法 格式 1public static 返回值类型 方法名称（参数列表）{方法体} 不能通过接口实现类的对象来调用接口当中的静态方法；正确用法：通过接口名称直接调用静态方法（静态只与类/接口，有关系）接口中的私有方法 通过抽取一个共有方法，用来解决两个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。 从JAVA9开始，接口中可以定义私有方法 1.普通私有方法 ：解决多个默认方法之间重复代码问题 1private 返回值类型 方法名称（参数列表）{方法体} 2.静态私有方法 ：解决多个静态方法之间重复代码问题 1private static 返回值类型 方法名称（参数列表）{方法体} 接口的常量定义 接口中也可以定义“成员变量”，但必须加上public static final三个修饰符（可以省略，但是不写也照样是这样，不能写别的），从效果上来说，这就是接口的常量*(final关键词修饰，说明不可改变） 格式1public static final 常量名称=数据值; 接口中的常量，要完全大写，下划线分割，必须赋初值 使用时，直接用接口名称.常量即可使用接口的注意事项 接口是没有静态代码块或构造方法的 一个类只有一个直接父类，但是一个类可以同时实现多个接口格式：123public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{ //覆盖重写所有抽象方法 } 如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类必须是一个抽象类。 如果实现类所实现的多个接口中，存在着重复的默认方法，则实现类一定要对冲突的默认方法进行覆盖重写。 继承优先于接口实现：一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突，优先使用父类中的方法接口之间的多继承 类与类之间是多继承的，直接父类只有一个 类与接口之间是多实现的，一个类可以实现多个接口 接口与接口之间是多继承的注意事项： 1.多个父接口当中的抽象方法如果重复，没关系（因为抽象方法没有方法体）2.多个父接口当中的默认方法如果重复，那么子接口必须对重复的默认方法进行覆盖重写，default关键字不能省略 第七章 多态多态的基本概念 学生类继承人类，小明是一个学生对象，那么小明：既是一个学生，也是一个人，体现了对象的多态性 代码中体现多态性就是：父类引用指向子类对象格式(左父右子）： 123父类名称 对象名=new 子类名称();或者接口名称 对象名称=new 实现类名称(); 多态中成员方法的使用特点 看new的是谁，就优先用谁，没有则向上找 父子都有，优先用子 成员方法：编译看左，运行看右 成员变量：编译看左，运行还看左 使用多态的好处等号左边形式统一 1234Worker teacher=new Teacher(); Worker cooker=new Cooker(); teacher.work(); cooker.work(); 对象的向上转型对象的向上转型，其实就是多态写法父类名称 对象名=new 子类名称()含义：右侧创建一个子类对象，把它当作父类来看待使用注意事项：向上转型一定是安全的 对象的向下转型 因为对象的向上转型有个缺点：无法通过父类引用指向子类对象的方式，调用子类特有方法 对象的向下转型，其实是一个还原动作，这样就可以调用子类独特方法 格式：子类名称 对象名=（子类名称）父类对象 注意事项：必须保证对象创建的时候本来就是猫，才能向下转型为猫instanceof的使用cat instanceof Cat第八章 Collection集合集合是JAVA提供的一种容器，可以存储多个数据与数组的区别： 集合长度可变 集合存储的是对象，且对象类型可以不一致一、Collection集合 集合框架 Collection常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可以操作所有的单列集合 public boolean add(E e):给定对象添加到集合中 public void clear()：清空集合中所有元素 public boolean remove(E e)：把给定的对象在当前集合中删除 public boolean contains(E e)：判断当前集合中是否包含给定对象 public boolean isEmpty()：判断集合是否为空 public int size()：返回集合元素数量 public Object[ ] toArray() ：把集合中的元素存储到数组中二、Iterator迭代器JDK中提供的专门用来遍历集合的接口（不是所有集合都有索引，即有些不能直接用for循环遍历） *迭代：即Collection集合元素通用的获取方式。取出元素前先判断集合中有没有元素，如果有则取出，再继续判断，一直到取完。这种取出方法的专业术语成为迭代Iterator迭代器是一个接口，无法直接使用，需要接口的实现类对象。其获取实现类的方式特殊**，Collection类中有一个方法叫iterator(),返回的就是Iterator的实现类对象常用方法boolean hasNext()：如果仍有元素可以迭代，返回trueE next()：返回迭代的下一个元素1234567891011121314Collection&lt;String&gt;coll=new ArrayList&lt;&gt;();coll.add(&quot;我爱你&quot;);coll.add(&quot;中国&quot;);coll.add(&quot;我爱你&quot;);coll.add(&quot;塞北的雪&quot;);Iterator&lt;String&gt;iter=coll.iterator();while(iter.hasNext()){ System.out.print(iter.next());}或者for(Iterator&lt;String&gt;iter=coll.iterator();iter.hasNext();){ System.out.print(iter.next());} 三、增强for增强for循环也称为for each循环，是JDK1.5以后出来的高级循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历中不能对集合中的元素进行增删操作。12345678910111213//foreach遍历数组 （注意只能遍历，不能增删，因为其只是Iterator遍历的简化格式）String[]arr={&quot;我爱你&quot;,&quot;中国&quot;,&quot;亲爱的宝宝&quot;};for(String i:arr){System.out.println(i);}//增强for循环遍历集合Collection&lt;Integer&gt;coll=new ArrayList&lt;&gt;();coll.add(1);coll.add(2);coll.add(3);for(Integer i:coll){System.out.println(i);} 四、List接口三个特点：1.有序 2.有索引 3.允许重复List接口中带索引的方法（特有） public void add(int index,E element)：将指定元素插入到指定位置 public E get(int index)：获取指定位置上的元素 public E remove(int index)：删除指定位置上的元素，并返回该元素 public E set(int index,E element)：用指定元素替换指定位置，并返回原来的元素List的子类1.ArrayList底层是数组，查询快，增删慢。增加元素时需要创建一个比原来数组大1的新数组，再调用System.arraycopy将原有数组拷贝到新数组，效率低。因此开发中，增删用的多不建议使用ArrayList2.LinkedList特点： 底层是链表结构：查询慢，增删快 包含大量操作首尾元素方法 常用方法 public void addFirst(E e) public void addList(E e) public E getFirst() public E getLast() public E removeFirst() public E removeLast()：等效于add方法 public E pop()：从此列表所表示的堆栈处弹出一个元素等效于removeFirst public void push(E e)：将元素推入此列表所表示的堆栈 等效于addFirst public boolean isEmpty() 注意：获取元素时注意如果集合中没有元素，则会报错，需要用isEmpty先判断一下 3.Vector集合单线程的，速度慢，JDK1.2后被ArrayList取代。了解即可 五、Set接口 特点： 不重复 没索引HashSet 特点： 不允许重复 没有索引 是无序集合，存储和取出的顺序可能不同 底层是一个哈希表结构（查询速度很快） 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址，是一个逻辑地址，不是实际地址）Object类中有一个方法，可以获取对象的哈希值int hashCode() 返回该对象的哈希值 hashCode源码：public native int hashCode(); *native**代表调用的是本地OS的方法 String类重写了Object类的hashCode方法HashSet集合存储数据的结构——哈希表JDK1.8之前：哈希表=数组+链表JDK1.8之后：哈希表=数组+链表/红黑树（提高查询速度）超过8个用红黑树 哈希表的特点：速度快 HashSet集合不重复原理 HashSet集合不允许存储重复元素的原理：在Set集合调用add方法时，会先调用hashCode方法，如果没有发生哈希冲突则存储到集合中；若发生冲突，则再调用equals方法与冲突位置上的各元素比较，如果有相同的则不存储。 *前提**：存储的元素必须重写hashCode方法和equals方法HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一12345678910111213@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } LinkedHashSetLinkedHashSet继承了HashSet，底层是哈希表（数组+红黑树/链表）和一条链表（记录元素存储顺序），HashSet是无序的（不能保证存储和取出顺序一致），LinkedHashSet额外实现了有序（存储和取出顺序一致），也不允许重复 可变参数使用前提： 参数列表的类型已经确定，但参数个数不确定时 一个方法的参数列表只能有一个可变参数 如果参数有多个，可变参数必须写在参数列表的末尾 底层原理：可变参数底层是一个数组，根据传入参数个数会创建不同长度的数组终极形式：object...obj 1234567891011public static void main(String[] args) { System.out.println(add(1,2)); System.out.println(add(1,2,3,4));}public static int add(int...arr){ int sum=0; for(int i:arr){ sum+=i; } return sum;} 六、Collections工具类常用功能java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。（使用前提，必须实现Comparable，重写接口中的compareTo方法/自己-目标是升序/） public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparable与Comparator的区别Comparable：即该类自身带有Comparable方法，可以实现本类的比较，需要实现Comparable接口，重写比较规则compareTo方法Comparator：相当于找一个第三方裁判，无需实现接口；规则：o1-o2升序 例子： 12345678910111213141516171819202122232425import java.util.*;public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); ArrayList&lt;String&gt;list=new ArrayList&lt;&gt;(); while(n--&gt;0) list.add(sc.next()); Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { int a=Integer.parseInt(o1+o2); int b=Integer.parseInt(o2+o1); if(a&gt;=b) return -1; return 1; } }); StringBuilder sb=new StringBuilder(); for(String e:list) sb.append(e); System.out.println(sb); }} 第九章 Map集合Map集合特点 Map集合是双列集合，一个元素包含两个值 key不可以重复，value可以重复 一个key唯一对应一个value常用子类HashMap集合特点： 底层是哈希表（查询速度快）JDK1.8之前：数组+单向链表 JDK1.8及以后：数组+单项链表/红黑树（8个+用红黑树） HashMap是无序集合（存储和取出顺序有可能不同）LinkedHashMap集合继承了HashMap集合特点： LinkedHashMap底层：哈希表+链表（保证迭代顺序） 有序（存储和取出顺序一致）Hashtable集合特点： 不允许存储null键-null值 线程安全的（同步的、单线程、速度慢）HashMap是多线程的，非线程安全，不同步，速度快 和Vector集合一样在JDK1.2后被取代（ArrayList，HashMap）但是Hashtable的子类Properties依然活跃，它是唯一一个与IO流结合的集合 Map接口中常用的方法 public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。如果key重复则替换value（返回被替换的值），不重复则添加（返回null） public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。123456789101112131415Map&lt;String,String&gt; map=new HashMap&lt;&gt;();map.put(&quot;大伯&quot;,&quot;大妈&quot;);map.put(&quot;二伯&quot;,&quot;二妈&quot;);map.put(&quot;老爸&quot;,&quot;老妈&quot;);//利用keySet遍历MapSet&lt;String&gt; set = map.keySet();Iterator&lt;String&gt; iter = set.iterator();while(iter.hasNext()){ System.out.println(map.get(iter.next()));} 或者使用灵活版的foreach循环 for(String i:map.keySet()){ String value=map.get(i); System.out.println(i+&quot;和&quot;+value); } Entry（项）键值对对象Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718Map&lt;String,Integer&gt;map=new HashMap&lt;&gt;();map.put(&quot;余丰旭&quot;,171);map.put(&quot;陈香玉&quot;,160);map.put(&quot;小小余&quot;,180);//遍历Map的第二种方法，使用Entey键值对对象//使用迭代器进行遍历Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator();while(iter.hasNext()){ Map.Entry&lt;String,Integer&gt; entry=iter.next(); String key=entry.getKey(); Integer value=entry.getValue(); System.out.println(key+&quot;身高是&quot;+value+&quot;厘米&quot;);}//使用增强for循环for(Map.Entry&lt;String,Integer&gt; i:map.entrySet()){ System.out.println(i.getKey()+&quot;身高为&quot;+i.getValue()+&quot;cm&quot;);} HashMap存储自定义类型键值Map集合保证key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一 第十章 泛型当我们不知道使用什么数据类型的时候，我们可以使用泛型。创建集合对象的时候就会确定泛型的数据类型 一、泛型概述 创建集合对象，不使用泛型 *好处**：元素类型不必一致，默认类型是Object类 *弊端**：不安全，使用了多态导致子类独特内容被屏蔽，需要向下转型（循环中又无法统一向下转型） 创建集合对象，使用泛型 *好处**： 1.避免了类型转换的麻烦，存储的什么类型，取出来就是什么类型2.把运行期异常（代码运行之后抛出的异常），提升到编译期。不使用泛型，需要向下转型，循环中会出现类型转换异常 弊端：泛型是什么类型，就只能存储什么类型 二、定义和使用有泛型的类定义了带泛型的类，创建对象时不写则默认为Object类 123456789101112131415161718public class One&lt;E&gt; { private E data; public One() { } public One(E data) { this.data = data; } public E getData() { return data; } public void setData(E data) { this.data = data; }} 1234567public static void main(String[] args) { One&lt;String&gt;one=new One&lt;&gt;(&quot;使用了泛型&quot;); System.out.println(one.getData()); One&lt;Integer&gt;two=new One&lt;&gt;(); two.setData(12); System.out.println(two.getData());} 含有泛型的方法含有泛型的方法，在调用方法时确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型 格式：修饰符&lt;泛型&gt; 返回值类型 方法名（参数列表*(使用泛型)*）{方法体} 含有泛型的接口 定义格式： 1修饰符 interface 接口名 &lt;代表泛型的变量&gt;{}共有两种使用方式 接口的抽象方法以泛型为参数 接口的实现类的泛型跟着接口的泛型走1public class Two&lt;E&gt;implements MyInterface&lt;E&gt; 泛型通配符用来表示暂时未知的类型1234567891011121314151617181920212223public class Demo { public static void main(String[] args) { ArrayList&lt;Integer&gt;list1=new ArrayList&lt;&gt;(); list1.add(1); list1.add(2); list1.add(3); ArrayList&lt;String&gt;list2=new ArrayList&lt;&gt;(); list2.add(&quot;我爱你&quot;); list2.add(&quot;塞北的雪&quot;); traverseList(list1); traverseList(list2); } public static void traverseList(ArrayList&lt;?&gt;list){ /*for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); }*/ //使用迭代器遍历 Iterator&lt;?&gt;iterator=list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } }} 通配符高级使用——受限泛型 泛型的上限* 格式：类型名称 &lt;? extends 类&gt; 对象名称 意义：只能接收该类型及子类型 泛型的下限* 格式：类型名称 &lt;? super 类&gt; 对象名称 意义：只能接收该类型及其父类型java 此时参数只能接收Person类及其子类对象 public static void func(Collection&lt;? extends Person&gt; coll) 此时参数只能接收Person类及其父类对象 public static void func(Collection&lt;? super Person&gt; coll) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EKBUBlAi-1580906486394)(img\\Collection与Map.bmp)]","link":"/2020/01/29/Java-java%E5%85%A5%E9%97%A8/"},{"title":"使用优先级队列合并K个升序链表","text":"在做23合并K个升序链表这题时，发现使用优先级队列（堆）能够高效地解决此问题。 思路：直接无脑地将所有节点扔进优先级队列中（小根堆），然后依次取出所有节点，按照头插法构建结果链即可。 注意：这里C++优先级队列对于自定义数据类型的比大小的实现，是通过一个结构体内实现()运算符重载来实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */struct cmp{ bool operator()(ListNode*&amp;p1,ListNode*&amp;p2){ return p1-&gt;val&lt;p2-&gt;val; }};class Solution {private: priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;que; //传入自定义比较器cmppublic: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { //将所有节点指针，放入大根堆中 for(int i=0;i&lt;lists.size();i++){ ListNode*p=lists[i]; while(p){ que.push(p); p=p-&gt;next; } } ListNode*res=new ListNode(0); while(!que.empty()){ //头插法 ListNode*t=que.top(); que.pop(); t-&gt;next=res-&gt;next; res-&gt;next=t; } return res-&gt;next; }};","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"利用双堆找中位数","text":"今天做了一题堆相关的题目295数据流的中位数，题解巧妙地用一个大根堆和一个小根堆来快速计算中位数。 其中添加新数字的写法十分精妙：如果一个数字要添加到小根堆，就先添加到大根堆，再将大根堆堆顶的元素转移至小根堆；反之亦然，以此能够保证小根堆中的元素永远大于大根堆中的元素。 其中，C++优先级队列底层默认是一个大根堆（使用了less&lt;xxx&gt;，更换成greater&lt;xxx&gt;，即变为小根堆）。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder {public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if(que1.size()&gt;=que2.size()){ que1.push(num); que2.push(que1.top()); que1.pop(); }else{ que2.push(num); que1.push(que2.top()); que2.pop(); } } double findMedian() { if(que1.size()&gt;que2.size()) return que1.top(); if(que1.size()==que2.size()) return (double)(que1.top()+que2.top())/2; return que2.top(); }private: priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;que1; //大根堆 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;que2; //小根堆};/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */","link":"/2021/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%A9%E7%94%A8%E5%8F%8C%E5%A0%86%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"堆与堆排序","text":"堆其实就是一种数组形式的完全二叉树，具体分为大根堆和小根堆 大根堆：父节点的值大于等于子节点的值 小根堆：父节点的值小于等于子节点的值 堆排序利用堆的特点，根节点大于等于所有节点的值（大根堆），那么每次建堆后将根节点与末尾节点交换位置，然后再对末尾节点以外的所有节点重新建堆（注意，这里不需要调用build_heap函数，只需要调用heapify函数即可，因为根节点的做右子树已经是堆，正因为如此，堆排序才有nlogn的时间复杂度），这样不断重复即可完成排序。 技巧：逆序下第一个有子节点的节点的下标，无论什么情形，固定为$len/2-1$ 原因：任意一个节点的父节点下标为(i-1)/2; 那么逆序第一个有子节点的节点，即为完全二叉树最后一个节点的父节点。故为(n-1-1)/2=n/2-1; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;void swap(int tree[], int c1, int c2) { int t = tree[c1]; tree[c1] = tree[c2]; tree[c2] = t;}/** * n个节点的完全二叉树 * 在第i个节点处建堆 * 前提：左右子树已经是堆 * @param tree * @param n 完全二叉树节点个数 * @param i 进行heapify的根节点 */void heapify(int tree[], int n, int i) { int p = i; while (p &lt; n) { int max = p; int l = 2 * p + 1, r = 2 * p + 2; if (l &lt; n &amp;&amp; tree[l] &gt; tree[max]) { max = l; } if (r &lt; n &amp;&amp; tree[r] &gt; tree[max]) { max = r; } if (max == p) break; swap(tree, p, max); p = max; }}/** * 对节点数为n的完全二叉树建堆 * @param tree * @param n 完全二叉树节点个数 */void build_heap(int tree[], int n) { int p = n / 2 - 1; while (p &gt;= 0) { heapify(tree, n, p); p--; }}/*堆排序*/void heap_sort(int tree[], int n) { build_heap(tree, n); for (int i = n - 1; i &gt; 0; i--) { swap(tree, 0, i); heapify(tree, i, 0); }}","link":"/2020/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"最大频率栈","text":"今天写到一到数据结构的题目，觉得很有意思，遂记录下leetcode895最大频率栈。这题既需要记录每个数字的频率，又需要记录每种频率拥有的数字，故采用两个map来实现。 执行过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FreqStack {public: FreqStack() { maxFreq=0; } void push(int val) { /*查询是否已存在*/ if(numFreq.find(val)==numFreq.end()){ numFreq[val]=1; freqNums[1].push(val); if(maxFreq==0) maxFreq=1; }else{ numFreq[val]++; freqNums[numFreq[val]].push(val); if(numFreq[val]&gt;maxFreq) maxFreq++; } } int pop() { int ans=freqNums[maxFreq].top(); freqNums[maxFreq].pop(); if(freqNums[maxFreq].empty()) maxFreq--; if(numFreq[ans]==1){ numFreq.erase(ans); }else{ numFreq[ans]--; } return ans; }private: map&lt;int,int&gt;numFreq; //每个数字的频率 map&lt;int,stack&lt;int&gt;&gt;freqNums; //每种频率含有的数字 int maxFreq; //最大频率};/** * Your FreqStack object will be instantiated and called as such: * FreqStack* obj = new FreqStack(); * obj-&gt;push(val); * int param_2 = obj-&gt;pop(); */","link":"/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"},{"title":"实现一个LRU缓存结构","text":"LRU：最近最少使用算法。LRU缓存算法，由哈希表和双向链表构成，能以O(1)时间复杂度获取缓存的键值，也能以O(1)的时间复杂度存储键值。 Java中有内置类型LinkedHashMap，可以直接用于LRUCache的实现。C++没有，需要手动实现，这里我手动实现一个。 leetcode有一题LRU题目LRU缓存机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//双向链表+哈希表struct Node{ int key,val; Node*pre,*next; Node(int k,int v):key(k),val(v),pre(NULL),next(NULL){}};class DoubleList{ public: DoubleList(){ size=0; head=new Node(0,0); tail=new Node(0,0); head-&gt;next=tail; tail-&gt;pre=head; } //在链表尾部添加节点 void addTail(Node*x){ x-&gt;next=tail; x-&gt;pre=tail-&gt;pre; tail-&gt;pre-&gt;next=x; tail-&gt;pre=x; size++; } //删除某个节点(根据地址) void deleteNode(Node*x){ x-&gt;pre-&gt;next=x-&gt;next; x-&gt;next-&gt;pre=x-&gt;pre; size--; //return x; } //删除首节点，并返回其键值，用于反向删除map中的键 int deleteFirst(){ int key=head-&gt;next-&gt;key; deleteNode(head-&gt;next); return key; } int getSize(){ return size; } private: int size; Node*head,*tail; //tail处是最近访问的};class LRUCache {public: LRUCache(int capacity) { this-&gt;capacity=capacity; } int get(int key) { if(node_map.find(key)==node_map.end()) return -1; Node*p=node_map[key]; makeRecent(p); return p-&gt;val; } void put(int key, int value) { //如果已经存在，则更新值 if(node_map.find(key)!=node_map.end()){ Node*p=node_map[key]; makeRecent(p); p-&gt;val=value; return; } //不存在的情况下： //如果满了 if(capacity==cache.getSize()){ removeLRU(); } Node*p=new Node(key,value); cache.addTail(p); //放入哈希表 node_map[key]=p; } //将某个节点提升到recent void makeRecent(Node*x){ cache.deleteNode(x); cache.addTail(x); } //删除LRU节点缓存 void removeLRU(){ int key=cache.deleteFirst(); node_map.erase(key); }private: int capacity; DoubleList cache; unordered_map&lt;int,Node*&gt;node_map;}; 123456789101112131415161718192021222324252627282930313233343536373839404142class LRUCache { int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int val) { if (cache.containsKey(key)) { // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (cache.size() &gt;= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的 key 添加链表尾部 cache.put(key, val); } private void makeRecently(int key) { int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); }}","link":"/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/"},{"title":"微服务优惠券项目","text":"项目简介微服务架构与传统架构的区别 传统架构（单体服务） 优点 所有功能集中在一起，结构简单 缺点 编写代码时，各种功能可能会发生冲突 需要修改某一功能时，需要重新编译整个项目 当某一功能发生故障时，可能会拖垮整个项目业务系统 微服务 微服务即将原本大系统中的各个功能点拆分为独立的小系统，并独立部署。致力于解决单体服务的各种弊端 优点 客户端不直接与微服务进行交互，而是通过网关做路由请求的分发 功能之间的方法调用，变成了微服务之间的服务调用 让开发、部署过程变得简单易维护 某个微服务出现问题，不会影响其他的微服务，对业务系统的高可用提供了保障项目架构 涉及的技术 Java Maven SpringCloud MySQL、Redis、Kafka MavenMaven是一种项目构建工具 相关特性 传递依赖与排除依赖 如果项目引用了一个jar包，而该jar包又引用了其他jar包。那么，默认情况下，项目编译时，Maven会把直接引用和间接引用的jar包都下载到本地（~/.m2/repository) 排除依赖：如果我们指向下载直接引用的jar包，那么需要在pom.xml中做如下配置（给出需要排除的坐标） 依赖冲突 说明：如果项目中多个jar同时引用了相同的jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的。 短路优先 本项目-&gt;A.jar-&gt;B.jar-&gt;X.jar 本项目-&gt;C.jar-&gt;X.jar 声明优先 若引用路径长度相同时，在pom.xml中，谁先被声明，就是用谁 多模块项目/聚合 为什么需要多个模块构成一个项目？ 项目很大的情况下，编译时间很长，只是改动某处的代码却需要编译整个项目 pom文件可以用来继承和重用，如果另一个项目需要用到这个项目中的某个模块，在不分模块的情况下（只有一个jar包或者war包），就只能依赖于一个很大的包，将整个项目都依赖进去。项目很大的情况下，维护困难，可重用性低。 dependencyManagement和dependencies标签的区别 dependencies子模块默认集成父项目的依赖项，全部继承 dependencyManagement只在父模块中声明依赖而不引入，子模块如果引入需要显示声明 父模块与子模块的关系 父模块管理所有jar包，子模块引用父模块即可，无需重复定义 父模块没有代码，只有pom文件管理所有的依赖，以及共同的配置 父模块packaging类型必须是pom（默认是jar）Redis支持的数据类型 String List 双向链表实现 Hash Set SortedSet 每个元素关联一个浮点型的权重值 Redis特性 Redis的所有操作都是原子的 一个操作要不全部完成，要不就不做 源自Redis的单线程 Redis可以对key设置过期时间（后面两种是Redis对key的删除方式） 定时删除 惰性删除 定期删除 Redis支持两种持久化方式 RDB（快照，默认）：一次性将redis数据全部写入磁盘文件中，在线上操作中几乎不被采用 AOF(append only file)：将用户的每一个写指令（添加、修改、删除），都备份到文件中，还原数据的时候，执行具体的写指令 Redis速度快的原因 完全基于内存 数据结构简单 单线程，没有切换 多路IO复用模型 select epoll 缓存穿透和缓存雪崩的问题 缓存穿透：指查询一个不存在的数据，但是由于Cache不命中，又需要去DB中查询，造成性能下降 解决方案：给没有命中的key设定“没有意义的空值”(防止对该key反复访问数据库） 缓存雪崩：指Cache设置了相同的过期时间，导致Cache在同一时间失效，请求全部转发到DB，DB的瞬间压力过大，造成雪崩 解决方案：给key设定不同的（随机的）过期时间 Redis的IO模型BIO BIO：Blocking I/O 阻塞模型 阻塞模型的特点 当read/write对某一文件描述符(FD)进行读写时，如果当前的FD不可读或者不可写，则服务阻塞 I/O多路复用在客户端/服务器的模型下：多个客户端（应用）向服务器（内核）请求数据（请求完后可以去做别的事情），服务器中有一个selector监听各个客户端请求的数据是否准备好，如果准备好了则发送消息通知客户端。 多路复用模型的特点： 同时监控(select/epoll)多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，就会返回可读以及可写的文件描述符（个数）Redis的Reactor设计模式MySQL版本 目前企业级开发中最常用的版本 MySQL5.5（又叫MySQL5） MySQL5.6（又叫MySQL6） MySQL5.7（又叫MySQL7） MySQL官方主推的版本 MySQL8.0 MySQL 8 Up to 2X Faster Than MySQL5.7 MySQL8.0配置 pom.xml的配置 jdbc驱动类的配置driver-class-name:com.mysql.cj.jdbc.Driver 数据库时区的配置(如果未设置时区，可能会报Time Zone错误）set GLOBAL time_zone=’+8:00’;InnoDB索引原理B树和B+树B树是一种多路平衡查找树，B是Balance，m阶（m&gt;=2）的B树有以下特性： 树中的每个子节点最多有m个子节点 除了根节点和叶子节点以外，其他每个节点至少有m/2个子节点 所有的叶子节点都在同一层 节点中关键字的顺序按照升序排列B+树是B树的一种变体，同样是多路平衡查找树，它与B树主要的不同是 非叶子节点不存储数据，只存储索引 叶子节点包含了全部的关键字信息，且叶子节点按照关键字顺序相互连接 Mysql索引主要使用的是B+树 聚簇索引聚簇索引的含义每个InnoDB的表都有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。聚簇索引的创建规则辅助索引辅助索引的含义除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于，辅助索引的叶子节点中存放的是主键的键值辅助索引的两次查找行记录常见索引类型 索引本质是一张表，保存的是主键与索引的字段，并且指向实体表的记录 Spring Data Jpa 什么是JPA即Java Persistence API，用于对象持久化的API，它是ORM规范(不是具体实现，只是定义了接口)，使得应用程序以统一的方式访问持久层。 ORM规范ORM 是 Object Relational Mapping 的缩写，译为 “对象关系映射” 框架。所谓的 ORM 框架就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述 Java 对象与数据库表之间的映射关系，自动将 Java 应用程序中的对象持久化到关系型数据库的表中。ORM 框架是一种数据持久化技术，即在对象模型和关系型数据库之间建立起对应关系，并且提供一种机制，可通JavaBean 对象操作数据库表中的数据。 JPA和Hibernate的关系 JPA是Hibernate的一个抽象 JPA是ORM规范，不是ORM框架 Hibernate是JPA的一种实现 JPA是Hibernate的一个功能子集 Hibernate 在查询不复杂、并发量小的情况下比较合适，查询复杂、并发量高的情况下用Mybatis，只要适合应用场景的就是好的技术。 JPA的优势 标准化 简单易用 面向对象 JPA包含的技术 ORM映射元数据 描述对象和表中数据的映射关系 提供了查询API 查询语句（JPQL）通过面向对象而非面向数据库的查询语言去查询数据，避免程序和具体的SQL耦合在一起 Spring Data项目 Spring Data是Spring的一个子项目，用于简化数据库访问 Spring Data JPA是Spring Data的一个子项目 Spring Data JPA致力于减少数据访问层（DAO）的开发量 数据库连接池 数据库连接池能够做什么 连接复用：通过简历一个数据库连接池以及一套连接使用管理策略，使得一个数据库可以得到高效、安全的复用，避免了数据库链接频繁简历、关闭的开销。 数据库连接池的基本原理 数据库连接池的基本原理是在内部对象池中维护一定数量的数据库链接，并对外暴露数据库连接获取和返回方法 getConnection releaseConnection 使用数据库连接池的优势 资源重用 更快的系统响应 优化的资源分配 统一的连接管理 SpringBoot2默认的数据库连接池Kafka消息系统 点对点消息系统 发布订阅消息系统 ## Kafka术语 ![在这里插入图片描述](https://yfx-blog-image.oss-cn-hangzhou.aliyuncs.com/img/202107101112313.png) 当需要保持消息的顺序时，可以设置partition数量为1（默认是1） kafka Brokers有自动负载均衡的功能 Kafka的使用 Kafka Producer消息分区 使用key指定分区，在实际开发中并不常用 Kafka Consumer消费组 Kafka保证，一个tipic中的每个信息，只被消费者组中的一个成员消费 消费者总是属于一个消费者组，即使不指定消费者组，kafka也会默认地将其放入一个消费者组中（只有它一个） SpringBootSpringBoot应用启动入口 应用启动的三种方式 SpringAppliction静态方法run 通过Api调整应用行为 SpringApplicationBuilder的Fluent Api，实现链式调用 自动配置原理（starter）配置文件 统一目录下的application和bootstrap bootstrap优先级高于application，优先被加载 bootstrap用于应用程序上下文的引导阶段，由父ApplicationContext加载 bootstrap是系统级别的配置（不变的参数），application是应用级别的配置 不同位置的配置文件加载顺序（优先级） 配置注入的方式即数据绑定的方式，有两种 通过配置直接注入 通过类注入定时和异步任务 单元测试开机启动Actuator监控遇到的问题及解决方案 在resources中自定义配置，编辑application.yml文件时，报错解决方法：书写键值的时候要加空格，如port: 8000，否则就会报错","link":"/2021/06/01/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"title":"Filter&amp;Listener","text":"Filter基本概念 JavaWeb三大组件：Servlet、listener、filter 当访问服务器资源时，过滤器可以将请求拦截下来，完成一些特殊功能 过滤器的作用 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…. 快速入门 步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解配置 代码 123456789101112131415161718192021@WebFilter(&quot;/*&quot;) //拦截所有资源public class FilterDemo01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;I am excuted&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { }} 过滤器细节 web.xml配置 12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;com.hhu.web.filter.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--拦截所有资源--&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器生命周期方法 服务器启动后，会创建Filter对象，然后调用init方法，只调用一次。用于加载资源 服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。用于释放资源 doFilter方法每次请求被拦截资源时，会执行。执行多次 过滤器配置详解 拦截路径配置： 具体资源路径：/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录：/user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截：*.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源: /* 拦截方式配置：资源被访问的方式 注解配置（**注意配置了拦截方式后，原来的拦截路径配置就不能省略value=**） 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请i去资源 FORWARD：转发访问资源 （了解）INCLUDE：包含访问资源 （了解）ERROR：错误跳转资源 （了解）ASYNC：异步访问资源 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链（配置多个过滤器） 执行顺序：如果有两个过滤器：1和2 1 2 资源执行 2 1 过滤器先后顺序问题 注解配置：按照类名的字符串比较规则，值小的先执行 web.xml配置：谁定义在上边，谁先执行 案例：登录验证 需求 对访问用户信息列表展示此案例的资源。验证其是否登录 如果登录了，则直接放行 如果没有，则跳转到登录也没面，提示“您尚未登录，请先登录“ 图示 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CBRlZe4g-1589287434701)(Fliter&amp;Listener.assets/image-20200510122521814.png)] 代码 1234567891011121314151617181920212223242526272829303132333435363738/** 完成登录验证的过滤器*/@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { //判断是否是登录相关的资源 //0.强制转换 HttpServletRequest request=(HttpServletRequest)req; //1.获取资源的请求路径 String URI = request.getRequestURI(); //2.判断是否包含登录相关资源路径,要注意排除掉css/js/图片/验证码资源 if(URI.contains(&quot;/login.jsp&quot;)||URI.contains(&quot;/loginServlet&quot;) ||URI.contains(&quot;/css/&quot;)||URI.contains(&quot;/fonts&quot;) ||URI.contains(&quot;/js&quot;)||URI.contains(&quot;/checkCodeServlet&quot;)){ //放行 chain.doFilter(req, resp); } else{ //不包含，验证用户是否登录 //3.从session里获取user Object user = request.getSession().getAttribute(&quot;user&quot;); if(user!=null) chain.doFilter(req, resp); else{ request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,resp); } } } public void init(FilterConfig config) throws ServletException { }} Listener 监听器 概念：web的三大组件 事件监听机制 事件：如点击按钮 事件源：事件发生的地方。如按钮 监听器：一个对象 注册监听：将事件、事件源、监听器绑定在一起 当事件源发生某个事件后，执行监听器代码 Listener用的少 ServletContextListener 接口：监听ServletContext对象的创建和销毁 方法 void contextDestroyed(ServletContextEvent sce) ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ServletContext对象创建后会调用该方法","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-Filter-Listener/"},{"title":"Redis","text":"NoSQL数据库概述NoSQL数据库，指的是非关系型的数据库。不依赖业务逻辑的方式存储，而是以简单的key-value模式存储。因此大大增加了数据库的扩展能力。 不遵循SQL标准 不支持ACID 原子性：事务的一组操作，要么都执行， 要么都不执行 一致性：满足数据完整性和一致性 隔离性：多个事务之间互不影响 事务隔离分为不同级别：读未提交、读提交、可重复读、串行化 持久性：一旦事务提交，即使数据库故障也不会丢失信息 远超SQL的性能NoSQL适用场景 对数据进行高并发的读写 海量数据的读写 对数据高可扩展性 NoSQL数据的存在意义就是从关系型数据库以业务逻辑为依据的存储模式，变为以性能为最优先考虑的存储方式，目的就是为了提高性能。 NoSQL不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，即需要即席查询常见NoSQL Memcache 支持的数据类型比较单一 不支持持久化操作 多线程+锁 Redis 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等 一般作为缓存数据库辅助持久化的数据库 单线程+多路IO复用 实现了多线程的效果，比memcache效率更高 MongoDB 高性能、开源、模式自由的文档型数据库 数据都在内存中 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据和大型对象 可以根据数据的特点替代RDBMS，成为独立的数据库。或者配合RDBMS，存储特定的数据。Redis安装 安装gcc redis官网找下载链接，用wget 下载安装包并解压 解压目录下编译make然后安装make install 安装后，将配置文件redis.conf复制到/etc下，并修改启动模式为后台启动，即修改redis.conf中daemonize no为yes 启动redis redis-server /etc/redis.conf 以该配置启动（后台启动） 打开客户端redis-cli 查看进程ps -ef | grep redis 测试验证：ping 得到pong回复，则说明运行正常 关闭redis redis cli shutdown 或者查看进程号 kill -9 xxx Redis常用五大数据类型库命令 默认16个数据库，下标从0开始，默认使用0号库 使用select &lt;dbid&gt;来切换数据库，如select 1 统一密码管理，所有库同样密码 dbsize查看当前数据库的key的数量 flushdb 清空当前库 flushall 通杀所有库 五大数据类型键的基本操作 keys* 查看当前库所有key （匹配 keys *1） exists key 判断某个key是否存在 type key 查看你的key是什么类型 del key 删除执行的key数据 unlink key 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作 expire key 10 10秒种：为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 字符串String简介 String是Redis最基本的数据类型，它是二进制安全的（意味着redis的String可以包含任何数据，比如jpg图片或者序列化的对象） 一个Redis种字符串value最多可以是512M常用命令 set &lt;key&gt;&lt;value&gt; 添加键值对 *NX 当数据库种key不存在时，可以将key-value添加进数据库 *XX 当数据库种key存在时，可以将key-value添加进数据库，与NX参数互斥 *EX key的超时秒数 *PX key的超时毫秒数，与EX互斥 get &lt;key&gt; 查询对应键值 append &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt;追加到原值的末尾 strlen &lt;key&gt; 获得值的长度 setnx &lt;key&gt;&lt;value&gt; 只有在key不存在时，设置key的值 incr 数字加一 decr 数字减一 incrby/decrby &lt;value&gt; &lt;步长&gt; 数字增减自定义长度 增减操作具有原子性，即原子操作不会被线程调度机制打断。Redis单命令的原子性主要得益于Redis的单线程（单线程+IO多路复用） Java种的i++不是原子操作 mset &lt;key1&gt;&lt;value1&gt; &lt;key2&gt;&lt;value2&gt;... 同时设置多个key-value mget &lt;key1&gt;&lt;key2&gt;... 同时获取多个value msetnx &lt;key1&gt;&lt;value1&gt; &lt;key2&gt;&lt;value2&gt;... 同时设置多个key-value，当且仅当所有给定key都不存在 以上三个操作具有原子性，有一个失败则都失败 getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt; 获得某范围内的值（左右都是闭区间） setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt; 用value覆盖从起始位置开始的值（索引从0开始） setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt; 设置键值的同时，设置过期时间，单位秒 getset&lt;key&gt;&lt;value&gt; 以旧换新，设置新值同时获得旧值数据结构String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS）。是可以修改的字符串，内部结构类似Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于1M时，扩容时加倍现有的空间，超过1M，扩容时只会多扩1M的空间。字符串的最大长度是512M。列表list 简介Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际上是双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能比较差。 常用命令 lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt;... 从左边/右边插入值 lpop/rpop &lt;key&gt; 从左边/右边吐出一个值。 rpoplpush &lt;key1&gt;&lt;key2&gt; 从key1列表右边吐出一个值，插入到key2列表左边 lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; 按照索引下标获得元素（从左到右） lrange &lt;key&gt; 0 -1 获取所有元素 index &lt;key&gt;&lt;index&gt; 按照索引下标获得元素（从左到右） llen &lt;key&gt; 获得列表长度 linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt; 在&lt;value&gt;的前边或后边插入值 lrem &lt;key&gt; &lt;n&gt; &lt;value&gt; 从左边删除n各value lset &lt;key&gt; &lt;index&gt; &lt;value&gt; 将列表key下标为index的值替换为value数据结构List的数据结构为快速链表quickList。首先在列表元素较少的情况下会使用一块连续的内存空间， 这个结构是ziplist，即压缩列表。它将所有的元素紧挨着一块存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。Redis将链表和ziplist结合起来组成quicklist。也就是将多个ziplist使用双向指针串起来。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。集合set简介与list类似，但是具有去重功能。Redis的Set是string类型的无序集合。它底层是一个value为null的哈希表，所以添加、删除、查找的复杂度都是O（1）常用命令 sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt;... 将一个或多个member元素加入集合key种，已经存在的member元素被忽略 smembers &lt;key&gt;取出该集合的所有值 sismember &lt;key&gt; &lt;value&gt; 判断集合key是否含有value值 scard&lt;key&gt; 返回该集合的元素个数 srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt;... 删除集合中的某个元素 spop &lt;key&gt; 随机从该集合种吐出一个值 srandmember &lt;key&gt; &lt;n&gt; 随机从该集合种取出n个值。不会删除成员。 smove &lt;source&gt; &lt;des&gt; value 把集合中一个值移动到另一个集合 sinter &lt;key1&gt; &lt;key2&gt; 返回两个集合的交集元素 sunion &lt;key1&gt;&lt;key2&gt; 返回两个集合的并集元素 sdiff &lt;key1&gt;&lt;key2&gt; 返回两个集合的差集元素（在key1中，不在key2中） 数据结构Set数据结构是dict字典，字典是用哈希表实现的。哈希Hash简介Redis Hash是一个键值对集合，是一个stirng类型的field和value的映射表，hash特别适合用于存储对象，类似Java中的Map&lt;String,Object&gt;。 #### 常用命令 hset &lt;key&gt;&lt;field&gt;&lt;value&gt;给key集合中field键赋值 hget &lt;key&gt;&lt;field&gt; 从集合key中的field中取值value hmset &lt;key&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... 批量设置hash的值 hexists&lt;key1&gt;&lt;field&gt; 查看哈希表key中，给定域field是否存在 hkeys &lt;key&gt; 列出该hash集合的所有field hvals &lt;key&gt; 列出该hash集合的所有value hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt; 为哈希表key中的域field的值加上增量1 -1 hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt; 将哈希表key中的域field的值设置为value，当且仅当域不存在 数据结构Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，是用ziplist，否则是用hashtable有序集合Zset (sorted set)常用命令 zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;... 将一个或多个member元素及其score值（用于排序）添加到有序集合key中 zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores] 返回有序集合key中，下标在start和stop之间的元素(0 -1展示全部），带withscores，可以让分数一起和值返回到结果集中。 zrangebyscore key minmax [withscores] [limit offset count] 返回有序集合key中，所有score值介于min和max之间（闭区间）的成员。有序集成员按score值递增次序排列 zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列 zincryby &lt;key&gt;&lt;increment&gt;&lt;value&gt; 为元素的score加上增量 zrem &lt;key&gt;&lt;value&gt; 删除该集合下，指定值的元素 zcount &lt;key&gt; &lt;min&gt; &lt;max&gt; 统计集合，分数区间内的元素个数 zrank &lt;key&gt; &lt;value&gt; 返回该值在集合中的排名，从0开始 案例：如何利用zset实现文章访问量的排行榜 数据结构SortedSet(Zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String,Double&gt;，可以给每个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表zset底层使用了两个数据结构 hash，hash的作用就是关联value和权重score，保障元素value的唯一性，通过元素value可以找到相应的score值 跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表Redis6的发布和订阅什么是发布和订阅Redis发布订阅(pub / sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。Redis客户端可以订阅任意数量的频道。Redis6新数据类型BitmapsHyperLogLogGeospatial Jedis操作Redis6","link":"/2021/06/10/%E6%8A%80%E6%9C%AF-Redis/"},{"title":"vue入门","text":"vue简介 JavaScript框架 简化Dom操作 响应式数据驱动 页面是由数据来生成的，数据改变，页面跟着改变 第一个Vue程序123456789101112131415161718&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; { {message} } &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=new Vue({ el:'#app', //#是id选择器 data:{ message:&quot;你好!&quot; } }) &lt;/script&gt;&lt;/body&gt; el:挂载点建议使用id选择器 只用用于双标签，但&lt;html&gt;和&lt;body&gt;除外，建议用于&lt;div&gt; data:数据对象1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;h2&gt;{ {person.name} }&lt;/h2&gt; &lt;h2&gt;{ {person.age} }&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;{ {subjects[0]} }&lt;/li&gt; &lt;li&gt;{ {subjects[1]} }&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', //#是id选择器 data:{ person:{ name:'余丰旭', age:22, }, subjects:['English','Math'] } }) &lt;/script&gt;&lt;/body&gt; 本地应用vue指令v-text v-text指令的作用是：设置标签的内容（textContent） 默认写法会替换全部内容，使用**差值表达式{ {} }**可以替换指定内容 内部支持写表达式 12345678910111213141516171819202122&lt;head&gt; &lt;title&gt;vue1111&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;h2 v-text=&quot;'message'+'!'&quot;&gt;大哥大&lt;/h2&gt; &lt;h2&gt;{ {info+'!'} }大哥大&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ message:'what', info:'how' } }) &lt;/script&gt;&lt;/body&gt; v-html 设置标签的innerHTML 123456789101112131415161718&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;p v-html='content'&gt;&lt;/p&gt; &lt;p v-text='content'&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ content:&quot;&lt;a href='https://www.baidu.com'&gt;百度官网&lt;/a&gt;&quot; } }) &lt;/script&gt;&lt;/body&gt; v-on 作用：为元素绑定事件 事件名不需要写on 指令可以简写为@ 绑定的方法定义在methods属性中 方法内部通过this关键字就可以访问定义在data中的数据 案例：计算器 知识点 创建Vue实例时：el（挂载点）,data（数据）,methods（方法） v-on指令的作用是绑定事件，简写为@ 方法中通过this，关键字获取data中的数据 v-text指令的作用是：设置元素的文本值，简写为{ {} } v-html指令的作用是：设置元素的innerHTML v-on补充 事件绑定的方法写成函数调用的形式，可以传入自定义参数 定义方法时需要定义形参来接收传入的实参 事件的后面跟上.修饰符可以对事件进行限制，如 @keyup.enter 回车按键松开 @keyup.left 左键松开 @keyup.right 右键松开 @keyup.up 上键松开 @keyup.down 下键松开 @keyup.delete 删除键松开 .enter可以限制触发的按键为回车 事件修饰符有多种 v-show 根据表达式的真假，让元素显示或者隐藏 v-if 和v-show基本相同 v-blind 修改属性 可以缩写为:属性= v-for 根据数据生成列表结构（响应式） 数组经常和v-for一起使用 语法是(item,index) in 数据 item和index可以结合其他指令一起使用 数组长度的更新会同步到页面上，是响应式的 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in arr&quot;&gt; 第{ {index} }个数:{ {item} } &lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;ol&gt; &lt;li v-for=&quot;(item,index) in objArr&quot;&gt; 第{ {index+1} }个人的名字是:{ {item.name} } &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ arr:[1,2,3,4,5], objArr:[ {name:'余丰旭'}, {name:'陈香玉'} ] } }) &lt;/script&gt;&lt;/body&gt; v-model 获取和设置表单元素的值（双向数据绑定） v-model指令的作用是便捷地设置和获取表单元素的值 绑定的数据会和表单元素值相关联 绑定的数据&lt;——&gt;表单元素的值 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;div id='app'&gt; &lt;input type=&quot;text&quot; v-model=&quot;textContent&quot; @keyup.enter='showMessage'&gt; &lt;br&gt; &lt;h2&gt;{ {textContent} }&lt;/h2&gt; &lt;br&gt; &lt;h2 v-text='textContent'&gt;&lt;/h2&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:&quot;#app&quot;, data:{ textContent:'你好鸭读研人~' }, methods:{ showMessage:function(){ alert(this.textContent) } } }) &lt;/script&gt;&lt;/body&gt; 案例：网页记事本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;head&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .item{ border:solid 1px black; width: 200px; } #calculator{ padding-left: 30%; border: 1px solid blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='calculator'&gt; &lt;h2 style=&quot;padding-left: 10%;&quot;&gt;在线记事本&lt;/h2&gt; &lt;input style=&quot;margin-left: 7%;&quot; type=&quot;text&quot; v-model=&quot;currentInput&quot; @keyup.enter=&quot;addItem(currentInput)&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in content&quot; class=&quot;item&quot;&gt; { {item} } &lt;button @click=&quot;deleteItem(index)&quot;&gt;x&lt;/button&gt; &lt;/li&gt; &lt;li style=&quot;font-size: small;&quot;&gt; 一共{ {content.length} }个项目 &lt;button @click=&quot;clearAll&quot;&gt;清空&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var calculator=new Vue({ el:'#calculator', data:{ content:[ '吃饭', '洗脸' ], currentInput:'请输入任务' }, methods:{ deleteItem:function(index){ // delete this.content.shift() this.content.splice(index,1) }, addItem:function(input){ this.content.push(input) }, clearAll:function(){ this.content=[] } } }) &lt;/script&gt;&lt;/body&gt; 网络应用 Vue结合网络数据开发应用 axios网络请求库 axios+vue axios基本使用 功能强大的网络请求库 axios必须先导入才能使用 使用get和post方法即可发送对应的请求 then方法中的回调函数会在请求成功或者失败时触发 通过回调函数的形参可以获取响应内容，或者错误信息 用法 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; axios.get(地址?查询字符串).then(function(response){},function(err){}) axios.post(地址,{key:value,key2:value2}).then(function(response){},function(err){}) 123456789101112131415161718192021222324252627&lt;head&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;get请求&quot; class='get'&gt; &lt;input type=&quot;button&quot; value=&quot;post请求&quot; class='post'&gt; &lt;script&gt; document.querySelector(&quot;.get&quot;).onclick=function(){ axios.get(&quot;https://autumnfish.cn/api/joke/list?num=6&quot;) .then(function(response){ console.log(response); },function(err){ console.log(err) }) } document.querySelector(&quot;.post&quot;).onclick=function(){ axios.post(&quot;https://autumnfish.cn/api/user/reg&quot;, {username:'jackandhisfriends'}) .then(function(response){ console.log(response) },function(err){ console.log(err) }) } &lt;/script&gt;&lt;/body&gt; axios+vue 网络应用的核心是：data中的一部分数据是从网络中获取的 保证编码在导入两个地址之后 坑 axios回调函数中的this已经改变，无法访问到data中的数据‘ 解决方法：把this保存起来，回调函数中直接使用保存的this即可 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='jokes'&gt; &lt;button @click=&quot;getJokes&quot;&gt;获取笑话&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in jokes&quot;&gt; { {item} } &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var jokes=new Vue({ el:'#jokes', data:{ jokes:[] }, methods:{ getJokes:function(){ var that=this; axios.get(&quot;https://autumnfish.cn/api/joke/list?num=3&quot;) .then(function(response){ that.jokes=response.data.jokes }) }, } }) &lt;/script&gt;&lt;/body&gt;","link":"/2020/03/10/%E6%8A%80%E6%9C%AF-vue%E5%85%A5%E9%97%A8/"},{"title":"github使用指南","text":"常见前后缀 找某项技术的百科大全：awesome xxx 如 awesome vue，点击第一个官方出品的，会展示vue相关的各种资源，包括教程，项目，相关等等。 总之，找某项知名技术，先搜awesome就对了 找例子：xxx sample 找空项目架子 xx starter 或者 xxx boilerplate 已经配置好的项目 找教程 xxx tutorial https://github.com/trending 根据热度查看项目","link":"/2020/01/10/%E9%9A%8F%E7%AC%94-github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"区块链溯源相关的问题与思考","text":"关于课题的想法2021/4/9今天去找了老师聊了一下，老俞的意思是说 主要是通过区块链，来保证大数据分发每个环节数据的真实性、不可篡改性； 当发生非法转发时，可以追溯到责任人； 授权访问、访问控制不是重点； 我的任务是在师姐搭好的平台上，实现相应的算法 跟师姐又聊了一下，师姐让我去看看MMR算法，默克尔山脉；提到了蚂蚁面试时问到了语言机、Oracle，另外面试官对大数据下的区块链溯源比较感兴趣。师姐让我把区块链平台搭好。 2021/3/10 什么是大数据分发？其模型是这样的吗？ 大数据分发和溯源平台是是公司内部使用，对员工或部分使用数据进行溯源？还是大众使用？还是说设计一套通用的。 大数据分发的溯源，溯的是什么源？（谁请求了这个数据，又转发给了谁，能否修改？） 重点在哪：是溯源，还是说大数据分发平台的构建和溯源同等重要？ 溯源的目的是什么？ 当数据发生泄漏时，快速定位泄露的环节和责任人。 还是说只负责溯源，具体的对溯源数据怎么使用，不是我的课题所关心的。 老俞的想法是，在一个大数据的环境下进行数据分发，比如授权A访问某项数据，并且A还可以转发给B（要能对这种转发的权限进行控制）。那么我要做的就是使数据被访问（涉不涉及到修改？）的路径可以被追溯。老俞还提到保护数据隐私（什么叫保护数据隐私？即没有授权的用户不能访问特定数据，或者转发给没有被授权的用户他不能访问？） 感觉百度云的分享模式再加个溯源就很符合老俞说的场景？ 我认为无法对转发进行限制（线下转发），只能是在系统内部进行转发时，加以记录然后溯源。 区块链原理相关问题 如何解决双花问题？ 双花问题指的是把一笔比特币同时转给A和B，那么我把这笔交易广播到全网，有的矿工M1会打包给A的这笔，有的矿工M2会打包B的这笔。甚至有的矿工会接收到这两笔交易，当然他如果将两笔交易同时打包在一个区块，会过不了合法性验证。M1、M2会将打包的区块发布到全网，最终哪种结果会生效，取决于哪个块在最长链上。对于其他所有节点来说，先收到M1的块，后续接收M2的块会导致分叉，至于他们认可哪个，取决于后续哪个块所在的链更长。 最长链，一般重要交易会等6个块确认 那我的问题来了，如果按照上述描述，M1的打包若是生效，M2的打包即其所耗费的大量算力就白费了，那么我作为一个普通的节点，我不是同时双花，而是同时十花、一百花、一千花、一万花，会不会导致全网算力的大幅浪费？从而导致短暂的全网算力下降？ 答案是不会，只会短暂产生大量分叉。我设想的场景是这样的，比如我把一笔钱同时转给10个人，那么就向全网广播了这10笔交易.矿工M1先收到的是我转给A，那么通过大量计算解出puzzle然后打包，剩下9个矿工分别先收到的是我转给B、C、D..的交易，都通过大量计算然后获得记账权然后打包。然后我想的是浪费了剩下九个人的算力。。如果同时转给一万个人，那么9999个人的算力都浪费了。不过答案是，算力本来就是用来浪费的，本来就只有一个人的结果才会成为最终共识的 区块链的不可篡改性，是对于共识的不可篡改，修改本地的区块，会导致其他节点对该节点的内容的不认可，从而导致该节点被提出共识圈子 区块链所指的不可篡改性，指的是区块链系统的共识不可篡改，而不是某个节点的内容不可篡改。 比特币使用POW的方法来实现共识，其共识是：大家都只认最长链上的块是合法的（前提是块通过了合法性验证）。 你给我转账，到底转没转，我只看最长链上有没有你给我转账的记录（需要等待6个块确认）。那在哪看呢？看自己本地的区块链吗？应该是的 那如果对方的这笔转账不向全网广播，只发送给我一个人，可以欺骗我吗？答案是不可以，因为只有交易不成块，我是不认的 那如果他挖出块，然后把给我转账的信息写入，然后只发给我，我会被欺骗吗？答案是不会，因为我会等待6个交易确认，那么他抢先在所有人之前连续挖出6个块的几率几乎为0，因为他的算力太小。","link":"/2021/03/19/%E9%9A%8F%E7%AC%94-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%BA%AF%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%9D%E8%80%83/"},{"title":"自建博客过程记录","text":"本博客采用hexo+gitee page+阿里云图床(阿里云对象存储oss)来建立的，主题选用的是基于hexo的icarus主题。一开始用的是hexo+githubpage，存在两个问题：1.博客部署在github部署和访问不稳定2.图片的使用和访问不方便。 建站过程 下载node.js、git等工具。进入在windows命令行 配置npm的国内源 12npm config set registry https://registry.npm.taobao.org #配置国内的镜像源npm info hexo # 测试查看hexo的安装信息，是否是taobao.org的源 安装hexo 12npm install -g hexo # 通过npm安装hexo# -g 指定全局安装，可以使用hexo命令 在自选的路径下，进行以下操作 123hexo init test # 初始化创建，会再桌面创建test文件夹cd test # 进入test目录npm install # 进一步安装hexo所需文件 hexo安装完成，启动hexo 123hexo clean # 清除所有记录hexo generate # 生成静态网页hexo server -p 80 # 在80端口启动服务，如果写-p xx 则在默认端口 浏览器访问localhost:端口号，可以查看博客当前的样子 主题配置：将下载的hexo主题（可以去github或者百度知乎上搜喜欢的）放在themes文件夹下，然后修改_config.yml配置文件 1theme: xxx # 这里与theme下主题文件夹的名称相同 在gitee中创建和用户名相同的仓库，然后修改_config.yml中的仓库url 123deploy: type: git repo: https://gitee.com/fxgood/fxgood # gitee的仓库地址 cd到博客根目录下，输入命令hexo generate &amp;&amp; hexo deploy 或者hexo g &amp;&amp;hexo d ，即可将博客部署到gitee page 阿里云购买域名，进行域名绑定 Typora绑定阿里云图床过程参考 https://zhuanlan.zhihu.com/p/138878534 注意事项 通过gitee page来建博客，仓库名一定要与gitee用户名一致，这样可以采用https://用户名.gitee.io/的方式来访问博客。 每次更新博客内容需要手动在gitee page上进行刷新（氪金会员据说可以自动刷新） hexo配置和主题配置，分别在_config.yml和_config.xxx主题名xx.yml中 写文章，就在source/_posts/下，可以再创建文件夹进行分类存放 生成文章摘要有两种方法 在文章中某一行添加&lt;-- more --&gt;，则该行以上的内容会作为摘要 在md文件开头添加属性excerpt:xxx内容填写摘要即可 添加代码实现文章首页顺序控制,修改node_modules/hexo-generator-index/lib/generator.js文件（没有top属性则比较日期，有则比较top大小，top越大文章在首页越靠前） 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';const pagination = require('hexo-pagination');const { sort } = require('timsort');module.exports = function(locals) { const config = this.config; const posts = locals.posts.sort(config.index_generator.order_by); //添加这一段 posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); //到此截止 sort(posts.data, (a, b) =&gt; (b.sticky || 0) - (a.sticky || 0)); const paginationDir = config.pagination_dir || 'page'; const path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 我在github和gitee都部署了我的博客，其中githubpage绑定了我阿里云买的域名fengxu.work。用git更新博客的时候，只需要修改_config.yml中的deploy下的repo地址。（因为github和gitee用户名和邮箱相同） hexo常用命令 注：首先要用cmd或者git来到本地博客根目录 hexo init初始化博客 hexo clean 刷新部署 hexo generate 更新博客内容后，需要重新生成 hexo deploy 部署到远程服务器上 hexo c &amp;&amp;hexo g &amp;&amp;hexo d 可以一键完成上述三个功能 文章常用yaml front matter title: xxx标题 category: 分类 tag: 标签 1234# 多个标签下tag:- 二叉树- 递归 excerpt: 文章摘要 updated: 2020-04-01 00:00:00 更新时间，（注意在_config.icarus.yml中article中可以设置update_time以实现控制) date: 2020-1-1 00:00:00 创建时间 top: num 根据num的大小，决定在首页的排列顺序，num越大优先级越高","link":"/2020/01/10/%E9%9A%8F%E7%AC%94-%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/"},{"title":"生成学习时间统计图表","text":"给女朋友做的学习时间统计柱状图，代码加以记录，以后方便复用 123456789101112131415import matplotlib.pyplot as plt# 这两行代码解决 plt 中文显示的问题plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = Falsedays = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]study_hours = [0,7,6.5,8,8.5,5,8,7,6.5,4,8,8,7,8.5,9,3,10,5.5,8,4,0,7.5,7,7.5,8,0,7.5,7.5,7,4,7.5]plt.bar(days, study_hours)plt.title('宝宝七月份学习时间统计')plt.ylabel('学习时间/h')plt.xlabel('日期')plt.show()","link":"/2021/06/02/%E9%9A%8F%E7%AC%94-%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8/"},{"title":"JavaScript","text":"JavaScript简介 概念：一门客户端脚本语言 运行在客户端浏览器中，每个浏览器都有javascript地解析引擎 脚本语言：无需编译，直接就可以被浏览器解析执行 功能： 可以来增强用户和html页面的交互。可以控制html元素，可以实现页面的动态效果，增强用户体验 JavaScript发展史 三足鼎立，略 ECMA（欧洲计算机制造商协会），制定出客户端脚本语言的标准：ECMAScript，统一了所有客户端脚本语言的编码方式 JavaScript=ECMAScript+JavaScript的（BOM+DOM) ECMAScript：客户端脚本语言的标准 ECMAScript基本语法 与html结合方式 内部JS 定义，标签体内容就是js代码 定义,通过src属性引入外部的js文件 &lt;script&gt;标签可以写在任意位置，但是影响加载顺序，一般放后面，否则会获取不到html对象 外部JS 注释 单行注释 // 多行注释 /* */ 数据类型 原始数据类型（基本数据类型） number：数字。 正数/小数/NaN（not a number） string：字符串。 字符/字符串 “abc” “a” ‘abc’ 没有字符的概念，不区分单双引号 boolean：true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值则会被默认赋值为undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而Javascript是弱类型语言，即申请空间时不规定类型 语法： var 变量名 = 初始化值； 12345678910111213&lt;script&gt; var a=1; var b=&quot;我是一句话&quot;; var c=NaN; var d=true; var e=null; var f=undefined; document.write(a+&quot;&lt;br&gt;&quot;); document.write(b+&quot;&lt;br&gt;&quot;); document.write(c+&quot;&lt;br&gt;&quot;); document.write(d+&quot;&lt;br&gt;&quot;); document.write(e+&quot;&lt;br&gt;&quot;); document.write(f+&quot;&lt;br&gt;&quot;);&lt;/script&gt; typeof 运算符可以查看变量类型 实际开发中不需要了解具体的类型，javascript是弱类型语言。但面试会问 运算符 跟java基本相同 多了一个===全等于符号，比较时先判断类型，类型不同直接返回false（javaScript在其他类型的运算符比较时，如果类型不同会先转换类型再比较） 注意：再JS中，如果运算数不是运算符所要求的类型，js引擎会自动将运算数进行类型转换 string转number，按照字面值转。如果字面值不是数字，则转为NaN类型 boolean转number，true转1，false转0 流程控制语句 和java相同 JS中，switch语句可以接受任意的原始数据 特殊语法 语句以;结尾，一行只有一个语句，可以省略（不推荐） 变量可以不使用var 用：定义的是局部变量 不用：定义的是全局变量（不建议在方法中不加var定义全局变量） 基本对象 Function对象：函数对象 创建 ```html//形参前面的var可以省略function fun1(a,b){alert(a+b); }12345* ```html var fun2=function(a,b){ alert(a+b); } 属性 length：代表形参个数 特点 方法定义中，形参的类型不用写，返回值类型也不写 方式是一个对象，如果定义名称相同的方法会覆盖 在JS中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数 Array：数组对象 创建 var arr=new Array(元素列表); var arr=new Array(默认长度); var arr=[元素列表] 方法 join()：将数组中的元素，按照指定的分隔符，拼接为字符串(默认是逗号) push()：类似java中的add(),向数组尾部添加1个或更多元素 其他的查看文档 属性 length 特点 JS中，数组元素的类型是可变的 JS中，数组长度可变（数组不会访问越界），会自动扩容 Date对象 创建 var date=new Date(); 方法 toLocalString()：以当地的使用习惯返回时间 getTime()：获取毫秒值。和1970年1月1日之间的毫秒值差 Math对象 创建： 特点：Math对象不用创建，直接使用 方法 Math.PI ：返回Π值 Math.random()：返回[0,1)之间的一个随机数 Math.ceil()：对数进行向上取整 Math.floor()：对数进行向下取整 Math.round()：四舍五入 属性 Math.PI：返回圆周率 Number String RegExp：正则表达式对象 正则表达式：定义字符串的组成规则 单个字符：[]。 如[a-z]表示a到z之间的一个字符 如[ab]表示a或者b [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符 \\d表示单个数字字符 \\w单个单词字符[a-zA-Z0-9_] 量词符号 *：表示0次或多次 ?：表示出现0次或1次 +：表示出现1次或多次 如\\w*表示一个字符串，由单个字符构成，出现0次或多次 {m,n}表示最多 m&lt;=数量&lt;=n \\w{6,12}长度为6到12的仅由单词字符组成的字符串 {,n}：m缺省表示最多n次 {m,}：最少m次 开始结束符号 ^：开始 $：结束 只用^表示以该正则开头，只用$表示以该正则结尾，^xxx$表示字符串须严格匹配正则 正则对象 创建 var reg=new RegExp(“正则表达式”) var reg=/正则表达式/ （不要加双引号） 方法 test(参数)：验证字符串是否符合正则表达式 ```html &lt;script&gt; var reg1=new RegExp(&quot;\\\\w{2,4}&quot;); var reg2=/\\w{0,4}/; /*使用test方法*/ var username=&quot;ab&quot;; document.write(reg2.test(username)); &lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263648. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用 2. 方法 * encodeURL():url编码 * decodeURL()：url解码 * encodeURLComponent()：url编码 * decodeURLComponent()：url节码 * **后面的两种，编码出来的字符更多** * parseInt()：将字符串转数字 * 逐一判断每个字符是否是数字，直到不是数字位置，将前边的数字部分转为number * isNaN（）：判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的比较结果全部为false * eval()：将字符串转为javaScript代码来执行# BOM## 简单学习1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象2. 组成 * Window：窗口对象 * 特点：不需要创建对象， window.方法名() 或直接写方法名() 如alert（） * 方法 * 与弹出框有关的方法 * alert()：弹出警告框 * confirm()：弹出确认框 * 用户点击确定，返回true * 用户点击取消，返回false * prompt():显示一个用户输入框，**现在不常用** * 与打开关闭有关的方法 * open()：返回一个新的window对象 * close()：谁调用，关闭谁 * ```html &lt;body&gt; &lt;input id=&quot;button1&quot; type=&quot;button&quot; value=&quot;点击以打开一个新的标签页&quot;&gt; &lt;input id=&quot;button2&quot; type=&quot;button&quot; value=&quot;点击以关闭当前的页面&quot;&gt; &lt;script&gt; var button1=document.getElementById(&quot;button1&quot;); var button2=document.getElementById(&quot;button2&quot;); var newWindow; button1.onclick=function () { newWindow=open(&quot;http://www.baidu.com&quot;); } button2.onclick=function () { if(newWindow==null) close(); else newWindow.close(); } &lt;/script&gt; &lt;/body&gt; 与定时器相关的方法 setTimeout()：在指定毫秒值之后执行事件 第一个参数：js代码或方法对象 毫秒值 返回值：唯一标识，用于取消定时器 12345678910111213141516&lt;script&gt; //setTimeout(&quot;f();&quot;,1000); /* setTimeout(f,1000); function f() { alert(&quot;1秒中过去了&quot;) }*/ var id=setInterval(f1,1000); var i=1; function f1() { if(i&lt;=3) document.write(&quot;第&quot;+(i++)+&quot;秒...&lt;br&gt;&quot;); else clearInterval(id); }&lt;/script&gt; clearTimeout()：取消由setTimeout（）方法设置的timeout setInterval()：循环执行的定时器 clearInterval():取消之 属性 获取其他BOM对象 history location navigator screen 获取DOM对象 document Navigator：浏览器对象 不讲解 Screen：显示器屏幕对象 不讲解 History：当前页面历史记录对象 创建 window.history 或省略window 方法 back()：加载history列表中的前一个url forward（）：加载history列表中的下一个url go()：加载history列表中的某个具体页面 参数为正数，前进n个历史记录 参数为负数，后退n个历史记录 属性 length：返回当前窗口历史列表中的url数量 Location：地址栏对象 创建：window.location （可以省略window） 方法 reload()：刷新 属性 href 设置或返回完整的url（可以用来跳转网页） 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;倒计时跳转&lt;/title&gt; &lt;style&gt; p{ text-align: center; } span{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;span id=&quot;time&quot;&gt;5&lt;/span&gt;秒之后跳转 &lt;/p&gt;&lt;script&gt; var n=4; var time=document.getElementById(&quot;time&quot;); function f1() { if(n&gt;=1) time.innerHTML=n--; else location.href=&quot;http://www.baidu.com&quot;; } setInterval(f1,1000);&lt;/script&gt;&lt;/body&gt; DOM简单学习 DOM：Document Object Model 文档对象模型 将标记语言文档的各个组成部分封装为对象，对标记语言文档进行CRUD的动态操作 功能：控制html文档的内容 即增删改查 代码：获取页面的标签（元素）对象 Element document.getElementById(“id值”)：通过元素的id获取元素对象 记得加双引号 操作对象 设置其属性 明确获取的对象是哪一个 查看API文档，找其中有哪些属性可以设置 修改标签体内容 属性：innerHTML 事件的简单学习 功能：某些组件被执行了某些操作后，触发某些代码的执行 如何绑定事件 直接在html标签上，指定事件的属性（操作），属性就是js代码 事件：onclick：单击事件 通过js获取元素对象，指定事件属性，设置一个函数 ```htmlfunction f1() { alert(&quot;我被点了&quot;); } var img1=document.getElementById(&quot;img1&quot;); img1.onclick = f1; 123456789101112131415161718192021222324 * **注意调用函数的时候不加括号，因为他是一个对象*** 案例 ```html &lt;body&gt; &lt;img src=&quot;../img/future.jpg&quot; id=&quot;img1&quot;&gt; &lt;script&gt; var img1=document.getElementById(&quot;img1&quot;); var flag=true; img1.onclick=function () { if(flag){ img1.src=&quot;../img/验证码1.png&quot;; flag=false; } else{ img1.src=&quot;../img/future.jpg&quot;; flag=true; } } &lt;/script&gt; &lt;/body&gt; DOM对象W3C DOM 标准被分为3个不同的部分 核心DOM Node对象 是其他5个的父对象 所有的dom对象都可以认为是一个Node（节点） 方法： CRUD dom树 appendChild()：向节点的子节点列表的尾部添加新的子节点 removeChild()：删除（并返回）当前节点的指定子节点 replaceChild()：用新节点替换一个子节点 属性 parentNode：返回当前节点的父节点 Document：文档对象 创建：可以用window对象来获取 window.document 直接document 方法 获取Element对象 getElementById() getElementsByTagName()：根据元素名称获取元素对象们。返回的是数组 getElementsByClassName()：根据class属性值来获取元素对象们 getElementsByName()：根据name属性值来获取元素们 创建其他的DOM对象 createElement() createAttribute(name) （如table） 属性 Element：元素对象 通过document来获取和创建 方法 removeAttribute():删除属性 setAttribute()：设置属性 Attribute：属性对象 Text：文本对象 Comment：注释对象 XML DOM HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 第一种方式 div1.style.border=&quot;solid red 1px&quot;; 遇到类似font-size的则改写为fontSizediv1.style.fontSize=&quot;20px&quot;; 第二种方式：通过控制className在CSS中控制样式 动态删除添加表格 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table{ margin:auto; width: 500px; } div{ margin: 50px; text-align: center; } th,td{ text-align: center; border: 1px solid; border-radius: 5px; } .btn{ text-align: center; border: 1px solid; border-radius: 5px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;编号&quot;&gt; &lt;input id=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot;&gt; &lt;input id=&quot;input3&quot; type=&quot;text&quot; placeholder=&quot;性别&quot;&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;&gt;&lt;/div&gt;&lt;table id=&quot;table&quot;&gt; &lt;tr id=&quot;tr1&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; /*发生错误时，浏览器F12 console查找错误*/ //1.获取输入内容 document.getElementById(&quot;btn1&quot;).onclick=function () { var code=document.getElementById(&quot;input1&quot;).value; var name=document.getElementById(&quot;input2&quot;).value; var gender=document.getElementById(&quot;input3&quot;).value; //获取table var table=document.getElementById(&quot;table&quot;); //创建三个td var td_code=document.createElement(&quot;td&quot;); var textNode_code=document.createTextNode(code); td_code.appendChild(textNode_code); var td_name=document.createElement(&quot;td&quot;); var textNode_name=document.createTextNode(name); td_name.appendChild(textNode_name); var td_gender=document.createElement(&quot;td&quot;); var textNode_gender=document.createTextNode(gender); td_gender.appendChild(textNode_gender); //创建一个tr var tr=document.createElement(&quot;tr&quot;); tr.appendChild(td_code); tr.appendChild(td_name); tr.appendChild(td_gender); //创建一个删除按钮 var btn_delete=document.createElement(&quot;input&quot;); btn_delete.setAttribute(&quot;type&quot;,&quot;button&quot;); btn_delete.setAttribute(&quot;value&quot;,&quot;删除&quot;); btn_delete.setAttribute(&quot;class&quot;,&quot;btn&quot;); btn_delete.onclick=function () { //删除本行 tr table.removeChild(tr); } tr.appendChild(btn_delete); //将tr放入表格 table.appendChild(tr); } //2.添加到表中 //3.删除按钮&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例动态删除添加表格_innerHTML简化版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table{ margin:auto; width: 500px; } div{ margin: 50px; text-align: center; } th,td{ text-align: center; border: 1px solid; border-radius: 5px; } .btn{ text-align: center; border: 1px solid red; border-radius: 5px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;编号&quot;&gt; &lt;input id=&quot;input2&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot;&gt; &lt;input id=&quot;input3&quot; type=&quot;text&quot; placeholder=&quot;性别&quot;&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;&gt;&lt;/div&gt;&lt;table id=&quot;table&quot;&gt; &lt;tr id=&quot;tr1&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; /*发生错误时，浏览器F12 console查找错误*/ //1.获取输入内容 function del(obj){ var table=obj.parentNode.parentNode.parentNode; var tr=obj.parentNode.parentNode; table.removeChild(tr); } document.getElementById(&quot;btn1&quot;).onclick=function () { var code=document.getElementById(&quot;input1&quot;).value; var name=document.getElementById(&quot;input2&quot;).value; var gender=document.getElementById(&quot;input3&quot;).value; var table=document.getElementById(&quot;table&quot;); table.innerHTML+=&quot;&lt;tr&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+code+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+name+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+gender+&quot;&lt;/td&gt;\\n&quot; + &quot; &lt;td&gt;&lt;a href='javascript:void(0);'onclick='del(this)' &gt;删除&lt;/td&gt;\\n&quot; + &quot; &lt;/tr&gt;&quot; } //2.添加到表中 //3.删除按钮&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/09/10/%E6%8A%80%E6%9C%AF-Javascrpit/"},{"title":"cookie&amp;session&amp;jsp","text":"会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围的多次请求间内共享数据 方式 客户端会话技术:cookie 数据存在客户端 服务器端会话技术:session 数据存在服务器端 Cookie 概念：客户端会话技术，将数据保存到客户端 快速入门 使用步骤 创建（API）Cookie对象，绑定数据 new Cookie(String name,String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() Cookie实现原理基于响应头set-Cookie和请求头cookie实现 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AAhdofVS-1589287359257)(会话技术cookie&amp;session&amp;JSP.assets/image-20200505183236228.png)] Cookie的细节 一次可不可以发送多个Cookie？ 可以 可以创建多个cookie对象，使用response调用多次addCookie发送cookie即可 Cookie在浏览器中保存多长时间？ 默认情况下，浏览器关闭后，cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：持久化将Cookie数据写到硬盘的文件中。代表cookie存活时间 负数：默认情况 0：删除cookie信息 cookie能不能存中文？ 在tomcat8之前，cookie中不能直接存储中文数据 需要将中文数据转码，一般采用URL编码（如%E3） 在tomcat8及之后，cookie支持中文数据。特殊字符还是不支持（如空格），建议使用URL编码存储，URL解码 cookie获取的范围是多大？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中，cookie能不能共享？ 默认情况下，cookie不能共享 setPath(String path)：设置cookie的获取范围。默认情况下，设置当前的虚拟目录 设置setPath(“/“) 即可实现多个web项目之间的cookie共享 不同的tomcat服务器间cookie共享问题？ setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie之间可以共享 setDomain(“.baidu.com”)，那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 Cookie存储数据在客户端浏览器，不安全 浏览器对于单个cookie大小有限制，以及同一个域名下的总cookie数量有限制（20个以内） 作用 cookie一般用于存储少量不敏感数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问的时间 需求 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问 如果不是第一次访问，则提示：欢迎回来，您上一次访问时间为：显示时间字符串 分析： 可以用Cookie完成 在服务器的Servlet中判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：您好，欢迎回来，您上次访问的时间为：xxxx 写回cookie 没有：是第一次访问 响应数据：您好，欢迎首次访问 写回Cookie：lastTime=xxx 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445@WebServlet(&quot;/rememberLastTimeAccess&quot;)public class rememberLastTimeAccess extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //获取cookie Cookie[] cookies = request.getCookies(); boolean flag=true; if(cookies!=null&amp;&amp;cookies.length&gt;0){ for(Cookie c:cookies){ if(&quot;lastTime&quot;.equals(c.getName())){ flag=false; //有该cookie表示不是第一次访问 String value = c.getValue(); String decode = URLDecoder.decode(value,&quot;utf-8&quot;); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次的访问时间：&quot;+decode+&quot;&lt;/h1&gt;&quot;); //获取当前时间的字符串，重新设置cookie的值 Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年mm月dd日 HH:mm:ss&quot;).format(date); //string中有空格，cookie不支持，故进行URL编码 String encode = URLEncoder.encode(time, &quot;utf-8&quot;); c.setValue(encode); //设置cookie存活时间 c.setMaxAge(3600*24*30); //存储一个月 response.addCookie(c);//会覆盖原来的值 break; } } } if(cookies==null||cookies.length==0||flag) { response.getWriter().write(&quot;&lt;h1&gt;欢迎您，首次访问！&lt;/h1&gt;&quot;); Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); String encode = URLEncoder.encode(time, &quot;utf-8&quot;); Cookie cookie=new Cookie(&quot;lastTime&quot;,encode); cookie.setMaxAge(3600*24*30); response.addCookie(cookie); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中（HttpSession） 快速入门 HttpSession对象 获取session对象 request.getSession() 使用 getAttribute(String name) setAttribute(String name,Object value) removeAttribute() 原理 服务器如何确保在一次会话范围内，多次获取的session对象是同一个？ Session是依赖于Cookie的（相当于把数据存在服务器，把这份数据的id通过cookie存在客户端浏览器） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zzUpGT0d-1589287359260)(会话技术cookie&amp;session&amp;JSP.assets/image-20200506102119056.png)] 细节 当客户端关闭后，服务器不关闭，两次session是否为同一个？ 默认情况下：不是（请求头中没有cookie记录） 如果需要相同，则可以创建Cookie，键设置为JSESSIONID，值为获取到的session的id，设置最大存活时间，让cookie持久化保存 12Cookie cookie=new Cookie(&quot;JSESSIONID&quot;,session.getId());response.addCookie(cookie); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失（Tomcat已帮我们自动完成，必须用本地的tomcat服务器启动才能实现，idea中部署tomcat服务器无法完成） Session的钝化 在服务器正常关闭之前，将Session对象序列化到硬盘上 Session的活化 在服务器启动后将session文件转化为内存中的Session对象即可 Session的默认失效时间？ 服务器关闭 session对象调用invalidate（） session默认失效时间是30分钟 可以在tomcat/conf/web.xml的 &lt;session-config&gt;中设置 特点 session用于存储一次会话的多次请求间的数据，存储在服务器端 session可以存储任意类型，任意大小的数据 session与cookie的区别 session在服务器端存储数据，cookie存在客户端 session可以存储任意数据类型，没有数据大小限制，cookie只能存储字符串，有大小限制 session比较安全，cookie相对不安全 案例：验证码JSP入门学习 概念：Java Server Pages：java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写 原理[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7V2NgSrk-1589287359261)(会话技术cookie&amp;session&amp;JSP.assets/image-20200505214202822.png)] 本质：JSP本质是一个Servlet JSP的脚本：JSP定义Java代码的方式 &lt;%java代码%&gt;：定义的java代码在Service方法中。service方法中可以定义什么，该脚本中就可以定义什么 &lt;%! java代码%&gt;：定义成员（成员变量，成员方法） &lt;%=java代码%&gt;：会将内容输出到页面中 jsp的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象 常用的3个 request response out：字符输出流对象，可以将数据输出到页面上。和response.getWriter()类似 tomcat服务器真正给客户端做出响应之前，会先找到response缓冲区数据，再找out缓冲区数据 response.getWriter().write()数据输出永远在out.write()之前 案例：改造cookie案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page import=&quot;java.net.URLDecoder&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%@ page import=&quot;java.text.SimpleDateFormat&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //获取cookie Cookie[] cookies = request.getCookies(); boolean flag=true; if(cookies!=null&amp;&amp;cookies.length&gt;0){ for(Cookie c:cookies){ if(&quot;lastTime&quot;.equals(c.getName())){ flag=false; //有该cookie表示不是第一次访问 String value = c.getValue(); String decode = URLDecoder.decode(value,&quot;utf-8&quot;);%&gt; &lt;h1&gt;欢迎回来，您上次的访问时间：&lt;%=decode%&gt;&lt;/h1&gt; &lt;% //获取当前时间的字符串，重新设置cookie的值 Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); //string中有空格，cookie不支持，故进行URL编码 String encode = URLEncoder.encode(time, &quot;utf-8&quot;); c.setValue(encode); //设置cookie存活时间 c.setMaxAge(3600*24*30); //存储一个月 response.addCookie(c);//会覆盖原来的值 break; } } } if(cookies==null||cookies.length==0||flag) {%&gt; &lt;h1&gt;欢迎您，首次访问！&lt;/h1&gt; &lt;% Date date=new Date(); String time = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(date); String encode = URLEncoder.encode(time, &quot;utf-8&quot;); Cookie cookie=new Cookie(&quot;lastTime&quot;,encode); cookie.setMaxAge(3600*24*30); response.addCookie(cookie); } %&gt; &lt;/body&gt;&lt;/html&gt; 指令 作用：用于配置JSP页面，导入资源文件 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ...%&gt; 分类 page：配置jsp页面 contentType：等同于response.setContentType() 设置响应体的mime类型和字符集 设置当前jsp页面的编码（只能是高级IDE才能生效，如果使用记事本开发则需要设置pageEncoing来设置当前页面的字符集编码） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：表示当前页面是否是错误也弥漫 true：可以使用内置对象exception false：默认值。不可以使用内置对象exception include：用不到。导入页面的资源文件 taglib：导入资源（一般用于导入标签库） ```java&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 * prefix：自定义的前缀## 注释1. html注释`&lt;!-- --&gt;`只能注释html代码片段2. （**推荐使用**）jsp注释：`&lt;%-- --%&gt;`可以注释所有## 内置对象* 在jsp页面中不需要创建，直接使用的对象* 一共有9个 * 四个域对象 * pageContext * 范围：当前页面共享数据 * 可以获取其他8个对象 * request * 一次请求内共享数据 * session * 一次会话的多个请求间共享数据 * application * 所有用户间共享数据 *** * response * 响应对象 * page * 当前页面（Servlet）的对象 this * out * 输出对象，可以把数据输出到页面上 * config * Servlet的配置对象 * exception * 异常对象# MVC：开发模式* jsp演变历史 1. 早期只有Servlet，只能使用response输出标签数据，非常麻烦 2. 后来有jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中既写大量的java代码，又写html标签，造成难以维护难以分工 3. 再后来，java的web开发借鉴了mvc开发模式使得程序的设计更加合理* MVC： * Model：模型 * 完成具体的业务操作，如：查询数据库，封装对象 * **使用JavaBean来充当** * View：视图 * 展示数据 * **使用JSP来充当** * Controller：控制器 * 获取用户的输入 * 调用模型 * 将模型返回的数据，交给视图进行展示 * **使用Servlet来充当** * 优点 * 耦合性低，方便维护，利于分工协作 * 重用性高 * 缺点 * 使得项目架构变得复杂，对开发人员要求高 * 不适合小型项目 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bkaXsHDs-1589287359265)(会话技术cookie&amp;session&amp;JSP.assets/image-20200506140632847.png)]# EL表达式1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：`${表达式}`4. 注意： * jsp默认支持el表达式 * `&lt;%@ page isELIgnored=&quot;true&quot;%&gt;` ：设置页面忽略EL表达式 * 加转义符`\\`反斜杠：忽略当前这个EL表达式5. 作用 1. 运算 * 运算符： 1. 算数运算符：+,-,*,/(div),%(mod) 2. 比较运算符 3. 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 4. 空运算符：empty * 功能：用于判断字符串，集合，数组对象是否为null并且长度是否为0 * `${empty list}` list为空或者长度为0，则该表达式返回true * `${not empty xxx}`：判断字符串、集合、数组对象是否不为null且长度&gt;0 2. 获取值 1. **el表达式只能从域对象中获取值** 2. 语法 1. `${域名称.键名}`：从指定域中获取指定键的值 * 域名称： 1. pageScope ——&gt; pageContext 2. requestScope ——&gt; request 3. sessionScope ——&gt; session 4. applicationScope ——&gt; application (ServletContext) * 举例：在request域中存储了name=张三 2. `${键名}`：表示**依次从最小的域**中查找是否有该键对应的值，直到找到为止 3. 获取对象，List集合，Map集合的值 1. 对象：${域名称.键名.属性名} * **本质上会去调用对象的get方法** ```java public class User { private String name; private int age; private Date date; //逻辑视图 public String getBirthday(){ if(date==null) return &quot;&quot;; return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(date); } 1234567891011&lt;% User user=new User(); user.setName(&quot;余丰旭&quot;); user.setAge(22); Date mydate = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1997-12-29&quot;); user.setDate(mydate); request.setAttribute(&quot;user1&quot;,user);%&gt;${user1.name}&lt;br&gt;${user1.age}&lt;br&gt;${user1.birthday}&lt;br&gt; //直接按照getBirthday()方法的返回值打印 2. List集合： * `${域名称.键名}` 域名可省略（**依次从最小的域**中查找是否有该键对应的值，直到找到为止） * ``${域名称.键名[索引]}` 如果索引越界，则什么都不显示 3. Map集合 * `${域名称.键名.key名称}` 域名可省略 * `${域名称.键名[&quot;key名称&quot;]}` 123456789&lt;%Map map=new HashMap();map.put(&quot;name&quot;,&quot;丰旭&quot;);map.put(&quot;user&quot;,user);request.setAttribute(&quot;map&quot;,map);%&gt;${map.name}&lt;br&gt;${map.user.name}&lt;br&gt;${map.user.birthday}&lt;br&gt; 隐式对象 作用：例如，如果想在jsp页面的html中的一个字符串中表示post或get方式提交过来的内容，则必须使用request.getParameter()方法，但是字符串中无法调用，只能用EL表达式先通过pageContext获取requst对象 el表达式中有11个隐式对象 pageContext: 获取jsp其他8个对象 如动态获取虚拟目录：${pageContext.request.contextPath} 用于路径的编写 JSTL标签 概念：JavaServer Pages Tag Libray JSP标准标签库 是由apache组织提供的开源的免费的jsp标签 作用：用于简化和替换jsp页面上的java代码 使用步骤 导入jar包 jsp页面引入标签库：&lt;%taglib prefix= url=%&gt; 使用标签 if 相当于java的if语句 属性： test 必须属性，接收boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示 一般情况下，test属性会综合el表达式一起使用 注意：c:if标签没有else情况，需要再定义if标签 1234&lt;h1&gt;判断数字是否为偶数&lt;/h1&gt;&lt;c:if test=&quot;${num%2==0}&quot;&gt; ${num}是偶数&lt;/c:if&gt; choose 相当于java的switch语句 12345678910111213&lt;% request.setAttribute(&quot;num&quot;,8);%&gt;&lt;c:choose &gt; &lt;c:when test=&quot;${num==1}&quot;&gt;星期一&lt;/c:when&gt; &lt;c:when test=&quot;${num==2}&quot;&gt;星期二&lt;/c:when&gt; &lt;c:when test=&quot;${num==3}&quot;&gt;星期三&lt;/c:when&gt; &lt;c:when test=&quot;${num==4}&quot;&gt;星期四&lt;/c:when&gt; &lt;c:when test=&quot;${num==5}&quot;&gt;星期五&lt;/c:when&gt; &lt;c:when test=&quot;${num==6}&quot;&gt;星期六&lt;/c:when&gt; &lt;c:when test=&quot;${num==7}&quot;&gt;星期日&lt;/c:when&gt; &lt;c:otherwise&gt;输入数字有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; foreach 相当于java的for语句 完成重复的操作 属性 begin：开始值 end：结束值（包含） var：临时变量 step：步长 varStatus：循环状态 123&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;1&quot; varStatus=&quot;status&quot;&gt; i的值：${i} 循环序号${status.index} 循环的总数${status.count} &lt;br&gt;&lt;/c:forEach&gt; 遍历容器 属性 items：容器对象 var：容器中元素的临时变量 123456789101112&lt;% List list=new ArrayList(); list.add(1); list.add(&quot;bb&quot;); list.add(&quot;ccc&quot;); request.setAttribute(&quot;list&quot;,list);%&gt;&lt;c:forEach items=&quot;${list}&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; ${s.index} ${s.count} ${str} &lt;br&gt;&lt;/c:forEach&gt; 练习 需求：再request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中。并实现table中奇数行和偶数行颜色不同 &lt;% List list=new ArrayList(); User user1=new User(); User user2=new User(); User user3=new User(); //User user3=new User(); user1.setName(&quot;余丰旭&quot;); user2.setName(&quot;陈香玉&quot;); user3.setName(&quot;小小余&quot;); user1.setAge(22); user2.setAge(24); user3.setAge(0); user1.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1997-12-29&quot;)); user2.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1995-11-25&quot;)); user3.setDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2026-1-1&quot;)); list.add(user1); list.add(user2); list.add(user3); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;table class=&quot;t1&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;c:if test=&quot;${not empty list}&quot;&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;u&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count%2==0}&quot;&gt; &lt;tr bgcolor=&quot;yellow&quot;&gt; &lt;td&gt;${u.name}&lt;/td&gt; &lt;td&gt;${u.age}&lt;/td&gt; &lt;td&gt;${u.birthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;c:if test=&quot;${status.count%2!=0}&quot;&gt; &lt;tr bgcolor=&quot;#ffc0cb&quot;&gt; &lt;td&gt;${u.name}&lt;/td&gt; &lt;td&gt;${u.age}&lt;/td&gt; &lt;td&gt;${u.birthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/c:if&gt; &lt;/table&gt; 三层架构：软件设计架构 界面层（表示层）：用户看到的界面，用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑（如登录，注册） 数据访问层：操作数据存储文件（如数据库、xml中） [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gsBaNMGW-1589287359267)(会话技术cookie&amp;session&amp;JSP.assets/image-20200507120117672.png)] 案例：用户信息列表展示 需求：用户信息的增删改查 设计： 技术选型：Servlet+JSP+MySQL+JDBCTemplate+Druid+BeanUtils+tomcat 数据库设计： 开发 环境搭建 创建数据库环境 创建项目，导入需要的jar包 编码 测试 部署运维 综合练习 简单功能 列表查询 登录 添加 删除 修改 复杂功能 删除选中 分页查询 复杂的条件查询，带有分页效果 登录功能 调整页面，加入验证码功能","link":"/2020/05/12/%E6%8A%80%E6%9C%AF-cookie-session-jsp/"},{"title":"HTML与CSS学习笔记","text":"JavaWeb概述 JavaWeb 使用Java开发的基于互联网的项目 软件架构 B/S C/S B/S架构详解 静态资源：使用静态网页开发技术发布的资源 特点： 所有用户访问，得到的结果相同 如：文本、图片、视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，服务器会直接将静态资源发送给浏览器，浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源：使用动态网页技术即时发布的资源 特点： 所有用户访问，得到的结果可能不同 如：jsp/servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转化为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源 静态资源： HTML：用于搭建基础网页，用于展示页面内容 CSS：用于美化页面，布局页面 JavaScript（盲猜做业务流用不到）：控制页面元素，让页面有一些动态效果 HTMLHTML基础1.概念：是最基础的网页开发语言 超文本：用超链接的方法，把不同空间的文字信息组织在一起的网状文本 标记语言：由标签构成的语言 2.快速入门 语法： html文档后缀.html 或.htm 标签分为 围堵标签：如 自闭和标签：开始标签和结束标签在一起，如 标签可以嵌套 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来 html标签不区分大小写，建议小写 3.标签（在帮助文档里可以查到具体的） 文件标签：构成html最基本的标签 html：html文档的根标签 head： 头标签。用于指定html文档的一些属性。引入外部资源 title：标题标签 body：体标签 ：html5中定义该文档是html文档 文本标签：和文本有关的标签 &lt;!– –&gt; ：注释 &lt;h1&gt; to &lt;h6&gt; ：标题标签 &lt;p&gt;：段落标签 （paragraph段落） &lt;br&gt;：换行标签 &lt;hr/&gt;:显示一条水平线 （自闭和标签）（horizontal rule 水平分割线） &lt;hr color=’red’ width=’200’ size=’10’ align=”left”/&gt; 可以设置属性来改变样式，不过了解即可，html5不推荐使用，后面会用CSS &lt;b&gt;:字体加粗 &lt;i&gt;：字体斜体 &lt;font&gt;：字体标签 不推荐使用，已废弃 图片标签： &lt;img/&gt;：自闭和标签，展示图片 只需记得src给出图片路径即可 相对路径 ./代表当前路径 可以省略 ../表示上一级目录 &lt;img src=&quot;image/timg.jpg&quot; align=&quot;right&quot; alt=&quot;美丽的风景&quot;/&gt; alt代表图片加载失败时显示的文字 列表标签： 有序列表 ol:(order list) li: 1234567//type省略默认按123..排序//start决定从什么开始数&lt;ol type=&quot;a&quot; start='3'&gt; &lt;li&gt;起床&lt;/li&gt; &lt;li&gt;刷牙&lt;/li&gt; &lt;li&gt;吃饭&lt;/li&gt; &lt;/ol&gt; 无序列表 ul：可以修改type li 链接标签： a：定义一个超链接 1&lt;a href=&quot;http://www.baidu.com&quot;&gt;点我 &lt;/a&gt; href：指定URL（统一资源定位符） target：-self指在本页面打开 _blank指在一个新的页面打开 可以用&lt;a&gt;标签包裹图片 div和span标签（了解，将来和CSS结合） span：文本信息在一行展示，行内标签 div：每一个div占满一整行，会自动换行。块级标签 语义化标签：html5中为了提高程序的可读性，提供了一些标签，结合CSS一起使用 header footer 表格标签 table：定义表格 一下属性html5基本都已废弃，改用CSS控制 width： border： cellpadding：定义内容与单元格之间的距离 cellspacing：定义单元格之间的距离，0则会变为线 bgcolor：背景色 tr：定义行 bgcolor：背景色 align：内部文本对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 caption：定义表格标题 thead：表示表格的头部分 tbody：表示表格的体部分 tfoot：表示表格的脚部分 html表单标签表单：用于采集用户输入的数据的。用于和服务器进行交互 使用的标签：form 可以定义一个范围，范围代表采集用户数据的范围 属性 action：指定提交数据的URL method：指定提交方式 get： 请求参数会在地址栏中显示。会封装到请求行中 请求参数长度有限制 不安全 post： 请求参数不会在地址栏中显示，会封装在请求体中（http协议） 请求参数的大小没有限制 较为安全 表单中的数据要想被提交，必须指定其name属性 例： 12345&lt;form action=&quot;###&quot; method=&quot;get&quot;&gt; 用户名：&lt;input name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 表单项标签 input：可以通过type属性值，改变元素展示的样式 type属性 text placeholder：指定输入框提示信息 password radio：单选框 注意：要想使多个单选框实现单选，他们的name必须相同 一般会给每个radio提供value值，指定其被选中后提交的值 checked，可以指定默认值 checkbox：复选框 checked，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息 按钮 submit：提交 button: 配合javascript使用的按钮 image：图片提交按钮 （src指定图片路径） label：指定输入项的文字描述信息 注意：label的for属性一般和input的id属性值对应。对应后点击label区域，会让input输入框获取焦点 select：下拉列表 option：指定列表项 textarea：文本域 cols：指定列数，每一行有多少字符 rows：默认多少行 案例 1234567891011121314151617181920212223&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;get&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;game&quot;&gt; 打游戏 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;learning&quot; checked&gt; 学习 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sports&quot;&gt; 运动 &lt;br&gt; 取色器：&lt;input type=&quot;color&quot; name=&quot;color&quot;&gt;&lt;br&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt;&lt;br&gt; 籍贯：&lt;select name=&quot;homecity&quot;&gt; &lt;option&gt;请选择&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;南京&lt;/option&gt; &lt;/select&gt;&lt;br&gt; 自我介绍：&lt;br&gt;&lt;textarea name=&quot;selfIntroduction&quot; rows=&quot;3&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt; 案例2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;!--定义表单--&gt; &lt;form action=&quot;###&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;500&quot;&gt; &lt;!--第一行--&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第二行--&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第三行--&gt; &lt;tr&gt; &lt;td&gt;Email&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;邮件&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第四行--&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第五行--&gt; &lt;tr&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;phoneNum&quot; placeholder=&quot;手机号码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第六行--&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;!--第七行--&gt; &lt;tr&gt; &lt;td&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第八行--&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;vcode&quot; placeholder=&quot;验证码&quot;&gt; &lt;img src=&quot;../image/验证码.jpg&quot; align=&quot;right&quot; width=&quot;150&quot; height=&quot;50&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--注册按钮--&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt; CSS基本概念 概念 CSS：页面美化和布局控制 Cascading style sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 使用CSS的好处 功能强大 将内容展示和样式控制分离 降低耦合度，解耦 让分工协作更容易， 可以提高开发效率 CSS与html结合方式内联样式 标签内使用style属性指定css代码 如&lt;div style=&quot;color: crimson&quot;&gt;IloveYoubaby&lt;/div&gt; 未实现内容与样式的分离，不推荐使用 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 ```html Title div{ color: blue; } Legionwhat's up? 1234567891011121314151617* 缺点：如上所有div使用同一的样式### 外部样式* 定义css资源文件* 在head标签内，定义link标签，引入外部的资源文件```html&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../CSS资源/a.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;计算机专硕复试&lt;/div&gt;&lt;/body&gt; 1234//css资源文件div{ color: green;} 小结 1方式不常用，后期常用2，3 第三种格式引入css资源还可以携程 123&lt;style&gt; @import &quot;##css位置##&quot;&lt;/style&gt; CSS基本语法格式12345选择器{ 属性名1:属性值; 属性名2:属性值; ...} 选择器：筛选具有相似特征的元素 注意：每一对属性需要使用;分开，最后一对可以不用 选择器分类： 基础选择器 id选择器：建议在一个html页面中id值唯一 12345678910111213141516&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #d1{ color: crimson; } #d2{ color: aqua; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;d1&quot;&gt;我是第一行&lt;/div&gt; &lt;div id=&quot;d2&quot;&gt;我是第二行&lt;/div&gt;&lt;/body&gt; 元素选择器：选择具有相同标签名称的元素（id选择器的优先级更高，会覆盖元素选择器） 12345678910111213&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ color: aquamarine; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是第一行&lt;/div&gt; &lt;div&gt;我是第二行&lt;/div&gt;&lt;/body&gt; 类选择器：选择具有相同class属性值的元素 语法：.class属性值{} 注意：优先级：id选择器&gt;类选择器&gt;元素选择器 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .c1{ color: crimson; } .c2{ color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;c1&quot;&gt; 这是第一段 &lt;/p&gt; &lt;div class=&quot;c2&quot;&gt;这是一行&lt;/div&gt; &lt;div class=&quot;c1&quot;&gt;这是二行&lt;/div&gt;&lt;/body&gt; 扩展选择器 *：选择所有元素 并集选择器： 语法：选择器1，选择器2{ } 子选择器：筛选选择器1元素下的选择器2元素 语法：选择器1 选择器2{ } 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div p{ color: crimson; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是第一行&lt;/p&gt; &lt;p&gt;这是第二行&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 父选择器：筛选选择器2上的父元素选择器1 语法：选择器1&gt;选择器2{} 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&gt;p{ border: 1px solid; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;我是div内的p&lt;/p&gt; &lt;/div&gt; &lt;p&gt;我是div外面的p&lt;/p&gt;&lt;/body&gt; 属性选择器：选择元素名称，属性名=属性值的元素语法：元素名称[属性名=“属性值”]{} 12345678910111213&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; input[type=&quot;password&quot;]{ background: crimson; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;password&quot;&gt;&lt;/body&gt; 伪类选择器：选择一个元素具有的状态 语法：元素：状态{} 如： link：初始化的状态 visited：被访问过的状态 active：正在访问的状态 hover：鼠标悬浮状态 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*控制超链接初始状态*/ a:link{ color: pink; } /*控制超链接悬浮状态下的颜色*/ a:hover{ color: yellow; } /*控制访问过的超链接的颜色*/ a:visited{ color: gray; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;http://www.4399.com&quot; target=&quot;_blank&quot;&gt;click me to find a new world!!&lt;/a&gt;&lt;/body&gt; 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景 backgroundbackground: url(&quot;../image/timg.jpg&quot;) no-repeat; 边框 border：设置边框，复合属性 尺寸 width： height： 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况会影响整个盒子大小 设置box-sizing: border-box 可以解决 float：浮动 left right 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ border: 1px solid red; } .d1{ height: 500px; width: 500px; margin: 300px; padding: 100px; } .d2{ height: 200px; width: 200px; /* margin: 300px; padding: 100px;*/ } .d3{ float: left; } .d4{ float: left; } .d5{ float: right; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;d3&quot;&gt;1111&lt;/div&gt; &lt;div class=&quot;d4&quot;&gt;2222&lt;/div&gt; &lt;div class=&quot;d5&quot;&gt;3333&lt;/div&gt; &lt;br&gt; &lt;div class=&quot;d1&quot;&gt; &lt;div class=&quot;d2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style&gt; *{ margin:0px; padding: 0px; /*设置后不会因为边距改变元素大小*/ box-sizing: border-box; } body{ background: url(&quot;../image/future.jpg&quot;) center no-repeat; background-size: cover; } .layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*水平居中*/ margin: auto; margin-top: 30px; } .left{ /*border: 1px red solid;*/ float: left; width: 200px; } .left p:first-child{ font-size: 20px; color: #FFD026; } .left p:last-child{ font-size: 20px; color: #A6A6A6; } .mid{ /*border: 1px red solid;*/ float: left; width: 450px; padding-top: 10px; } .right{ /*border: 1px red solid;*/ float: right; margin:15px; } .right p:only-child{ font-size: 15px; } .right p a{ color: pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 30px; padding-top: 10px; } #username,#password,#email,#name,#phoneNum,#birthday,#vcode{ width: 200px; height: 30px; border-radius: 7px; border: 1px solid gray; padding-left: 10px; } #vcode{ width: 120px; } #img_check{ /*width: 50px;*/ height:30px; /*设置水平居中*/ vertical-align: middle; } #register{ width: 150px; height: 40px; background-color: bisque; border: 1px ; margin-top: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;User Register&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;mid&quot;&gt; &lt;div class=&quot;form&quot;&gt; &lt;form action=&quot;###&quot; method=&quot;post&quot;&gt; &lt;table &gt; &lt;!--第一行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第二行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;密码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第三行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;Email&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;邮件&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第四行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;姓名&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第五行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;手机号码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;phoneNum&quot; name=&quot;phoneNum&quot; placeholder=&quot;手机号码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第六行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;性别&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;!--第七行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;出生日期&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; id=&quot;birthday&quot; name=&quot;birthday&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--第八行--&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;验证码&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot;id=&quot;vcode&quot; name=&quot;vcode&quot; placeholder=&quot;验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;../image/验证码1.png&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--注册按钮--&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input id=&quot;register&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;http://www.baidu.com&quot;&gt;立即注册&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/29/%E6%8A%80%E6%9C%AF-html%E5%92%8Ccss/"},{"title":"C++编程中遇到的问题","text":"普通问题 C++中默认的取整方式是向下取整 如果需要计算a/b向上取整，则写成(a+b-1)/b即可 其含义是，将a提升一个b的倍数，但是因为减一，又到不到上面一个倍数 C++左值、右值、左值引用、右值引用 左值和右值的概念 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 引用 引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。 引用可以改变指针的指向，还可以改变指针所指向的值。 引用的基本规则： 声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义； 对引用的一切操作，就相当于对原对象的操作。 bool类型数字，赋值任意非0数字，最后保存的都是1（使用的C++98是这样的） 复制数组memcpy(目标数组,被拷贝数组,字节数); 容器求和函数 123#include &lt;numeric&gt;vector&lt;int&gt;arr(3,5);cout&lt;&lt;accumulate(arr.begin(),arr.end(),0); //第三个参数是sum初始值 C++是静态类型语言,对象的类型在编译时必须确定,且运行时不能更改。类型转换只不过是将某种类型的对象当做另一种类型的对象来用而已,对象本身的类型不会改变 所以试图对变量或者对象本身进行类型转换是不切实际的，如int a; (long long)a;或者a=(long long)a; C++ 伪随机数 由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。） 这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数 123456789#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;int main(){ srand((unsigned)time(NULL)); for(int i=0;i&lt;100;i++) printf(&quot;%d &quot;,rand()); return 0;} next_permutation()使用之前必须排好序！ lower_bound是找数组或者容器中第一个大于等于val的值 upper_bound是找数组或容器中第一个大于val的值 对于需要使用long long的时候，注意用int进行计算之前就要对第一个数进行强制类型转换，如下 123456LL ans=0;for(int i=1;i&lt;=2019;i++){ if(check(i)){ ans+=(LL)i*i*i; }} stringstream重复使用一定要clear 定义一个引用，Typename &amp;A=xxx 大多数编译器要求创建数组时，长度是常量，即直接给出长度。 可以使用new或者malloc来进行动态创建 C++中的log函数 以e为底：log(n) 以10为底：log10(n) 以m为底：log(n)/log(m) C语言&lt;limits.h&gt;有INT_MAX、INT_MIN，C++中推荐使用&lt;climits&gt; 队列用push, set用insert CodeBlocks没有代码补全解决方法： 建立工程文件 修改settings-editor-code completion，像如下这样设置 然后重启codeblocks C++中，访问迭代器指向的元素需要使用(*it)，若是访问对象的成员则使用it-&gt;first。而auto则直接使用，访问成员则使用.。 C++中除了函数以外，如类、结构体，结尾都要加; C++11新增的emplace与之前容器所用的insert,push等的区别是，emplace自动调用构造函数先对元素进行构造再插入，而之前的是之前插入元素。 lower_bound()用来寻找[first,last)范围内第一个大于等于target的元素，如果时数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。如果不存在，那么返回可以插入该元素的位置的指针或迭代器。 此外用其返回值-nums.begin()，可以直接得到其位置。 upper_bound()同理 函数指针 12345678910111213int add(int a,int b){ return a+b;}int sum(int a,int b,int c,int (*func)(int,int)){ int t=func(a,b); return func(t,c);}int main(){ int a=1,b=2,c=3; printf(&quot;%d&quot;,sum(a,b,c,add)); return 0;} 创建对象数组时，如果该对象写了构造方法则会把默认构造顶掉，需要补上。这样才能创建对象数组。 Clion不能debug，是因为新版本问题，使用2020.2.5版本即可 CodeBlocks不能debug是因为没有建立工程 bool变量在java里默认是false, C+ +里没有规定,所以依赖编译器实现，千万不要让编译器决定你的默认值，永远初始化 codeblocks下载下来编译器有问题，就去重新下自带mingw的 gcc、g++、mingw gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。 现在你在编译代码时调用的gcc，已经不是当初那个c语言编译器了，更确切的说他是一个驱动程序，根据代码的后缀名来判断调用c编译器还是c++编译器 (g++)。比如你的代码后缀是*.c，他会调用c编译器还有linker去链接c的library。如果你的代码后缀是cpp, 他会调用g++编译器，当然library call也是c++版本的。 就把gcc当成c语言编译器，g++当成c++语言编译器用就是了。 mingw作为gcc在windows上的一个实现 访问迭代器所指向的对象的内部成员，括号要这样写:(*it)-&gt;parent C++中判断子串用s1.find(s2)!=string::npos表示s2是s1的子串 typedef long long LL; 运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041struct fraction { int up; int down; //构造函数，并保证分子分母互质 fraction(int a, int b) { int t = gcd(a, b); while (t != 1) { a /= t; b /= t; t = gcd(a, b); } up = a; down = b; } //求最大公因数 int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } //分数除法 friend fraction operator/(fraction &amp;f1, fraction &amp;f2) { return {f1.up * f2.down, f1.down * f2.up}; } //分数比大小 friend bool operator&lt;(fraction &amp;f1, fraction &amp;f2) { return f1.up * f2.down &lt; f2.up * f1.down; } friend bool operator&gt;(fraction &amp;f1, fraction &amp;f2) { return !operator&lt;(f1, f2); } //拷贝构造函数 fraction(fraction &amp;b) { up = b.up; down = b.down; }}; C++中除了0，都是true 故不要用 return person1.age-person2.age作为运算符重载的返回值 数组作为参数传递时会退化成指针，无法在函数内得出长度 二维数组可以使用全排列next_permutation()吗？ 对于含有重复元素的序列，next_permutation()会自动去重吗？ 是！ 注意！使用之前，序列必须已经排好序！ bool型占1个字节，int占4字节 创建标记数组时，优先使用bool型！ 因为竞赛题中，对内存大小的使用是有限制的 c/c++的编译器中有一个变量表，表的关键字段有（数据类型，变量名，首地址，值），每声明一个变量，就把这个变量的相关信息填进表中 next_permunation的使用，注意需要添加using namespace std;和algorithm 注意！使用之前，序列必须已经排好序！ 123456789101112#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int main(){ char *arr=new char[3]{'a','b','c'}; do{ for(char*p=arr;p&lt;arr+3;p++) printf(&quot;%c &quot;,*p); putchar('\\n'); }while(next_permutation(arr,arr+3)); return 0;} 以数组为参数的函数内部，无法正确用sizeof(arr)/sizeof(arr[0])计算出数组长度，因为这时的数组名arr已经退化为普通的指针，失去了原来作为数组名的特殊数据结构，所以只能在外边计算完len，作为参数传入才可。 使用memset需要添加&lt;cstring&gt;头文件，只能赋值0或者1，因为它是以字节为单位进行赋值的，如果赋其他值，可能会出错，赋其他值可以用fill函数，但更慢 memeset(数组名，值，sizeof(数组名)) 注意：这里sizeof（数组名）是计算出这个数组有多少个字节！，直接写数组的长度会出错 C++中的随机数 123456#include &lt;cstdlib&gt;#include &lt;ctime&gt;srand((unsigned)time(NULL));for(int i=0;i&lt;10;i++){ printf(&quot;%d &quot;,rand());} 其范围是[0,RAND_MAX]，RAND_MAX是stdlib头文件中的一个常数 故如果要输出[a,b]范围内的随机数，需要使用rand()%(b-a+1)+a, C++全排列的写法，注意，next_permutation第二个参数要多一位 注意！使用之前，序列必须已经排好序！ 123456789#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int arr[]={1,2,3}; do{ printf(&quot;%d %d %d\\n&quot;,arr[0],arr[1],arr[2]); }while(next_permutation(arr,arr+3)); //注意这里是arr+3！！} C++动态创建多维数组的方法 1234int a,b,c,m;scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;m);int *ships=new int[a*b*c];int (*attack)[7]=new int[m][7]; 二维数组初始化 bool mark[N][N]={false}; set集合添加基本数据类型以外的数据，需要添加比较器，如添加char* 123456struct cmp{ bool operator()(char*a,char*b){ //必须重载()括号运算符 return strcmp(a,b)&lt;0; }};set&lt;char *,cmp&gt; record_digits; 结构体作为vector、set、que等的参数可以直接写成这样 123456789101112131415#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct Node{ char*s; int key; Node(char*_s,int _key):s(_s),key(_key){}};int main(){ queue&lt;Node&gt;que; char*s=&quot;abc&quot;; que.push({s,2}); que.push(Node(s,1)); return 0;} VSCode中文乱码问题 因为windows默认编码是GB2312（即GBK），VSCode默认是UTF-8，所以发生中文乱码 在设置中找到Files:Encoding,修改为Simplified Chinese(GB 2312)即可 当前页面，需要点击右下角的编码进行适配 fstream对象打开文件时，如何用自定义的文件名称ofs.open(date.c_str(), ios::out|ios::app);使用字符串的方法c_str()即可 字符数组清空char arr[10]={0}; 获取系统时间 1234567891011121314151617181920212223struct tm t; //tm结构指针time_t now; //声明time_t类型变量time(&amp;now); //获取系统日期和时间localtime_s(&amp;t, &amp;now); //获取当地日期和时间tm_sec分钟后的几秒 (0-59)。tm_min小时后的分钟 (0-59)。tm_hour午夜后经过的小时 (0-23)。tm_mday月 (1-31) 天。tm_mon月 (0 – 11;年 1 月 = 0）。tm_year年份 （当前年份减去 1900年）。tm_wday星期几 (0 – 6;星期日 = 0）。tm_yday每年的一天 (0-365;1 月 1 日 = 0)。tm_isdst如果夏令时有效，则为，正值夏时制不起作用; 如果为 0如果夏时制的状态是未知的负值。 如果 TZ 设置环境变量，C 运行库会假定规则适用于美国境内用于实现夏令时 (DST) 计算。 switch语句中，如果要定义局部变量，需要在那句case加{} 直接在文件夹里打开codeblocks生成的exe文件，报错找不到libgcc_s_dw2-1.dll, 尝试重新安装该程序以解决问题 只需要在电脑中搜索这个文件名，然后添加到系统环境变量path里D:\\Softwares\\CodeBlocks\\MinGW\\bin,添加其bin目录即可 判断int n是否素数只需判断是否整除2~&radic;n(向下取整)项 ClodeBlocks要在General setting—Encoding settings里设置位UTF-8 在写1&lt;x&lt;2时，只能写成1&lt;x&amp;&amp;x&lt;2 使用递归计算阶乘时，要么参数传引用可以使用**–n**,要么直接传参，只能使用n-1作为下一层递归的参数 123456int fac(int &amp;n) //使用传引用 { if(n==1) return 1; return n*fac(--n); //此时--n可以改变n的值} 123456int fac(int n) //直接传参{ if(n==1) return 1; return n*fac(n-1); //只能用n-1作为新的参数，--n不能改变n的值} 因为0的ASCII码值为48，因此数字0~9转化为字符，只需+48即可 二维数组作为参数，行数可以不写，列数要写 给二维数组赋值 123char CountryName[3][30]; //定义二维字符数组 for(int i=0;i&lt;3;i++) cin&gt;&gt;CountryName[i]; 定义一个函数，要求该函数能够返回一个指向字符串“I love C”的指针并能在主程序中正确得到该字符串的内容 123456789char *getString(){ char str[]=&quot;abc&quot;; //此种写法错误！！！ 此时的str字符数组是一个局部变量 return str; //当函数getString执行完毕后，str【】就被系统回收}int main(){ cout&lt;&lt;getString(); //无法得出} 123456//应该使用指针，则系统不会回收char *getString(){ char *str=&quot;abc&quot;; return str;} int型转字符串 C++11标准库已添加to_string方法 利用指针给数组、二维数组赋值、输出，更方便，不过注意定义指向二维数组的指针时，需要如下 1int *p=&amp;maxtrix[0][0] 使用cin给字符串指针赋值，必须先new一个实体 12string *str=new string;cin&gt;&gt;*str; //正确 12string *str;cin&gt;&gt;*str; //错误！ 声明函数时记得带上返回值 类模板的声明和实现貌似不能分开（不能放在不同文件中） 在实现复数与int型数相加时，重载运算符+函数为友元函数时，参数不能使用引用！ 1friend Complex operator+(Complex,Complex); //使用引用会导致类型转换出错 写头文件的时候报错[Error] ‘ostream’ does not name a type io库的都在std中, 使用前要声明一下 在头文件中使用了cout，同样要using namespace std; 文件操作 文件概念：文件是磁盘中的数据 ASCII文件，每个字节存放一个ASCII字符 二进制文件，把内存中的存储形式原样输出到磁盘上存放 C++中有三个用于文件操作的文件类 ifstream，由istream派生来，支持从磁盘输入（输入到内存） ofstream，由ostream派生来，支持从磁盘输出 （从内存输出） fstream，由iostream派生来，支持对磁盘文件的输入输出 文件操作的过程： 要以磁盘文件为对象进行输入输出，必须定义一个文件流对象，通过文件流对象将数据从内存输出到磁盘文件，或者将磁盘文件输入到内存。 定义文件流对象后，还需要将其与指定磁盘文件建立关联，并确定工作方式（输入还是输出，ASCII还是二进制）。 相对路径与绝对路径（windows下） 相对路径 ./当前文件夹下 ../上一级文件夹下 这里有个坑：Clion的exe文件和.cpp文件不在同一文件夹下，所以直接使用./xxx.txt或者xxx.txt不可以 绝对路径 E:\\\\dir1\\\\dir\\\\a.txt 对ASCII文件的操作 会自动跳过空格、回车和制表符 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){ ofstream outfile(&quot;a.txt&quot;, ios::out); if (!outfile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } // 写入数字 1-5 到文件中 for (int i = 1; i &lt; 6; i++) { outfile &lt;&lt; i &lt;&lt; '\\n'; } outfile.close(); ifstream infile(&quot;a.txt&quot;, ios::in); if (!infile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char data; // 从文件中读出数字 1-5 for (int i = 1; i &lt; 6; i++) { infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; '\\n'; } infile.close(); return 0;} 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;char strs[201];int main(){ //读取文件 ifstream ifs(&quot;D:\\\\tmp.txt&quot;,ios::in); if(!ifs.is_open()){ cerr&lt;&lt;&quot;Fail to open file&quot;; return 0; } //会自动跳过空格回车换行符 int i=0; while(!ifs.eof()){ //一直读到文件末尾 ifs&gt;&gt;strs[i++]; } for(int i=0;i&lt;200;i++){ cout&lt;&lt;strs[i]; } return 0;} 对二进制文件的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){ ofstream outfile(&quot;a.txt&quot;, ios::binary); if (!outfile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char a[] = {'h', 'e', 'l', 'l', 'o', ','}; char b[] = {'s', 'e', 'n', 'i', 'u', 's', 'e', 'n', '!'}; outfile.write(a, 6); // 将以 a 为首地址的 6 个字符写入文件 outfile.write(b, 9); outfile.close(); ifstream infile(&quot;a.txt&quot;, ios::binary); if (!infile) { cerr &lt;&lt; &quot;Failed to open the file!&quot;; return 1; } char data[6]; infile.read(data, 6); // 从文件中读出 6 个字符到以 data 为首地址的字符数组中 for (int i = 0; i &lt; 6; i++) { cout &lt;&lt; data[i]; } char datb[6]; infile.read(datb, 9); for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; datb[i]; } infile.close(); return 0;} 输入输出问题 输入一行数据两种方法的比较：gets(char*),scanf(&quot;%s&quot;,&amp;arr) gets(char*)： 遇到buff中的第一个\\n立马结束输入，然后将字符数组的字符串结尾处后一个设置为\\0 如果控制台只输入一个\\n（buff中第一个就是回车），那么gets会立即结束输入，并且将字符数组第一个位置写成\\0 scanf(&quot;%s&quot;,&amp;arr) 会将两个enter之间的内容放入arr字符数组中，并且结尾后一位会放上\\0 如果buff中\\n\\n\\nabc\\n，则会吸收掉前面三个回车和后边一个回车，将abc写入字符数组 输入一行数据（字符串）的两种方法 第一种：getline(cin,str) 第二种：cin.getline(char []buff,100) 12string temp;getline(cin,temp); 1234char buff[100];cin.getline(buff,100);int len=strlen(buff);string temp2(buff,len); 注意在使用之前，如果有cin，或者scanf（除%c外），则需要吸收回车 cin和scanf的区别 scanf使用的是输入缓冲，cin使用的是输入流，但是输入流会主动与输入缓冲同步 std::ios::sync_with_stdio(false);输入流可以设置设置不与输入缓冲同步 scanf(&quot;%c&quot;) %c是一个很奇葩的设定，单独读入一个字符，包括不可见的控制字符（换行等），而其他格式化符号（如%d %lld %f %lf %s等）会在读入未完成时将换行符、空格、制表符等空白字符统统舍弃忽略（但是会留在输入缓冲中），直到读到了足够的数据或遇到文件结尾才结束。 换行符（等其他不可见控制字符）问题 cin（cin所有类型，包括cin&gt;&gt;char类型变量)，和，scanf除%c以外的scanf的情况，遇到控制字符（如换行符）在读取时会直接跳过（不读取），但是输入的最后一个控制字符（如换行符），会留在输入缓冲中。因此如果后边紧跟着scanf的%c，一定要用getchar来吸收掉控制字符。 %c和其他（如cin，%f）等连用的问题 如上边所说，如果前边有除scanf %c以外的所有输入情况，都得吸收控制字符。 以上讨论暂不包括行输入。 两种输入一行字符串的方法getline(cin,str)和cin.get(char arr[],100)，完成输入之后，不会在输入缓冲区留下控回车 输入一行数据，可以使用getline(cin,str) 关于换行符的问题：因为scanf()会将换行符留在缓存中，所以如果geline前边有scanf，则需要getchar()吸收回车，循环getline之间并不需要吸收换行符。 对字符进行输入时，一行结束，要吸收空格 把时间中的3点12分输出成03:12 printf(&quot;%02:%02d&quot; ,h,m) 读入一行数据可以使用(注意读入一行数据前如果有单个数据读入，需要吸收换行符） 将一行数据中的某些信息（如字符串中的数字）进行提取，可以使用sscanf; 123456789int N;cin&gt;&gt;N;cin.get(); //吸收换行符char line[100];cin.getline(line,100)int len=strlen(line);sscanf(line,&quot;%d:%d:%d (+%d)&quot;,&amp;h,&amp;m,&amp;s,&amp;d); printf输出浮点数采取的保留小数措施是四舍六入五成双，比如保留2位小数时 第二位小数，如果&lt;=4则舍去，如果&gt;=6则进位 如果==5 5后边还有数，那么舍5进1 5后没有数 5前是奇数，则舍5进1 5前是偶数，则舍去5 %5s表示输出宽度为5的字符串（如果长度不够，左边补空字符） printf(&quot;%*s&quot;,5,&quot;abc&quot;);有上述同样的效果 scanf中 float是%f，double是%lf long long是%lld printf中 float和double都是%f long long仍然是%lld 字符串相关问题 根据分隔符分割字符串123456789101112131415//将一个字符串，根据分隔符来切分vector&lt;string&gt; splitStr(string s,char seq){ vector&lt;string&gt;ans; string tmp; for(auto&amp;ch:s){ if(ch!=seq) tmp.push_back(ch); else{ ans.push_back(tmp); tmp.clear(); } } ans.push_back(tmp); return ans;} C++字符转string类型的方法是，将字符放在字符数组中，使用string的构造函数来实现。 string str(char *arr, 字符个数) string的find返回的是找到的子串的开头index，如果没找到返回-1 在父串中查找存在多少子串12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt;first_pos;int hasHowManySub(string str1,int left,int right,string str2){ if(left&gt;right) return 0; int pos=str1.find(str2,left); if(pos==-1){ return 0; } first_pos.insert(pos); return 1+hasHowManySub(str1,left+1,right,str2);}int main(){ string str1=&quot;2020203332020&quot;; string str2=&quot;2020&quot;; int ans=hasHowManySub(str1,0,str1.length()-1,str2); cout&lt;&lt;ans&lt;&lt;endl; for(set&lt;int&gt;::iterator it=first_pos.begin();it!=first_pos.end();it++){ cout&lt;&lt;*(it); }} print(&quot;%s&quot;)无法打印string类型的数据，因为string是STL容器，前边的这种写法只能打印字符数组（结尾是\\0） C++取子串的两种方式 string str2(str1, 起始下标，截取连续多少个字符） str1.substr(起始下标，截取连续多少个字符） 可以用字符数组生成一个string对象 char words[1000001]; gets(words); string text(words); C++中字符串==是比较字典序是否相同 数字转字符串使用&lt;sstream&gt; 注意，在进行多次类型转换前，必须先运行clear() 可以使用&lt;algorithm&gt;中的sort来对字符串进行排序 逆置字符串:reverse(s.begin(),s.end()); 手动拷贝字符数组（字符串）时，要在末尾加\\0 关于字符和字符串的输入，某些情况下，要注意用getchar()吸收回车 1234567char a,b;scanf(&quot;%c&quot;,&amp;a);scanf(&quot;%c&quot;,&amp;b);printf(&quot;a=%c,b=%c&quot;,a,b);//控制台如下a //输入a然后enter，没等输入b直接出了结果，把回车（换行符）赋给了ba=a,b= 数字转字符串 12345678910111213#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;void intToStr(int x,string&amp;res){ stringstream ss; ss&lt;&lt;x; ss&gt;&gt;res;}int main(){ string s; intToStr(123,s); cout&lt;&lt;s&lt;&lt;endl;} 字符串查找子串 1234string a=&quot;abc&quot;;if(a.find(&quot;d&quot;)==string::npos) cout&lt;&lt;&quot;There is no 'd'&quot;&lt;&lt;endl;//如果找到了 sscanf的用法（在C标准库中,&lt;cstdio&gt;或者&lt;stdio.h&gt;） 1234char ss[]=&quot;10:12:32&quot;;int h,m,s;sscanf(ss,&quot;%d:%d:%d&quot;,&amp;h,&amp;m,&amp;s);printf(&quot;%d,%d,%d&quot;,h,m,s); 结构体作为参数时的快捷写法 12345678910struct Point{ int x; int y;};//void f(int i,int j){ queue&lt;Point&gt;que; que.push({i,j}); } 应该是编译器做了优化，对两个内容相同的字符串指针进行比较，结果是true 123456789101112131415161718192021222324int main(){ char*a=&quot;abc&quot;; char*b=&quot;abc&quot;; int c=1,d=1; int *cc=&amp;c; int *dd=&amp;d; set&lt;int*&gt;s1; set&lt;char*&gt;s2; s2.insert(a); s2.insert(b); s1.insert(cc); s1.insert(dd); printf(&quot;%d\\n&quot;, s1.size()); printf(&quot;%d&quot;,s2.size());}//结果是21 对一个字符指针来说 使用%s则输出字符串 使用%p则输出字符指针地址 迭代器STL相关问题比较STL容器内容是否完全相同，可以用== map 比较两个map内容是否完全相同，可以用== 注意：map1中key1:0，map2中没有key1，则判断结果为false 访问不存在的索引时，会自动插入该索引key，并且将value初始化（数字则初始化为0，字符串则初始化为空字符串） 因此在某些场景下，如统计字符串中每个字符的个数，可以直接map[xx]++；但是在其他场景下，会导致额外的key被插入map，应当要先判断key是否存在。 vector set转vector vector&lt;int&gt;vec(s.begin(), s.end() ); 复制vector只需要vector t1,t2; t2=t1; C++98 vector初始化方法 vector&lt;int&gt; ilist1 vector&lt;int&gt; ilist2(ilist) 或者 vector&lt;int&gt; ilist2 = ilist vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1) vector&lt;int&gt; ilist4(7) 或者 vector&lt;int&gt; ilist5(7,3)指定长度为7，每个元素都为3 vector的初始化 vector&lt;int&gt; ilist1 vector&lt;int&gt; ilist2(ilist) 或者 vector&lt;int&gt; ilist2 = ilist vector&lt;int&gt; ilist = {1,2,3.0,4,5,6,7}或者vector&lt;int&gt; ilist {1,2,3.0,4,5,6,7} vector&lt;int&gt; ilist3(ilist.begin()+2,ilist.end()-1) vector&lt;int&gt; ilist4(7) 或者 vector&lt;int&gt; ilist5(7,3)指定长度为7，每个元素都为3 指定位置插入数据1234567v2.insert(v2.begin()+4, L&quot;3&quot;); //在指定位置，例如在第五个元素前插入一个元素 v2.insert(v2.end(), L&quot;3&quot;); //在末尾插入一个元素 v2.push_back(L&quot;9&quot;); //在末尾插入一个元素 v2.insert(v2.begin(), L&quot;3&quot;); //在开头插入一个元素 插入数据使用push_back 除了vector&lt;bool&gt;以外，都可以用for(auto&amp;i:vector)进行遍历，如果是bool，不能加引用&amp; pair 需要添加头文件&lt;utility&gt;和using namespace std;； 或者添加&lt;map&gt;，因为map中会自动添加&lt;utility&gt; pair作为set或map集合的元素时，其唯一性判断是根据pair的第一个参数来的，与第二个参数无关 创建pair的方法 make_pair(&quot;haha&quot;,2); pair&lt;string,int&gt;(&quot;haha&quot;,2) pair中已经定义好了比大小、判断相等的函数 因此pair&lt;type T1,Type T2&gt;中如果是基本数据类型，则可以直接进行比大小 规则是：先比第一个，再比第二个 set set合并：用insert即可 set集合去重的原理 使operator&lt;函数，在a&lt;b时返回true，在a==b或者a&gt;b时，都返回false 尽量不要自己自定义去重逻辑，会出现很大问题 其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：1）将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值 2）将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中；如果1、2两步的返回值都是true，则可能发生未知行为，因此，记住一个准则：永远让比较函数对相同元素返回false。 其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：1）将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值2）将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。 如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中 如果1、2两步的返回值都是true，则可能发生未知行为 重载&lt;运算符，和自定义struct比较器，都是一样的逻辑 为甚么要重载&lt;运算符呢？能不能重载”&lt;=”或者”&gt;=”运算符？答案是不可以。几乎所有的方法或容器都需要排序来满足数学意义上的标准严格弱序化，否则这些方法或容器的行为将不可预知。假设f(x,y)是一个比较函数。 如果该函数满足如下条件则它是严格弱序化的。 这是一个成功的案例 12345678910111213141516171819202122232425262728293031struct Node { char outer[13]; char mid[9]; char inner[5]; Node(string a, string b, string c) { for (int i = 0; i &lt; 12; i++) outer[i] = a[i]; for (int i = 0; i &lt; 8; i++) mid[i] = b[i]; for (int i = 0; i &lt; 4; i++) inner[i] = c[i]; outer[12]='\\0'; mid[8]='\\0'; inner[4]='\\0'; } //逻辑：不满足a&lt;b，的统统返回false bool operator&lt;(const Node &amp;a) const { if (strcmp(outer, a.outer) &lt; 0) return true; if (strcmp(outer, a.outer) &gt; 0) return false; //如果等于，得看下一层 if (strcmp(mid, a.mid) &lt; 0) return true; if (strcmp(mid, a.mid) &gt; 0) return false; //还等于，还得看下一层 return strcmp(inner, a.inner) &lt; 0; //除a&lt;b,其他情况都返回false }}; set集合添加基本数据类型以外的数据，有两种方式 添加比较器 在类（结构体）中进行&lt;运算符重载 123456struct cmp{ bool operator()(char*a,char*b){ //必须重载()括号运算符 return strcmp(a,b)&lt;0; }};set&lt;char *,cmp&gt; record_digits; priority_queue 注意优先级队列的比较跟set他们是反着的 priority_queue对比大小的三种定义方式 定义一个结构体类型的比较方法 友元函数 在自定义类型中定义比较函数 12345678910struct cmp{ //作用是，让第二个参数小的优先级高 bool operator()(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;&amp;p2) { return p1.second&gt;p2.second; }}; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,cmp&gt; pq; 123456struct person{ int age; friend bool operator&lt;(person p1,person p2){ return p1.age&lt;p2.age; //表示age大的优先级高 }}; 12345678struct Node{ int time; int id; Node(int t,int i):time(t),id(i){} bool operator&lt;(const Node &amp;n)const{ return time&lt;n.time; }}; priority_queue使用的例子 题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 注意，priority_queue的cmp比较，与sort中是相反的123456789101112131415161718192021222324252627282930313233343536373839404142struct cmp{ //作用是，让第二个参数小的优先级高 bool operator()(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;&amp;p2) { return p1.second&gt;p2.second; }};class Solution{public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { map&lt;int,int&gt;mp; for(int i=0; i&lt;nums.size(); i++) { mp[nums[i]]++; } //优先级队列，频次低的优先级高 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,cmp&gt; pq; for(map&lt;int,int&gt;::iterator it=mp.begin(); it!=mp.end(); it++) { if(pq.size()&lt;k) { pq.push({it-&gt;first,it-&gt;second}); } else{ if(pq.top().second &lt; it-&gt;second){ pq.pop(); pq.push({it-&gt;first,it-&gt;second}); } } } vector&lt;int&gt;ans; while(!pq.empty()){ ans.push_back(pq.top().first); pq.pop(); } return ans; }}; priority_queue默认是一个大根堆 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q：第二个参数vector&lt;int&gt;表示用来承载底层数据结构堆(heap)的容器，less&lt;int&gt;表示数字大的优先级越大，而greater&lt;int&gt;表示数字越小的优先级越大。 priority_queue的使用 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct person{ int age; friend bool operator&lt;(person p1,person p2){ return p1.age&lt;p2.age; //表示age大的优先级高 }};int main() { priority_queue&lt;person&gt;priorityQueue; priorityQueue.push(person{1}); priorityQueue.push(person{3}); priorityQueue.push(person{2}); priorityQueue.push(person{5}); while(!priorityQueue.empty()){ person front=priorityQueue.top(); printf(&quot;%d\\n&quot;,front.age); priorityQueue.pop(); } return 0;}//打印结果5321 deque双端队列的头文件&lt;deque&gt;具体用法见：deque用法 others 使用pair需要添加头文件utility和using namespace std; 嵌套vector&lt;&lt;vector&gt; &gt;，中间要加括号，否则有些C++11之前的编译器，会把它当成移位操作 STL中，只有在vector和string中，才允许使用vi.begin()+3这种迭代器加上整数的写法 sort函数需要加上&lt;algorithm&gt;和using namespace std; sort(首元素地址，尾元素的下一个地址,比较函数) 123bool cmp(int a,int b){ return a&gt;b;} //从高到低排列 第三个参数填入cmp，即可实现从大到小排序，注意，如果在类里边定义cmp函数，需要加static，如下：12345678910class Solution {public: static bool cmp(int a,int b){ return a&gt;b; } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(),nums.end(),cmp); return nums[k-1]; }}; 队列出队，先用front再用pop 12Point head=que.front();que.pop(); 动态二维数组 12345vector&lt;vector&lt;int&gt; &gt;group;//指定外层初始长度vector&lt;vector&lt;int&gt; &gt;group(K);//指定外层和内层初始长度vector&lt;vector&lt;int&gt; &gt;group(K,vector&lt;int&gt;(3)); lambda表达式1、概念lambda表达式是C++11中引入的，它是一种匿名函数，通常它作为一个参数传递给接收函数指针或者函数符的函数使用。在C++的STL算法使用过程中，经常可以看到它的身影。 2、优点 遵守就近原则：随时定义随时使用，lambda表达式的定义和使用在同一个地方，并且lambda表达式可以直接在其他函数中定义使用，其他函数没有这个优势。 简洁明了：lambda表达式相比较其他函数的更加的简洁明了。 效率相对高些：lambda表达式不会阻止编译器的内联，而函数指针则会阻止编译器内联。 捕获动态变量：lambda表达式可以捕获它可以访问的作用域内的任何动态变量。3、基本语法capture list (params list) mutable exception-&gt; return type { function body }表达式中各个参数的含义如下： (params list):形参列表mutable:表示能不能修改捕获的变量exception:异常设定return type:返回类型function body:函数体虽然lambda中的参数变量很多，通常情况下并不需要把每一个都使用上，根据自己的需要使用即可，大多数情况下可以直接省略-&gt;、mutable、exception，不需要返回类型的话也可以省略return type。一个简单的lambda表达式：[](int x){return x*x;}。 4、捕获外部变量的办法 参数以值传递方式被捕获：参数以值传递的方式传入到lambda表达式中，值传递方式参数在lambda表达式中值不能被修改。 参数引用传递方式被捕获：参数以引用的方式传入到lambda表达式中，引用传递方式参数在lambda表达式内部修改和表达式外部的修改会相互影响。 表达式自行推导捕获：当捕获列表capture list中不传入任何变量而是写成[=]或者[&amp;]，lambda表达式会以值传递[=]或[&amp;]引用传递的方式捕获参数，参数的捕获根据表达式中变量使用情况来推导。 语法问题 两个int相乘或者相加，要注意溢出的问题 正确写法：先强转再相乘 12int a=xxx;long long b=(long long )a*a; 错误写法：先相乘再强转，已经丢失精度了 12int a=xxx;long long b=(long long )(a*a); 蓝桥杯注意事项（ISO98标准） 非静态成员不能初始化 嵌套容器的&gt; &gt;要空一格 vector&lt;pair&lt;int,int&gt; &gt;不能直接vec.push_back({1,2});这是C++11的语法 需要写成vec.push_bakc(make_pair(1,2)); 二维vector初始化vector&lt;vector&lt;bool&gt; &gt;mark(A.size(),vector&lt;bool&gt;(A[0].size(),true)); 数组无法直接转换成vector，需要使用for循环一个一个添加 有double的题目，一定要小心，不要把double写成int了！ 存在long long数据的时候，写函数一定要注意相应的函数参数不能写成int； 读入一行最好的方法是sacnf(&quot;%s&quot;,字符数组名) 因为其会舍弃前后的enter，只将中间的内容写入字符数组","link":"/2021/03/15/C-C-%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"C++学习笔记","text":"一、基于过程的程序设计1.1 概念及基础 #pragma once //防止头文件重复包含 自定义的头文件用&quot; &quot;，系统的用&lt; &gt; 在标准输入流与输出流中使用控制符需要添加#include iomanip头文件 C++教材p50页 有设置基数10、16、8；填充字符；设置精度；字段宽度；输出左对齐右对齐；输出正数给+ 12cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setiosflags(ios::right)&lt;&lt;setprecision(2);//输出数据右对齐，取两位小数 putchar和getchar 进行字符的输入和输出 c=getchar() 无参数 C++兼容C语言的scanf和printf scanf(“%d %c %f”,&amp;a,&amp;c,&amp;b); printf(“a=%d,b=%f,c=%c\\n”,a,b,c) switch结构 12345678switch(c) //括号中可以是数值类型的数据（包括char类型）{ case 0:###;break; //当c与case后的表达式相同时，执行此句 case 1:###;break; //冒号后可以是好几句代码，break …… default:###; //若所有表达式都不满足，则执行default子句的内嵌语句 //default不需要break；同时也可以没有default} C++提供了两种类型的字符串表示形式 C风格字符串 Index 0 1 2 3 4 5 Variable H e l l o \\0 Address 0x23451 0x23452 0x23453 0x23454 0x23455 0x23456 C++引入的string类类型 定义字符串string str=”Hello”; 复制字符串str1=str2; 连接字符串str=str1+str2; 计算字符串长度str.size() 内置函数（内联函数） 12345678910111213141516#include&lt;iostream&gt;using namespace std;inline int max(int,int,int); //可以在声明和定义函数时写inline，也可以只在函数声明时加int main() //inline，而定义时不加。{ int i=10,j=20.k=30,m; m=max(i,j,k); //编译时直接将max函数体的代码替换此句，同时将实参代替形参 cout&lt;&lt;m; return 0;}inline int max(int a,int b,int c) { if(b&gt;a)a=b; if(c&gt;a)a=c; return a;} 函数的重载：重载函数的参数个数，参数类型，或者参数顺序中必须至少有一种不同 函数模板：建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就是函数模板。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;T max(T a,T b,T c){ if(b&gt;a)a=b; if(c&gt;a)a=c; return a;}int main(){ int a1=1,a2=2,a3=3; double b1=0.1,b2=0.2,b3=0.3; int i;double j; i=max(a1,a2,a3); //调用函数模板，此时T被int取代 j=max(b1,b2,b3); //调用函数模板，此时T被double取代} 函数模板的一般形式为 12345template&lt;typename T&gt;通用函数定义或（二者等价）template&lt;class T&gt;通用函数定义 函数模板只适用于函数体相同、函数的参数个数相同、而类型不同的情况。同时类型参数可以不止一个，可以根据需要确定个数如： 1template&lt;class T1,typename T2&gt; 有默认参数的函数，暂时仅作了解 C++中变量除了有数据类型的属性以外，还有存储类别的属性：自动的auto，静态的static，寄存器的register，外部的extern 自动变量auto：auto可以省略，大多数变量都是自动变量 静态局部变量:对静态局部变量是在编译时赋初值，即只赋值初值一次，以后每次调用函数时不再重新赋初值，而是保留上一次函数调用结束的值 12345678910int f(a){ static int c=1; //c是静态局部变量，只赋一次初值，再次调用时屏蔽此句 c=c+1; return a+c;}int main(){ cout&lt;&lt;f(1)&lt;&lt;' '&lt;&lt;f(1); //输出结果：3，4} 虽然静态局部变量在函数调用结束后仍然存在，但是别的函数不能引用它 寄存器变量：有些变量使用频繁（如在一个函数中执行10000次，每次循环都引用某局部变量），使用寄存器存放大大提高效率(编译器会自动识别高频变量并设置为register variable，无需程序员指定，了解即可) 1register int i=1; 全局变量（外部变量）：作用域从变量的定义处开始到本程序文件的末尾 1234567891011file1.cppextern int a,b; //外部变量声明,两个文件链接后执行file1此句时，编译器先在本文件中找a，bint main() //定义，找不到就去file2中找{cout&lt;&lt;a&lt;&lt;b;}file2.cppint a=3,b=4; 用static声明静态外部变量：如果希望某些外部变量只限于被本文引用，而不能被其他文件引用，此时可以在定义外部变量时加一个static声明，为程序的模块化、通用性提供了方便： 1234567file1.cppstatic int a=3;...file2.cppextern int a; //虽然有此句，但file2仍然无法使用file1中的a... 根据函数是否能被其他源文件调用，将函数区分为内部函数和外部函数 内部函数：只能被本文件中其他函数所调用 1static int func(int a,int b) 外部函数：定义函数时省略extern，默认为外部函数 1extern int func(int a,int b) 控制台停止system(“pause”); 1.1.1生成随机数#include&lt;ctime&gt;srand(time(0));rand()%100 生成0~99区间内的随机数 1.1.2字符数组与字符串 字符数组可以一次性定义，但不可一次赋值，只能分别对每个数组元素赋值 123char C[5];C={'C','h','i','n','a'}; //错误！C[0]='C',C[1]='h'... //正确！ 字符串操作函数(需要#include) 字符串连接函数strcat，是string catenate的缩写 函数原型strcat(char[],const char[]) 12345char str1[30]=&quot;People's Republic of&quot;;char str2[]=&quot;China&quot;;cout&lt;&lt;strcat(str1,str2); //调用strcat函数输出： People's Republic of China 字符串赋值函数strcpy 函数原型strcpy(char[],const char) 123char str1[10],str2[]=&quot;China&quot;;strcpy(str1,str2);//执行后str2中的5个字符和'\\0'被复制到str1中 字符串比较函数strcmp,是string compare的缩写 函数原型strcmp(const char[],const char[]) 1234strcmp(str1,str2);strcmp(&quot;China&quot;,&quot;Beijing&quot;);strcmp(str1,&quot;China&quot;);//以上写法均合法 如果两字符串相等，返回0 字符串1&gt;字符串2，返回正整数 字符传1&lt;字符传2，返回负整数 字符串比较规则是：自左至右逐个字符比ASCII码 字符串长度函数strlen,返回字符串实际长度，不包括’\\0’ 函数原型strlen(const char[]); C++提供全新的数据类型——字符串类型（string类型） 需要#include 字符串赋值直接只用= 字符串连接直接使用+ 字符串比较直接使用关系运算符 String类型的长度固定一般为16字节 指针法表示数组元素 123456int a[10];int *p=a;for(int i=0;i&lt;10;i++) cin&gt;&gt;*(p+i);for(p=a;p&lt;(a+10);p++) cout&lt;&lt;*p; C++有三种方法访问一个字符串 字符数组存放字符串 1char str[]=&quot;I love China&quot;; 用字符串变量存放字符串 1string str=&quot;I love China&quot;; 用字符指针指向一个字符串 1char *str=&quot;I love China&quot;; 1.1.3指针与引用 指针变量也可以指向一个函数。函数再编译时被分配给一个入口地址，这个函数入口地址就成为函数的指针。可以用一个指针变量指向函数，然后通过该指针变量调用此函数。 1234int max(int x,int y); //函数声明int (*p)(int,int); //定义指向函数的指针变量pp=max; //使p指向函数maxint m=p(1,2); //通过p调用函数max 指针数组 1int *p[4]; //由于[]优先级高，p先和[]结合成为数组，然后数组元素的类型是int * 指向指针的指针 123char *(*p);或char **p; 1234char **p; char *arr[]={&quot;BASIC&quot;,&quot;FORTRAN&quot;,&quot;C++&quot;,&quot;Pascal&quot;}; p=arr+2; cout&lt;&lt;*p&lt;&lt;endl&lt;&lt;**p; *arr[2]中存放了字符串”C++”的第一个字符的地址，因此cout&lt;&lt;p就是从第一个字符开始输出字符串”C++”。**p，应该理解为*(*p)，即**p存放的是p所指向内容的地址，即C的地址，故cout&lt;&lt;**p输出的是C； const指针 指向常量的指针变量（经定义后，不允许通过指针变量改变它指向对象的值） 12345int a=12，b=15;const int *p=&amp;a; //定义了p为指向整型变量a的const指针变量*p=13; //试图通过p改变它指向的对象a的值，非法p=&amp;b; //p改为指向b，合法a=15; //直接改变a的值，合法 12const int a=12; //要想绝对保证a的值不变，应该把a定义为常变量//这样p就成为了指向常变量的指针变量，无论直接访问方式还是间接访问方式都无法改变a的值 常变量和常量的区别：变量是再运行时赋值，常量是在编译时赋值。常变量是在程序执行时赋值，只是值不再改变而已。 说明：如果一个变量已经被声明为常变量，则只能用指向常变量的 指针指向它 常指针（指针的指向不能改变） 12char *const p1=&quot;China&quot;; //p1是字符指针变量，其指向不能改变p1=&quot;Canada&quot;; //试图改变p1的指向，非法 指向常量的常指针（结合上面两种，即指针指向一个固定的对象，且不能通过指针改变该对象的值） 12int a=10;const int *const p=&amp;a; 其实上述常指针，和指向常量的指针很简单 12const int *p=&amp;a; //*p左边代表p指向的类型，故p指向常量char *const p=&quot;China&quot;; //const位于*和p之间，代表p是一个常指针，不可以更换指向目标 void指针类型：“指向空类型“或者”不指向确定的类型“ 指针额外知识点 指针可以有空值，即该指针变量不指向任何变量 123p=NULL;//一般情况编译系统中iostream里已经定义了符号常量NULL代表0 #define NULL 0//p=NULL就是使p指向地址为0的单元，即p不指向任何有效的单元 两个指针变量可以相减 如果两个指针变量指向同一个数组的元素，则两个指针的差就是两个指针之间的元素个数 12//假设p1指向a[1],p2指向a[4]p2-p1=3; 两个指针变量比较 若两个指针变量指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量小于指向后面元素的指针变量。 12//假设p1指向a[1],p2指向a[4]p1&lt;p2的值为true; 引用 引用的作用是给变量起别名 声明一个引用时，必须同时使之初始化 1.1.4结构体类型 结构体变量的初始化 可以在定义结构体时指定初始值 也可以在定义变量时进行初始化 指向结构体变量的指针 123Student *p=&amp;stu; cout&lt;&lt;p-&gt;Name; cout&lt;&lt;(*p).score; //注意观察两种输出方式 1.1.5new和delete运算符 new 12345new int; //开辟一个存放整数的存储空间，返回一个指向该 存储空间的地址（即指针）new int(100); //除了上述操作外，指定该整数的初值为100new char[10]; //开辟一个存放字符数组（包含10个元素）的空间，返回字符数组首元素地址new int[5][4]; //开辟一个存放二维数组（大小为5*4）的空间，返回首元素地址float *p=new float(3.14159) //开辟一个存放单精度数的空间，并指定该数初值为3.14159，将该空间的地址赋给指针变量p 注意：用new分配数组空间时不能指定初值，如果由于内存不足无法正常分配空间，new会返回一个空指针NULL delete 123delete p; //撤销上面用new开辟的存放单精度数的空间char *pt=new char[10];delete [] pt; //撤掉该数组空间 1.1.6枚举类型 定义：如果有一个变量只能有几种可能的值，可以定义为枚举（enumeration)类型。 1enum weekday{sun,mon,tue,wed,thu,fri,sat}; weekday为枚举类型。sun,mon,tue…称为枚举元素或枚举常量，它们时用户自定义的标识符 说明 枚举元素按常量处理，故称枚举常量，他们不是变量，不能对他们赋值，即枚举元素的值时固定的 1sun=0; //错误 枚举元素作为常量，它们是有值的，其值是一个整数，编译系统按定义时的顺序对他们赋值为0,1,2… 123weekday workday; //定义枚举变量workdayworkday=mon; //把枚举常量mon的值赋给枚举变量workday,workday的值等于1cout&lt;&lt;workday; //输出结果为1，而不是字符mon 也可以在声明枚举类型的时候自己指定枚举元素的值，如 1enum weekday{sun=7,mon=1,tue,wed,thu,fri,sat}; 枚举值可以用来做判断比较，规则按整数比较进行 不能把一个整数直接赋给一个枚举变量，枚举变量只能接受枚举类型数据，如 12345workday=tue; //正确workday=2； //错误，它们属于不同类型workday=(weekday)2; //正确，C语言的强制转换workday=weekday(2); //正确，C++风格的强制转换 1.1.7typedef typedef的作用相当于取别名 1234typedef int INTEGER;//如此，以下两行等价int i,j;INTEGER i,j; 也可以对一个结构体类型声明一个新的名字 1234567typedef struct{ int month; int day; int year;}DATE;DATE birthday;DATE *p; 还可以进一步用typedef声明一个新的类型名 12345678typedef int NUM[100]; //声明NUM为整型数组类型，包含100个元素NUM n; //定义n为包含100个整形元素的数组typedef char * STRING; //声明STRING为char *类型，即字符指针类型STRING p,s[10];typedef int(*POINTER)(); //声明POINTER为指向函数的指针类型，函数返回整型值POINTER p1,p2; typedef定义的一般用纯大写 定义结构体时同时定义该结构体类型的指针，可以这样写 12345typedef struct Node{ int num; Node *next;}*PNode; 1.1.8基本数据类型占用字节数 1234short takes 2 Bytesint takes 4 Byteslong takes 4 Byteslong long takes 8 Bytes 1.1.9 引用 引用的本质：给变量起别名 注意事项：1.引用必须初始化int &amp;a=b; 2.引用一旦初始化就不可更改 引用作函数参数：1.值传递2.地址传递3.引用传递12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//值传递void swapValue(int a,int b){ int temp=a; a=b; b=temp;}//地址传递void swapAddress(int *a,int *b){ int temp=*a; *a=*b; *b=temp;}//引用传递void swapQuote(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;}int main(){ int a=1,b=2; swapAddress(&amp;a,&amp;b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b;} 引用作为返回值 不要返回局部变量的引用 函数的调用可以作为左值（实质：引用是别名，相当于一个变量名）12345678910111213using namespace std;int&amp;func(){ static int a=10; return a; 注意这里返回的是a不是&amp;a,因为a是名字，返回值是别名类型已经一致}int main(){ 这里的func()相当于是一个变量名,引用的实质是别名 func()=20; cout&lt;&lt;func();} 引用的本质本质：引用的本质在C++内部实现是一个指针常量（指针的指向不能修改）12345678910111213141516void func(int&amp;ref) 系统自动转换为 int*const ref{ ref=30; 系统自动转换为 *ref=30}int main(){ int a=10; int&amp;ref=a; 系统自动转换为int*const ref=&amp;a 将a的地址放在ref中 ref=20; 系统自动转换为 *ref=20; func(a); } 1.1.10 常量引用 *作用**：常量引用主要用来修饰形参，防止误操作 *知识点**： 1.非常量引用的初始值必须为左值2.常量引用则可以直接引用值 123const int&amp; ref = 10; 编译系统自动将代码转换为：int temp=10;const int&amp;ref=temp;cout &lt;&lt; ref; 3.加上const后变成只读状态，不能修改 使用场景：用来修饰形参，防止误操作 123int&amp; ref = 10; 操作非法！const int&amp; ref = 10; 操作合法！加上const后系统自动转换为：int temp=10; const int&amp;ref=temp; 1.1.11指针 指针占用的内存空间32位OS下占4字节,无论什么数据类型的指针（开发一般都是32位环境x86）64位OS下占8字节(x64) 空指针：指针变量指向内存中编号为0的空间用途：初始化指针变量注意：空指针指向的内存是不可访问的（0~255内存是OS占用的不可访问） 野指针：指针变量指向非法的内存空间没有申请就访问一块内存，会产生访问权限冲突。在程序中要避免野指针的出现。1.1.12this指针 this指针指向被调用的成员函数所属的对象*this指针的用途： 1.当形参和成员变量同名时，可用this指针来区分2.在类的非静态成员函数中返回自身，可使用return *this (用于链式调用） 123456789101112131415class Saler {public: Saler(int = 0); Saler&amp; addIncome(int n) { 注意返回值用引用接收 income += n; return *this; 返回的是自身本体 } int income;};Saler::Saler(int a):income(a){}int main(){ Saler Mike; Mike.addIncome(10).addIncome(10).addIncome(20);} Saler addIncome(int n){...}返回的不是引用，则会调用拷贝构造函数，返回一份拷贝而不是本体 空指针访问成员函数12345678910111213class Person {public: void showName() { cout &lt;&lt; &quot;Name=&quot; &lt;&lt; name &lt;&lt; endl; 系统自动添加this.name }private: string name;};int main() { Person* p = NULL; p-&gt;showName(); 代码崩溃,因为this指向当前函数所属对象，但空指针无指向对象} 为了增加程序的健壮性，我们添加if(this==NULL) return;在函数中1.2零碎知识点1.2.1生成随机数12345678#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;int main(){ srand(time(0)); cout&lt;&lt;rand()%10+1&lt;&lt;endl;} 1.2.2 goto跳转语句1.23 函数的分文件编写 swap.h*123#include&lt;iostream&gt;using namespace std;void swap(int&amp;,int&amp;); swap.cpp*(名字不一定要相同）123456#include&quot;swap.h&quot;void swap(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;} main.cpp*1234567#include&quot;swap.h&quot;void swap(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;} 1.2.4 string相关问题直接定义string类型不需要导包用到string相关方法，或用到cout需要导包&lt;string&gt;1.2.5static 静态局部变量*特点： 1.该变量在全局区分配内存2.只能初始化一次，在声明处初始化，如果未初始化系统会自动初始化3.始终驻留全局区，直到程序结束。但是作用域仅为函数内用法：1.在循环中，若赋初值操作只想用一次 123456int count = 0;while (count&lt;5) { static int i = 0; i被声明为static后，这句话只会执行一次 count += i; 后续循环不再赋予初值 i++;} 1.3 函数1.3.1函数默认参数123456void sumNum(int a, int b = 10, int c = 20) { cout &lt;&lt; &quot;sum=&quot; &lt;&lt; a + b + c &lt;&lt; endl;}int main() { sumNum(10);} 注意事项： 1.如果某个位置已经有默认参数，那么从这往右的参数都必须有默认值2.如果函数声明有默认参数，函数实现就不能有默认参数（函数的声明和实现只能有一个有默认参数） 1.3.2 函数重载 函数重载条件：前提：函数作用域相同 1.函数参数类型不同 2.函数参数个数不同 3.函数参数顺序不同 注意：返回值不能作为重载的条件 函数重载两个特殊情形 1.引用作为重载条件const int&amp; 和 int&amp; 视为不同类型 123456789101112131415void func(int&amp;n){ cout&lt;&lt;&quot;int&amp;&quot;&lt;&lt;endl;}void func(const int&amp;n){ cout&lt;&lt;&quot;const int&amp;&quot;&lt;&lt;endl;}int main(){ int a=10; func(a); func(10); 因为int&amp;n=10不合法！ const int&amp;n=10合法! 系统自动转换为int temp=10;const int&amp;n=temp;} 2.尽量避免函数重载和默认参数同时出现 12345678910111213void func(int a,int=10){ cout&lt;&lt;a;}void func(int a){ cout&lt;&lt;a;}int main(){ func(20); 此时编译系统不知道要调用哪个函数，故无法重载 func(10,20); 合法，不产生二义性} 1.3.3指针和函数二、基于对象的程序设计2.0 内存分区模型C++程序在执行时，将内存大方向分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的函数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由OS回收 内存分区的意义： 不同区域存放的数据，赋予不同的生命名周期，给我们更大的灵活编程 2.0.1 程序运行前在程序编译后，生成exe可执行文件前，未执行该程序前分为两个区域代码区： 存放着CPU执行的机器指令 代码区是共享的，目的对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是只读的，防止程序意外地修改它的指令 全局区： 存放全局变量和静态变量 全局区还包括常量区，存放字符串常量和const修饰的变量 该区域的数据在程序结束后由操作系统释放1234567891011using namespace std;int&amp;func(){ static int a=10; return a;}int main(){ func()=20; cout&lt;&lt;func();} 2.0.2 程序运行后 栈区* 存放函数的参数值，局部变量等 由编译器自动分配释放 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放12345678910int*func(){ int a=10; return &amp;a;}int main(){ int *p=func(); cout&lt;&lt;*p;局部变量a存放在栈区，由OS决定该地址的内容是否释放，不能保证输出的一定是10} 堆区*由程序员分配释放，若程序员不释放，程序结束时由操作系统回收C++中主要利用new在堆区开辟内存2.0.3 new操作符 new的基本语法123456789101112#include&lt;iostream&gt;using namespace std;int*func(){ return new int(10);}int main(){ int *p=func(); cout&lt;&lt;*p; system(&quot;pause&quot;);} 在堆区利用new开辟数组123456789101112#include&lt;iostream&gt;using namespace std;int*func(){ return new int(10);}int main(){ int *p=func(); cout&lt;&lt;*p; system(&quot;pause&quot;);} 2.0.4delete操作符释放数组空间需要加上[]:delete [] arr;2.1类和对象2.1.0对象的特性 空对象占用1字节存储（面试可能会），目的是区分不同空对象在内存中的位置，每个空对象也应该有一个独一无二的内存地址 成员变量和成员函数是分开存储的，除了非静态成员变量属于对象，其他都不属于对象（静态成员变量、非静态成员函数、静态成员函数）2.1.1基本概念 面向对象程序设计有4个主要特点：抽象、封装、继承、多态 多态性：由继承而产生的不同派生类，其对象对同一消息会作出不同的相应 如同样是双击操作，windows下，对可执行文件双击就会执行此程序，对文本文件就会启动文本编辑器并打开该文件 类代表了某一批对象的共性和特征。类时对象的抽象，而对象时类的具体实例，也可以说，类是对象的模板。 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 123456789101112class Student{ private: int num; char name[20]; public: void display(){ cout&lt;&lt;&quot;num=&quot;&lt;&lt;num; cout&lt;&lt;&quot;name=&quot;&lt;&lt;name; }};Student stu1,stu2; 如果在类的定义中既不指定private，也不指定public，则系统默认是私有的 私有成员(private),只能被本类中的成员函数引用，类外不能调用（友元类除外） 公用成员（public），既可以被本类中的成员函数所引用也可以被类的作用域内的其他函数引用 受保护的成员(protected),不能被类外访问，但是可以被派生类的成员函数访问 建议先写public部分，因为这样可以使用户将注意力集中在能被外界调用的成员上 当其他类对象作为本类成员，构造的时候先构造类对象，再构造自身。析构时满足先构造的后析构，后构造的先析构原则 2.1.2类的成员函数 工具函数：有的函数不是准备为外界调用的，而是为本类中的成员函数所调用的，就应该将他们指定为private，这种函数的作用是支持其他函数的操作，是类中其他成员的工具函数（utility function),用户不能调用这些私有的工具函数 在类外定义成员函数 12345678class Student{ ...}void Student::display(){ ...} 内置成员函数 使用inline的原因：规模很小的函数，调用的开销比执行的开销更大，因此直接内置更高效 inline函数的作用是在调用该函数时，将函数的代码赋值插入到函数调用点，而若不用inline声明，在调用该函数时 ，流程转去函数代码的入口地址，在执行完该函数的代码段后，流程返回函数调用点 只有在类外定义的成员函数规模很小而调用频率很高时，才指定为内置函数 类内定义的成员函数可以省略inline，因为已被隐含地指定为内置函数 类体外定义的函数，需要用inline显式声明 成员函数的存储方式 不论成员函数是在类内定义还是在类体外定义，成员函数的代码段的存储方式是相同的，都不占用对象的存储空间。（否则要为每个对象存储相同的代码段，对空间极大浪费） inline声明的成员函数，其代码段同样不占用对象的存储空间 2.1.3对象成员的引用 访问对象中的成员有三种方法 通过对象名和成员运算符 通过指向对象的指针 通过对象的引用 123Time t1;Time &amp;t2=ti;cout&lt;&lt;t2.hour; 2.1.4类的封装性和信息隐蔽 公用成员函数是用户使用类的公用接口（public interface），或者说是类对外接口 如同照相机拍照只需要按下快门，并不需要关心其内部的电路和机械结构是如何实现拍照的，这就是接口与实现分离 2.1.5类声明和成员函数定义的分离 实际上，一个C++程序是由3个部分组成的 类声明头文件（后缀为.h)，可以理解为用户使用类库的公用接口 类实现文件（后缀为.cpp)，包括类成员函数的定义 类的使用文件（后缀为.cpp)，即主文件 2.1.6面向对象程序设计中的几个名词 三个术语：对象、方法、消息 1stud.display(); stud是对象，display（）是方法，调用一个对象的方法（如stud.display())就是一个发对对象的消息，要求对象执行一个操作 2.1.7 C++三个文件分离 **#include后面用双引号引起来 “ “ **,不要用&lt; &gt; 主文件（即类的使用文件），后缀为.cpp 123456#include&lt;iostream&gt;#include &quot;time.h&quot;int main(){ ...} 类声明头文件，后缀为.h 12345678910class Time{public: void setTime(); void showTime();private: int hour; int minute; int sec;}; 类的实现文件，包括类成员函数的定义,后缀为.cpp 123456789101112#include&lt;iostream&gt;#include &quot;time.h&quot;using namespace std;void Time::setTime(){ cout&lt;&lt;&quot;Enter hour,minute,sec:&quot;; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;sec;}void Time::showTime(){ cout&lt;&lt;&quot;Time is &quot;&lt;&lt;hour&lt;&lt;'h'&lt;&lt;minute&lt;&lt;&quot;min&quot;&lt;&lt;sec&lt;&lt;'s'&lt;&lt;endl;} 2.1.8struct和class的区别C++中struct和class唯一的区别就在于默认的访问权限不同 1.struct默认访问权限为public2.class默认权限为private 2.2怎样使用类和对象2.2.1利用构造函数对类对象进行初始化 如果一个类中的所有成员都是公用的，则可以在定义对象的时候对数据成员进行初始化 1234567class Time{ public: int hour; int minute;};Time t1={11,23}; C++提供构造函数(Constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。 构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值 可以用一个类对象初始化另一个类对象，此时不调用构造函数，调用拷贝构造函数 12Time t1;Time t2=t1; //建立对象t2，并用t1初始化t2 注意：Person p();不能调用默认构造函数，编译系统会认定其为函数声明；调用默认构造函数直接写Person p; 2.2.2带参数的构造函数 12345678910111213141516171819class Box{public: Box(int,int,int);private: int height; int width; int length;}Box::Box(int h,int w,int len){ height=h; width=w; length=len;}int main(){ Box box1(12,25,30);} 2.2.3用参数初始化表对数据成员进行初始化1Box::Box(int h,int w,int len):height(h),width(w),length(len){} 如果数据成员是数组，则应当在构造函数的函数体中用语句对其赋值，而不能用参数初始化表对其初始化 1234567891011121314class Student{public: Student(int n,char s,char nam[]):num(n),sex(s) { strcpy(name,nam); }private: int num; char sex; char name[20];};Student stu1(10101,'m',&quot;Wang_li&quot;); 2.2.4构造函数的重载 一个类中可以定义多个构造函数，以便为对象提供不同的初始化方法。这些构造函数具有相同的名字，而参数的个数或者参数的类型不相同，创建对象时，据此系统自动选择对应的构造函数 12345678910111213Box();Box(int h,int w,int len):height(h),width(w),length(len){}Box::Box(){ height=10; width=10; length=10;}int main(){ Box box1; Box box2(12,13,14);} 2.2.5使用默认参数的构造函数 带默认参数的构造函数的意思是，如果不输入其某项数据，该项数据将取默认值 应该在声明构造函数时指定默认值，而不能只在定义构造函数时指定默认值 声明构造函数时，形参名可以省略 1Box(int=10,int=10,int=10); 全部参数都指定了默认值的构造函数也属于默认构造函数，一个类只能由一个默认构造函数，也就是说无参数而调用的构造函数，一个类只能由一个 12Box(); //声明了一个无参的构造函数Box(int=10,int=10,int=10); //声明了一个全部都指定了了默认值的构造函数 一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。因为会产生歧义 123456789101112131415161718192021222324class Box{public: Box(int h=10,int w=10.int len=10); //使用默认参数（形参给定值） //或Box(int=10,int=10,int=10);private: int height; int width; int length;};Box::Box(int h,int w,int len){ height=h; width=w; length=len;}//或Box::Box(int h,int w,int len):height(h),width(w),length(len){}int main(){ Box box1; //不指定参数，各参数取默认值 Box box2(15); //只给定一个实参，剩下的取默认值 Box box3(15,30); //只给定两个实参，剩下的取默认值 Box box4(12,30,20); //给定3个实参} 12//上面类体外对构造函数的声明也可以写成参数初始化表的形式Box::Box(int h,int w,int len):height(h),width(w),length(len){} 2.2.6析构函数 析构函数的作用并不是删除对象，而是撤销对象占用的内存空间之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。 析构函数不返回任何值，没有函数类型，也没有函数参数，不能被重载，一个类有多个构造函数，但是只能有一个析构函数 实际上，析构函数的作用并不仅限于释放资源，还可以被用来执行用户希望在最后一次使用对象之后所执行的任何操作，例如输出相关信息。 1234~Student(){ cout&lt;&lt;&quot;Destructor called.&quot;; } 先构造的后析构，后构造的先析构 2.2.6对象数组 如果构造函数只有一个参数,定义数组时可以直接在等号后面的花括号内提供实参 1Student stu[3]={3,2,13}; 如果有多个参数 12345Student stu[3]={ Student(1001,12,39); //调用第一个元素的构造函数，向他提供3个实参 Student(1002,13,23); //调用第二个元素的构造函数，向他提供3个参数 Student(1003,14,78); //调用第三个元素的构造函数，向他提供3个参数}; 2.2.7对象指针 对象空间的起始地址就是对象的指针 123456789Time *pt;Time t1;pt=&amp;t1;//通过指针访问对象的成员(*pt).hourpt-&gt;hour(*pt).get_time()pt-&gt;get_time() 2.2.8指向对象成员的指针 指向对象数据成员的指针 123int *p;p=&amp;t1.hour;cout&lt;&lt;*p; 指向对象成员函数的指针 定义指向对象成员函数的指针变量的方法和定义指向普通函数的指针变量方法有所不同 12345678910//指向普通函数的指针变量void(*p)(); //p是指向void型函数的指针变量p=fun;(*p)(); //调用fun函数//指向对象成员函数的指针变量//需要三步void(Time::*p2)(); //定义p2是一个指向Time类成员函数 返回值为void 的指针p2=&amp;Time::get_time; //注意！此处get_time后不加括号(t1.*p2)(); //调用t1的get_time成员函数 this指针：它是指向本类对象的指针常量（不可修改指向），它的值是当前被调用的成员函数所在对象的起始地址 2.2.9公用数据的保护 常对象 在常对象的生命周期中，t1所有数据成员的值都不能被修改 可以在定义对象时加关键字const，指定对象为常对象。常对象必须有初值。 123Time const t1(12,34,56); 或const Time t1(12,34,56); 常对象只能调用常函数 12const Time t1(12,34,56);t1.get_time(); //非法！试图用调用t1的普通成员函数 声明常成员函数 1void get_time()const; 12345678910class Person {public: void showName()const this指针的本质是Person*const this 指针常量 { 常成员函数相当于把this变成了const Person*const this name = &quot;YUfengxu&quot;; name其实是this-&gt;name }private: string name;}; 常成员函数可以访问常对象中的数据成员，但不允许修改常对象中的数据成员的值 C++考虑到实际编程的需要，将数据成员声明为mutable，这样就可用常成员函数修改它的值 1mutable int count; 1234567public: void showName()const { name = &quot;YUfengxu&quot;; 即使是常成员函数，加了mutable也能修改 }private: mutable string name; 总结一下就两条：1.只有常成员函数能访问常对象，但不能修改数据成员 **2.只有声明为muable的数据成员，才能被常成员函数修改** 常对象成员 可以将对象的成员声明为const，包括常数据成员和常成员函数 常数据成员 只能通过构造函数的参数初始化表对常数据成员进行初始化，任何其他函数都不能对常数据成员赋值 123456const int hour;//不能采用在构造函数中队常数据成员赋初值Time::Time(int h){ hour=h; //非法，不能对之赋值} 12//应当写成Time::Time(int h):hour(h){} 常成员函数 1void get_time()const; 调用时不必加const 常成员函数可有引用const数据成员，也可以引用非const数据成员 数据成员 普通成员函数 const成员函数 非const的普通数据成员 可以引用，也可以改变值 可以引用，但不可以改变值 const数据成员 可以引用，但不可以改变值 可以引用，但不可以改变值 const对象 不允许 可以引用，但不可以改变值 总结一下就是：const成员函数只能引用，不能改变值；普通成员函数要看情况 指向对象的常指针 将指针声明为const型，这样指针变量始终保持为初值，不能改变，即其指向不变 1234Time t1(10,12,15),t2;Time *const p;p=&amp;t1;p=&amp;t2; //错误，p不能改变指向 指向常对象的指针变量 与前面所说的指针和其所指向变量的关系，是一致的。指向常变量的指针可以指向const和非const型的变量，而指向非const型变量的指针只能指向非const的变量 只需将“变量”替换为“对象”即为对象与指针的规则 如果一个对象已经被声明为常对象，则只能用指向常对象的指针指向它。 如果定义了一个指向常对象的指针，并使它指向一个非const对象，则其指向的对象不能通过该指针变量来改变 总之，常指针不能改变方向，指向常变量/常对象的指针不能通过指针修改目标值（除非将涉及到的成员函数都设置为const，涉及到的数据成员都设置为mutable） 1234Time t1(10,12,15);const Time *p=&amp;t1;t1.hour=12; //合法(*p).hour=15; //非法，不能通过指针变量改变t1的值 12//如果希望任何情况下t1的值都不能被改变，应该把他定义为const型const Time t1(10,12,15); 注意区别 常指针和指向常对象的指针，不同的定义方法 12Time *const p; //指向对象的常指针const Time *p; //指向常对象的指针变量 对象的常引用 如果不希望在函数中修改实参t1的值，可以吧fun函数的形参t声明为const（常引用） 1void fun(const Time &amp;t); 在C++面向对象程序设计中，经常用到常指针和常引用作为函数参数。这样既能保证数据安全，使数据不能被随意修改，在调用函数时又不必建立实参的拷贝，常指针和常饮用作函数参数，可以提高程序效率 const型数据小结 形式 含义 Time const t t是常对象，其值任何情况下都不能改变 void Time::fun()const fun是Time类的常成员函数，可以引用，但是不能修改本类中的数据成员 Time *const p p是指向Time类对象的常指针，p的指向不能改变 const Time*p p是指向Time类常对象的指针，不能通过p改变目标值 const Time&amp;t1=t t1是Time类对象t的常引用，二者指向同一存储空间，t的值不能改变 2.2.10对象的动态建立和释放12345Box *pt;pt=new Box;cout&lt;&lt;pt-&gt;height;cout&lt;&lt;pt-&gt;volume(); 1Box *pt=new Box(12,15,16); //可以在执行new时，对新建立的对象进行初始化 在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成相关善后清理工作 1delete pt; //释放pt所指向的内存空间 2.2.11对象的赋值和复制(拷贝构造函数） 对象的赋值 123Student stu1,stu2;...stu2=stu1; 注意，用此方式赋值，类的数据成员中不能包括动态分配的数据，否则在赋值时会出现严重后果 对象的复制 1Box box2(box1); //用已有的对象box1去复制出一个新的对象box2 编译系统自动调用复制构造函数，而不会去调用其他构造函数 如果用户未定义复制构造函数，则编译系统会自动提供一个默认的复制构造函数，其作用是简单地复制类中的每个数据成员 C++还提供另一种方便用户的复制形式，但作用都是调用复制构造函数 1Box box2=box1,box3=box2; 123456Student(const Student&amp;stu){ cout&lt;&lt;&quot;Copy-Constructor running!&quot;&lt;&lt;endl; age=stu.age; sex=stu.sex;} 2.2.12静态成员 静态数据成员（即类的各对象共享的数据，只要修改，因为所有对象都引用这一值，故都改变） 静态数据成员不是说数据保持不变，而是说静态数据成员属于类，不是对象，但类的对象可以引用它,如果改变它的值，则在各对象中这个数据成员的值都同时改变了。 123456789class Box{public: int volume();private: static int height; //将height定义为静态的数据成员 int width; int length;};int Box::height=10; //只能在类体外初始化 静态数据成员可以初始化，但只能在类体外进行初始化 在编译阶段（程序还未运行）分配内存（全局区） 不能用参数初始化表对静态数据成员进行初始化 静态数据成员既可以通过对象名引用，也可以通过类名来引用 12cout&lt;&lt;a.height;cout&lt;&lt;Box::height; 静态成员函数 静态成员函数属于类的一部分而不是对象的一部分，如果要在类外调用公用的静态成员函数，要用类名和域运算符:: 123static int volume();Box::volume();a.volume(); 静态成员函数与非静态成员函数的根本区别：非静态成员函数有this指针，而静态成员函数由于属于类而没有this指针,由此决定了静态成员函数不能访问本类中的非静态成员 静态成员函数可以直接引用本类中的静态成员，因为静态成员同样属于类。 C++中，静态成员函数主要用来访问静态数据成员，而不访问非静态成员，假如在一个静态成员函数中有以下语句 12cout&lt;&lt;height&lt;&lt;endl; //height已声明为satic，合法cout&lt;&lt;width&lt;&lt;endl; //width非静态成员，错误 如果一定要用静态成员函数访问本类的非静态成员，只是不能进行默认访问，因为无法知道去找哪个对象 1cout&lt;&lt;a.width; //用静态成员函数访问本类中非静态成员 C++程序员应该养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员 2.2.13友元 将普通函数声明为友元函数 1234567891011class Time{public: Time(int,int,int); friend void display(Time &amp;); //声明display函数为Time类的友元函数}void display(Time &amp;t){ cout&lt;&lt;t.hour;} 友元成员函数 注意在调用非本类中的成员时，必须加上对象名，如display()是另一个函数的友元函数，调用其内容时必须加上其对象名 1234567891011121314151617181920212223242526272829303132333435class Date; //对Date类的提前引用声明class Time{public: Time(int,int,int); void display(Date &amp;); //display是成员函数，形参是Date类对象的引用private: int hour; int minute; int sec;};class Date{public: Date(int,int,int); friend void Time::display(Date &amp;); //声明Time中的display函数为本类的友元成员函数private: int month; int day; int year;};void Time::display(Date &amp;d){ cout&lt;&lt;d.month; //注意在输出Date类的对象中成员时，必须加上对象名d.month}... int main(){ Time t1(10,13,26); Date d1(12,25,2004); t1.display(d1); //调用t1中的display函数，实参是Date类对象d1} 友元类 不仅可以将一个函数声明为一个类的“朋友”,还可以将一个类B声明为另一个类A的“朋友”，这时B类就是A类的友元类，B中的所有函数都时A类的友元函数，可以访问A类中的所有成员 友元类的关系时单向的 友元类的关系不能传递 2.2.14类模板/参数化的类 类模板是类的抽象，类是类模板的实例 类模板可以有一个或多个虚拟的参数类型 12345678910111213template &lt;class numtype&gt;class Compare{public: Compare(numtype a,numtype b); {x=a;y=b;} numtype max() {return(x&gt;y)?x:y;} numtype min() {return(x&lt;y)?x:y;}private: numtype x,y;}; 其中numtype只是表示“数据类型”的意思而已，这个名字可以任意取，只要是合法的标识符即可 如何使用类模板 1Compare &lt;int&gt; cmp(4,7)； 可以这样声明和使用类模板 首先，写出一个实际的类，由于其语义明确，不容易出错 然后，将此类中准备改变的类型名，改用一个自己指定的虚拟类型名（如numtype) 最后，在类声明前加上一行template &lt;class 虚拟类型参数&gt; 在类模板外声明成员函数，前提是声明和类模板必须放在同一文件中 12template&lt;class T1,class T2&gt; //T1 Compare&lt;T1,T2&gt;::max(){...}; 2.2.15仿函数&amp;匿名对象123456789101112131415class myPrint{public: void operator()(string str) { cout &lt;&lt; str; }};int main(){ myPrint obj; obj(&quot;第一个字符串&quot;); cout &lt;&lt; endl; myPrint()(&quot;第二个字符串&quot;); 使用了匿名对象} 2.3运算符重载本章知识点最全最正确的案例Tips:前置运算符返回引用（引用传递），后置运算符返回值（值传递） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;class Complex {public: //默认构造函数 Complex() { real = 0; imag = 0; } //带参构造函数 Complex(double r,double i) :real(r),imag(i){} //重载运算符+ Complex operator+(Complex c) { return Complex(real + c.real, imag + c.imag); } //运算符函数也可以重载 Complex operator+(double num) { return Complex(real + num, imag); } //重载运算符&lt;&lt; friend ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex c); //重载运算符&gt;&gt; friend istream&amp; operator&gt;&gt;(istream&amp; input, Complex &amp;c); //重载运算符前置++ Complex&amp; operator++() { real++; return *this; } //重载运算符后置++ 返回的是值不是引用，即后置++不能链式使用 Complex operator++(int) { Complex c(*this); //或Complex c=*this; 两种方式都可以调用拷贝构造函数 real++; return c; //值传递 }private: double real; double imag;};ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex c){ if (c.imag &gt;= 0) output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; else output &lt;&lt; c.real &lt;&lt; c.imag&lt;&lt;'i'; return output;}istream&amp; operator&gt;&gt;(istream&amp; input, Complex &amp;c){ input &gt;&gt; c.real &gt;&gt; c.imag; return input;} &lt;&lt;运算符重载参数写成引用的话，须这样写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;class Complex {public: //默认构造函数 Complex() { real = 0; imag = 0; } //带参构造函数 Complex(double r,double i):real(r),imag(i){} //重载运算符+ Complex&amp; operator+(Complex &amp;c) { //不能返回局部变量的引用，new在堆区创建对象在函数执行后才不会被销毁 return *(new Complex(real + c.real, imag + c.imag)); //new返回的是地址，要解引用 } //运算符函数也可以重载 Complex&amp; operator+(int num) { Complex*p=new Complex(real + num, imag); return *p; //解引用 } //重载运算符&lt;&lt; friend ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex&amp;c); //重载运算符&gt;&gt; friend istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c); //重载运算符前置++ Complex&amp; operator++() { real++; return *this; } //重载运算符后置++ Complex&amp; operator++(int) { real++; return *this; }private: int real; int imag;};ostream&amp; operator&lt;&lt;(ostream&amp; output, Complex&amp; c){ if (c.imag &gt;= 0) output &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; else output &lt;&lt; c.real &lt;&lt; c.imag&lt;&lt;'i'; return output;}istream&amp; operator&gt;&gt;(istream&amp; input, Complex&amp; c){ input &gt;&gt; c.real &gt;&gt; c.imag; return input;} 2.3.1运算符重载的方法 运算符重载的实质是函数的重载 函数类型 operator 运算符名称(形参表){对运算符的重载处理} c1+c2，编译系统将它解释为c1. operator+ （c2） ，即通过对象c1调用运算符重载函数”operator+”，并以表达式中的第2个参数（运算符右侧的类对象c2）作为函数参数 1234567891011121314151617class Complex //定义复数类{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 void display();private: double real; double imag;};Complex&amp; Complex::operator+(Complex &amp;c2){ Complex *c=new Complex(real+c2.real,imag+c2.imag); return *c;} 2.3.2 重载运算符的规则 C++不允许用户自定义新的运算符，只能对已有的C++运算符进行重载 C++允许重载的运算符，见红C++书p302 不能重载的运算符只有5个 成员访问运算符 . 成员指针访问运算符 * 域运算符 :: 长度运算符 sizeof 条件运算符 ?: 重载不改变运算符的优先级别 重载不能改变运算符的结合性 重载不能改变操作数的个数 重载运算符的函数不能由默认的参数，否则就改变了运算符参数的个数，与上面一点矛盾 重载的运算符必须和用户自定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象（或类对象的引用）。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质 12int operator+(int a,int b){return a-b;} //错误！ 用于类对象的运算符一般必须重载，但有两个例外，运算符“=”和“&amp;”不必用户重载 2.3.3运算符重载函数作为类成员函数和友元函数 对运算符重载的函数有两种处理方式 作为类的成员函数 普通函数，声明为友元函数 123456789101112131415161718class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} friend Complex operator+(Complex &amp;c1,Complex &amp;c2); //重载函数作为友元函数 void display();private: double real; double imag;};Complex&amp; operator+(Complex&amp;c1,Complex&amp;c2){ Complex* c=new Complex(c1.real+c2.real,c1.imag+c2.imag); return *c;} 有的C++编译系统如Visual C++ 6.0没有完全实现C++标准，不支持把运算符重载函数作为友元函数，但是VisualC++6.0提供的老版本的带后缀.h的头文件可以支持 此功能，因此可以把程序头两行改为以下一行 1#include&lt;iostream.h&gt; 由于编译器是将c1+c2解释为c1. operator+ （c2） ，operator+整体作为前者对象的成员函数来调用，如果第一个参数是int型，则运算符重载函数不能作为成员函数，如果函数需要访问私有成员，则必须声明为友元函数 1234567//在Complex类中声明：friend Complex operator+(int &amp;i,Complex &amp;c); //第一个参数可以不是类对象//在类外定义友元函数Complex&amp; operator+(int &amp;i,Complex &amp;c) //运算符重载函数不是成员函数{ Complex *c1=new Complex(i+c.real,c.imag); return *c1;} 将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参列表中必须有两个参数，不能省略，形参的顺序任意。但是在使用运算符的表达式中，要求运算符左侧的操作数与函数第一个参数对应，右侧操作数与第二个参数对应： 12c3=i+c2; //正确c3=c2+i; //错误 如果想使用交换律，必须再重载一次运算符 究竟是把运算符重载函数作为类的成员函数好，还是友元函数好？由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符函数作为成员函数，但还应考虑到各方面的因素和程序员的习惯，以下可供参考 C++规定，=,[],(),-&gt;必须作为成员函数重载 流插入&lt;&lt;和流提取运算符&gt;&gt;，类型转换运算符函数不能定义为类的成员函数，只能作为友元函数 一般将单目运算符和复合运算符+=,-=,/=,*=,&amp;=,!=,^=,%=,&gt;&gt;=,&lt;&lt;=重载为成员函数 一般将双目运算符重载为友元函数 2.3.4重载双目运算符 注意！在其他普通函数中使用重载运算符时，只能以调用重载运算符函数的形式使用 12345void Compare(String &amp;st1,String &amp;str2){ if(operator&gt;(string1,string2)==1) //在别的函数中，只能以operatir&gt;( )的形式使用重载运 算符 ...} 2.3.5重载单目运算符12345678Time Time::operator++(){ if(++sec&gt;=60){ sec-=60; ++minute; } return *this;} 后置++，增加一个int形参就可以实现 12345678910Time Time::operator++(int){ Time temp(*this); //将当前对象的内容复制给新建的对象temp sec++; if(sec&gt;=60){ sec-=60; ++minute; } return temp;} 注意二者区别，前者是先自加然后返回修改后的自身；而后者返回的是自加前的对象，然后对象自加（说白了就是返回一个还没改变的临时镜像，然后原来的对象自增） 2.3.6重载流插入运算符&lt;&lt;和流提取运算符&gt;&gt; 重载的函数形式如下 12istream &amp; operator&gt;&gt;(istream &amp;,用户自定义类&amp;);ostream &amp; operator&lt;&lt;(ostream &amp;,用户自定义类&amp;); 重载运算符&gt;&gt;的函数的第一个参数和函数的类型都必须是istream&amp;类型，第二个参数是要进行输入操作的类。重载&lt;&lt;的函数的第一个参数和函数的类型都必须是ostream&amp;类型，函数第二个参数是要进行输入操作的类。因此只能将重载&lt;&lt; &gt;&gt;的函数作为友元函数，而不能将它们定义为成员函数。(因为运算符重载为成员函数后，如果出现表达式c1+c2,编译系统会把它解释为c1.operator+(c2) ) 为什么重载&lt;&lt;和&gt;&gt;不能用成员函数？因为无法实现cout在左侧!使用成员函数重载运算符后，对象在左边 p&lt;&lt;cout。因此必须用全局函数重载它们。operator&lt;&lt;(cout,p)的简化形式是cout&lt;&lt;p 重载流插入运算符&lt;&lt; 在程序中，人们希望能用插入运算符&lt;&lt;来输出用户自己声明的类的对象的信息，这就需要重载&lt;&lt; 1234567891011121314151617181920212223242526class Complex //定义复数类{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,Complex&amp;); //运算符&lt;&lt;重载为友元函数private: double real; double imag;};... ostream&amp;operator&lt;&lt;(ostream&amp;output,Complex&amp;c){ output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;'+'&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; return output;}int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+c2; cout&lt;&lt;c3;} cout&lt;&lt;c3 cout是头文件iostream中声明的ostream类对象，c3是Complex类对象，由于已将运算符&lt;&lt;的重载函数声明为Complex类的友元函数，编译系统把cout&lt;&lt;c3解释为：operator&lt;&lt;(cout,c3),即以cout和c3作为实参，调用上面的operator&lt;&lt;函数。调用函数时形参output成为实参cout的引用，形参c成为c3的引用。 return output的作用：output是cout的引用即别名，相当于return cout，将输出流cout的现状返回，即保留输出流的现状，目的是连续向输出流插入信息 123cout&lt;&lt;c3&lt;&lt;c2;//即(cout&lt;&lt;c3)&lt;&lt;c2; 执行(cout&lt;&lt;c3)的结果就是具有新内容的流对象cout，因此(cout&lt;&lt;c3)&lt;&lt;c2相当于cout(新值)&lt;&lt;c2,现在理解为什么C++规定运算符&lt;&lt;重载函数的第一次参数和函数的类型必须是ostream类型的引用了吧！就是为了返回cout当前值以便连续输出 重载流提取符&gt;&gt; C++预定义的运算符&gt;&gt;的作用是从一个输入流中提取数据，如cin&gt;&gt;i,表示从输入流中提取一个整数赋给变量i。重载流提取符的目的是希望将&gt;&gt;用于输入自定义类型的对象的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i){real=r;imag=i;} Complex operator+(Complex &amp;c2); //声明重载运算符+的函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,Complex&amp;); //运算符&lt;&lt;重载为友元函数 friend istream&amp;operator&gt;&gt;(istream&amp;,Complex&amp;); //运算符&gt;&gt;重载为友元函数private: double real; double imag;};Complex Complex::operator+(Complex &amp;c2){ return Complex(real+c2.real,imag+c2.imag);}ostream&amp;operator&lt;&lt;(ostream&amp;output,Complex&amp;c){ if(c.imag&gt;=0) output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;'+'&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; else output&lt;&lt;'('&lt;&lt;c.real&lt;&lt;c.imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl; return output;}istream&amp;operator&gt;&gt;(istream&amp;input,Complex&amp;c){ cout&lt;&lt;&quot;Input real part and imaginary part of complex number:&quot;; input&gt;&gt;c.real&gt;&gt;c.imag; return input;}int main(){ Complex c1,c2; cin&gt;&gt;c1&gt;&gt;c2; cout&lt;&lt;&quot;c1=&quot;&lt;&lt;c1; cout&lt;&lt;&quot;c2=&quot;&lt;&lt;c2;} 2.3.7赋值运算符重载 C++至少给一个类添加四个函数： 1.默认构造函数2.默认析构函数3.默认拷贝构造函数4.赋值运算符operator=,对属性值进行拷贝 如果不对赋值运算符进行重载，在堆区开辟内存了的类，如果进行p1=p2赋值运算，在销毁时可能会发生堆区内存重复释放12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class Person{public: Person(int a) { //new在堆区开辟内存存放数字，返回地址 agePointer = new int(a); } //在堆区开辟的内存，需要程序员自行销毁 ~Person() { //需要先判断是否指向空，因为如果指向空，不能对该指针进行detele操作 //增强程序健壮性 if (agePointer!= NULL) { delete agePointer; agePointer= NULL; } } int*agePointer;};void func(){ Person p1(10), p2(20); p1 = p2; 函数执行完后p1，p2均会调用析构函数对堆区中同一块内存 进行delete操作（重复释放），导致程序出错！}int main(){ func();} 对赋值运算符operator=进行重载12345678Person&amp; operator=(Person &amp;p) 返回引用以实现 p1=p2=p3{ 先将自己占用的内存释放干净 if (agePointer != NULL) delete agePointer; agePointer = new int(*p.agePointer); return *this;} 2.3.8 ==和!=运算符重载12345678910111213141516171819202122232425262728293031class Car{public: Car(string b, string l) { brand = b; licenseNum = new string(l); } ~Car() { if (licenseNum != NULL) { delete licenseNum; licenseNum = NULL; } } bool operator==(Car &amp;c) { if (this == &amp;c) return true; if (brand == c.brand &amp;&amp; *licenseNum == *c.licenseNum) return true; return false; } bool operator!=(Car c) { return !(*this == c); }private: string brand; string* licenseNum;}; 2.3.9 函数调用运算符（）重载由于重载后使用的方式非常像函数的调用，因此被成为仿函数仿函数没有固定的写法，非常灵活2.4不同类型数据间的转换 2.4.1标准数据类型间的转换 C++保留了C语言的强制转换方式(int)89.5,提倡C++提供的方法int(89.5) 2.4.2用构造函数进行不同类型数据的转换 转换构造函数的作用是将一个其他类型的数据转换成一个类的对象 回顾以前学过的几种构造函数： 默认构造函数 1Complex(); //没有参数 用于初始化的构造函数 1Complex(double r,double i); 用于复制对象的复制构造函数 1Complex(Complex &amp;c); //形参是本类对象的引用 现在要介绍一种新的构造函数——转换构造函数，转换构造函数只有一个形参，如 123Complex(double r){real=r;imag=0;}//这样就可以将一个double类型的数据 强制转换 为一个Complex类对象c=c1+Complex(2.5); //运算符+已重载 其作用是将double型的参数r转换成Complex类的对象，将r作为复数的实部，虚部为0。用户可以根据需要定义转换构造函数，在函数体中告诉编译系统怎样去进行转换 转换构造函数只能有一个参数，如果有多个参数的，它就不是转换构造函数!原因是显然的，如果有多个参数，那么究竟将哪个转换为Complex对象呢？ 不仅可以将一个标准数据类型转换为类对象，还可以将另一个类对象转换为 转换构造函数所在的类对象。如果，可以将一个学生类对象转换为教师类对象（学生毕业后当了老师），要求把某学生的编号、姓名、性别复制到一个教师类对象中，可以在Teacher类中写出如下的转换构造函数 1Teacher(Student&amp;s){num=s.num;strcpy(name,s.name);sex=s.sex;} 同时应注意，对象s中的num，name，sex必须是共用成员，否则不能被类外引用 2.4.3类型转换函数 类型转换函数的作用是将一个类的对象转换成另一个类型的数据。如果已声明了一个Complex类，可以在Complex类中这样定义类型转换函数： 12operator double(){return real;}x` 123456789101112131415161718class Complex{public: Complex(){real=0;imag=0;} Complex(double r,double i):real(r),imag(i){} operator double(){return real;} //定义类型转换函数private: double real; double imag;};int main(){ Complex c1(3,4),c2(5,-10),c3; double d; d=2.5+c1; //隐式地调用类型转换函数 cout&lt;&lt;d&lt;&lt;endl;} 注意，函数名是operator double,函数没有参数,其返回值的类型是由函数名中指定的类型名来确定的。类型转换函数只能作为成员函数，因为转换的主体是本类的对象。不能作为友元函数或普通函数。 double类型经过重载后，除了原有的含义外，还获得新的含义（将一个Complex类对象转换为double类型数据，并指定了转换方法）。这样，编译系统不仅能识别原有的double型数据，而且还会把Complex类对象作为double型数据处理。Complex类对象只有在需要的时候才进行转换，要根据表达式的上下文来确定 ！！！注意，重载运算符+的友元函数时，参数不能使用引用，否则会导致类型转换出错 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class Complex{public: Complex(){real=0;imag=0;} //默认构造函数，无形参 Complex(double r){real=r;imag=0;} //转换构造函数，一个形参 Complex(double r,double i){real=r;imag=i;} //实现初始化的构造函数，两个形参 friend Complex operator+(Complex c1,Complex c2); //重载运算符+的友元函数 //注意此处没有使用引用，如果使用引用会导致无法类型转换 void display();private: double real; double imag;};Complex operator+(Complex c1,Complex c2){ return Complex(c1.real+c2.real,c1.imag+c2.imag);}void Complex::display(){ cout&lt;&lt;'('&lt;&lt;real&lt;&lt;','&lt;&lt;imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl;}int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+2.5; //复数与double数据相加 c3.display();} 程序分析 如果没有定义转换构造函数，则此程序出错，因为没有重载运算符能使之将Complex类对象与double数据相加，由于c3是Complex类对象，必须设法将2.5转换为Complex类对象，然后与c1相加，再赋值给c3 现在，再类Complex中定义了转换构造函数，并具体规定了怎样构成一个复数。由于已经重载了运算符+，再处理表达式c1+2.5时，编译系统把他解释为 1operator+(c1,2.5); 由于2.5不是Complex类对象，系统先调用转换构造函数Complex(2.5),建立一个临时的Complex类对象，其值是(2.5+0i)。相当于 1operator+(c1,Complex(2,5)); 如果把c3=c1+2.5改为c3=2.5+c1，同样可以运行！ 结论 在已经定义了相应转换构造函数的情况下，将运算符+函数重载为友元函数，在进行两个复数相加时，可以用交换律 如果运算符函数重载为成员函数，它的第一个参数必须是本类的对象。交换律不适用！ 因此，一般情况下将双目运算符函数重载为友元函数，单目运算符则多重载为成员函数 1234567891011121314151617181920class Complex{public: Complex(){real=0;imag=0;} //默认构造函数，无形参 Complex(double r){real=r;imag=0;} //转换构造函数，一个形参 Complex(double r,double i){real=r;imag=i;} //实现初始化的构造函数，两个形参 operator double(){return real;} //类型转换函数，无形参 friend Complex operator+(Complex c1,Complex c2); //重载运算符+的友元函数 void display();private: double real; double imag;};...int main(){ Complex c1(3,4),c2(5,-10),c3; c3=c1+2.5; //复数与double数据相加 c3.display();} 编译报错，原因是出现二义性，在处理c1+2.5时，一种理解是调用转换构造函数将2.5变成Complex类对象，然后调用运算符+重载函数，与复数c1进行相加。另一种理解是，调用类型转换函数，把c1转换为double型数，然后与2.5进行相加。系统无法判定，这二者是矛盾的。如果要使用类型转换函数，就应删去运算符+重载函数。 2.4 对象的初始化和清理2.4.1 构造函数的分类及调用三类：构造函数、拷贝构造函数、析构函数调用：1.括号法 123Person p1; 默认构造函数（注意不要加括号，否则会被认为是函数声明）Person p2(10); 有参构造函数Person p3(p2); 拷贝构造函数 2.显示法 1234Person p1;Person p2=Person(10); 有参构造Person p3=Person(p2); 拷贝构造注意事项：不要用拷贝构造函数初始化匿名对象：Person(p2); 3.隐式转换法 1Person p1=10; 系统会自动转换为Person p1=Person(10); 2.4.2 拷贝构造函数的调用时机1.使用一个已经创建完毕的对象来初始化一个新对象Person p2(p1);2.值传递的方式给函数参数传值 123void func(Student stu) {}函数体为空，参数为类对象，函数参数值传递相当于拷贝一份临时的数据，会调用拷贝构造函数 3.值方式返回局部对象 123456789101112Student returnValue() { Student stu; return stu; 此时并不是返回上面的stu本身，而是返回一份拷贝数据}int main() { Student stu = returnValue();}运行结果：默认构造函数调用拷贝构造函数调用析构函数调用析构函数调用 2.4.3构造函数调用规则默认情况下，C++编译器至少会给一个类添加三个函数1.默认构造函数（无参，类体为空）2.默认析构函数（无参，类体为空）3.默认拷贝构造函数，对属性值进行拷贝 构造函数调用规则如下：1.如果用户定义了有参构造函数，C++不再提供默认无参构造函数，但是会提供拷贝构造函数2.如果用户定义了拷贝构造函数，C++不再提供其他构造函数 2.4.4深拷贝与浅拷贝问题（面试常考）浅拷贝：简单的赋值拷贝操作(编译系统赠送的拷贝构造函数）深拷贝：在堆区重新申请空间，进行拷贝操作 浅拷贝存在的问题：可能造成堆区内存的重复释放 12345678910111213141516171819202122232425262728在此情况下，如果使用了浅拷贝的拷贝构造函数，将造成同一块内存区域的重复释放原因：浅拷贝简单地把在堆区开辟的内存的地址复制到新的对象中class Student{public: Student(int a,int h) { age=a; height=new int(h); 堆区开辟内存，使指针height指向该内存 } ~Student() { if(height!=NULL) { delete height; height=NULL: } }private: int age; int*height;};int main(){ Student stu1(22, 170); Student stu2(stu1); } 解决方法：自己实现拷贝构造函数 1234Student(const Student&amp; stu) { age = stu.age; height = new int(*stu.height);} 三、面向对象的程序设计 3.1继承与派生C++提供了类的继承机制，解决了软件重用问题 3.1.1继承与派生的概念 单继承：一个派生类只从一个基类派生 多重继承：一个派生类有两个或多个基类 派生类是基类的具体化，而基类则是派生类的抽象 3.1.2派生类的声明方式123class Student1:public Student{派生类新增加的成员}; 构造函数和析构函数不能从基类继承，因此应当自己定义派生类的构造函数和析构函数 只能覆盖，不能舍弃基类成员，可以在派生类中声明一个与基类成员同名的成员以覆盖（注意覆盖成员函数需要保持函数类型，参数个数，参数类型相同 3.1.3派生类成员的访问属性 公用继承：基类私有不可访问（即没有继承下来，要访问还得用基类的成员函数），其他保持原有不变 私有继承：基类私有不可访问，剩下的变为派生类的私有成员 基类的公用成员函数变成了派生类的私有成员函数，不能直接调用 123456789101112131415161718192021222324252627282930313233343536373839404142using namespace std;class Student{public: void get_value(){ cin&gt;&gt;num&gt;&gt;name&gt;&gt;sex;} void display() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;&quot;sex:&quot;&lt;&lt;sex&lt;&lt;endl; }private: int num; string name; char sex;};class Student2:private Student //私有继承{public: void get_value_1() { get_value(); //基类的公用函数被私有继承为私有函数，故只能通过基类函数调用它 cin&gt;&gt;age&gt;&gt;addr; } void display_1() { display(); cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl&lt;&lt;&quot;address:&quot;&lt;&lt;addr&lt;&lt;endl; }private: int age; string addr;};int main(){ Student2 stu; stu.get_value(); //错误！基类的公用函数已被私有继承为私有函数，不能直接调用 stu.get_value_1(); //正确，这是派生类的函数，通过其调用基类的共有成员函数} 受保护的继承：基类私有成员不可访问，剩下的变成派生类的受保护的成员（外界不可访问，如用xx.num) 保护继承的特点：保护基类的公有成员和保护成员都在派生类中成了保护成员，其私有成员仍未基类私有，也就是把基类原有的公有成员也保护了起来，不让类外任意访问 总之，基类私有不可被派生类访问，只能通过基类的成员函数来引用 实际中，公用继承用的最多，私有继承和保护继承方式用的很少，只需了解以便阅读别人写的程序时能理解 3.1.4派生类的构造函数 简单的派生类的构造函数 12345678910111213141516171819202122232425262728class Student{public: Student(int n,string nam,char s):num(n),name(nam),sex(s){} ~Student(){}protected: int num; string name; char sex;};class Student1:public Student{public: Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } void show() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;address:&quot;&lt;&lt;addr&lt;&lt;endl; } ~Student1(){}private: int age; string addr;}; 注意派生类的构造函数，Student(n,nam,s)不需要写类型，因为相当于把前面传进来的参数摘给后边 12345Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } 如果在类内声明，类体外定义则不需写Student(n,nam,s) 12345678//类内Student1(int n,string nam,char s,int a,string ad);//类外定义Student1::Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) { age=a; addr=ad; } 还可以直接使用常量或全局变量 1Student1(int n,string nam,char s,int a,string ad):Student(10010,nam,s) 也可以用参数初始化表 1Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s),age(a),addr(ad){} 执行构造函数和析构函数的顺序： 派生类构造函数先调用基类构造函数 再执行派生类构造函数本身（即派生类构造函数的函数体），上述例中：先初始化num,name,sex再初始化age,addr 在派生类对象释放时，先执行派生类析构函数，再执行基类析构函数 有子对象的派生类的构造函数 指的是成员中含有对象的对象 123456789101112131415//基类中Student(int n,string nam):num(n),name(nam){}//派生类中public: Student1(int n,string nam,int n1,string nam1,int a,string ad) :Student(n,nam),monitor(n1,nam1)//派生类构造函数 { age=a; addr=ad; }...private: Student monitor; //私有成员中含有类对象 int age; string addr; 派生类构造函数的任务包括三个部分 对基类数据成员的初始化 对子对象数据成员的初始化 对派生类数据成员初始化 3.1.5多层派生时的构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student{public: Student(int n,string nam):num(n),name(nam){} void display() { cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; }protected: int num; string name;};class Student1:public Student{public: Student1(int n,string nam,int a):Student(n,nam) { age=a; } void show() { display(); cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl; }private: int age;};class Student2:public Student1{public: Student2(int n,string nam,int a,int s):Student1(n,nam,a) { score=s; } void show_all() { show(); cout&lt;&lt;&quot;score:&quot;&lt;&lt;score&lt;&lt;endl; }private: int score;}; 3.1.6派生类构造函数的特殊形式 不需要对派生类新增的成员进行任何初始操作时，派生类构造函数的函数体可以为空 1Student2(int n,string nam,int a,int s):Student1(n,nam,a){} 另一种怪麻烦的，请查谭浩强C++第三版P356页 3.1.7继承后子类是否保留父类数据 子类中所有非静态成员变量都会保留到子类中* 123456789101112131415161718192021class Father{public: int a;protected: int b;private: int c;};class Son :public Father{public: int d;};int main(){ cout &lt;&lt; &quot;Son的大小是&quot; &lt;&lt; sizeof(Son) &lt;&lt;&quot;字节&quot;&lt;&lt; endl; 输出结果是16字节，说明子类完全地保留了父类的数据} 使用VS自带的工具开发者命令提示工具可以查看类的结构 1.找到文件路径，输入如下命令D:\\Codes\\VisualStudioProjects\\Project01\\继承后的父类数据是否拷贝&gt;cl /d1 reportSingleClassLayoutSon 源.cpp 123456789class Son size(16): +--- 0 | +--- (base class Father) 0 | | a 4 | | b 8 | | c | +---12 | d +--- 3.1.8继承中的构造和析构顺序创建一个子类对象，其中构造函数和析构函数的顺序如下：1.父类构造函数2.子类构造函数3.子类析构函数4.父类析构函数面试题：创建一个子类对象会不会有父类对象的创建？答：有！ 3.1.9继承中的同名成员处理加上作用域::即可。注意一下情形：子类中的同名函数会隐藏掉父类中所有同名函数（包括所有重载形式）需要加作用域才能调用 继承同名静态成员的处理方式：1.同名静态数据成员（编译阶段分配内存，类内声明，类外初始化）2.同名静态成员函数处理方式仍然是加上父类作用域以访问父类静态成员有两种方式:1.Father::num2.Son::Father::num 3.2多重继承(multiple inheritance)实际开发中不建议使用多继承 3.2.1多重继承的声明12class D:public A,private B,protected C{类D新增加的成员} 3.2.2多重继承派生类的构造函数12Graduate(string nam,int a,char s,string t,float sco,float w): Teacher(nam,a,t),Student(nam,s,sco),wage(w){} 3.2.3多重继承引起的二义性问题 第一种情况：两基类有同名成员 加上限定符即可，如c1.A::display(); 若在派生类C中的成员函数访问基类A的display,则A::display(); 第二种情况：两个基类和派生类三者都有同名成员，即有3个display函数 答案时：会产生覆盖，基类的同名函数（注意要保持函数类型、参数个数、参数类型相同，否则就是重载）被派生类函数覆盖 如果类A和类B是从同一个基类N派生的 应该加上限定符A::或B::,如c1.A::a=3;c1.A::display();//要访问的是类N的派生类A中的基类成员 3.3解决菱形继承问题——虚基类菱形继承：子类继承两份相同的数据，导致资源浪费以及含义的冲突（如年龄） 3.3.1虚基类的作用C++提供虚基类virtual base class的方法，使得在继承简介共同基类时只保留一份成员 12345graph LRA[A] -- 派生 --&gt; B[B]A --派生--&gt; C[C]B --派生--&gt; D[D]C --派生--&gt; D 现在将类A声明为虚基类，虚基类是在声明派生类时，指定继承方式时声明的！ 123456class A{...};class B:virtual public A{...};class C:virtual public A{...}; 3.3.2虚基类的初始化如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类（包括直接派生类和间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类进行初始化，因为只有一份数据，如果由B和C分别初始化，会造成数据不一致发生矛盾 123456789101112class A{A(int i){} //基类构造函数，有一个参数..}class B:virtual public A{B(int n):A(n){}...};class C:virtual public A{C(int n):A(n){}...};class D:public B,public C{D(int n):A(n),B(n),C(n){} //D类构造函数，在初始化表中对所有基类初始化...} C++编译器只执行最后的派生类对虚基类的构造函数的调用，忽略其他的，保证虚基类的数据成员不会被多次初始化多重继承容易产生二义性问题，如果能用单一继承解决得问题不要使用多重继承 3.3.3基类与派生类的转换 派生类对象可以向基类对象赋值，相反则不可以 派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化 12345假设已定义Point类，和派生类CircleCircle c(1,2,3);//输出的是半径为3的圆Point&amp;p=c; //p和c共享 基类Point那一段存储空间此时p是c的部分引用，注意是部分！p共享c的基类那一部分存储空间，故cout&lt;&lt;p; //输出的是(1,2)点信息 如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象 12345如有一函数funvoid fun(A&amp;r) //形参是A类对象的引用{cout&lt;&lt;r.num&lt;&lt;endl;} //输出该引用中的数据成员num//在调用fun函数时可以用派生类B的对象b1作实参fun(b1); 指向基类对象的指针变量也可以指向派生类对象，但通过指向基类对象的指针只能访问派生类中的基类成员，而不能访问派生类增加的成员 3.4继承与组合123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;class Teacher{public: Teacher(int n,string nam,char s):num(n),name(nam),sex(s){} void display() { cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;&quot;name=&quot;&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;&quot;sex=&quot;&lt;&lt;sex&lt;&lt;endl; }private: int num; string name; char sex;};class BirthDate{public: BirthDate(int y,int m,int d):year(y),month(m),day(d){} void display() { cout&lt;&lt;year&lt;&lt;'/'&lt;&lt;month&lt;&lt;'/'&lt;&lt;day&lt;&lt;endl; }private: int year; int month; int day;};class Professor:public Teacher{public: Professor(int n,string nam,char s,int y,int m,int d) :Teacher(n,nam,s),birthday(y,m,d){} void show() { Teacher::display(); //对同名函数加上限定符 birthday.display(); }private: BirthDate birthday;}; 3.5多态性与虚函数3.5.1多态性的概念多态的实质：父类引用指向子类对象多态性：向不同的对象发送同一消息，不同的对象在接收时会产生不同的行为（即方法），分为静态多态性和动态多态性。 静态多态性的应用即函数的重载和运算符重载,编译阶段确定函数地址 动态多态性的特点是：在程序运行过程中动态地确定操作所针对的对象，又称运行时的多态性，是通过虚函数来实现的。运行阶段确定函数地址3.5.2静态多态性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104using namespace std;class Point //点类{public: Point(float x=0,float y=0); void setPoint(float,float); float getX()const{return x;} //读x坐标，getX函数为常成员函数 float getY()const{return y;} //读y坐标，getY函数为常成员函数 friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Point&amp;);//友元重载运算符&lt;&lt;protected: float x,y;};Point::Point(float a,float b){ x=a;y=b;}void Point::setPoint(float a,float b){ x=a;y=b;}ostream&amp;operator&lt;&lt;(ostream&amp;output,const Point&amp;p) //重载运算符&lt;&lt;，使之能输出点的坐标{ output&lt;&lt;'['&lt;&lt;p.x&lt;&lt;','&lt;&lt;p.y&lt;&lt;']'&lt;&lt;endl; return output;}//派生类Circleclass Circle:public Point{public: Circle(float x=0,float=0,float=0);//带默认参数的构造函数 void setRadius(float); //设置半径值 float getRadius()const; //读取半径值 常成员函数不能修改数据 float area()const; //计算圆面积 设置为常成员函数不能修改数据 friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Circle &amp;); //重载运算符&quot;&lt;&lt;&quot;,使之能输出Circle类对象protected: float radius;};//定义构造函数，对圆心坐标和半径初始化Circle::Circle(float a,float b,float r):Point(a,b),radius(r){}//设置半径void Circle::setRadius(float r){ radius=r;}//读取半径值float Circle::getRadius()const{ return radius;}//计算面积float Circle::area()const{ return 3.14159*radius*radius;}//重载运算符“&lt;&lt;&quot;，使之能按规定的形式输出圆的信息ostream&amp;operator&lt;&lt;(ostream&amp;output,const Circle&amp;c){ output&lt;&lt;&quot;Center=[&quot;&lt;&lt;c.x&lt;&lt;','&lt;&lt;c.y&lt;&lt;&quot;],r=&quot;&lt;&lt;c.radius&lt;&lt;&quot;,area=&quot;&lt;&lt;c.area()&lt;&lt;endl; return output;}//Cylinder是Circle的公用派生类（圆柱体）class Cylinder:public Circle{public: //带默认参数的构造函数，若对应数据项不输入则取默认值 Cylinder(float=0,float=0,float=0,float=0); //构造函数初始化 /*Cylinder(float a,float b,float r,float h) :Circle(a,b,r),height(h){} 定义了全部都是默认参数的构造函数后不能再重载构造函数，否则会发生矛盾*/ void setHeight(float h){height=h;} float getHeight()const{return height;} float volume()const; friend ostream&amp;operator&lt;&lt;(ostream&amp;,const Cylinder&amp;); //运算符重载只能声明为友元函数，申明为成员函数默认参数为本类对象private: float height;};Cylinder::Cylinder(float a,float b,float r,float h):Circle(a,b,r){height=h;}ostream&amp;operator&lt;&lt;(ostream&amp;output,const Cylinder&amp;c){ output&lt;&lt;'['&lt;&lt;c.x&lt;&lt;','&lt;&lt;c.y&lt;&lt;&quot;],r=&quot;&lt;&lt;c.radius&lt;&lt;&quot;,height=&quot;&lt;&lt;c.height&lt;&lt;&quot;,volume=&quot;&lt;&lt;c.volume()&lt;&lt;endl;}float Cylinder::volume()const{ return area()*height;}int main(){ Cylinder c; cout&lt;&lt;c; Circle&amp;cir=c; //此时cir部分引用Cylinder类对象c， cout&lt;&lt;cir; //输出的是c的Circle基类部分 Point&amp;po=c; cout&lt;&lt;po;} 3.5.3利用虚函数实现动态多态性所谓虚函数就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。在程序运行期间，用指针指向某一派生类对象，这样就能调用指针指向的派生类对象中的函数，而不会调用其他派生类中的函数。注意：虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。虚函数的使用方法是： 在基类中用virtual声明成员函数为虚函数。在类外定义虚函数时不必再加virtual 在派生类中重新定义此函数，函数名、函数类型、参数个数和类型必须与基类的虚函数相同，根据派生类的需要重新定义函数体。当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时可以加virtual，也可以不加。但是习惯上一般在每一层声明该函数时都加virtual，使程序更清晰。 定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。 通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数 123456Student stud1(1001,&quot;Li&quot;,99); Graduate grad1(2001,&quot;Wang&quot;,98,1200); Student*pt=&amp;stud1; pt-&gt;display(); pt=&amp;grad1; //指向基类对象类型的指针，直接修改指向 pt-&gt;display(); 未定义虚函数时，结果是： 1234567num:1001name:Liscore:99num:2001name:Wangscore:98 //调用了基类对象的display()函数 定义虚函数后，结果是： 12345678num:1001name:Liscore:99num:2001name:Wangscore:98wage=1200 //调用了子类对象的display()函数 3.5.4在什么情况下应当声明虚函数 使用虚函数需要注意以下两点 不能将类外的普通函数声明为虚函数 一个成员函数被声明为虚函数后，在同一类族中的类就不能再定义一个非virtual得但与该虚函数具有相同得参数和函数返回值类型得同名函数 根据什么考虑把一个成员函数声明为虚函数 首先看成员函数所在的类是否会作为基类。然后看成员函数再类的继承后有无可能被更改功能，如果希望其更改功能的，一般应声明为虚函数 如果成员函数在类被继承后功能无需修改，或在派生类中用不到该函数，则不要把他声明为虚函数。 应考虑对成员函数的调用是通过对象名还是通过基类指针或引用去访问，如果是通过基类指针或引用去访问，则应当声明为虚函数。‘ 有时，在定义虚函数时，并不定义其函数体，即函数体是空的。它的作用只是定义了一个虚函数名，具体功能留给派生类去添加。 需要说明的是：使用虚函数，系统有一定的时空开销。当一个类带有虚函数时，编译系统会为该类构造一个虚函数表(virtual function table，简称vtable)，它是一个指针数组，存放每个虚函数的入口地址，系统在进行动态关联时的时间开销是很小的，因此，多态性是高效的。 3.5.5虚析构函数析构函数的作用是在对象撤销之前做必要的“清理现场”的工作。当派生类的对象从内存中撤销时，一般先调用派生类的析构函数，然后调用基类的析构函数。但是如果用new运算符建立了临时对象，若基类中有析构函数，并且定义了一个指向该基类的指针变量。在程序中用delete运算符撤销对象时，会发生一个情况：系统只会执行基类的析构函数，而不执行派生类的析构函数。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Point{public: Point(){} ~Point(){cout&lt;&lt;&quot;Executing Point destructor&quot;&lt;&lt;endl;}};class Circle:public Point{public: Circle(){} ~Circle(){cout&lt;&lt;&quot;executing Circle destuctor&quot;&lt;&lt;endl;}private: int radius;};int main(){ Point*p=new Circle; delete p;} 此时，执行结果是：Executing Point destructor只调用了基类的析构函数。如果希望能执行派生类circle的析构函数，可以将基类中的析构函数声明为虚函数 1virtual~Point(){cout&lt;&lt;&quot;Executing Point destructor&quot;&lt;&lt;endl;} 此时执行结果便是executing Circle destructorExecuting Point destructor 虚构函数的概念和用法很简单，但它在面向对象程序设计中是很重要的技巧。专业人员一般都习惯声明虚析构函数，即使基类并不需要析构函数，也显式地定义一个函数体为空的虚析构函数，以保证在撤销动态分配空间时能得到正确的处理。 构造函数不能声明为虚函数。因为在执行构造函数时类对象还未完成建立过程，当然谈不上把函数与类对象的绑定。3.5.6多态的原理剖析多态的原理：用虚函数表来实现的声明了虚函数的类中，会添加一个vfptr虚函数表指针，指向自己的虚函数表vftable我们使用vs开发人员命令提示符查看该类的结构,结果如下：类的代码1234567class Animal{public: virtual void sound() { cout &lt;&lt; &quot;动物叫~&quot; &lt;&lt; endl; }}; 查看结果1234567891011class Animal size(4): +--- 0 | {vfptr} +---Animal::$vftable@: | &amp;Animal_meta | 0 0 | &amp;Animal::sound //记录下虚函数入口地址Animal::sound this adjustor: 0 如果子类没有重写父类方法，子类结构：1234567891011class Cat size(4): +--- 0 | +--- (base class Animal) 0 | | {vfptr} | +--- +---Cat::$vftable@: | &amp;Cat_meta | 0 0 | &amp;Animal::sound //存放的是父类sound函数的入口地址 重写父类方法后，子类结构：1234567891011class Cat size(4): +--- 0 | +--- (base class Animal) 0 | | {vfptr} | +--- +---Cat::$vftable@: | &amp;Cat_meta | 0 0 | &amp;Cat::sound 3.6纯虚函数与抽象类3.6.1纯虚函数 声明纯虚函数pure virtual function 1virtual float area(参数列表)const=0;//只需在虚函数声明后再加=0，const不是必要 纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：我在这里声明了一个虚函数，留待派生类中定义。3.6.2抽象类不用来定义对象，而只作为一种基本类型用作继承的类，成为抽象类abstract class)，由于它常用作基类，通常称为抽象基类abstract base class。凡是包含纯虚函数的类都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类无法建立对象，抽象类的作用是作为一个类族的共同基类，或者说为一个类族提供一个公共接口。 *继承抽象类的子类如果不对所有的纯虚函数进行重写，那么它也是一个抽象类，不能实例化。好多的面向对象的系统，其层次结构的顶部是一个抽象基类，甚至顶部有好几层都是抽象类。如果在抽象类所派生出的新类中对基类的所有纯虚函数进行了定义，那么这些函数就被赋予了功能，可以被调用。这个派生类就成为了具体类**concrete class。虽然抽象类不能定义对象（或者说抽象类不能实例化），但是可以定义指向抽象类数据的指针类型。当派生类成为具体类后，就可以用这种指针指向派生类对象，然后通过调用虚函数，实现多态性的操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;class AbstractMakeDrink{public: virtual void spoilWater() = 0; virtual void putIn() = 0; virtual void addThings() = 0;};class makeTea :public AbstractMakeDrink{public: void spoilWater() { cout &lt;&lt; &quot;正在为茶烧开水&quot; &lt;&lt; endl; } void putIn() { cout &lt;&lt; &quot;将茶放入开水中&quot; &lt;&lt; endl; } void addThings() { cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl; }};class makeCoffee :public AbstractMakeDrink{public: void spoilWater() { cout &lt;&lt; &quot;正在为咖啡烧开水&quot; &lt;&lt; endl; } void putIn() { cout &lt;&lt; &quot;将咖啡放入开水中&quot; &lt;&lt; endl; } void addThings() { cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl; } };void makeDrinks(AbstractMakeDrink* ptr){ ptr-&gt;spoilWater(); ptr-&gt;putIn(); ptr-&gt;addThings(); delete ptr;}void test(){ makeDrinks(new makeCoffee); cout &lt;&lt; &quot;=======================&quot; &lt;&lt; endl; makeDrinks(new makeTea);}int main(){ test();} 3.6.3虚析构与纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码解决方式：将父类中的析构函数改为虚析构函数或纯虚析构函数二者共性： 1.可以解决父类指针释放子类对象2.都需要有具体的函数来实现 虚析构和纯虚析构的区别：如果是纯虚析构，那么该类属于抽象类，无法实例化 虚析构语法:virtual ~类名(){}纯虚析构语法:virtual~类名()=0;类名::~类名(){}同时需要具体实现！否则报错 说白了虚析构的作用，就是弥补多态不能调用子类析构函数的的缺陷（父类中如果不写虚析构或纯虚析构，那么多态下是不会执行子类析构代码的） 总结：1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构3.拥有虚析构的类是抽象类，不饿能实例化 四、文件操作C++中对文件进行操作需要包含头文件&lt;fstream&gt; 文件分为两种类型：1.文本文件：文件以文本的ASCII码形式存储在计算机中2.二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂 操作文件的三大类：1.ofstream:写操作2.ifstream:读操作3.fstream：读写操作 4.1文本文件4.1.1写文件写文件步骤：1.包含头文件#include&lt;fstream&gt;2.创建流对象ofstream ofs;3.打开文件ofs.open(&quot;文件路径&quot;,打开方式);4.写数据ofs&lt;&lt;&quot;写入的数据&quot;&lt;&lt;endl;5.关闭文件ofs.close(); 文件打开方式| 打开方式 | 解释 || ————————————————- | —————————- || ios::in | 读文件 || ios::out | 写文件 || ios::ate | 初始位置：文件尾 || ios::app | 追加方式写文件 || ios::trunc | 如果文件存在，先删除，再创建 || ios::binary | 二进制方式 || 注意：文件打开方式可以配合使用，利用操作符| | | 4.1.2读文件读文件步骤：1.包含头文件#include&lt;fstream&gt;2.创建流对象ifstream ifs;3.打开文件ifs.open(&quot;文件路径&quot;,打开方式);4读数据：四种方式读取5.关闭文件ofs.close(); 四种方式案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;void test01(){ ofstream ofs; ofs.open(&quot;ForMyBaby.txt&quot;, ios::out); ofs &lt;&lt; &quot;亲爱的宝宝&quot;&lt;&lt;endl&lt;&lt;&quot;我想你啦&quot;; ofs.close();}void readFileWay1(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; } char buf[1024] = { 0 }; while (ifs &gt;&gt; buf) //一次读一行，读到整个文件末尾返回false { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay2(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } char buf[1024] = { 0 }; while (ifs.getline(buf, sizeof(buf))) { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay3(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } string buf; while (getline(ifs, buf)) { cout &lt;&lt; buf &lt;&lt; endl; } ifs.close();}void readFileWay4(){ ifstream ifs; ifs.open(&quot;ForMyBaby.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } char c; while ((c = ifs.get()) != EOF)//end of file { cout &lt;&lt; c; } ifs.close();} 4.2二进制文件的读写123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class Phone{public: char brand[64]; int price;};void writeBinary(){ ofstream fs(&quot;BinaryFile.txt&quot;, ios::out|ios::binary); Phone apple = { &quot;Apple&quot;,5888 }; fs.write((const char*)&amp;apple, sizeof(apple)); fs.close();}void readBinary(){ ifstream fs(&quot;BinaryFile.txt&quot;, ios::out | ios::binary); if (!fs.is_open()) { cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl; return; } Phone p; fs.read((char*)&amp;p, sizeof(Phone)); cout &lt;&lt; &quot;手机品牌:&quot; &lt;&lt; p.brand &lt;&lt; &quot;,手机价格:&quot; &lt;&lt; p.price &lt;&lt; endl; fs.close();}int main(){ writeBinary(); readBinary();} 五、泛型编程C++另一种编程思想成为泛型编程，主要利用的技术就是模板C++提供两种模板机制：函数模板和类模板 5.1函数模板函数模板语法 12template&lt;typename T&gt; 其中typename可以用class代替函数声明或定义","link":"/2020/01/05/C-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"优先级队列","slug":"优先级队列","link":"/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"速决结构","slug":"速决结构","link":"/categories/%E9%80%9F%E5%86%B3%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"我的项目","slug":"我的项目","link":"/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}